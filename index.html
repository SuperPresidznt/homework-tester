<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xooper's Battleground</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
/* === RESET & VARIABLES === */
*{box-sizing:border-box;margin:0;padding:0}
:root{
    --navy:#1a3a5c;--navy-dark:#0d2137;--blue:#2980b9;--blue-light:#3498db;
    --green:#27ae60;--green-light:#2ecc71;--red:#c0392b;--red-light:#e74c3c;
    --orange:#f39c12;--yellow:#ffd60a;
    --bg:#e8e8e8;--white:#fff;--gray-50:#f5f5f5;--gray-100:#eee;
    --gray-200:#ddd;--gray-300:#ccc;--gray-400:#aaa;--gray-500:#999;--gray-600:#777;
    --gray-700:#555;--gray-800:#333;--gray-900:#222;
    --radius:4px;--shadow:0 2px 8px rgba(0,0,0,.12);
}
body{font-family:Arial,Helvetica,sans-serif;font-size:14px;background:var(--bg);color:var(--gray-800);min-height:100vh;-webkit-tap-highlight-color:transparent}
a{color:var(--blue);text-decoration:none}
a:hover{text-decoration:underline}
button{font-family:inherit;cursor:pointer;transition:transform .1s ease}
button:active:not(:disabled){transform:scale(0.97)}

/* === HEADER === */
.main-header{background:linear-gradient(to bottom,var(--navy),var(--navy-dark));color:#fff;border-bottom:3px solid var(--blue)}
.header-top{display:flex;align-items:center;justify-content:space-between;padding:8px 20px;min-height:55px}
.logo-area{display:flex;align-items:center;gap:12px}
.logo-text{font-size:18px;font-weight:bold;letter-spacing:.5px}
.header-actions{display:flex;align-items:center;gap:12px}
.header-actions button{background:none;border:1px solid rgba(255,255,255,.3);color:#fff;padding:5px 12px;border-radius:var(--radius);font-size:12px}
.header-actions button:hover{background:rgba(255,255,255,.1)}

/* === SUBHEADER === */
.subheader{background:var(--gray-50);border-bottom:1px solid var(--gray-300);display:flex;align-items:center;justify-content:space-between;padding:6px 20px;min-height:40px;flex-wrap:wrap;gap:8px}
.test-name{font-size:15px;font-weight:bold;color:var(--navy)}
.test-name span{background:#ff0;padding:1px 6px}
.section-tab{display:inline-block;background:var(--navy);color:#fff;padding:5px 16px;border-radius:3px 3px 0 0;font-size:13px;font-weight:bold}
.timer-area{display:flex;align-items:center;gap:10px;font-size:13px;color:var(--gray-700)}
.timer-display{font-family:'Courier New',monospace;font-size:16px;font-weight:bold;color:var(--red);background:#fff;border:1px solid var(--gray-300);padding:3px 10px;border-radius:3px}
.timer-display.warning{animation:flash .5s infinite alternate}
@keyframes flash{from{background:#fff}to{background:#ffeaea;color:#c0392b}}
[data-theme="dark"] .timer-display.warning{animation:flashDark .5s infinite alternate}
@keyframes flashDark{from{background:#1f2937}to{background:#450a0a;color:#fca5a5}}
.timer-toggle{color:#1a5276;cursor:pointer;font-size:12px;font-weight:bold}

/* === SCREENS === */
.screen{display:none;max-width:960px;margin:0 auto;padding:20px;min-height:calc(100vh - 200px);opacity:0;transform:translateY(6px);transition:opacity .25s ease,transform .25s ease}
.screen.active{display:block;opacity:1;transform:translateY(0)}
.screen.active{animation:screenIn .25s ease forwards}
@keyframes screenIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}

/* === HOME SCREEN === */
.home-grid{display:flex;flex-direction:column;gap:24px}
.home-main,.home-side{width:100%}
.home-hero{text-align:center;padding:30px 0 20px}
.home-hero h1{color:var(--navy);font-size:28px;margin-bottom:8px}
.home-hero p{color:var(--gray-600);font-size:15px}
.animated-bg body,.animated-bg .screen{transition:background 1s ease}
body.animated-bg{background:radial-gradient(circle at 20% 20%,rgba(255,255,255,.25),transparent 35%),radial-gradient(circle at 80% 10%,rgba(255,255,255,.18),transparent 40%),linear-gradient(135deg,#0f172a,#1e3a5f,#111827)}
body.animated-bg .home-hero{position:relative;padding:48px 0 28px;color:#f8fafc}
body.animated-bg .home-hero::after{content:"";position:absolute;inset:10px 0;border-radius:24px;background:rgba(15,23,42,.45);filter:blur(18px);z-index:-1}
body.animated-bg .home-hero h1{color:#facc15;text-shadow:0 0 16px rgba(250,204,21,.5)}
body.animated-bg .home-hero p{color:#e2e8f0}
.home-hero .bg-orb{position:absolute;inset:0;pointer-events:none;z-index:-1;opacity:.5;animation:floatOrb 12s ease-in-out infinite}
.home-hero .bg-orb:nth-child(1){left:10%;top:5%;width:120px;height:120px;background:radial-gradient(circle,#ff8fb1,transparent 70%)}
.home-hero .bg-orb:nth-child(2){right:15%;bottom:-10%;width:160px;height:160px;background:radial-gradient(circle,#60a5fa,transparent 70%);animation-delay:-4s}
@keyframes floatOrb{0%,100%{transform:translateY(0)}50%{transform:translateY(-12px)}}

.trinket-shelf{display:flex;gap:14px;margin:18px 0;padding:12px 16px;border:1px dashed rgba(15,23,42,.15);border-radius:14px;background:rgba(255,255,255,.85);align-items:center}
.trinket-shelf h4{margin:0;font-size:13px;color:var(--gray-700);text-transform:uppercase;letter-spacing:.08em}
.trinket-items{display:flex;gap:10px;flex-wrap:wrap}
.trinket-chip{display:flex;align-items:center;gap:6px;padding:6px 10px;border-radius:12px;background:rgba(15,23,42,.05);border:1px solid rgba(15,23,42,.1);font-size:12px;color:var(--navy)}
.trinket-chip span{font-size:16px}
.backpack-panel{position:relative;margin-top:16px;padding:16px;border-radius:16px;background:linear-gradient(135deg,rgba(15,23,42,.9),rgba(59,130,246,.35));color:#e2e8f0;box-shadow:0 10px 30px rgba(15,23,42,.2)}
.backpack-panel h4{margin:0 0 8px;font-size:14px;letter-spacing:.06em;text-transform:uppercase;color:#fcd34d}
.backpack-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(110px,1fr));gap:10px}
.backpack-slot{border:1px dashed rgba(248,250,252,.4);border-radius:10px;padding:10px;min-height:64px;display:flex;flex-direction:column;gap:4px;justify-content:center;align-items:center;font-size:12px;color:#f8fafc;background:rgba(15,23,42,.35)}
.backpack-slot .slot-icon{font-size:20px}
.backpack-slot.empty{opacity:.5;font-style:italic}

body.trinkets-enabled .home-side{position:relative}
body.trinkets-enabled #xpBarContainer{background:rgba(255,255,255,.9);border:1px solid rgba(15,23,42,.08);border-radius:14px;padding:18px;box-shadow:0 10px 30px rgba(15,23,42,.12)}
body.trinkets-enabled .trinket-shelf{display:flex}
.home-actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:16px 0}
.home-actions .btn-nav{min-width:150px}
.home-stats-wrapper{margin-top:24px}
.home-stats-wrapper h3{font-size:16px;color:var(--navy);margin-bottom:8px}
.difficulty-panel{margin:12px 0 16px;padding:12px;border:1px dashed var(--gray-300);border-radius:10px;background:rgba(26,58,92,0.03)}
.difficulty-panel .setting-row{margin-bottom:12px}
.difficulty-panel select{width:100%;padding:8px;border-radius:6px;border:1px solid var(--gray-300)}
.difficulty-panel input[type="range"]{width:100%}

body.compact-home .home-grid{flex-direction:row;align-items:flex-start}
body.compact-home .home-main{flex:1 1 65%;min-width:0}
body.compact-home .home-side{flex:1 1 32%;min-width:280px;position:sticky;top:90px;align-self:flex-start;display:flex;flex-direction:column;gap:16px}
body.compact-home .home-side > *{margin:0}
body.compact-home .home-hero{padding:10px 0 0;text-align:left}
body.compact-home .home-hero h1{font-size:24px;margin-bottom:4px}
body.compact-home .home-hero p{font-size:14px;color:var(--gray-500)}
body.compact-home .stats-row{grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
body.compact-home .stat-card{padding:12px 10px;border-radius:10px}
body.compact-home #bankList{margin-top:8px}
body.compact-home .home-actions{justify-content:flex-start;margin:12px 0 16px}
body.compact-home .home-stats-wrapper h3{font-size:13px;text-transform:uppercase;letter-spacing:.08em;color:var(--gray-500)}
body.compact-home .bank-card{border-radius:14px;padding:18px;box-shadow:0 20px 45px rgba(15,23,42,0.08);border:1px solid rgba(15,23,42,0.06)}
body.compact-home .bank-card h2{font-size:20px;margin-bottom:6px}
body.compact-home .bank-card .mode-buttons{grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px}
body.compact-home #streakBanner,body.compact-home #dailyGoalCard,body.compact-home #xpBarContainer{width:100%}
body.compact-home #xpBarContainer{background:var(--white);border:1px solid rgba(15,23,42,0.08);border-radius:12px;padding:16px}

.stats-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;margin:20px 0}
.stat-card{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:16px;text-align:center;transition:transform .2s ease,box-shadow .2s ease}
.stat-card:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.08)}
.stat-card .stat-val{font-size:28px;font-weight:bold;color:var(--navy)}
.stat-card .stat-lbl{font-size:12px;color:var(--gray-600);margin-top:4px}
.stat-card .stat-sub{font-size:11px;color:var(--gray-500);margin-top:4px}

/* === STREAK & DAILY GOAL === */
.streak-banner{display:flex;align-items:center;justify-content:center;gap:12px;margin:16px 0;padding:16px;background:linear-gradient(135deg,#ff6b35,#f7931e);border-radius:12px;color:#fff;font-weight:bold}
.streak-banner .streak-flame{font-size:32px;line-height:1}
.streak-banner .streak-info{text-align:left}
.streak-banner .streak-count{font-size:24px}
.streak-banner .streak-label{font-size:12px;opacity:.9;font-weight:normal}
.streak-banner.no-streak{background:var(--gray-200);color:var(--gray-600)}
.streak-banner.no-streak .streak-flame{opacity:.5}

.daily-goal-card{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:16px;margin:12px 0}
.daily-goal-card h3{font-size:14px;color:var(--navy);margin-bottom:8px;display:flex;align-items:center;gap:8px}
.daily-goal-card .goal-progress{display:flex;align-items:center;gap:12px}
.daily-goal-card .goal-bar{flex:1;height:12px;background:var(--gray-200);border-radius:6px;overflow:hidden}
.daily-goal-card .goal-bar-fill{height:100%;background:linear-gradient(90deg,var(--green),var(--green-light));border-radius:6px;transition:width .3s ease}
.daily-goal-card .goal-bar-fill.complete{background:linear-gradient(90deg,var(--green),#2ecc71)}
.daily-goal-card .goal-text{font-size:14px;color:var(--gray-700);min-width:100px;text-align:right}
.daily-goal-card .goal-text.complete{color:var(--green);font-weight:bold}
.goal-celebration{text-align:center;padding:8px;margin-top:8px;background:#eafaf1;border-radius:6px;color:var(--green);font-weight:bold;animation:goalPulse .5s ease}
@keyframes goalPulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}

.bank-card{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:20px;margin:16px 0;box-shadow:var(--shadow);transition:box-shadow .2s ease}
.bank-card:hover{box-shadow:0 4px 16px rgba(0,0,0,.15)}
.bank-card h2{color:var(--navy);font-size:20px;margin-bottom:4px}
.bank-card .bank-desc{color:#555;font-size:13px;margin-bottom:16px}
.bank-card .bank-meta{display:flex;gap:16px;font-size:12px;color:var(--gray-600);margin-bottom:16px;flex-wrap:wrap}

.mode-buttons{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px}
.mode-btn{padding:14px 16px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);text-align:left;transition:all .2s ease}
.mode-btn:hover{border-color:var(--blue);background:#f0f7ff;transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1)}
.mode-btn h3{font-size:14px;color:var(--navy);margin-bottom:4px}
.mode-btn p{font-size:12px;color:var(--gray-600);line-height:1.4}
.mode-btn.m-test{border-left:4px solid var(--red)}
.mode-btn.m-practice{border-left:4px solid var(--green)}
.mode-btn.m-drill{border-left:4px solid var(--orange)}
.mode-btn.m-review{border-left:4px solid var(--blue)}
.mode-btn.m-ai{border-left:4px solid #9b59b6}

/* === AI PRACTICE MODE === */
.ai-practice-container{max-width:700px;margin:0 auto}
.ai-progress{text-align:center;color:var(--gray-600);font-size:14px;margin-bottom:20px;padding:16px;background:var(--white);border:1px solid var(--gray-200);border-radius:8px}
.ai-progress .targeting{font-weight:bold;color:#9b59b6;font-size:16px;margin-bottom:8px}
.ai-progress .session-stats{display:flex;justify-content:center;gap:20px;margin-top:8px;flex-wrap:wrap}
.ai-progress .session-stat{text-align:center}
.ai-progress .session-stat .val{font-size:20px;font-weight:bold;color:var(--navy)}
.ai-progress .session-stat .lbl{font-size:11px;color:var(--gray-600)}
.ai-progress .weak-areas{margin-top:12px;font-size:12px;color:var(--gray-600)}
.ai-progress .weak-areas .weak-cat{display:inline-block;background:var(--gray-100);padding:2px 8px;border-radius:12px;margin:2px 4px;font-size:11px}
.ai-progress .weak-areas .weak-cat.current{background:#9b59b6;color:#fff}

.ai-card{background:#fff;border:1px solid var(--gray-300);border-radius:8px;padding:30px;min-height:300px;box-shadow:var(--shadow)}
.ai-card .ai-loading{text-align:center;padding:60px 20px;color:var(--gray-600)}
.ai-card .ai-loading .spinner{display:inline-block;width:40px;height:40px;border:4px solid var(--gray-200);border-top:4px solid #9b59b6;border-radius:50%;animation:aispin 1s linear infinite;margin-bottom:16px}
@keyframes aispin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.ai-card .ai-loading p{font-size:14px;margin-top:8px}
.ai-card .question-text{font-size:16px;line-height:1.7;margin-bottom:20px}
.ai-card .options-list{list-style:none}
.ai-card .option-item{display:flex;align-items:flex-start;gap:10px;padding:12px 14px;margin:8px 0;border:1px solid var(--gray-200);border-radius:var(--radius);cursor:pointer;transition:all .15s}
.ai-card .option-item:hover:not(.disabled){background:#f0f7ff;border-color:var(--blue)}
.ai-card .option-item.selected{background:#e3f0fc;border-color:var(--blue)}
.ai-card .option-item.correct-answer{border:2px solid var(--green);background:#eafaf1}
.ai-card .option-item.wrong-answer{border:2px solid var(--red);background:#fdf2f2}
.ai-card .option-item.disabled{cursor:not-allowed;opacity:0.8}
.ai-card .option-label{font-size:14px;line-height:1.6}

.ai-card .ai-explanation{margin-top:20px;padding:16px;border-radius:var(--radius);background:#f0faf4;border:1px solid #c3e6cb;font-size:14px;line-height:1.6;color:#155724}
.ai-card .ai-explanation.incorrect{background:#fdf2f2;border-color:#f5c6cb;color:#721c24}
.ai-card .ai-explanation h4{margin-bottom:8px;font-size:15px}

.ai-card .ai-buttons{display:flex;gap:10px;margin-top:20px;justify-content:center;flex-wrap:wrap}
.ai-card .ai-btn{padding:12px 24px;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold;color:#fff;min-width:140px;cursor:pointer}
.ai-card .ai-btn.btn-check{background:#9b59b6}
.ai-card .ai-btn.btn-check:hover{background:#8e44ad}
.ai-card .ai-btn.btn-check:disabled{background:var(--gray-500);cursor:not-allowed}
.ai-card .ai-btn.btn-next{background:var(--blue)}
.ai-card .ai-btn.btn-next:hover{background:var(--blue-light)}
.ai-card .ai-btn.btn-end{background:var(--gray-700)}
.ai-card .ai-btn.btn-end:hover{background:var(--gray-600)}

.ai-card .ai-difficulty{display:flex;align-items:center;gap:8px;margin-bottom:16px;font-size:12px;color:var(--gray-600)}
.ai-card .ai-difficulty .diff-indicator{display:flex;gap:3px}
.ai-card .ai-difficulty .diff-dot{width:10px;height:10px;border-radius:50%;background:var(--gray-200)}
.ai-card .ai-difficulty .diff-dot.filled{background:#9b59b6}

.ai-session-summary{text-align:center;padding:40px 20px}
.ai-session-summary h2{color:var(--navy);margin-bottom:16px}
.ai-session-summary .summary-score{font-size:48px;font-weight:bold;color:#9b59b6;margin-bottom:8px}
.ai-session-summary .summary-label{font-size:16px;color:var(--gray-600);margin-bottom:24px}
.ai-session-summary .summary-details{max-width:400px;margin:0 auto 24px;text-align:left}
.ai-session-summary .summary-details table{width:100%;border-collapse:collapse}
.ai-session-summary .summary-details td{padding:8px 12px;font-size:14px;border-bottom:1px solid var(--gray-100)}
.ai-session-summary .summary-details .label-col{color:var(--gray-600)}
.ai-session-summary .summary-details .value-col{font-weight:bold;text-align:right}
.ai-session-summary .category-improvements{margin-top:20px}
.ai-session-summary .category-improvements h3{font-size:16px;color:var(--navy);margin-bottom:12px}
.ai-session-summary .cat-improvement{display:flex;align-items:center;gap:10px;margin:6px 0;font-size:13px}
.ai-session-summary .cat-improvement .cat-name{flex:1}
.ai-session-summary .cat-improvement .cat-score{font-weight:bold}
.ai-session-summary .cat-improvement .cat-score.improved{color:var(--green)}
.ai-session-summary .cat-improvement .cat-score.declined{color:var(--red)}
.ai-session-summary .summary-actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
.ai-session-summary .summary-actions button{padding:12px 28px;border:none;border-radius:var(--radius);font-size:15px;font-weight:bold;color:#fff;cursor:pointer}

.ai-error{text-align:center;padding:40px;color:var(--red)}
.ai-error h3{margin-bottom:12px}
.ai-error p{color:var(--gray-600);margin-bottom:20px}

/* Dark mode support for AI Practice */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .ai-progress { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .ai-progress .targeting { color: #a78bfa; }
    body:not([data-theme="light"]) .ai-progress .session-stat .val { color: #93c5fd; }
    body:not([data-theme="light"]) .ai-progress .weak-areas .weak-cat { background: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .ai-progress .weak-areas .weak-cat.current { background: #7c3aed; color: #fff; }
    body:not([data-theme="light"]) .ai-card { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .ai-card .option-item { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .ai-card .option-item:hover:not(.disabled) { background: #1e3a5f; border-color: var(--blue); }
    body:not([data-theme="light"]) .ai-card .option-item.selected { background: #1e3a5f; }
    body:not([data-theme="light"]) .ai-card .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
    body:not([data-theme="light"]) .ai-card .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
    body:not([data-theme="light"]) .ai-card .ai-explanation { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
    body:not([data-theme="light"]) .ai-card .ai-explanation.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
    body:not([data-theme="light"]) .ai-session-summary h2 { color: #93c5fd; }
    body:not([data-theme="light"]) .ai-session-summary .summary-score { color: #a78bfa; }
}
[data-theme="dark"] .ai-progress { background: #16213e; border-color: #374151; }
[data-theme="dark"] .ai-progress .targeting { color: #a78bfa; }
[data-theme="dark"] .ai-progress .session-stat .val { color: #93c5fd; }
[data-theme="dark"] .ai-progress .weak-areas .weak-cat { background: #374151; color: #d1d5db; }
[data-theme="dark"] .ai-progress .weak-areas .weak-cat.current { background: #7c3aed; color: #fff; }
[data-theme="dark"] .ai-card { background: #16213e; border-color: #374151; }
[data-theme="dark"] .ai-card .option-item { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .ai-card .option-item:hover:not(.disabled) { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .ai-card .option-item.selected { background: #1e3a5f; }
[data-theme="dark"] .ai-card .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
[data-theme="dark"] .ai-card .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
[data-theme="dark"] .ai-card .ai-explanation { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
[data-theme="dark"] .ai-card .ai-explanation.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
[data-theme="dark"] .ai-session-summary h2 { color: #93c5fd; }
[data-theme="dark"] .ai-session-summary .summary-score { color: #a78bfa; }

/* === QUESTION CONTAINER === */
.question-container{background:#fff;border:1px solid var(--gray-300);border-radius:var(--radius);padding:25px 30px;margin-bottom:15px;min-height:250px}
.question-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--gray-100);flex-wrap:wrap;gap:8px}
.question-number{font-weight:bold;color:var(--navy);font-size:14px}
.question-actions{display:flex;gap:8px}
.btn-bookmark,.btn-clear{padding:4px 14px;border:1px solid var(--gray-500);border-radius:3px;background:#f0f0f0;font-size:12px;color:#333}
.btn-bookmark:hover,.btn-clear:hover{background:#e0e0e0}
.btn-bookmark.flagged{background:#fff3cd;border-color:var(--orange);color:#856404}
.question-text{font-size:15px;line-height:1.7;margin-bottom:20px;color:var(--gray-900);word-break:normal;overflow-wrap:break-word;white-space:normal}
.question-text p{margin-bottom:8px;word-break:normal;white-space:normal}

/* === OPTIONS === */
.options-list{list-style:none}
.option-item{display:flex;align-items:flex-start;gap:10px;padding:10px 14px;margin:6px 0;border:1px solid var(--gray-200);border-radius:var(--radius);cursor:pointer;transition:all .15s ease}
.option-item:hover{background:#f0f7ff;border-color:var(--blue)}
.option-item.selected{background:#e3f0fc;border-color:var(--blue)}
.option-item input[type="radio"]{margin-top:3px;accent-color:var(--blue)}
.option-label{font-size:14px;line-height:1.6;color:var(--gray-800);word-break:normal;overflow-wrap:break-word;white-space:normal}

/* Practice/Review feedback on options */
.option-item.correct-answer{border:2px solid var(--green);background:#eafaf1;animation:correctPop .3s ease}
.option-item.wrong-answer{border:2px solid var(--red);background:#fdf2f2;animation:wrongShake .4s ease}
@keyframes correctPop{0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
@keyframes wrongShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-4px)}40%{transform:translateX(4px)}60%{transform:translateX(-3px)}80%{transform:translateX(2px)}}

/* === EXPLANATION PANEL === */
.explanation-panel{display:none;margin-top:15px;padding:16px;border-radius:var(--radius);background:#f0faf4;border:1px solid #c3e6cb;font-size:14px;line-height:1.6;color:#155724;word-break:normal;overflow-wrap:break-word;white-space:normal}
.explanation-panel.show{display:block}
.review-q .rq-note-label{font-weight:bold;color:var(--blue);margin-bottom:4px;font-size:12px}

/* === CHECK ANSWER BUTTON (Practice mode) === */
.btn-check{padding:10px 24px;background:var(--green);color:#fff;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold;margin-top:10px}
.btn-check:hover{background:var(--green-light)}
.btn-check:disabled{background:var(--gray-500);cursor:not-allowed}

/* === CONFIDENCE INDICATOR (Practice mode) === */
.confidence-panel{display:flex;align-items:center;gap:8px;margin-top:12px;padding:10px;background:#f8f9fa;border-radius:var(--radius);flex-wrap:wrap}
.confidence-label{font-size:13px;color:var(--gray-700);margin-right:4px}
.confidence-btn{padding:6px 14px;border:1px solid var(--gray-300);border-radius:16px;background:#fff;font-size:12px;color:var(--gray-700);cursor:pointer;transition:all .15s}
.confidence-btn:hover{border-color:var(--blue);color:var(--blue)}
.confidence-btn.selected{background:var(--blue);color:#fff;border-color:var(--blue)}
.confidence-btn.conf-maybe.selected{background:var(--orange);border-color:var(--orange)}
.confidence-btn.conf-probably.selected{background:var(--blue);border-color:var(--blue)}
.confidence-btn.conf-definitely.selected{background:var(--green);border-color:var(--green)}

/* === TOOLBAR (Calculator, Audio, Timer, Notes) === */
.toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.tool-btn{background:var(--gray-100);border:1px solid var(--gray-300);border-radius:var(--radius);padding:6px 12px;font-size:12px;color:var(--gray-700);display:flex;align-items:center;gap:4px}
.tool-btn:hover{background:var(--gray-200)}
.tool-btn.active{background:var(--blue);color:#fff;border-color:var(--blue)}
.tool-btn svg{width:14px;height:14px}
.tool-btn.has-note{position:relative}
.tool-btn.has-note::after{content:'';position:absolute;top:4px;right:6px;width:6px;height:6px;border-radius:50%;background:var(--orange)}

/* === CALCULATOR === */
.calc-panel{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,.3);z-index:400;width:280px;max-width:90vw;touch-action:none}
.calc-panel.open{display:block}
.calc-panel.dragging{opacity:.95;box-shadow:0 18px 44px rgba(0,0,0,.35)}
.calc-header{background:var(--navy);color:#fff;padding:10px 14px;display:flex;justify-content:space-between;align-items:center;border-radius:8px 8px 0 0;cursor:move;user-select:none}
.calc-header h4{font-size:14px;margin:0}
.calc-close{background:none;border:none;color:#fff;font-size:18px;cursor:pointer}
.calc-display{background:#222;color:#0f0;font-family:monospace;font-size:24px;padding:12px;text-align:right;min-height:50px;word-break:break-all}
.calc-buttons{display:grid;grid-template-columns:repeat(4,1fr);gap:2px;padding:8px}
.calc-btn{padding:14px;font-size:16px;border:none;background:var(--gray-100);cursor:pointer}
.calc-btn:hover{background:var(--gray-200)}
.calc-btn.op{background:var(--orange);color:#fff}
.calc-btn.op:hover{background:#e67e22}
.calc-btn.eq{background:var(--green);color:#fff}
.calc-btn.clear{background:var(--red);color:#fff}

/* === POWER-UP BAR (styles in gamification section below) === */

/* === METRICS PANEL === */
.metrics-summary{background:var(--gray-50);border:1px solid var(--gray-200);border-radius:8px;padding:16px;margin-top:20px}
.metrics-summary h3{font-size:14px;color:var(--navy);margin-bottom:12px}
.metrics-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px}
.metric-item{text-align:center}
.metric-val{font-size:20px;font-weight:bold;color:var(--navy)}
.metric-lbl{font-size:11px;color:var(--gray-600)}
.time-per-q{margin-top:12px;font-size:12px;color:var(--gray-600)}
.time-per-q table{width:100%;margin-top:8px;font-size:11px}
.time-per-q th,.time-per-q td{padding:4px 8px;text-align:left;border-bottom:1px solid var(--gray-200)}
.time-bar{height:8px;background:var(--gray-200);border-radius:4px;overflow:hidden;margin-top:2px}
.time-bar-fill{height:100%;background:var(--blue);border-radius:4px}

/* === FOOTER NAV === */
.footer-nav{background:var(--gray-50);border-top:1px solid var(--gray-300);padding:10px 20px;position:sticky;bottom:0;z-index:50}
.nav-controls{display:flex;align-items:center;max-width:960px;margin:0 auto;gap:12px;flex-wrap:wrap}
.nav-buttons{display:flex;gap:8px;align-items:center;flex-shrink:0}
.nav-buttons-left{flex-wrap:wrap}
.nav-buttons-right{margin-left:auto}
.btn-nav{padding:8px 20px;border:1px solid var(--navy);border-radius:3px;background:var(--navy);color:#fff;font-size:13px;font-weight:bold}
.btn-nav:hover{background:#2c5a8a}
.btn-nav:disabled{background:var(--gray-500);border-color:var(--gray-500);cursor:not-allowed}
.btn-submit{background:var(--red);border-color:var(--red)}
.btn-submit:hover{background:var(--red-light)}
.btn-home{background:var(--gray-700);border-color:var(--gray-700)}

/* === QUESTION PALETTE === */
.palette-wrap{flex:1;text-align:center;min-width:0;overflow:hidden;display:flex;flex-direction:column;align-items:center}
.question-palette{display:flex;flex-wrap:wrap;gap:4px;justify-content:center;max-width:600px;margin:0 auto}
.q-num{width:32px;height:28px;display:flex;align-items:center;justify-content:center;border:1px solid var(--gray-500);border-radius:3px;cursor:pointer;font-size:12px;font-weight:bold;background:#fff;color:#666;transition:all .15s;flex-shrink:0}
.q-num:hover{border-color:var(--blue);color:var(--blue)}
.q-num.current{background:var(--navy);color:#fff;border-color:var(--navy)}
.q-num.answered{background:var(--green);color:#fff;border-color:var(--green)}
.q-num.visited{color:#996600}
.q-num.flagged{position:relative}
.q-num.flagged::after{content:'';position:absolute;top:-2px;right:-2px;width:8px;height:8px;background:var(--orange);border-radius:50%}
.q-num.has-note{position:relative}
.q-num.has-note::before{content:'✎';position:absolute;bottom:-6px;left:50%;transform:translateX(-50%);font-size:9px;color:var(--blue);}
/* Practice palette colors */
.q-num.p-correct{background:var(--green);color:#fff;border-color:var(--green)}
.q-num.p-incorrect{background:var(--red);color:#fff;border-color:var(--red)}
.q-num.p-skipped{background:var(--orange);color:#fff;border-color:var(--orange)}

.palette-legend{display:flex;gap:15px;font-size:11px;color:var(--gray-600);margin-top:8px;justify-content:center;flex-wrap:wrap}
.legend-item{display:flex;align-items:center;gap:4px}
.legend-dot{width:12px;height:12px;border-radius:2px;border:1px solid var(--gray-500)}
.legend-dot.lg-current{background:var(--navy);border-color:var(--navy)}
.legend-dot.lg-answered{background:var(--green);border-color:var(--green)}
.legend-dot.lg-unanswered{background:#fff;border:2px solid #666}
.legend-dot.lg-flagged{background:var(--orange);border-color:var(--orange)}

/* === MINI PALETTE (shows ~5 around current) === */
.palette-mini{display:flex;gap:4px;justify-content:center;align-items:center;margin-bottom:6px}
.palette-mini .q-num{width:36px;height:32px;font-size:13px}
.palette-mini .pm-ellipsis{color:var(--gray-500);font-size:14px;padding:0 4px}
.palette-expand-btn{background:none;border:1px solid var(--gray-400);color:var(--gray-600);padding:4px 12px;border-radius:12px;font-size:11px;margin-bottom:6px}
.palette-expand-btn:hover{background:var(--gray-100)}
.question-palette.collapsed{display:none}
.question-palette.expanded{display:flex}

/* === MODAL === */
.modal-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1000}
.modal-overlay.active{display:flex;align-items:center;justify-content:center}
.modal{background:#fff;border-radius:6px;padding:30px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto}
.modal h2{color:var(--navy);margin-bottom:15px;font-size:18px}
.modal table{width:100%;border-collapse:collapse;margin:15px 0}
.modal th,.modal td{padding:8px 12px;border:1px solid var(--gray-200);text-align:left;font-size:13px}
.modal th{background:var(--navy);color:#fff}
.modal-actions{display:flex;gap:10px;justify-content:flex-end;margin-top:20px}
.modal .btn-nav{font-size:14px;padding:10px 24px}

/* === SCORE SCREEN === */
.score-screen{text-align:center;padding:40px 20px}
.score-big{font-size:64px;font-weight:bold;color:var(--navy);animation:scoreReveal .6s ease}
.score-big.pass{color:var(--green)}
.score-big.fail{color:var(--red)}
@keyframes scoreReveal{from{opacity:0;transform:scale(.5)}to{opacity:1;transform:scale(1)}}
.score-label{font-size:18px;color:var(--gray-600);margin:10px 0 20px}
.score-details{max-width:450px;margin:0 auto;text-align:left}
.score-details table{width:100%;border-collapse:collapse}
.score-details td{padding:6px 10px;font-size:14px;border-bottom:1px solid var(--gray-100)}
.score-details .label-col{color:var(--gray-600)}
.score-details .value-col{font-weight:bold;text-align:right}
.category-breakdown{margin-top:20px}
.category-breakdown h3{font-size:16px;color:var(--navy);margin-bottom:10px}
.cat-row{display:flex;align-items:center;gap:10px;margin:6px 0;font-size:13px}
.cat-bar{flex:1;height:20px;background:var(--gray-100);border-radius:10px;overflow:hidden}
.cat-fill{height:100%;border-radius:10px;transition:width .8s cubic-bezier(.4,0,.2,1);animation:barGrow .8s ease forwards}
.cat-fill.good{background:var(--green)}
.cat-fill.warn{background:var(--orange)}
.cat-fill.bad{background:var(--red)}
.score-actions{margin-top:30px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
.score-actions button{padding:12px 28px;border:none;border-radius:var(--radius);font-size:15px;font-weight:bold;color:#fff;cursor:pointer}

/* === DRILL MODE === */
.drill-container{max-width:700px;margin:0 auto}
.drill-progress{text-align:center;color:var(--gray-600);font-size:14px;margin-bottom:20px}
.drill-progress .due-count{font-weight:bold;color:var(--navy)}
.drill-card{background:#fff;border:1px solid var(--gray-300);border-radius:8px;padding:30px;min-height:300px;box-shadow:var(--shadow);animation:cardSlideIn .3s ease}
@keyframes cardSlideIn{from{opacity:0;transform:translateX(20px)}to{opacity:1;transform:translateX(0)}}
.drill-card .question-text{font-size:16px}
.drill-answer{display:none;margin-top:20px;padding-top:20px;border-top:2px solid var(--gray-200)}
.drill-answer.show{display:block}
.drill-answer .correct-label{font-weight:bold;color:var(--green);font-size:15px;margin-bottom:8px}
.drill-answer .explanation{color:var(--gray-700);font-size:14px;line-height:1.6}
.drill-buttons{display:flex;gap:10px;margin-top:20px;justify-content:center;flex-wrap:wrap}
.drill-btn{padding:12px 24px;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold;color:#fff;min-width:120px}
.drill-btn.btn-got-it{background:var(--green)}
.drill-btn.btn-struggled{background:var(--orange)}
.drill-btn.btn-missed{background:var(--red)}
.drill-btn.btn-show{background:var(--blue);min-width:200px}
.drill-session-done{text-align:center;padding:40px}
.drill-session-done h2{color:var(--navy);margin-bottom:10px}

/* === REVIEW MODE === */
.review-controls{display:flex;gap:10px;margin-bottom:20px;flex-wrap:wrap;align-items:center}
.review-controls select,.review-controls input{padding:8px 12px;border:1px solid var(--gray-300);border-radius:var(--radius);font-size:13px}
.review-controls input{flex:1;min-width:200px}
.review-category{margin-bottom:20px}
.review-category h3{color:var(--navy);font-size:16px;padding:10px 0;border-bottom:2px solid var(--navy);cursor:pointer;display:flex;justify-content:space-between;align-items:center}
.review-category h3 .toggle-arrow{transition:transform .2s}
.review-category h3 .toggle-arrow.collapsed{transform:rotate(-90deg)}
.review-q{background:#fff;border:1px solid var(--gray-200);border-radius:var(--radius);padding:16px;margin:8px 0}
.review-q .rq-text{font-size:14px;line-height:1.6;margin-bottom:12px}
.review-q .rq-options{list-style:none}
.review-q .rq-opt{padding:6px 10px;margin:3px 0;border-radius:3px;font-size:13px}
.review-q .rq-opt.rq-correct{background:#eafaf1;border:1px solid #c3e6cb;font-weight:bold}
.review-q .rq-explanation{margin-top:10px;padding:10px;background:#f8f9fa;border-left:3px solid var(--yellow);font-size:13px;line-height:1.5;color:var(--gray-700)}
.review-q .rq-meta{display:flex;gap:8px;margin-top:8px;font-size:11px}
.review-q .rq-tag{background:var(--gray-100);padding:2px 6px;border-radius:3px;color:#333}

/* === ELDEN MODE PANELS === */
.elden-panel{display:none;margin:18px 0;padding:16px 18px;border:1px solid rgba(139,92,246,0.4);border-radius:12px;background:linear-gradient(135deg,rgba(76,29,149,0.08),rgba(15,23,42,0.08));box-shadow:0 8px 26px rgba(15,23,42,0.12);animation:eldenFade .35s ease;position:relative;overflow:hidden}
.elden-panel::after{content:"";position:absolute;inset:0;background:radial-gradient(circle at 85% 10%,rgba(236,72,153,0.25),transparent 55%);opacity:.6;pointer-events:none}
.elden-panel h4{margin:0 0 6px;color:#8b5cf6;font-size:13px;letter-spacing:.08em;text-transform:uppercase}
.elden-region{font-size:18px;font-weight:600;color:#f9fafb;margin-bottom:4px}
.elden-desc{font-size:13px;color:#d1d5db;margin-bottom:10px;line-height:1.5}
.elden-npc{display:flex;gap:12px;align-items:flex-start;border-top:1px solid rgba(255,255,255,0.08);padding-top:10px;margin-top:10px}
.elden-npc-avatar{width:44px;height:44px;border-radius:50%;background:rgba(15,23,42,0.5);display:flex;align-items:center;justify-content:center;font-size:20px}
.elden-npc-line{flex:1;font-size:13px;color:#e0e7ff;line-height:1.5}
.elden-egg{margin-top:10px;font-size:12px;color:#fbbf24;font-style:italic;display:flex;align-items:center;gap:6px}
.elden-egg::before{content:"✧";color:#fbbf24}
@keyframes eldenFade{from{opacity:0;transform:translateY(8px)}to{opacity:1;transform:translateY(0)}}

/* === SETTINGS === */
.settings-panel{max-width:600px;margin:0 auto}
.settings-panel h2{color:var(--navy);margin-bottom:20px}
.setting-group{background:#fff;border:1px solid var(--gray-200);border-radius:8px;padding:20px;margin-bottom:16px}
.setting-group h3{font-size:14px;color:var(--navy);margin-bottom:12px}
.setting-row{margin-bottom:12px}
.setting-row label{display:block;font-size:13px;color:var(--gray-700);margin-bottom:4px}
.setting-row input,.setting-row select{width:100%;padding:8px 12px;border:1px solid var(--gray-300);border-radius:var(--radius);font-size:14px}
.setting-row input[type="password"]{font-family:monospace}
.setting-row .hint{font-size:11px;color:#555;margin-top:4px}
.setting-row button{margin-top:8px}
.btn-save-settings{padding:10px 24px;background:var(--green);color:#fff;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold}

/* === AI CHAT BUBBLE === */
.chat-fab{position:fixed;bottom:80px;right:20px;width:50px;height:50px;border-radius:50%;background:var(--navy);color:#fff;border:none;font-size:22px;box-shadow:0 4px 12px rgba(0,0,0,.3);z-index:200;display:flex;align-items:center;justify-content:center;transition:transform .2s}
.chat-fab:hover{transform:scale(1.1)}
.chat-fab.has-context::after{content:'';position:absolute;top:2px;right:2px;width:10px;height:10px;background:var(--green);border-radius:50%;border:2px solid var(--navy)}

/* === NOTE PANEL === */
.note-panel{display:none;position:fixed;right:32px;bottom:120px;width:min(340px,calc(100vw - 32px));max-height:60vh;background:#fff;border:1px solid var(--gray-300);border-radius:12px;box-shadow:0 14px 48px rgba(0,0,0,.25);z-index:380;padding:0;flex-direction:column;touch-action:none}
.note-panel.open{display:flex}
.note-panel.dragging{opacity:.96;box-shadow:0 18px 48px rgba(0,0,0,.35)}
.note-panel-header{display:flex;justify-content:space-between;align-items:flex-start;padding:14px 16px;border-bottom:1px solid var(--gray-200);cursor:move;user-select:none}
.note-panel-title{font-size:14px;font-weight:600;color:var(--navy)}
.note-panel-sub{font-size:12px;color:var(--gray-600)}
.note-close{background:none;border:none;color:var(--gray-500);font-size:20px;line-height:1;cursor:pointer;padding:0;margin:0}
.note-textarea{width:100%;flex:1;min-height:140px;padding:14px;border:none;border-bottom:1px solid var(--gray-200);font-size:13px;font-family:inherit;resize:none;outline:none}
.note-panel-footer{display:flex;justify-content:space-between;align-items:center;padding:10px 14px;gap:12px}
.note-clear{border:none;background:var(--gray-200);color:var(--gray-700);padding:6px 10px;border-radius:var(--radius);font-size:12px;cursor:pointer}
.note-clear:hover{background:var(--gray-300)}
.note-saved{font-size:11px;color:var(--green);opacity:0;transition:opacity .3s}
.note-saved.show{opacity:1}
.chat-tts-btn{position:absolute;top:4px;right:4px;background:none;border:none;cursor:pointer;font-size:14px;opacity:.4;padding:2px 4px;border-radius:4px;line-height:1}
.chat-tts-btn:hover{opacity:.8;background:rgba(0,0,0,.05)}
.chat-tts-btn.speaking{opacity:1;color:var(--blue)}

/* === QUESTION COUNT PICKER === */
#qCountModal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:500;align-items:center;justify-content:center;padding:20px}
.modal-box{background:var(--white);border-radius:12px;padding:24px;max-width:400px;width:100%;box-shadow:0 8px 32px rgba(0,0,0,.3)}
.qcount-options{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.qcount-opt{padding:14px 12px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);cursor:pointer;text-align:center;transition:all .15s;font-size:14px;font-weight:bold;color:var(--gray-800)}
.qcount-opt:hover{border-color:var(--blue);background:#f0f7ff}
.qcount-opt.selected{border-color:var(--blue);background:#e3f0fc;color:var(--navy)}
.qcount-opt .qcount-label{font-size:13px;font-weight:normal;color:var(--gray-600);margin-top:2px}
[data-theme="dark"] .modal-box{background:#1a2332;color:#e0e0e0}
[data-theme="dark"] .qcount-opt{background:#16213e;border-color:#374151;color:#e0e0e0}
[data-theme="dark"] .qcount-opt:hover{background:#1e3a5f;border-color:var(--blue)}
[data-theme="dark"] .qcount-opt.selected{background:#1e3a5f;border-color:var(--blue)}
body:not([data-theme="light"]) .modal-box{background:#1a2332;color:#e0e0e0}
body:not([data-theme="light"]) .qcount-opt{background:#16213e;border-color:#374151;color:#e0e0e0}
body:not([data-theme="light"]) .qcount-opt:hover{background:#1e3a5f;border-color:var(--blue)}
body:not([data-theme="light"]) .qcount-opt.selected{background:#1e3a5f;border-color:var(--blue)}

/* === TABLET (landscape/compact) === */
@media(max-height:700px),(max-width:1024px) and (max-height:900px){
    .main-header .header-top{padding:4px 12px;min-height:40px}
    .subheader{padding:4px 12px;min-height:32px}
    .screen{padding:8px 12px}
    .question-container{padding:12px 16px;margin-bottom:8px;min-height:auto}
    .question-header{margin-bottom:8px;padding-bottom:6px}
    .question-text{margin-bottom:12px;font-size:14px;line-height:1.5}
    .option-item{padding:8px 12px;margin:4px 0}
    .option-label{font-size:13px;line-height:1.4}
    .btn-check{padding:8px 20px;margin-top:8px}
    .confidence-panel{margin-top:8px;padding:8px}
    .explanation-panel{margin-top:10px;padding:12px}
    .footer-nav{padding:6px 12px}
    .nav-buttons{gap:6px}
    .palette-mini{margin-bottom:4px}
}

/* === MOBILE === */
@media(max-width:768px){
    .header-top{padding:6px 12px}
    .logo-text{font-size:15px}
    .subheader{padding:4px 12px}
    .screen{padding:8px;max-width:100%;box-sizing:border-box}
    .question-container{padding:12px;max-width:100%;box-sizing:border-box;overflow-x:hidden;min-height:auto}
    .question-text,.option-label,.explanation-panel,.explanation-panel p{word-break:normal;overflow-wrap:break-word;white-space:normal}
    .question-text{font-size:14px;line-height:1.5;margin-bottom:12px}
    .option-item{padding:10px 12px;margin:4px 0;min-height:44px}
    .mode-buttons{grid-template-columns:1fr 1fr}
    .nav-controls{flex-direction:column;gap:6px}
    .nav-buttons{width:100%;justify-content:space-between;flex-wrap:wrap}
    .nav-buttons-right{justify-content:flex-end}
    .toolbar{width:100%;justify-content:center;margin-bottom:4px!important;margin-right:0!important}
    .tool-btn{flex:1;justify-content:center;padding:8px 10px;font-size:11px;min-height:40px}
    .tool-btn svg{width:14px;height:14px}
    .question-palette{max-width:100%;gap:4px}
    .calc-panel{width:calc(100vw - 24px);max-width:320px}
    .note-panel{left:12px;right:12px;bottom:80px;width:auto;max-height:70vh}
    .q-num{width:38px;height:38px;font-size:12px}
    .palette-mini .q-num{width:38px;height:38px}
    .btn-nav{padding:10px 14px;min-height:40px;font-size:12px}
    .drill-btn{padding:12px 18px;min-height:44px}
    .confidence-btn{min-height:40px;padding:8px 10px}
    .score-big{font-size:48px}
    .chat-panel{width:calc(100vw - 24px);right:12px;bottom:60px;height:calc(100vh - 100px)}
    .chat-fab{bottom:60px;right:12px;min-width:44px;min-height:44px}
    .stats-row{grid-template-columns:repeat(2,1fr)}
    .home-hero h1{font-size:22px}
    .home-hero{padding:15px 0 10px}
    .home-grid{gap:16px}
}
@media(max-width:400px){
    .mode-buttons{grid-template-columns:1fr}
    .q-num{width:40px;height:40px;font-size:11px}
}

/* === AI PRACTICE MOBILE === */
@media(max-width:768px){
    .ai-practice-container{padding:0 8px}
    .ai-card{padding:16px}
    .ai-card .question-text{font-size:15px}
    .ai-card .option-item{padding:10px 12px}
    .ai-card .option-label{font-size:13px}
    .ai-buttons{flex-direction:column;gap:8px}
    .ai-btn{width:100%;min-width:unset}
    .ai-progress .session-stats{gap:12px}
    .ai-progress .session-stat .val{font-size:18px}
    .ai-session-summary{padding:20px 12px}
    .ai-session-summary .summary-score{font-size:36px}
}
@media(max-width:400px){
    .ai-card{padding:12px}
    .ai-progress{padding:12px}
    .ai-progress .weak-areas .weak-cat{padding:2px 6px;font-size:10px;margin:2px}
    .ai-card .ai-difficulty{font-size:11px}
}

/* === ACCESSIBILITY - FOCUS STATES === */
button:focus-visible {
    outline: 2px solid var(--blue);
    outline-offset: 2px;
}
.option-item:focus-within {
    outline: 2px solid var(--blue);
}

/* === DARK MODE === */
/* System preference detection */
@media (prefers-color-scheme: dark) {
    :root:not([data-theme="light"]) {
        --bg: #1a1a2e;
        --white: #16213e;
        --gray-50: #1f2937;
        --gray-100: #374151;
        --gray-200: #4b5563;
        --gray-300: #6b7280;
        --gray-500: #9ca3af;
        --gray-600: #d1d5db;
        --gray-700: #e5e7eb;
        --gray-800: #e5e7eb;
        --gray-900: #f3f4f6;
    }
    body:not([data-theme="light"]) { color: #e5e7eb; }
}

/* Manual dark mode via data-theme attribute */
:root[data-theme="dark"] {
    --bg: #1a1a2e;
    --white: #16213e;
    --gray-50: #1f2937;
    --gray-100: #374151;
    --gray-200: #4b5563;
    --gray-300: #6b7280;
    --gray-500: #9ca3af;
    --gray-600: #d1d5db;
    --gray-700: #e5e7eb;
    --gray-800: #e5e7eb;
    --gray-900: #f3f4f6;
}
[data-theme="dark"] body, body[data-theme="dark"] { color: #e5e7eb; }

/* Dark mode component overrides */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .question-container,
    body:not([data-theme="light"]) .bank-card,
    body:not([data-theme="light"]) .modal,
    body:not([data-theme="light"]) .chat-panel,
    body:not([data-theme="light"]) .calc-panel,
    body:not([data-theme="light"]) .drill-card,
    body:not([data-theme="light"]) .review-q,
    body:not([data-theme="light"]) .setting-group,
    body:not([data-theme="light"]) .stat-card,
    body:not([data-theme="light"]) .mode-btn {
        background: #16213e;
        border-color: #374151;
    }
    body:not([data-theme="light"]) .option-item { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .option-item:hover { background: #1e3a5f; border-color: var(--blue); }
    body:not([data-theme="light"]) .option-item.selected { background: #1e3a5f; }
    body:not([data-theme="light"]) .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
    body:not([data-theme="light"]) .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
    body:not([data-theme="light"]) .explanation-panel { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
    body:not([data-theme="light"]) .explanation-panel.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
    body:not([data-theme="light"]) .subheader { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .footer-nav { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .q-num { background: #1f2937; border-color: #6b7280; color: #9ca3af; }
    body:not([data-theme="light"]) .timer-display { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .calc-btn { background: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .calc-btn:hover { background: #4b5563; }
    body:not([data-theme="light"]) .chat-msg.assistant { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .chat-input-area input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .review-controls select,
    body:not([data-theme="light"]) .review-controls input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .setting-row input,
    body:not([data-theme="light"]) .setting-row select { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .rq-explanation { background: #1f2937; border-color: var(--yellow); color: #d1d5db; }
    body:not([data-theme="light"]) .rq-opt.rq-correct { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
    body:not([data-theme="light"]) .confidence-btn { background: #1f2937; border-color: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .metrics-summary { background: #1f2937; border-color: #374151; }
}

/* Manual dark mode component overrides */
[data-theme="dark"] .question-container,
[data-theme="dark"] .bank-card,
[data-theme="dark"] .modal,
[data-theme="dark"] .chat-panel,
[data-theme="dark"] .calc-panel,
[data-theme="dark"] .drill-card,
[data-theme="dark"] .review-q,
[data-theme="dark"] .setting-group,
[data-theme="dark"] .stat-card,
[data-theme="dark"] .mode-btn {
    background: #16213e;
    border-color: #374151;
}
[data-theme="dark"] .option-item { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .option-item:hover { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .option-item.selected { background: #1e3a5f; }
[data-theme="dark"] .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
[data-theme="dark"] .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
[data-theme="dark"] .explanation-panel { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
[data-theme="dark"] .explanation-panel.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
[data-theme="dark"] .subheader { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .footer-nav { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .q-num { background: #1f2937; border-color: #6b7280; color: #9ca3af; }
[data-theme="dark"] .timer-display { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .calc-btn { background: #374151; color: #e5e7eb; }
[data-theme="dark"] .calc-btn:hover { background: #4b5563; }
[data-theme="dark"] .chat-msg.assistant { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .chat-input-area input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .review-controls select,
[data-theme="dark"] .review-controls input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .setting-row input,
[data-theme="dark"] .setting-row select { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .rq-explanation { background: #1f2937; border-color: var(--yellow); color: #d1d5db; }
[data-theme="dark"] .rq-opt.rq-correct { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
[data-theme="dark"] .confidence-btn { background: #1f2937; border-color: #374151; color: #d1d5db; }
[data-theme="dark"] .metrics-summary { background: #1f2937; border-color: #374151; }

/* Additional dark mode text and element overrides */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .test-name { color: #93c5fd; }
    body:not([data-theme="light"]) .bank-card h2,
    body:not([data-theme="light"]) .home-hero h1,
    body:not([data-theme="light"]) .settings-panel h2,
    body:not([data-theme="light"]) .setting-group h3,
    body:not([data-theme="light"]) .question-number,
    body:not([data-theme="light"]) .stat-card .stat-val,
    body:not([data-theme="light"]) .mode-btn h3,
    body:not([data-theme="light"]) .metrics-summary h3,
    body:not([data-theme="light"]) .drill-session-done h2,
    body:not([data-theme="light"]) .review-category h3,
    body:not([data-theme="light"]) .category-breakdown h3,
    body:not([data-theme="light"]) .score-screen .score-big { color: #93c5fd; }
    body:not([data-theme="light"]) .score-big.pass { color: var(--green-light); }
    body:not([data-theme="light"]) .score-big.fail { color: var(--red-light); }
    body:not([data-theme="light"]) a { color: #60a5fa; }
    body:not([data-theme="light"]) .hint { color: #d1d5db; }
    body:not([data-theme="light"]) .bank-desc,
    body:not([data-theme="light"]) .bank-meta,
    body:not([data-theme="light"]) .mode-btn p,
    body:not([data-theme="light"]) .stat-card .stat-lbl { color: #d1d5db; }
    body:not([data-theme="light"]) .palette-expand-btn { background: #1f2937; border-color: #4b5563; color: #9ca3af; }
    body:not([data-theme="light"]) .tool-btn { background: #374151; border-color: #4b5563; color: #d1d5db; }
    body:not([data-theme="light"]) .tool-btn:hover { background: #4b5563; }
    body:not([data-theme="light"]) .btn-bookmark,
    body:not([data-theme="light"]) .btn-clear { background: #374151; border-color: #4b5563; color: #d1d5db; }
    body:not([data-theme="light"]) .btn-note { background: #374151; border-color: #4b5563; color: #d1d5db; }
    body:not([data-theme="light"]) .btn-note.has-note { background: #1e3a5f; border-color: var(--blue); color: #60a5fa; }
    body:not([data-theme="light"]) .note-panel { background: #111827; border-color: #1f2937; }
    body:not([data-theme="light"]) .note-textarea { background: #1f2937; color: #e5e7eb; }
    body:not([data-theme="light"]) .note-panel-header { border-color: #1f2937; }
    body:not([data-theme="light"]) .note-panel-footer { border-color: #1f2937; }
    body:not([data-theme="light"]) .review-q .rq-note { background: #1e3a5f; border-color: var(--blue); color: #d1d5db; }
    body:not([data-theme="light"]) .modal th { background: #1e3a5f; }
    body:not([data-theme="light"]) .daily-goal-card { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .daily-goal-card h3 { color: #93c5fd; }
    body:not([data-theme="light"]) .daily-goal-card .goal-bar { background: #374151; }
    body:not([data-theme="light"]) .daily-goal-card .goal-text { color: #d1d5db; }
    body:not([data-theme="light"]) .goal-celebration { background: #064e3b; color: #a7f3d0; }
    body:not([data-theme="light"]) .streak-banner.no-streak { background: #374151; color: #9ca3af; }
    body:not([data-theme="light"]) .rq-tag { background: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .timer-toggle { color: #60a5fa; }
    body:not([data-theme="light"]) .legend-dot.lg-unanswered { background: #374151; border-color: #9ca3af; }
}
[data-theme="dark"] .test-name { color: #93c5fd; }
[data-theme="dark"] .bank-card h2,
[data-theme="dark"] .home-hero h1,
[data-theme="dark"] .settings-panel h2,
[data-theme="dark"] .setting-group h3,
[data-theme="dark"] .question-number,
[data-theme="dark"] .stat-card .stat-val,
[data-theme="dark"] .mode-btn h3,
[data-theme="dark"] .metrics-summary h3,
[data-theme="dark"] .drill-session-done h2,
[data-theme="dark"] .review-category h3,
[data-theme="dark"] .category-breakdown h3,
[data-theme="dark"] .score-screen .score-big { color: #93c5fd; }
[data-theme="dark"] .score-big.pass { color: var(--green-light); }
[data-theme="dark"] .score-big.fail { color: var(--red-light); }
[data-theme="dark"] a { color: #60a5fa; }
[data-theme="dark"] .hint { color: #d1d5db; }
[data-theme="dark"] .bank-desc,
[data-theme="dark"] .bank-meta,
[data-theme="dark"] .mode-btn p,
[data-theme="dark"] .stat-card .stat-lbl { color: #d1d5db; }
[data-theme="dark"] .palette-expand-btn { background: #1f2937; border-color: #4b5563; color: #9ca3af; }
[data-theme="dark"] .tool-btn { background: #374151; border-color: #4b5563; color: #d1d5db; }
[data-theme="dark"] .tool-btn:hover { background: #4b5563; }
[data-theme="dark"] .btn-bookmark,
[data-theme="dark"] .btn-clear { background: #374151; border-color: #4b5563; color: #d1d5db; }
[data-theme="dark"] .btn-note { background: #374151; border-color: #4b5563; color: #d1d5db; }
[data-theme="dark"] .btn-note.has-note { background: #1e3a5f; border-color: var(--blue); color: #60a5fa; }
[data-theme="dark"] .note-panel { background: #111827; border-color: #1f2937; }
[data-theme="dark"] .note-textarea { background: #1f2937; color: #e5e7eb; border-color:#1f2937; }
[data-theme="dark"] .note-panel-header { border-color: #1f2937; }
[data-theme="dark"] .note-panel-footer { border-color: #1f2937; }
[data-theme="dark"] .review-q .rq-note { background: #1e3a5f; border-color: var(--blue); color: #d1d5db; }
[data-theme="dark"] .modal th { background: #1e3a5f; }
[data-theme="dark"] .daily-goal-card { background: #16213e; border-color: #374151; }
[data-theme="dark"] .daily-goal-card h3 { color: #93c5fd; }
[data-theme="dark"] .daily-goal-card .goal-bar { background: #374151; }
[data-theme="dark"] .daily-goal-card .goal-text { color: #d1d5db; }
[data-theme="dark"] .goal-celebration { background: #064e3b; color: #a7f3d0; }
[data-theme="dark"] .streak-banner.no-streak { background: #374151; color: #9ca3af; }
[data-theme="dark"] .rq-tag { background: #374151; color: #d1d5db; }
[data-theme="dark"] .timer-toggle { color: #60a5fa; }
[data-theme="dark"] .legend-dot.lg-unanswered { background: #374151; border-color: #9ca3af; }
[data-theme="dark"] .mode-btn:hover { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .test-name span { background: #854d0e; color: #fef08a; }
[data-theme="dark"] .chat-msg.system { background: #422006; color: #fbbf24; }
[data-theme="dark"] .timer-display { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .btn-bookmark.flagged { background: #422006; border-color: var(--orange); color: #fbbf24; }

/* === PROGRESS DASHBOARD === */
.progress-chart{margin:16px 0}
.chart-row{display:flex;align-items:center;margin:6px 0}
.chart-label{width:140px;font-size:12px;color:var(--gray-700);flex-shrink:0}
.chart-bar-bg{flex:1;height:20px;background:var(--gray-200);border-radius:10px;overflow:hidden}
.chart-bar-fill{height:100%;border-radius:10px;transition:width .5s}
.chart-bar-fill.good{background:var(--green)}
.chart-bar-fill.warn{background:var(--orange)}
.chart-bar-fill.bad{background:var(--red)}
.chart-value{width:50px;text-align:right;font-size:12px;font-weight:bold;color:var(--gray-700);margin-left:8px}

.progress-section{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:16px;margin-bottom:16px}
.progress-section h3{font-size:14px;color:var(--navy);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--gray-100)}

.progress-table{width:100%;border-collapse:collapse;font-size:13px}
.progress-table th,.progress-table td{padding:8px 10px;text-align:left;border-bottom:1px solid var(--gray-100)}
.progress-table th{background:var(--gray-50);color:var(--navy);font-weight:bold}
.progress-table tr:hover{background:var(--gray-50)}

.mastery-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
.mastery-item{text-align:center;padding:12px;background:var(--gray-50);border-radius:8px}
.mastery-item .value{font-size:24px;font-weight:bold}
.mastery-item .label{font-size:11px;color:var(--gray-600);margin-top:4px}
.mastery-item.mastered .value{color:var(--green)}
.mastery-item.learning .value{color:var(--orange)}
.mastery-item.new .value{color:var(--blue)}

.study-bars{display:flex;align-items:flex-end;gap:4px;height:80px;margin-top:12px}
.study-day{flex:1;display:flex;flex-direction:column;align-items:center}
.study-day .bar{width:100%;height:80px;background:var(--gray-100);border-radius:4px 4px 0 0;overflow:hidden;display:flex;flex-direction:column-reverse}
.study-day .bar-seg{width:100%;transition:height .3s}
.study-day .bar-seg.active{background:var(--blue)}
.study-day .bar-seg.idle{background:linear-gradient(180deg,rgba(255,177,66,.8),rgba(255,138,0,.85))}
.study-day .day-label{font-size:10px;color:var(--gray-600);margin-top:4px}

@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .progress-section { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .progress-table th { background: #1f2937; color: #93c5fd; }
    body:not([data-theme="light"]) .mastery-item { background: #1f2937; }
    body:not([data-theme="light"]) .progress-section h3 { color: #93c5fd; }
}
[data-theme="dark"] .progress-section { background: #16213e; border-color: #374151; }
[data-theme="dark"] .progress-table th { background: #1f2937; color: #93c5fd; }
[data-theme="dark"] .mastery-item { background: #1f2937; }
[data-theme="dark"] .progress-section h3 { color: #93c5fd; }

/* Inline chart container */
.inline-chart-wrap{margin:12px 0;border:1px solid var(--gray-200);border-radius:8px;overflow:hidden;background:#fff;width:100%;max-width:100%;box-sizing:border-box}
.inline-chart-wrap canvas{display:block;width:100%;max-width:100%;height:clamp(180px,35vw,320px);max-height:320px;box-sizing:border-box}
[data-theme="dark"] .inline-chart-wrap{background:#16213e;border-color:#374151}
@media(prefers-color-scheme:dark){body:not([data-theme="light"]) .inline-chart-wrap{background:#16213e;border-color:#374151}}

/* Graph/image placeholder styling for dark mode */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .question-text em[data-graph],
    body:not([data-theme="light"]) .question-text .graph-placeholder {
        display: inline-block;
        background: #374151;
        border: 1px dashed #6b7280;
        padding: 8px 12px;
        border-radius: 4px;
        color: #9ca3af;
        font-style: italic;
    }
}
[data-theme="dark"] .question-text em[data-graph],
[data-theme="dark"] .question-text .graph-placeholder {
    display: inline-block;
    background: #374151;
    border: 1px dashed #6b7280;
    padding: 8px 12px;
    border-radius: 4px;
    color: #9ca3af;
    font-style: italic;
}

/* === PRINT STYLESHEET === */
@media print {
    /* Hide UI elements */
    .main-header, .footer-nav, .chat-fab, .chat-panel,
    .calc-panel, .modal-overlay, .toolbar,
    .btn-bookmark, .btn-clear, .btn-check,
    .palette-expand-btn, .palette-legend,
    .score-actions, #helpModal { display: none !important; }

    /* Reset backgrounds for printing */
    body { background: white !important; color: black !important; }
    .screen { display: none !important; }
    .screen.active { display: block !important; max-width: 100% !important; }
    .question-container, .bank-card, .score-screen,
    .review-q, .progress-section {
        background: white !important;
        border: 1px solid #ccc !important;
        page-break-inside: avoid;
    }

    /* Make content readable */
    .question-text, .option-label { color: black !important; }
    .option-item.correct-answer { background: #e8f5e9 !important; border: 2px solid #4caf50 !important; }

    /* Remove shadows and transitions */
    * { box-shadow: none !important; transition: none !important; }
}

/* === GAMIFICATION SYSTEM === */
/* XP Bar */
.xp-bar-container{display:flex;align-items:center;gap:12px;background:linear-gradient(135deg,#1e3a5c,#2c5a8a);padding:12px 20px;border-radius:10px;margin:12px 0;box-shadow:0 4px 12px rgba(0,0,0,.2)}
.xp-level{background:var(--yellow);color:#1a3a5c;font-weight:bold;font-size:16px;padding:6px 12px;border-radius:6px;min-width:60px;text-align:center}
.xp-bar{flex:1;height:16px;background:rgba(255,255,255,.2);border-radius:8px;overflow:hidden;position:relative}
.xp-fill{height:100%;background:linear-gradient(90deg,var(--yellow),var(--orange));border-radius:8px;transition:width .5s ease;position:relative}
.xp-fill::after{content:'';position:absolute;top:0;left:0;right:0;height:50%;background:linear-gradient(to bottom,rgba(255,255,255,.3),transparent);border-radius:8px 8px 0 0}
.xp-info{text-align:right;min-width:100px}
.xp-text{color:#fff;font-size:12px;opacity:.9}
.xp-title{color:var(--yellow);font-size:11px;font-weight:bold;margin-top:2px}
.xp-bar-container .buddy-mini{font-size:24px;margin-left:8px;cursor:pointer;transition:transform .2s}
.xp-bar-container .buddy-mini:hover{transform:scale(1.2)}
.xp-meta{display:flex;gap:8px;margin-top:6px;flex-wrap:wrap}
.xp-meta .meta-pill{font-size:11px;padding:4px 10px;border-radius:999px;background:rgba(26,58,92,0.08);color:var(--navy);text-transform:uppercase;font-weight:bold;letter-spacing:.4px}
.xp-meta .meta-pill.momentum{background:rgba(255,107,53,0.15);color:#c0392b}
.xp-meta .meta-pill.batch{background:rgba(39,174,96,0.15);color:#1d7a46}
.xp-meta .meta-pill.pet{background:rgba(155,89,182,0.15);color:#70347c}

/* Combo Display */
.combo-display{position:fixed;top:90px;left:50%;transform:translateX(-50%);background:linear-gradient(135deg,#ff6b35,#f7931e);color:#fff;padding:10px 16px;border-radius:12px;box-shadow:0 4px 16px rgba(255,107,53,.4);z-index:100;display:none;align-items:center;gap:8px;font-weight:bold;max-width:220px;cursor:grab;touch-action:none;user-select:none}
.combo-display.active{display:flex}
.combo-display.dragging{cursor:grabbing;opacity:.95}
.combo-fire{font-size:24px;animation:firePulse .5s infinite alternate}
.combo-count{font-size:20px}
.combo-mult{font-size:14px;opacity:.9;background:rgba(0,0,0,.2);padding:2px 8px;border-radius:4px}
.combo-display.heating .combo-mult{background:rgba(0,0,0,.3);color:#fffbeb}
.combo-display.blazing .combo-mult{background:rgba(0,0,0,.35);color:#fef3c7;box-shadow:0 0 8px rgba(255,255,255,.4)}
@keyframes firePulse{0%{transform:scale(1)}100%{transform:scale(1.15)}}

/* XP Popup */
.xp-popup{position:fixed;pointer-events:none;font-weight:bold;font-size:18px;color:var(--yellow);text-shadow:0 2px 4px rgba(0,0,0,.3);animation:xpFloat 1.5s ease-out forwards;z-index:500}
@keyframes xpFloat{0%{opacity:1;transform:translateY(0) scale(1)}50%{opacity:1;transform:translateY(-30px) scale(1.1)}100%{opacity:0;transform:translateY(-60px) scale(0.9)}}

/* Coin Display */
.coin-display{background:linear-gradient(135deg,#ffd700,#ffb700);color:#5a3e00;font-weight:bold;font-size:13px;padding:4px 10px;border-radius:12px;white-space:nowrap;cursor:default;min-width:60px;text-align:center;box-shadow:0 2px 6px rgba(255,183,0,.3)}

/* Coin Popup */
.coin-popup{position:fixed;pointer-events:none;font-weight:bold;font-size:16px;color:#ffd700;text-shadow:0 2px 4px rgba(0,0,0,.4);animation:coinFloat 1.5s ease-out forwards;z-index:500}
@keyframes coinFloat{0%{opacity:1;transform:translateY(0) scale(1)}50%{opacity:1;transform:translateY(-25px) scale(1.1)}100%{opacity:0;transform:translateY(-50px) scale(0.9)}}

/* === SHOP === */
.shop-header{display:flex;align-items:center;gap:12px;padding:12px 0;margin-bottom:12px;border-bottom:2px solid var(--gray-200)}
.shop-header h2{color:var(--navy);font-size:22px}
.shop-tabs{display:flex;gap:6px;margin-bottom:16px;overflow-x:auto;padding-bottom:4px}
.shop-tab{padding:8px 14px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:13px;font-weight:bold;color:var(--gray-700);white-space:nowrap;transition:all .2s}
.shop-tab:hover{border-color:var(--blue);color:var(--blue)}
.shop-tab.active{background:var(--navy);color:#fff;border-color:var(--navy)}
.shop-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px}
.shop-item{background:var(--white);border:2px solid var(--gray-200);border-radius:12px;padding:16px;text-align:center;transition:all .2s}
.shop-item:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1)}
.shop-item.cant-afford{opacity:.6}
.shop-item.locked-item{opacity:.5;position:relative}
.shop-item.locked-item .shop-item-icon{filter:grayscale(1)}
.shop-item-lock{font-size:11px;color:#ef4444;font-weight:600;margin:4px 0}
.shop-item.sold-out{opacity:.4}
.pet-roster{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px}
.pet-roster-item{display:flex;flex-direction:column;align-items:center;padding:8px 12px;border:2px solid var(--gray-200);border-radius:10px;cursor:pointer;transition:all .2s;min-width:80px}
.pet-roster-item.active{border-color:var(--blue);background:#eff6ff}
.pet-roster-item:hover{transform:scale(1.05)}
.pet-roster-emoji{font-size:28px}
.pet-roster-name{font-size:11px;font-weight:bold;color:var(--navy)}
.pet-roster-info{font-size:10px;color:var(--gray-600)}
.pet-roster-active{font-size:9px;background:var(--blue);color:#fff;padding:1px 6px;border-radius:4px;margin-top:2px}
.pet-selector{display:flex;gap:6px;justify-content:center;margin-bottom:8px}
.pet-sel-btn{padding:6px 10px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:20px;cursor:pointer;transition:all .2s}
.pet-sel-btn.active{border-color:var(--blue);background:#eff6ff}
.pet-sel-btn:hover{transform:scale(1.1)}
.shop-item.sold-out{opacity:.5}
.shop-item-icon{font-size:36px;margin-bottom:8px}
.shop-item-name{font-weight:bold;font-size:14px;color:var(--navy);margin-bottom:4px}
.shop-item-desc{font-size:11px;color:var(--gray-600);margin-bottom:6px;line-height:1.3}
.shop-item-owned{font-size:11px;color:var(--gray-500);margin-bottom:6px}
.shop-buy-btn{background:linear-gradient(135deg,#ffd700,#ffb700);color:#5a3e00;border:none;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:bold;cursor:pointer;transition:all .2s}
.shop-buy-btn:hover:not(:disabled){transform:scale(1.05);box-shadow:0 2px 8px rgba(255,183,0,.4)}
.shop-buy-btn:disabled{background:var(--gray-300);color:var(--gray-500);cursor:not-allowed}

/* === GARDEN === */
.garden-header{display:flex;align-items:center;gap:8px;padding:12px 0;margin-bottom:12px;border-bottom:2px solid var(--gray-200);flex-wrap:wrap}

/* Garden Scene */
.garden-scene{position:relative;border-radius:16px;overflow:hidden;min-height:420px;background:linear-gradient(to bottom,#87CEEB 0%,#a8d8ea 28%,#7CCD7C 28%,#6ab84a 40%,#5a9e3a 100%);padding:0;display:flex;flex-direction:column}
.garden-sky{position:absolute;top:0;left:0;right:0;height:28%;pointer-events:none;z-index:1}
.garden-sky-sun{position:absolute;top:12px;right:16px;font-size:28px;filter:drop-shadow(0 0 8px rgba(255,200,0,.5));transition:opacity .3s}
.garden-sky-stars{display:none;position:absolute;top:8px;left:16px;font-size:16px;letter-spacing:12px}
.garden-fence{position:relative;z-index:2;display:flex;justify-content:center;padding:4px 12px 0;font-size:11px;letter-spacing:1px;color:#8B6914;opacity:.5;user-select:none}
.garden-ground{position:relative;z-index:2;flex:1;display:flex;flex-direction:column;padding:8px 16px 12px}
.garden-plots{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;max-width:480px;margin:0 auto;width:100%}

/* Dirt plot beds */
.garden-plot{aspect-ratio:1;background:linear-gradient(145deg,#8B6C42,#6B4E2E);border:2px solid #5a3e1b;border-radius:14px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:all .2s;position:relative;min-height:100px;box-shadow:inset 0 2px 6px rgba(0,0,0,.3),0 3px 6px rgba(0,0,0,.2)}
.garden-plot:hover{transform:scale(1.04);box-shadow:inset 0 2px 6px rgba(0,0,0,.3),0 5px 14px rgba(0,0,0,.25)}
.garden-plot.locked{background:linear-gradient(145deg,#6b6b6b,#4a4a4a);border-color:#3a3a3a;cursor:pointer;opacity:.6}
.garden-plot.locked:hover{opacity:.75}
.plot-lock{font-size:24px}
.plot-empty-icon{font-size:28px;opacity:.6;transition:opacity .2s}
.garden-plot.empty:hover .plot-empty-icon{opacity:1}
.garden-plot.empty{border-style:dashed;border-color:#7a5c30}
.plot-water-btn{margin-top:6px;padding:3px 10px;font-size:11px;border-radius:999px;border:1px solid rgba(59,130,246,.4);background:rgba(59,130,246,.15);color:#0b5394;font-weight:600;cursor:pointer;transition:all .2s}
.plot-water-btn:hover{background:rgba(59,130,246,.25);border-color:rgba(59,130,246,.6)}
.plot-water-btn:disabled{opacity:.5;cursor:not-allowed}
.plot-plant{font-size:40px;transition:all .3s;filter:drop-shadow(0 2px 2px rgba(0,0,0,.2))}
.plot-plant.glow-bounce{animation:glowBounce 1s infinite alternate;filter:drop-shadow(0 0 10px rgba(255,215,0,.7)) drop-shadow(0 0 20px rgba(255,215,0,.3))}
@keyframes glowBounce{0%{transform:scale(1)}100%{transform:scale(1.12) translateY(-5px)}}
.plot-progress-bar{width:75%;height:5px;background:rgba(0,0,0,.3);border-radius:3px;overflow:hidden;margin-top:6px}
.plot-progress-fill{height:100%;background:linear-gradient(90deg,#4ade80,#22c55e);border-radius:3px;transition:width .3s}
.plot-ready{font-size:11px;font-weight:bold;color:#fef08a;margin-top:4px;animation:pulse 1s infinite alternate;text-shadow:0 1px 2px rgba(0,0,0,.5)}
@keyframes pulse{0%{opacity:.7}100%{opacity:1}}
.plot-label{font-size:10px;color:rgba(255,255,255,.75);margin-top:2px;text-shadow:0 1px 1px rgba(0,0,0,.4)}
.plot-fertilized{position:absolute;top:4px;right:4px;font-size:14px;filter:drop-shadow(0 0 4px rgba(100,200,255,.5))}

/* Decorations in scene */
.garden-decos-row{display:flex;gap:10px;justify-content:center;padding:6px 0;z-index:2}
.garden-deco{font-size:26px;cursor:default;filter:drop-shadow(0 2px 2px rgba(0,0,0,.2))}

/* Garden Pet in scene */
.garden-pet{position:absolute;bottom:12px;left:16px;z-index:3;cursor:pointer;transition:transform .2s;text-align:center}
.garden-pet:hover{transform:scale(1.08)}
.garden-pet-sprite{position:relative;display:inline-block}
.garden-pet-emoji{font-size:44px;animation:petIdle 2s ease-in-out infinite;filter:drop-shadow(0 2px 3px rgba(0,0,0,.3))}
@keyframes petIdle{0%,100%{transform:translateY(0)}50%{transform:translateY(-5px)}}
.pet-accessory{position:absolute;top:-10px;right:-10px;font-size:20px}
.garden-pet-name{font-weight:bold;font-size:11px;color:#fff;text-shadow:0 1px 3px rgba(0,0,0,.5)}
.garden-pet-mood-bubble{position:absolute;top:-24px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,.92);border-radius:10px;padding:2px 7px;font-size:11px;white-space:nowrap;box-shadow:0 1px 4px rgba(0,0,0,.15);pointer-events:none}
.garden-pet-mood-bubble::after{content:'';position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:8px;height:4px;background:rgba(255,255,255,.92);clip-path:polygon(0 0,100% 0,50% 100%)}
.garden-bowls{position:absolute;bottom:20px;left:18px;display:flex;flex-direction:column;gap:8px;background:rgba(255,255,255,.85);border:2px solid rgba(15,23,42,.15);border-radius:14px;padding:10px 14px;box-shadow:0 6px 18px rgba(15,23,42,.15);min-width:150px}
.pet-bowl{display:flex;flex-direction:column;gap:4px}
.pet-bowl h4{font-size:12px;margin:0;color:var(--navy)}
.pet-bowl-level{height:8px;background:rgba(15,23,42,.08);border-radius:999px;overflow:hidden;position:relative}
.pet-bowl-fill{height:100%;background:linear-gradient(90deg,#f97316,#fbbf24);transition:width .3s}
.pet-bowl.water .pet-bowl-fill{background:linear-gradient(90deg,#2563eb,#60a5fa)}
.pet-bowl-actions{display:flex;gap:6px}
.pet-bowl-actions button{flex:1;padding:4px 6px;font-size:11px;border-radius:8px;border:1px solid rgba(15,23,42,.2);background:#fff;cursor:pointer}
.pet-bowl-actions button:disabled{opacity:.4;cursor:not-allowed}
.pet-bowl-meta{font-size:10px;color:var(--gray-600)}

/* Watering can button in scene */
.garden-water-btn,.garden-timeskip-btn{position:absolute;bottom:12px;z-index:3;background:rgba(255,255,255,.85);border:2px solid rgba(52,152,219,.4);border-radius:12px;padding:6px 12px;cursor:pointer;font-size:14px;transition:all .2s;display:flex;align-items:center;gap:4px;box-shadow:0 2px 8px rgba(0,0,0,.1)}
.garden-water-btn{right:16px}
.garden-timeskip-btn{right:128px;background:rgba(255,255,255,.78)}
.garden-water-btn:hover,.garden-timeskip-btn:hover{background:rgba(255,255,255,.95);transform:scale(1.05);border-color:rgba(52,152,219,.7)}
.garden-water-btn .water-count,.garden-timeskip-btn .skip-count{font-size:12px;font-weight:bold;color:#2563eb}
.garden-timeskip-btn.disabled{opacity:.45;cursor:not-allowed;transform:none}
.garden-water-meter{position:absolute;bottom:110px;right:16px;z-index:3;background:rgba(255,255,255,.92);border:2px solid rgba(52,152,219,.35);border-radius:14px;padding:10px 14px;font-size:12px;box-shadow:0 2px 10px rgba(0,0,0,.12);width:160px}
.garden-water-meter .water-meter-label{font-weight:600;color:#2563eb;margin-bottom:4px;text-transform:uppercase;font-size:11px;letter-spacing:.05em}
.garden-water-meter .water-meter-bar{position:relative;height:10px;background:rgba(37,99,235,.12);border-radius:999px;overflow:hidden}
.garden-water-meter .water-meter-fill{position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,#2563eb,#60a5fa);border-radius:999px;transition:width .3s ease}
.garden-water-meter .water-meter-text{margin-top:6px;font-weight:bold;color:#2563eb}
.garden-water-meter .water-meter-text.low{color:#f97316}
.garden-water-meter .water-meter-text.critical{color:#dc2626}
.garden-water-meter.pulse .water-meter-fill{animation:meterPulse .7s ease}
@keyframes meterPulse{0%{box-shadow:0 0 0 0 rgba(96,165,250,.6)}100%{box-shadow:0 0 0 12px rgba(96,165,250,0)}}

/* Weather effects on scene */
.garden-scene.water-low{filter:saturate(.6) brightness(.92)}
.garden-scene.water-critical{filter:saturate(.35) brightness(.82)}

/* Seed Picker & Plot Info Modals */
.garden-modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:5000;animation:fadeIn .2s}
.garden-modal{background:var(--white);border-radius:16px;padding:24px;max-width:380px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,.3);position:relative;max-height:80vh;overflow-y:auto}
.garden-modal h3{margin:0 0 16px;font-size:18px;color:var(--navy);text-align:center}
.garden-modal-close{position:absolute;top:10px;right:12px;background:none;border:none;font-size:22px;color:var(--gray-400);cursor:pointer;line-height:1;padding:4px}
.garden-modal-close:hover{color:var(--gray-700)}
.seed-option{display:flex;align-items:center;gap:12px;padding:12px;border:2px solid var(--gray-200);border-radius:12px;cursor:pointer;transition:all .15s;margin-bottom:8px}
.seed-option:hover{border-color:var(--green);background:rgba(74,222,128,.08);transform:translateX(4px)}
.seed-option:active{transform:translateX(2px) scale(.98)}
.seed-option-icon{font-size:32px;flex-shrink:0}
.seed-option-info{flex:1}
.seed-option-name{font-weight:bold;font-size:14px;color:var(--navy)}
.seed-option-meta{font-size:12px;color:var(--gray-600);margin-top:2px}
.seed-option-count{font-size:12px;font-weight:bold;color:var(--green);background:rgba(74,222,128,.15);padding:2px 8px;border-radius:8px;flex-shrink:0}
.plot-info-header{text-align:center;margin-bottom:16px}
.plot-info-header .plot-info-emoji{font-size:48px}
.plot-info-header .plot-info-name{font-size:16px;font-weight:bold;color:var(--navy);margin-top:4px}
.plot-info-stats{display:flex;flex-direction:column;gap:8px;margin-bottom:16px}
.plot-info-stat{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--gray-700)}
.plot-info-stat span:last-child{font-weight:600}
.plot-info-progress{width:100%;height:8px;background:var(--gray-200);border-radius:4px;overflow:hidden;margin:4px 0 12px}
.plot-info-progress-fill{height:100%;background:linear-gradient(90deg,#4ade80,#22c55e);border-radius:4px;transition:width .3s}
.plot-info-actions{display:flex;flex-direction:column;gap:8px}
.plot-info-action{display:flex;align-items:center;gap:10px;padding:10px 12px;border:2px solid var(--gray-200);border-radius:10px;cursor:pointer;transition:all .15s;background:none;width:100%;text-align:left;font-size:13px;color:var(--navy)}
.plot-info-action:hover:not(:disabled){border-color:var(--blue);background:rgba(37,99,235,.06)}
.plot-info-action:disabled{opacity:.4;cursor:not-allowed}
.plot-info-action-icon{font-size:22px;flex-shrink:0}
.plot-info-action-label{font-weight:600}
.plot-info-action-desc{font-size:11px;color:var(--gray-500)}

/* === PET MODAL === */
.pet-modal-content{background:var(--white);border-radius:16px;padding:24px;max-width:400px;width:90%;margin:40px auto;position:relative;max-height:85vh;overflow-y:auto}
.pet-modal-close{position:absolute;top:12px;right:12px;background:none;border:none;font-size:24px;color:var(--gray-500);cursor:pointer}
.pet-modal-sprite{text-align:center;position:relative;display:inline-block;width:100%}
.pet-modal-emoji{font-size:64px}
.pet-modal-acc{position:absolute;top:0;right:calc(50% - 50px);font-size:24px}
.pet-modal-name{text-align:center;font-size:20px;font-weight:bold;color:var(--navy);cursor:pointer;margin:8px 0 4px}
.pet-modal-name:hover{text-decoration:underline}
.pet-modal-stage{text-align:center;font-size:13px;color:var(--gray-600);margin-bottom:12px}
.pet-meters{display:flex;flex-direction:column;gap:8px;margin-bottom:16px}
.pet-meter{display:flex;align-items:center;gap:8px;font-size:12px;color:var(--gray-700)}
.pet-meter span{min-width:70px}
.pet-meter span:last-child{min-width:35px;text-align:right}
.pet-meter-bar{flex:1;height:10px;background:var(--gray-200);border-radius:5px;overflow:hidden}
.pet-meter-fill{height:100%;border-radius:5px;transition:width .3s}
.pet-meter-fill.hunger{background:linear-gradient(90deg,#e74c3c,#e67e22)}
.pet-meter-fill.happiness{background:linear-gradient(90deg,#f39c12,#ffd60a)}
.pet-meter-fill.evolution{background:linear-gradient(90deg,#9b59b6,#3498db)}
.pet-meter-fill.care{background:linear-gradient(90deg,#10b981,#06b6d4)}
.pet-sick-banner{background:#fef3c7;border:1px solid #f59e0b;color:#92400e;padding:6px 10px;border-radius:8px;font-size:12px;text-align:center;margin:6px 0;animation:buddySick 2s ease-in-out infinite}
.pet-evo-timer{font-size:11px;color:var(--blue);text-align:center;margin:4px 0;font-weight:500}
.food-growth{font-size:9px;color:var(--green);margin-left:4px;font-weight:600}
.pet-modal-content h4{font-size:13px;color:var(--navy);margin:12px 0 8px;border-bottom:1px solid var(--gray-200);padding-bottom:4px}
.pet-food-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px}
.pet-food-btn{padding:8px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:12px;cursor:pointer;transition:all .2s;display:flex;align-items:center;gap:6px}
.pet-food-btn:hover:not(:disabled){border-color:var(--green);background:#eafaf1}
.pet-food-btn:disabled{opacity:.4;cursor:not-allowed}
.pet-food-count{margin-left:auto;background:var(--gray-100);padding:2px 6px;border-radius:4px;font-size:11px}
.pet-accessory-grid{display:flex;flex-wrap:wrap;gap:6px}
.pet-accessory-btn{width:44px;height:44px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:20px;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center}
.pet-accessory-btn:hover{border-color:var(--blue)}
.pet-accessory-btn.equipped{border-color:var(--green);background:#eafaf1}
.pet-modal-stats{display:flex;gap:16px;justify-content:center;margin-top:16px;font-size:11px;color:var(--gray-500)}

/* Achievement Toast */
.achievement-toast{position:fixed;bottom:100px;right:20px;background:#fff;border:2px solid var(--yellow);border-radius:12px;padding:16px 20px;box-shadow:0 8px 24px rgba(0,0,0,.2);z-index:600;display:flex;align-items:center;gap:14px;animation:achievementSlide .5s ease-out;max-width:320px}
.achievement-toast.hidden{display:none}
.ach-icon{font-size:40px;flex-shrink:0}
.ach-info{flex:1}
.ach-name{font-weight:bold;font-size:16px;color:var(--navy);margin-bottom:2px}
.ach-desc{font-size:13px;color:var(--gray-600)}
.ach-xp{font-size:12px;color:var(--green);font-weight:bold;margin-top:4px}
@keyframes achievementSlide{0%{opacity:0;transform:translateX(100px)}100%{opacity:1;transform:translateX(0)}}

/* Level Up Modal */
.levelup-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);z-index:1000;display:none;align-items:center;justify-content:center}
.levelup-overlay.active{display:flex}
.levelup-modal{background:linear-gradient(135deg,#1e3a5c,#2c5a8a);color:#fff;padding:40px 50px;border-radius:20px;text-align:center;animation:levelUpBounce .6s ease-out;box-shadow:0 20px 60px rgba(0,0,0,.4)}
.levelup-modal .level-icon{font-size:60px;margin-bottom:12px}
.levelup-modal h2{font-size:32px;margin-bottom:8px;color:var(--yellow)}
.levelup-modal .level-num{font-size:64px;font-weight:bold;color:#fff;margin:12px 0}
.levelup-modal .level-title{font-size:20px;color:var(--yellow);margin-bottom:16px}
.levelup-modal .level-rewards{font-size:14px;opacity:.9;margin-bottom:20px}
.levelup-modal button{background:var(--yellow);color:#1a3a5c;border:none;padding:12px 32px;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer}
.levelup-modal button:hover{background:#fff}
@keyframes levelUpBounce{0%{opacity:0;transform:scale(.5)}60%{transform:scale(1.1)}100%{opacity:1;transform:scale(1)}}

/* Study Buddy Widget */
.study-buddy{position:fixed;background:#fff;border:2px solid var(--gray-200);border-radius:16px;padding:12px 16px;box-shadow:0 4px 12px rgba(0,0,0,.1);z-index:100;display:none;text-align:center;cursor:grab;transition:transform .2s,box-shadow .2s;touch-action:none;user-select:none;transform-origin:center}
.study-buddy.hidden{display:none!important}
.study-buddy.active{display:block}
@media (hover:hover) {
    .study-buddy:hover:not(.dragging){transform:scale(1.05)}
}
.study-buddy.dragging{cursor:grabbing;box-shadow:0 6px 18px rgba(0,0,0,.25)}
.buddy-sprite{font-size:36px;margin-bottom:4px}
.buddy-name{font-size:12px;font-weight:bold;color:var(--navy)}
.buddy-mood{font-size:10px;color:var(--gray-600)}
.study-buddy.urgent{animation:buddyPulse 1.5s ease-in-out infinite;border-color:#ef4444}
.study-buddy.sick{animation:buddySick 1s ease-in-out infinite;border-color:#f59e0b;background:#fffbeb}
@keyframes buddyPulse{0%,100%{transform:scale(1);box-shadow:0 4px 12px rgba(0,0,0,.1)}50%{transform:scale(1.08);box-shadow:0 4px 16px rgba(239,68,68,.3)}}
@keyframes buddySick{0%,100%{transform:rotate(0deg)}25%{transform:rotate(-3deg)}75%{transform:rotate(3deg)}}
.buddy-progress{width:60px;height:4px;background:var(--gray-200);border-radius:2px;margin:6px auto 0;overflow:hidden}
.buddy-progress-fill{height:100%;background:var(--green);border-radius:2px}

/* Power-Up Button */
.powerup-btn{background:linear-gradient(135deg,#9b59b6,#8e44ad);color:#fff;border:none;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:bold;cursor:pointer;display:inline-flex;align-items:center;gap:6px;margin:4px;transition:all .2s}
.powerup-btn:hover{transform:scale(1.05);box-shadow:0 4px 12px rgba(155,89,182,.4)}
.powerup-btn:disabled{background:var(--gray-400);cursor:not-allowed;transform:none}
.powerup-btn .pu-icon{font-size:16px}
.powerup-btn .pu-count{background:rgba(255,255,255,.3);padding:2px 6px;border-radius:4px;font-size:11px}

/* Power-Up Bar */
.powerup-bar{display:flex;flex-wrap:wrap;gap:6px;margin:8px 0;justify-content:center}

/* Category Mastery Badges */
.mastery-badge{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:12px;font-size:11px;font-weight:bold}
.mastery-badge.bronze{background:#cd7f32;color:#fff}
.mastery-badge.silver{background:#c0c0c0;color:#333}
.mastery-badge.gold{background:linear-gradient(135deg,#ffd700,#ffb700);color:#333}
.mastery-badge.platinum{background:linear-gradient(135deg,#e5e4e2,#a0d2db);color:#333}

/* === BATTLE SYSTEM === */
.battle-header{display:flex;align-items:center;gap:8px;padding:12px 0;margin-bottom:12px;border-bottom:2px solid var(--gray-200);flex-wrap:wrap}
.battle-header h2{flex:1;text-align:center;margin:0;font-size:18px;color:var(--navy)}
.battle-header .battle-stars{color:var(--yellow);font-size:14px;letter-spacing:2px}
.battle-arena{display:flex;flex-direction:column;align-items:center;gap:8px;padding:16px 0}
.battle-combatant{display:flex;flex-direction:column;align-items:center;gap:6px;padding:12px 20px;background:var(--white);border:2px solid var(--gray-200);border-radius:12px;min-width:220px;position:relative;transition:transform .15s}
.battle-combatant.enemy-side{border-color:var(--red)}
.battle-combatant.pet-side{border-color:var(--blue)}
.battle-combatant .combatant-sprite{font-size:48px;line-height:1}
.battle-combatant .combatant-name{font-size:14px;font-weight:bold;color:var(--gray-800)}
.battle-combatant .combatant-level{font-size:11px;color:var(--gray-600)}
.battle-hp{width:100%;display:flex;align-items:center;gap:6px;font-size:11px}
.battle-hp-bar{flex:1;height:12px;background:var(--gray-200);border-radius:6px;overflow:hidden}
.battle-hp-fill{height:100%;border-radius:6px;transition:width .4s ease}
.battle-hp-fill.hp-high{background:linear-gradient(90deg,#27ae60,#2ecc71)}
.battle-hp-fill.hp-mid{background:linear-gradient(90deg,#f39c12,#f1c40f)}
.battle-hp-fill.hp-low{background:linear-gradient(90deg,#c0392b,#e74c3c)}
.battle-vs{font-size:28px;font-weight:bold;color:var(--gray-400);margin:4px 0}
.battle-stats-row{display:flex;gap:16px;font-size:11px;color:var(--gray-600)}
.battle-stats-row span{display:flex;align-items:center;gap:3px}
.battle-question{margin-top:12px;padding:16px;background:var(--white);border:1px solid var(--gray-200);border-radius:8px}
.battle-question .bq-text{font-size:14px;color:var(--gray-800);margin-bottom:12px;line-height:1.5}
.battle-question .bq-options{display:grid;gap:8px}
.battle-question .bq-opt{padding:12px 14px;border:2px solid var(--gray-200);border-radius:var(--radius);background:var(--white);text-align:left;font-size:13px;cursor:pointer;transition:all .15s}
.battle-question .bq-opt:hover:not(.disabled){background:#f0f7ff;border-color:var(--blue)}
.battle-question .bq-opt.correct{border-color:var(--green);background:#eafaf1}
.battle-question .bq-opt.wrong{border-color:var(--red);background:#fdf2f2}
.battle-question .bq-opt.disabled{cursor:not-allowed;opacity:.7}
.battle-items-bar{display:flex;gap:8px;justify-content:center;margin-top:12px;flex-wrap:wrap}
.battle-item-btn{padding:8px 14px;border:1px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:12px;display:flex;align-items:center;gap:4px;cursor:pointer;transition:all .15s}
.battle-item-btn:hover:not(:disabled){border-color:var(--blue);background:#f0f7ff}
.battle-item-btn:disabled{opacity:.4;cursor:not-allowed}
.battle-item-btn .item-count{background:var(--blue);color:#fff;border-radius:50%;width:18px;height:18px;display:inline-flex;align-items:center;justify-content:center;font-size:10px;font-weight:bold}
.battle-log{margin-top:8px;padding:8px 12px;background:var(--gray-50);border-radius:6px;font-size:12px;color:var(--gray-600);text-align:center;min-height:24px}

/* Chapter Select */
.chapter-select{display:grid;grid-template-columns:1fr;gap:12px;max-width:500px;margin:0 auto}
.chapter-card{display:flex;align-items:center;gap:14px;padding:16px;border:2px solid var(--gray-200);border-radius:12px;background:var(--white);cursor:pointer;transition:all .2s}
.chapter-card:hover:not(.locked){border-color:var(--blue);transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1)}
.chapter-card.locked{opacity:.5;cursor:not-allowed;filter:grayscale(.6)}
.chapter-card.current{border-color:var(--green);background:#eafaf1}
.chapter-card .ch-icon{font-size:36px;line-height:1}
.chapter-card .ch-info{flex:1}
.chapter-card .ch-name{font-size:15px;font-weight:bold;color:var(--navy)}
.chapter-card .ch-progress{font-size:11px;color:var(--gray-600);margin-top:2px}
.chapter-card .ch-stars{color:var(--yellow);font-size:13px;letter-spacing:1px}
.chapter-card .ch-lock{font-size:20px;color:var(--gray-400)}
.chapter-card .ch-req{font-size:11px;color:var(--gray-500)}

/* Battle result overlay */
.battle-result-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:5000;animation:fadeIn .3s}
.battle-result-modal{background:var(--white);border-radius:16px;padding:32px;text-align:center;max-width:360px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,.3)}
.battle-result-modal h2{font-size:24px;margin-bottom:8px}
.battle-result-modal .result-icon{font-size:56px;margin-bottom:12px}
.battle-result-modal .result-rewards{margin:16px 0;font-size:14px;color:var(--gray-700)}
.battle-result-modal .result-rewards div{margin:4px 0}
.battle-result-modal button{margin:6px;padding:10px 24px;border:none;border-radius:8px;font-size:14px;font-weight:bold;cursor:pointer}
.battle-result-modal .btn-primary{background:var(--blue);color:#fff}
.battle-result-modal .btn-secondary{background:var(--gray-200);color:var(--gray-700)}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}

/* Battle animations */
@keyframes battleShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-8px)}40%{transform:translateX(8px)}60%{transform:translateX(-5px)}80%{transform:translateX(5px)}}
@keyframes battleFlash{0%{opacity:1}25%{opacity:.3}50%{opacity:1}75%{opacity:.3}100%{opacity:1}}
.battle-shake{animation:battleShake .4s ease}
.battle-flash{animation:battleFlash .5s ease}
.battle-dmg-popup{position:absolute;top:-10px;right:0;font-size:18px;font-weight:bold;color:var(--red);animation:dmgFloat .8s ease forwards;pointer-events:none}
.battle-dmg-popup.heal{color:var(--green)}
@keyframes dmgFloat{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-30px)}}

/* Battle dark mode */
[data-theme="dark"] .battle-header{border-color:#374151}
[data-theme="dark"] .battle-combatant{background:#16213e;border-color:#374151}
[data-theme="dark"] .battle-combatant.enemy-side{border-color:#7f1d1d}
[data-theme="dark"] .battle-combatant.pet-side{border-color:#1e3a5f}
[data-theme="dark"] .battle-combatant .combatant-name{color:#e5e7eb}
[data-theme="dark"] .battle-hp-bar{background:#374151}
[data-theme="dark"] .battle-question{background:#16213e;border-color:#374151}
[data-theme="dark"] .battle-question .bq-text{color:#e5e7eb}
[data-theme="dark"] .battle-question .bq-opt{background:#1f2937;border-color:#374151;color:#e5e7eb}
[data-theme="dark"] .battle-question .bq-opt:hover:not(.disabled){background:#1e3a5f;border-color:var(--blue)}
[data-theme="dark"] .battle-question .bq-opt.correct{background:#064e3b;border-color:var(--green)}
[data-theme="dark"] .battle-question .bq-opt.wrong{background:#7f1d1d;border-color:var(--red)}
[data-theme="dark"] .battle-item-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .battle-log{background:#1f2937;color:#9ca3af}
[data-theme="dark"] .chapter-card{background:#16213e;border-color:#374151;color:#e5e7eb}
[data-theme="dark"] .chapter-card:hover:not(.locked){border-color:var(--blue);background:#1e3a5f}
[data-theme="dark"] .chapter-card.current{border-color:var(--green);background:#064e3b}
[data-theme="dark"] .chapter-card .ch-name{color:#93c5fd}
[data-theme="dark"] .battle-result-modal{background:#16213e;color:#e5e7eb}
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .battle-header{border-color:#374151}
    body:not([data-theme="light"]) .battle-combatant{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .battle-combatant.enemy-side{border-color:#7f1d1d}
    body:not([data-theme="light"]) .battle-combatant.pet-side{border-color:#1e3a5f}
    body:not([data-theme="light"]) .battle-hp-bar{background:#374151}
    body:not([data-theme="light"]) .battle-question{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .battle-question .bq-opt{background:#1f2937;border-color:#374151;color:#e5e7eb}
    body:not([data-theme="light"]) .battle-question .bq-opt:hover:not(.disabled){background:#1e3a5f;border-color:var(--blue)}
    body:not([data-theme="light"]) .battle-question .bq-opt.correct{background:#064e3b;border-color:var(--green)}
    body:not([data-theme="light"]) .battle-question .bq-opt.wrong{background:#7f1d1d;border-color:var(--red)}
    body:not([data-theme="light"]) .battle-item-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
    body:not([data-theme="light"]) .battle-log{background:#1f2937;color:#9ca3af}
    body:not([data-theme="light"]) .chapter-card{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .chapter-card:hover:not(.locked){border-color:var(--blue);background:#1e3a5f}
    body:not([data-theme="light"]) .chapter-card .ch-name{color:#93c5fd}
    body:not([data-theme="light"]) .battle-result-modal{background:#16213e;color:#e5e7eb}
}

/* Confetti Canvas */
#confettiCanvas{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999}

/* Gamification Settings */
.gamify-settings{margin-top:12px}
.gamify-settings label{display:flex;align-items:center;gap:8px;margin:8px 0;font-size:13px;color:var(--gray-700);cursor:pointer}
.gamify-settings input[type="checkbox"]{width:18px;height:18px;accent-color:var(--blue)}
.gamify-settings .volume-row{display:flex;align-items:center;gap:12px;margin:12px 0}
.gamify-settings .volume-row label{margin:0;flex-shrink:0}
.gamify-settings input[type="range"]{flex:1;height:6px;accent-color:var(--blue)}
.gamify-settings .gamify-reset{margin-top:12px}

/* Dark Mode Gamification */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .xp-bar-container{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
    body:not([data-theme="light"]) .achievement-toast{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .achievement-toast .ach-name{color:#93c5fd}
    body:not([data-theme="light"]) .achievement-toast .ach-desc{color:#d1d5db}
    body:not([data-theme="light"]) .study-buddy{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .study-buddy .buddy-name{color:#93c5fd}
    body:not([data-theme="light"]) .study-buddy .buddy-mood{color:#9ca3af}
    body:not([data-theme="light"]) .levelup-modal{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
}
[data-theme="dark"] .xp-bar-container{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
[data-theme="dark"] .achievement-toast{background:#16213e;border-color:#374151}
[data-theme="dark"] .achievement-toast .ach-name{color:#93c5fd}
[data-theme="dark"] .achievement-toast .ach-desc{color:#d1d5db}
[data-theme="dark"] .study-buddy{background:#16213e;border-color:#374151}
[data-theme="dark"] .study-buddy .buddy-name{color:#93c5fd}
[data-theme="dark"] .study-buddy .buddy-mood{color:#9ca3af}
[data-theme="dark"] .levelup-modal{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
[data-theme="dark"] .shop-item,[data-theme="dark"] .pet-modal-content{background:#16213e;border-color:#374151}
[data-theme="dark"] .shop-item-name,[data-theme="dark"] .pet-modal-name{color:#93c5fd}
[data-theme="dark"] .shop-tab{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .shop-tab.active{background:#2563eb;border-color:#2563eb}
[data-theme="dark"] .garden-scene{background:linear-gradient(to bottom,#0d1b3e 0%,#162350 28%,#1a3a1a 28%,#122e12 40%,#0a1f0a 100%)}
[data-theme="dark"] .garden-sky-stars{display:block}
[data-theme="dark"] .garden-sky-sun{display:none}
[data-theme="dark"] .garden-plot{background:linear-gradient(145deg,#4a3728,#3a2718);border-color:#2a1a0a}
[data-theme="dark"] .garden-plot.locked{background:linear-gradient(145deg,#2a2a2a,#1a1a1a);border-color:#111}
[data-theme="dark"] .garden-plot.empty{border-color:#5a4530}
[data-theme="dark"] .garden-header{border-color:#374151}
[data-theme="dark"] .garden-modal{background:#16213e}
[data-theme="dark"] .garden-modal h3,.garden-modal .plot-info-name{color:#93c5fd}
[data-theme="dark"] .seed-option{border-color:#374151}
[data-theme="dark"] .seed-option:hover{border-color:#4ade80;background:rgba(74,222,128,.1)}
[data-theme="dark"] .seed-option-name{color:#e2e8f0}
[data-theme="dark"] .seed-option-meta{color:#9ca3af}
[data-theme="dark"] .plot-info-stat{color:#d1d5db}
[data-theme="dark"] .plot-info-action{border-color:#374151;color:#e2e8f0}
[data-theme="dark"] .plot-info-action:hover:not(:disabled){border-color:#60a5fa;background:rgba(96,165,250,.1)}
[data-theme="dark"] .garden-water-btn,[data-theme="dark"] .garden-timeskip-btn{background:rgba(30,40,60,.85);border-color:rgba(96,165,250,.4);color:#e2e8f0}
[data-theme="dark"] .garden-water-meter{background:rgba(15,23,42,.92);border-color:rgba(96,165,250,.3)}
[data-theme="dark"] .garden-water-meter .water-meter-bar{background:rgba(59,130,246,.2)}
[data-theme="dark"] .garden-water-meter .water-meter-fill{background:linear-gradient(90deg,#3b82f6,#60a5fa)}
[data-theme="dark"] .garden-pet-mood-bubble{background:rgba(30,40,60,.92);color:#e2e8f0}
[data-theme="dark"] .garden-pet-mood-bubble::after{background:rgba(30,40,60,.92)}
[data-theme="dark"] .shop-header{border-color:#374151}
[data-theme="dark"] .pet-food-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .pet-accessory-btn{background:#1f2937;border-color:#374151}
[data-theme="dark"] .pet-meter-bar{background:#374151}
[data-theme="dark"] .pet-sick-banner{background:#451a03;border-color:#92400e;color:#fbbf24}
[data-theme="dark"] .study-buddy.sick{background:#1c1917;border-color:#92400e}
[data-theme="dark"] .pet-sel-btn{background:#1f2937;border-color:#374151}
[data-theme="dark"] .pet-sel-btn.active{background:#1e3a5f;border-color:#2563eb}
[data-theme="dark"] .pet-roster-item{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .pet-roster-item.active{background:#1e3a5f;border-color:#2563eb}
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .shop-item,body:not([data-theme="light"]) .pet-modal-content{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .shop-item-name,body:not([data-theme="light"]) .pet-modal-name{color:#93c5fd}
    body:not([data-theme="light"]) .shop-tab{background:#1f2937;border-color:#374151;color:#d1d5db}
    body:not([data-theme="light"]) .shop-tab.active{background:#2563eb;border-color:#2563eb}
    body:not([data-theme="light"]) .garden-scene{background:linear-gradient(to bottom,#0d1b3e 0%,#162350 28%,#1a3a1a 28%,#122e12 40%,#0a1f0a 100%)}
    body:not([data-theme="light"]) .garden-sky-stars{display:block}
    body:not([data-theme="light"]) .garden-sky-sun{display:none}
    body:not([data-theme="light"]) .garden-plot{background:linear-gradient(145deg,#4a3728,#3a2718);border-color:#2a1a0a}
    body:not([data-theme="light"]) .garden-plot.locked{background:linear-gradient(145deg,#2a2a2a,#1a1a1a);border-color:#111}
    body:not([data-theme="light"]) .garden-plot.empty{border-color:#5a4530}
    body:not([data-theme="light"]) .garden-header,body:not([data-theme="light"]) .shop-header{border-color:#374151}
    body:not([data-theme="light"]) .garden-modal{background:#16213e}
    body:not([data-theme="light"]) .garden-water-btn,body:not([data-theme="light"]) .garden-timeskip-btn{background:rgba(30,40,60,.85);border-color:rgba(96,165,250,.4);color:#e2e8f0}
    body:not([data-theme="light"]) .garden-pet-mood-bubble{background:rgba(30,40,60,.92);color:#e2e8f0}
    body:not([data-theme="light"]) .pet-food-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
    body:not([data-theme="light"]) .pet-accessory-btn{background:#1f2937;border-color:#374151}
    body:not([data-theme="light"]) .pet-meter-bar{background:#374151}
    body:not([data-theme="light"]) .pet-sick-banner{background:#451a03;border-color:#92400e;color:#fbbf24}
    body:not([data-theme="light"]) .study-buddy.sick{background:#1c1917;border-color:#92400e}
}

/* === CENGAGE LIGHT THEME === */
[data-theme="cengage-light"] {
    --navy: #1a4480; --navy-dark: #0d2a5a; --blue: #0066cc; --blue-light: #1a8cff;
    --bg: #f0f2f5; --white: #ffffff; --gray-50: #f8f9fa; --gray-100: #e9ecef;
    --gray-200: #dee2e6; --gray-300: #ced4da; --gray-400: #adb5bd; --gray-500: #6c757d;
    --gray-600: #495057; --gray-700: #343a40; --gray-800: #212529; --gray-900: #111;
    --green: #198754; --green-light: #20c997; --red: #dc3545; --red-light: #f77;
    --orange: #fd7e14; --yellow: #ffc107;
}
[data-theme="cengage-light"] .main-header {
    background: linear-gradient(to bottom, #1a4480, #0d2a5a);
    border-bottom: 3px solid #ffc107;
}
[data-theme="cengage-light"] .option-item { border-radius: 2px; }
[data-theme="cengage-light"] .bank-card,
[data-theme="cengage-light"] .question-container,
[data-theme="cengage-light"] .modal { border-radius: 2px; border: 1px solid #dee2e6; }
[data-theme="cengage-light"] .btn-nav { border-radius: 2px; }

/* === CENGAGE DARK THEME === */
[data-theme="cengage-dark"] {
    --navy: #1a4480; --navy-dark: #0d1b33; --blue: #4d9fff; --blue-light: #6db3ff;
    --bg: #1e1e2e; --white: #2a2a3a; --gray-50: #2f2f42; --gray-100: #3a3a50;
    --gray-200: #4a4a60; --gray-300: #6a6a80; --gray-400: #8a8a9a; --gray-500: #a0a0b0;
    --gray-600: #c0c0d0; --gray-700: #d8d8e8; --gray-800: #e8e8f0; --gray-900: #f0f0f8;
    --green: #20c997; --green-light: #3ddca8; --red: #ff6b6b; --red-light: #ff8a8a;
    --orange: #ffa94d; --yellow: #ffd43b;
}
[data-theme="cengage-dark"] body, body[data-theme="cengage-dark"] { color: #e8e8f0; }
[data-theme="cengage-dark"] .main-header {
    background: linear-gradient(to bottom, #0d1b33, #060e1f);
    border-bottom: 3px solid #ffd43b;
}
[data-theme="cengage-dark"] .question-container,
[data-theme="cengage-dark"] .bank-card,
[data-theme="cengage-dark"] .modal,
[data-theme="cengage-dark"] .score-container { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .option-item { background: #2f2f42; border-color: #3a3a50; border-radius: 2px; }
[data-theme="cengage-dark"] .option-item:hover:not(.disabled):not(.correct-answer):not(.wrong-answer) { background: #35355a; border-color: #4d9fff; }
[data-theme="cengage-dark"] .option-item.selected { background: #1a3366; border-color: #4d9fff; }
[data-theme="cengage-dark"] .option-item.correct-answer { background: #0d3b2e; border-color: #20c997; }
[data-theme="cengage-dark"] .option-item.wrong-answer { background: #4a1a1a; border-color: #ff6b6b; }
[data-theme="cengage-dark"] .btn-nav { border-radius: 2px; }
[data-theme="cengage-dark"] .explanation-panel { background: #0d3b2e; border-color: #20c997; color: #a7f3d0; }
[data-theme="cengage-dark"] .explanation-panel.incorrect { background: #4a1a1a; border-color: #ff6b6b; color: #fecaca; }
[data-theme="cengage-dark"] .xp-bar-container { background: linear-gradient(135deg, #0d1b33, #1a2844); }
[data-theme="cengage-dark"] .achievement-toast { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .study-buddy { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .levelup-modal { background: linear-gradient(135deg, #0d1b33, #1a2844); }
[data-theme="cengage-dark"] .ai-card { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .ai-card .option-item { background: #2f2f42; border-color: #3a3a50; }
[data-theme="cengage-dark"] .progress-section { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .progress-table th { background: #1a2844; color: #6db3ff; }

/* === SYNTHWAVE THEME (fun) === */
[data-theme="synthwave"] {
    --navy: #2b1055; --navy-dark: #1a0a33; --blue: #00d4ff; --blue-light: #00eaff;
    --bg: #0f0e17; --white: #1a1a2e; --gray-50: #1f1f35; --gray-100: #2a2a44;
    --gray-200: #3a3a55; --gray-300: #5a5a75; --gray-400: #8080a0; --gray-500: #a0a0c0;
    --gray-600: #c0c0e0; --gray-700: #d8d8f0; --gray-800: #e8e8ff; --gray-900: #f0f0ff;
    --green: #00ff88; --green-light: #33ffaa; --red: #ff2a6d; --red-light: #ff5588;
    --orange: #ff6e27; --yellow: #ffdd00;
    --radius: 8px;
}
[data-theme="synthwave"] body, body[data-theme="synthwave"] { color: #e8e8ff; }
[data-theme="synthwave"] .main-header {
    background: linear-gradient(135deg, #2b1055 0%, #d53369 50%, #2b1055 100%);
    border-bottom: 3px solid #00d4ff;
}
[data-theme="synthwave"] .main-header .logo-text { text-shadow: 0 0 10px #00d4ff; }
[data-theme="synthwave"] .home-hero h1 { background: linear-gradient(90deg, #00d4ff, #ff2a6d, #ffdd00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
[data-theme="synthwave"] .question-container,
[data-theme="synthwave"] .bank-card,
[data-theme="synthwave"] .modal,
[data-theme="synthwave"] .score-container { background: #1a1a2e; border: 1px solid #3a3a55; box-shadow: 0 0 15px rgba(0,212,255,0.08); }
[data-theme="synthwave"] .option-item { background: #1f1f35; border-color: #3a3a55; }
[data-theme="synthwave"] .option-item:hover:not(.disabled):not(.correct-answer):not(.wrong-answer) { background: #2a2050; border-color: #00d4ff; box-shadow: 0 0 8px rgba(0,212,255,0.2); }
[data-theme="synthwave"] .option-item.selected { background: #2a1060; border-color: #d53369; box-shadow: 0 0 10px rgba(213,51,105,0.3); }
[data-theme="synthwave"] .option-item.correct-answer { background: #0a3020; border-color: #00ff88; box-shadow: 0 0 10px rgba(0,255,136,0.2); }
[data-theme="synthwave"] .option-item.wrong-answer { background: #3a0a20; border-color: #ff2a6d; box-shadow: 0 0 10px rgba(255,42,109,0.2); }
[data-theme="synthwave"] .btn-nav { border-radius: 8px; }
[data-theme="synthwave"] .btn-nav:hover { box-shadow: 0 0 8px rgba(0,212,255,0.3); }
[data-theme="synthwave"] .explanation-panel { background: #0a3020; border-color: #00ff88; color: #aaffcc; }
[data-theme="synthwave"] .explanation-panel.incorrect { background: #3a0a20; border-color: #ff2a6d; color: #ffaacc; }
[data-theme="synthwave"] .xp-bar-container { background: linear-gradient(135deg, #1a0a33, #2b1055); }
[data-theme="synthwave"] .xp-bar .xp-fill { background: linear-gradient(90deg, #d53369, #00d4ff); }
[data-theme="synthwave"] .achievement-toast { background: #1a1a2e; border-color: #d53369; box-shadow: 0 0 15px rgba(213,51,105,0.2); }
[data-theme="synthwave"] .study-buddy { background: #1a1a2e; border-color: #3a3a55; }
[data-theme="synthwave"] .levelup-modal { background: linear-gradient(135deg, #1a0a33, #2b1055); }
[data-theme="synthwave"] .combo-display.active { background: linear-gradient(135deg, #d53369, #2b1055); border-color: #00d4ff; }
[data-theme="synthwave"] .ai-card { background: #1a1a2e; border-color: #3a3a55; }
[data-theme="synthwave"] .ai-card .option-item { background: #1f1f35; border-color: #3a3a55; }
[data-theme="synthwave"] .progress-section { background: #1a1a2e; border-color: #3a3a55; }
[data-theme="synthwave"] .progress-table th { background: #2b1055; color: #00d4ff; }
[data-theme="synthwave"] .bank-card h2 { color: #00d4ff; }
[data-theme="synthwave"] .mode-btn:hover { box-shadow: 0 0 12px rgba(0,212,255,0.15); }
[data-theme="synthwave"] .stat-card { background: #1f1f35; border: 1px solid #3a3a55; }
[data-theme="synthwave"] .stat-card .stat-val { color: #00d4ff; }
[data-theme="synthwave"] .timer-display.warning { animation: flashSynth .5s infinite alternate; }
@keyframes flashSynth { from { background: #1a1a2e; } to { background: #3a0a20; color: #ff5588; } }

/* Mobile Gamification */
@media(max-width:768px){
    .xp-bar-container{flex-wrap:wrap;padding:10px 14px;gap:8px}
    .xp-bar{order:3;flex-basis:100%}
    .xp-info{order:2;min-width:auto}
    .combo-display{top:70px;left:50%;transform:translateX(-50%);padding:8px 12px;font-size:14px;max-width:260px}
    .combo-fire{font-size:20px}
    .achievement-toast{bottom:80px;right:10px;left:10px;max-width:none}
    .study-buddy{bottom:80px;left:10px}
    .levelup-modal{padding:30px;margin:20px}
    .levelup-modal .level-num{font-size:48px}
    /* Shop responsive */
    .shop-grid{grid-template-columns:repeat(auto-fill,minmax(130px,1fr));gap:8px}
    .shop-item{padding:12px}
    .shop-item-icon{font-size:28px}
    .shop-tabs{gap:4px}
    .shop-tab{padding:6px 10px;font-size:12px}
    /* Garden responsive */
    .garden-scene{min-height:360px}
    .garden-plots{gap:6px}
    .garden-plot{min-height:75px}
    .plot-plant{font-size:30px}
    .plot-empty-icon{font-size:22px}
    .garden-header{gap:6px;font-size:12px}
    .garden-pet-emoji{font-size:36px}
    .garden-pet{bottom:8px;left:8px}
    .garden-water-btn{bottom:8px;right:8px;padding:5px 8px;font-size:12px}
    .garden-timeskip-btn{bottom:8px;right:96px;padding:5px 8px;font-size:12px}
    .garden-water-meter{right:8px;bottom:72px;width:140px}
    .garden-ground{padding:6px 8px 10px}
    .garden-modal{padding:16px;max-width:320px}
    /* Pet modal responsive */
    .pet-modal-content{padding:16px;margin:20px auto}
    .pet-modal-emoji{font-size:48px}
    .pet-food-grid{grid-template-columns:1fr}
}
</style>
</head>
<body>

<!-- HEADER -->
<div class="main-header">
    <div class="header-top">
        <div class="logo-area">
            <svg width="36" height="36" viewBox="0 0 40 44" fill="none"><defs><linearGradient id="hsg" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#8b5cf6"/><stop offset="100%" stop-color="#ec4899"/></linearGradient><filter id="hglow"><feGaussianBlur stdDeviation="1" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><path d="M20 3L35 10V23C35 31 28 37 20 40 12 37 5 31 5 23V10Z" fill="url(#hsg)" filter="url(#hglow)"/><path d="M14 15L26 28M26 15L14 28" stroke="#fff" stroke-width="3.5" stroke-linecap="round"/></svg>
            <span class="logo-text">Xooper's Battleground</span>
        </div>
        <div class="header-actions">
            <button onclick="if(document.getElementById('screen-exam').classList.contains('active') && !App.submitted){App.exitToHome()}else{SessionState.clear();showScreen('home');Home.render()}">Home</button>
            <button onclick="if(App.timerInterval && !App.timerPaused){App.toggleTimer()}showScreen('settings')">Settings</button>
            <button onclick="document.getElementById('helpModal').classList.add('active')" title="Keyboard shortcuts (?)" aria-label="Help" style="font-size:14px;padding:5px 10px">?</button>
        </div>
    </div>
</div>

<!-- FLOATING NOTE PANEL -->
<div class="note-panel" id="notePanel" role="dialog" aria-modal="true" aria-labelledby="notePanelTitle">
    <div class="note-panel-header">
        <div>
            <div class="note-panel-title" id="notePanelTitle">Question Notes</div>
            <div class="note-panel-sub" id="notePanelSub">Question 1</div>
        </div>
        <button class="note-close" onclick="Notes.toggle(false)" aria-label="Close notes">&times;</button>
    </div>
    <textarea class="note-textarea" id="noteTextarea" placeholder="Add your notes here..." oninput="Notes.onInput()" onblur="Notes.save()"></textarea>
    <div class="note-panel-footer">
        <button class="note-clear" onclick="Notes.clearCurrent()">Clear note</button>
        <div class="note-saved" id="noteSaved">Note saved</div>
    </div>
</div>

<!-- SUBHEADER (test/practice modes) -->
<div class="subheader" id="subheader" style="display:none">
    <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap">
        <div class="test-name" id="testNameBar">Test</div>
        <div class="section-tab" id="modeTab">Test Mode</div>
    </div>
    <div class="timer-area">
        <span class="timer-toggle" id="timerToggle" onclick="App.toggleTimer()">Pause Timer</span>
        <span class="timer-display" id="timerDisplay" aria-live="polite">01:30:00</span>
    </div>
</div>

<!-- ========== HOME SCREEN ========== -->
<div class="screen active" id="screen-home">
    <div class="home-grid">
        <div class="home-main">
            <div class="home-hero">
                <svg width="80" height="88" viewBox="0 0 80 88" fill="none" style="display:block;margin:0 auto 8px"><defs><linearGradient id="herosg" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#8b5cf6"/><stop offset="100%" stop-color="#ec4899"/></linearGradient><linearGradient id="herosw" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient><filter id="heroglow"><feGaussianBlur stdDeviation="2" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><line x1="12" y1="6" x2="68" y2="82" stroke="url(#herosw)" stroke-width="3" stroke-linecap="round"/><line x1="68" y1="6" x2="12" y2="82" stroke="url(#herosw)" stroke-width="3" stroke-linecap="round"/><rect x="4" y="2" width="16" height="3" rx="1.5" fill="#fbbf24" transform="rotate(40 12 6)"/><rect x="60" y="2" width="16" height="3" rx="1.5" fill="#fbbf24" transform="rotate(-40 68 6)"/><circle cx="12" cy="6" r="3" fill="#fbbf24" opacity=".6"/><circle cx="68" cy="6" r="3" fill="#fbbf24" opacity=".6"/><path d="M40 12L64 22V44C64 58 53 68 40 76 27 68 16 58 16 44V22Z" fill="url(#herosg)" filter="url(#heroglow)"/><path d="M30 31L50 55M50 31L30 55" stroke="#fff" stroke-width="6" stroke-linecap="round"/></svg>
                <h1>Xooper's Battleground</h1>
                <p>Choose a question bank and study mode</p>
            </div>

            <div class="home-actions">
                <button class="btn-nav" style="background:var(--blue);border-color:var(--blue)" onclick="Progress.show()">View Progress</button>
                <button class="btn-nav" style="background:var(--green);border-color:var(--green)" id="btnGarden" onclick="Garden.show()">&#127793; Garden</button>
                <button class="btn-nav" style="background:var(--orange);border-color:var(--orange)" id="btnShop" onclick="Shop.show()">&#128176; Shop</button>
                <button class="btn-nav" style="background:var(--red);border-color:var(--red)" id="btnBattle" onclick="Battle.show()">&#9876;&#65039; Battle</button>
            </div>

            <div class="home-stats-wrapper">
                <h3>Today</h3>
                <div class="stats-row" id="homeStats"></div>
            </div>

            <div id="bankList"></div>
        </div>

        <div class="home-side">
            <div id="streakBanner"></div>
            <div id="dailyGoalCard"></div>
            <div id="xpBarContainer"></div>
        </div>
    </div>
</div>

<!-- ========== SHOP SCREEN ========== -->
<div class="screen" id="screen-shop">
    <div class="shop-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:auto">Home</button>
        <h2 style="flex:1;text-align:center;margin:0">Shop</h2>
        <span class="coin-display shop-coins" id="shopCoins">&#x1FA99; 0</span>
    </div>
    <div class="shop-tabs" id="shopTabs"></div>
    <div class="shop-items" id="shopItems"></div>
</div>

<!-- ========== GARDEN SCREEN ========== -->
<div class="screen" id="screen-garden">
    <div class="garden-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:8px">Home</button>
        <span class="coin-display" id="gardenCoins" style="margin-left:auto">&#x1FA99; 0</span>
        <button class="btn-nav" style="background:var(--orange);border-color:var(--orange);margin-left:8px" onclick="Shop.show()">Shop</button>
    </div>
    <div class="garden-scene" id="gardenScene">
        <div class="garden-sky">
            <span class="garden-sky-sun" id="gardenSun">&#9728;&#65039;</span>
            <span class="garden-sky-stars">&#10024; &#11088; &#10024;</span>
        </div>
        <div class="garden-fence">&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;</div>
        <div class="garden-ground">
            <div class="garden-plots" id="gardenGrid"></div>
            <div class="garden-decos-row" id="gardenDecos"></div>
        </div>
        <div class="garden-pet" id="gardenPet" onclick="PetModal.show()"></div>
        <div class="garden-bowls" id="gardenBowls" style="display:none"></div>
        <div class="garden-timeskip-btn" id="gardenSkipBtn" onclick="Garden.useTimeSkip()" title="Spend a Time Capsule to fast-forward care">
            <span>⏩</span>
            <span class="skip-count" id="gardenSkipCount">0</span>
        </div>
        <div class="garden-water-btn" id="gardenWaterBtn" onclick="Garden.useWater()" title="Use Watering Can">
            <span>&#x1FAA3;</span>
            <span class="water-count" id="gardenWaterCount">0</span>
        </div>
    </div>
</div>

<!-- ========== BATTLE SCREEN ========== -->
<div class="screen" id="screen-battle">
    <div class="battle-header">
        <button class="btn-nav btn-home" onclick="Battle.goHome()">Home</button>
        <h2 id="battleTitle">Battle</h2>
        <span class="battle-stars" id="battleStars"></span>
    </div>
    <div id="battleContent"></div>
</div>

<!-- ========== TEST / PRACTICE SCREEN ========== -->
<div class="screen" id="screen-exam">
    <div class="question-container" id="questionContainer">
        <div class="question-header">
            <span class="question-number" id="questionNumber">Question 1 of 70</span>
            <div class="question-actions">
                <button class="btn-bookmark" id="btnBookmark" onclick="App.toggleBookmark()" aria-label="Bookmark this question">Bookmark</button>
                <button class="btn-clear" onclick="App.clearAnswer()">Clear</button>
            </div>
        </div>
        <div class="powerup-bar" id="powerupBar" style="display:none"></div>
        <div class="question-text" id="questionText"></div>
        <ul class="options-list" id="optionsList"></ul>
        <button class="btn-check" id="btnCheck" style="display:none" onclick="App.checkAnswer()">Check Answer</button>
        <div class="confidence-panel" id="confidencePanel" style="display:none">
            <span class="confidence-label">How confident?</span>
            <button class="confidence-btn conf-maybe" onclick="App.setConfidence(1)">Maybe</button>
            <button class="confidence-btn conf-probably" onclick="App.setConfidence(2)">Probably</button>
            <button class="confidence-btn conf-definitely" onclick="App.setConfidence(3)">Definitely</button>
        </div>
        <div class="explanation-panel" id="explanationPanel"></div>
    </div>
</div>

<!-- ========== SCORE SCREEN ========== -->
<div class="screen" id="screen-score">
    <div class="score-screen">
        <div class="score-big" id="scoreBig" aria-live="polite">0%</div>
        <div class="score-label" id="scoreLabel">Score</div>
        <div class="score-details">
            <table>
                <tr><td class="label-col">Correct</td><td class="value-col" id="scoreCorrect">0</td></tr>
                <tr><td class="label-col">Incorrect</td><td class="value-col" id="scoreIncorrect">0</td></tr>
                <tr><td class="label-col">Unanswered</td><td class="value-col" id="scoreUnanswered">0</td></tr>
                <tr><td class="label-col">Total</td><td class="value-col" id="scoreTotal">70</td></tr>
                <tr><td class="label-col">Time</td><td class="value-col" id="scoreTime">00:00:00</td></tr>
            </table>
        </div>
        <div class="category-breakdown" id="categoryBreakdown"></div>
        <div class="score-actions">
            <button style="background:var(--red-light)" onclick="App.reviewWrongOnly()">Review Wrong Only</button>
            <button style="background:var(--blue)" onclick="App.startReview()">Review All</button>
            <button style="background:var(--orange)" onclick="App.drillWrongOnly()">Drill Missed Questions</button>
            <button style="background:var(--red)" onclick="App.retakeTest()">Retake</button>
            <button style="background:var(--gray-700)" onclick="showScreen('home');Home.render()">Home</button>
            <button style="background:var(--gray-600)" onclick="window.print()">Print Results</button>
        </div>
    </div>
</div>

<!-- ========== DRILL SCREEN ========== -->
<div class="screen" id="screen-drill">
    <div class="drill-container">
        <div class="drill-progress" id="drillProgress"></div>
        <div class="drill-card" id="drillCard"></div>
    </div>
</div>

<!-- ========== AI PRACTICE SCREEN ========== -->
<div class="screen" id="screen-ai-practice">
    <div class="ai-practice-container">
        <div class="ai-progress" id="aiProgress"></div>
        <div class="ai-card" id="aiCard"></div>
    </div>
</div>

<!-- ========== REVIEW SCREEN ========== -->
<div class="screen" id="screen-review">
    <h2 style="color:var(--navy);margin-bottom:16px">Review All Questions</h2>
    <div class="review-controls">
        <select id="reviewCatFilter" onchange="Review.render()"><option value="">All Categories</option></select>
        <select id="reviewDiffFilter" onchange="Review.render()"><option value="">All Difficulty</option><option value="1">Easy</option><option value="2">Medium</option><option value="3">Hard</option></select>
        <input type="text" id="reviewSearch" placeholder="Search questions..." oninput="Review.render()">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Home</button>
    </div>
    <div id="reviewContent"></div>
</div>

<!-- ========== PROGRESS SCREEN ========== -->
<div class="screen" id="screen-progress">
    <h2 style="color:var(--navy);margin-bottom:16px">Progress Dashboard</h2>
    <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-bottom:16px">Back to Home</button>
    <div id="progressContent"></div>
</div>

<!-- ========== SETTINGS SCREEN ========== -->
<div class="screen" id="screen-settings">
    <div class="settings-panel">
        <h2>Settings</h2>
        <div class="setting-group">
            <h3>Appearance</h3>
            <div class="setting-row">
                <label>Theme</label>
                <select id="settingTheme" onchange="Theme.apply(this.value)">
                    <option value="system">System (Auto)</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                    <option value="cengage-light">Cengage Light</option>
                    <option value="cengage-dark">Cengage Dark</option>
                    <option value="synthwave">Synthwave</option>
                </select>
                <div class="hint">Choose your preferred color scheme. "System" follows your device settings.</div>
            </div>
        </div>
        <div class="setting-group">
            <h3>Daily Goal</h3>
            <div class="setting-row">
                <label>Questions per day</label>
                <select id="settingDailyGoal" onchange="DailyGoal.setGoal(parseInt(this.value))">
                    <option value="5">5 questions</option>
                    <option value="10" selected>10 questions</option>
                    <option value="15">15 questions</option>
                    <option value="20">20 questions</option>
                    <option value="30">30 questions</option>
                </select>
                <div class="hint">Set a daily study goal. Build a streak by reaching your goal each day!</div>
            </div>
        </div>
        <div class="setting-group">
            <h3>Experimental Modes</h3>
            <div class="setting-row">
                <label>Elden Mode (story + NPC guides)</label>
                <select id="settingEldenMode" onchange="Settings.setEldenMode(this.value === 'on')">
                    <option value="off">Off (default)</option>
                    <option value="on">On</option>
                </select>
                <div class="hint">Toggle Elden Ring-inspired features (lore hubs, NPC mentors, heroic quests). Disabled by default.</div>
            </div>
        </div>
        <div class="setting-group">
            <h3>AI Chat - Anthropic (Claude)</h3>
            <div class="setting-row">
                <label>Anthropic API Key</label>
                <input type="password" id="settingAnthropicKey" placeholder="sk-ant-api03-...">
                <div class="hint">Get yours at console.anthropic.com. Stored locally only.</div>
            </div>
            <div class="setting-row">
                <label>Claude Model</label>
                <select id="settingAnthropicModel">
                    <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5 (Fast)</option>
                    <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (Fastest)</option>
                    <option value="claude-opus-4-5-20251101">Claude Opus 4.5 (Best)</option>
                </select>
            </div>
        </div>
        <div class="setting-group">
            <h3>AI Chat - OpenAI (GPT)</h3>
            <div class="setting-row">
                <label>OpenAI API Key</label>
                <input type="password" id="settingOpenaiKey" placeholder="sk-proj-...">
                <div class="hint">Get yours at platform.openai.com. Stored locally only.</div>
            </div>
            <div class="setting-row">
                <label>OpenAI Model</label>
                <select id="settingOpenaiModel">
                    <option value="gpt-4o-mini">GPT-4o Mini (Fast)</option>
                    <option value="gpt-4o">GPT-4o (Best)</option>
                    <option value="gpt-4.1-mini">GPT-4.1 Mini</option>
                    <option value="gpt-4.1">GPT-4.1</option>
                </select>
            </div>
        </div>
        <div class="setting-group">
            <h3>Active Provider</h3>
            <div class="setting-row">
                <select id="settingProvider">
                    <option value="anthropic">Anthropic (Claude)</option>
                    <option value="openai">OpenAI (GPT)</option>
                </select>
                <div class="hint">Switch between providers anytime. Both keys are saved independently.</div>
            </div>
            <button class="btn-save-settings" onclick="Settings.save()">Save Settings</button>
        </div>
        <div class="setting-group">
            <h3>Keyboard Shortcuts</h3>
            <div class="setting-row">
                <table style="width:100%;border-collapse:collapse;font-size:13px">
                    <thead>
                        <tr style="background:var(--navy);color:#fff">
                            <th style="padding:8px 12px;text-align:left">Key</th>
                            <th style="padding:8px 12px;text-align:left">Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">?</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Show keyboard shortcuts help</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&larr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">P</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Previous question</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&rarr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">N</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Next question</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">1</kbd> - <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">4</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Select answer option</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">B</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Bookmark question</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">T</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle notes panel</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">C</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle calculator</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Enter</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Check answer (Practice mode)</td></tr>
                        <tr><td style="padding:6px 12px"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Esc</kbd></td><td style="padding:6px 12px">Close modals/calculator</td></tr>
                    </tbody>
                </table>
                <div class="hint" style="margin-top:8px">Press <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">?</kbd> anytime to see a quick reference overlay.</div>
            </div>
        </div>
        <div class="setting-group">
            <h3>🎮 Gamification</h3>
            <div class="gamify-settings">
                <label><input type="checkbox" id="gamifyEnabled" checked onchange="Gamification.updateSettings()"> Enable Gamification</label>
                <label><input type="checkbox" id="gamifySounds" checked onchange="Gamification.updateSettings()"> Sound Effects</label>
                <label><input type="checkbox" id="gamifyConfetti" checked onchange="Gamification.updateSettings()"> Visual Effects (Confetti)</label>
                <label><input type="checkbox" id="gamifyXpPopups" checked onchange="Gamification.updateSettings()"> XP Popups</label>
                <label><input type="checkbox" id="gamifyPet" checked onchange="Gamification.updateSettings()"> Study Buddy</label>
                <label><input type="checkbox" id="gamifyGarden" checked onchange="Gamification.updateSettings()"> Garden System</label>
                <label><input type="checkbox" id="gamifyCoinPopups" checked onchange="Gamification.updateSettings()"> Coin Popups</label>
                <label><input type="checkbox" id="gamifyPixelArt" onchange="Gamification.updateSettings()"> Pixel Art Mode</label>
                <div class="setting-row" style="margin:12px 0 4px"><strong>Experimental Toggles</strong></div>
                <label><input type="checkbox" id="gamifyPetBowls" onchange="Gamification.updateSettings()"> Enable Pet Food/Water Bowls</label>
                <label><input type="checkbox" id="gamifyTimeSkip" onchange="Gamification.updateSettings()"> Enable Time Capsules / Time Skips</label>
                <label><input type="checkbox" id="gamifyCompactHome" onchange="Gamification.updateSettings()"> Compact Home Layout</label>
                <label><input type="checkbox" id="gamifyDifficultyControls" onchange="Gamification.updateSettings()"> Difficulty Controls (Easy/Normal/Hard + Slider)</label>
                <div class="setting">
                    <label><input type="checkbox" id="gamifyAdaptiveXp" onchange="Gamification.updateSettings()"> Adaptive XP (novel/harder = more, repeats = less)</label>
                </div>
                <label><input type="checkbox" id="gamifyMomentum" onchange="Gamification.updateSettings()"> Momentum Rewards (session streak boosts)</label>
                <label><input type="checkbox" id="gamifyDisasters" onchange="Gamification.updateSettings()"> Hard Mode Disasters (bugs/robbers if away too long)</label>
                <label><input type="checkbox" id="gamifyAnimatedBg" onchange="Gamification.updateSettings()"> Animated Backgrounds</label>
                <label><input type="checkbox" id="gamifyTrinkets" onchange="Gamification.updateSettings()"> Desk Trinkets & Backpack</label>
                <div id="difficultyControlsPanel" class="difficulty-panel" style="display:none">
                    <div class="setting-row">
                        <label>Difficulty Mode</label>
                        <select id="difficultyMode" onchange="Gamification.updateSettings()">
                            <option value="easy">Easy</option>
                            <option value="normal" selected>Normal</option>
                            <option value="hard">Hard</option>
                        </select>
                        <div class="hint">Easy: slower decay & generous bowls. Hard: faster decay, lower efficiency.</div>
                    </div>
                    <div class="setting-row">
                        <label>Intensity Slider <span id="difficultySliderLabel">50</span></label>
                        <input type="range" id="difficultySlider" min="0" max="100" value="50" onchange="Gamification.updateSettings()">
                        <div class="hint">Fine-tune hunger/happiness decay (left = gentler, right = punishments).</div>
                    </div>
                </div>
                <div class="volume-row">
                    <label>Volume:</label>
                    <input type="range" id="gamifyVolume" min="0" max="100" value="50" onchange="Gamification.updateSettings()">
                    <span id="gamifyVolumeLabel">50%</span>
                </div>
                <div class="gamify-reset">
                    <button class="btn-nav" style="background:var(--red);border-color:var(--red)" onclick="Gamification.resetProgress()">Reset Gamification Data</button>
                    <div class="hint">Clears XP, level, achievements, and power-ups.</div>
                </div>
            </div>
        </div>
        <div class="setting-group">
            <h3>Data</h3>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--blue);border-color:var(--blue)" onclick="Notes.exportAll()">Export Notes</button>
                <div class="hint">Download all your notes as a JSON file.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--green);border-color:var(--green)" onclick="Settings.exportAll()">Export All Data</button>
                <div class="hint">Download all progress, history, stats, notes, and settings as a backup file.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--blue);border-color:var(--blue)" onclick="document.getElementById('importFile').click()">Import Data Backup</button>
                <input type="file" id="importFile" accept=".json" style="display:none" onchange="Settings.importAll(this)">
                <div class="hint">Restore from a previously exported backup file. Merges with existing data.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--orange);border-color:var(--orange)" onclick="Settings.clearProgress()">Clear All Progress</button>
                <div class="hint">Removes all test history, drill progress, and stats.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Back to Home</button>
            </div>
        </div>
    </div>
</div>

<!-- KEYBOARD SHORTCUTS HELP MODAL -->
<div class="modal-overlay" id="helpModal" onclick="if(event.target===this)document.getElementById('helpModal').classList.remove('active')">
    <div class="modal" style="max-width:400px" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
        <h2 id="helpModalTitle">Keyboard Shortcuts</h2>
        <table style="width:100%;border-collapse:collapse;font-size:13px">
            <thead>
                <tr><th style="padding:8px 12px;text-align:left;background:var(--navy);color:#fff">Key</th><th style="padding:8px 12px;text-align:left;background:var(--navy);color:#fff">Action</th></tr>
            </thead>
            <tbody>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&larr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">P</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Previous question</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&rarr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">N</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Next question</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">1</kbd> - <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">4</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Select answer option</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">B</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Bookmark question</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">T</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle notes panel</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">C</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle calculator</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Enter</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Check answer (Practice)</td></tr>
                <tr><td style="padding:6px 12px"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Esc</kbd></td><td style="padding:6px 12px">Close modals</td></tr>
            </tbody>
        </table>
        <div class="modal-actions" style="margin-top:16px">
            <button class="btn-nav" onclick="document.getElementById('helpModal').classList.remove('active')">Close</button>
        </div>
    </div>
</div>

<!-- CALCULATOR PANEL -->
<div class="calc-panel" id="calcPanel" role="dialog" aria-modal="true" aria-labelledby="calcPanelTitle">
    <div class="calc-header">
        <h4 id="calcPanelTitle">Calculator</h4>
        <button class="calc-close" onclick="Calc.toggle()">&times;</button>
    </div>
    <div class="calc-display" id="calcDisplay">0</div>
    <div class="calc-buttons">
        <button class="calc-btn clear" onclick="Calc.clear()">C</button>
        <button class="calc-btn" onclick="Calc.input('(')">(</button>
        <button class="calc-btn" onclick="Calc.input(')')">)</button>
        <button class="calc-btn op" onclick="Calc.input('/')">&divide;</button>
        <button class="calc-btn" onclick="Calc.input('7')">7</button>
        <button class="calc-btn" onclick="Calc.input('8')">8</button>
        <button class="calc-btn" onclick="Calc.input('9')">9</button>
        <button class="calc-btn op" onclick="Calc.input('*')">&times;</button>
        <button class="calc-btn" onclick="Calc.input('4')">4</button>
        <button class="calc-btn" onclick="Calc.input('5')">5</button>
        <button class="calc-btn" onclick="Calc.input('6')">6</button>
        <button class="calc-btn op" onclick="Calc.input('-')">-</button>
        <button class="calc-btn" onclick="Calc.input('1')">1</button>
        <button class="calc-btn" onclick="Calc.input('2')">2</button>
        <button class="calc-btn" onclick="Calc.input('3')">3</button>
        <button class="calc-btn op" onclick="Calc.input('+')">+</button>
        <button class="calc-btn" onclick="Calc.input('0')">0</button>
        <button class="calc-btn" onclick="Calc.input('.')">.</button>
        <button class="calc-btn" onclick="Calc.backspace()">&larr;</button>
        <button class="calc-btn eq" onclick="Calc.equals()">=</button>
    </div>
</div>

<!-- TIMER ADJUST MODAL -->
<div class="modal-overlay" id="timerModal" onclick="if(event.target===this)App.hideTimerModal()">
    <div class="modal" style="max-width:350px" role="dialog" aria-modal="true" aria-labelledby="timerModalTitle">
        <h2 id="timerModalTitle">Adjust Timer</h2>
        <div class="setting-row">
            <label>Test Duration (minutes)</label>
            <input type="number" id="timerMinutes" min="1" max="300" value="90">
            <div class="hint">Default: 90 minutes (1.5 hours)</div>
        </div>
        <div class="modal-actions">
            <button class="btn-nav" style="background:var(--gray-500);border-color:var(--gray-500)" onclick="App.hideTimerModal()">Cancel</button>
            <button class="btn-nav" style="background:var(--green);border-color:var(--green)" onclick="App.applyTimerChange()">Apply</button>
        </div>
    </div>
</div>

<!-- FOOTER NAV (exam/practice/review-after-test) -->
<div class="footer-nav" id="footerNav" style="display:none">
    <div class="nav-controls">
        <div class="nav-buttons nav-buttons-left">
            <div class="toolbar" style="margin-right:8px">
                <button class="tool-btn" id="btnCalc" onclick="Calc.toggle()" title="Calculator" aria-label="Open Calculator">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V9h2v4zm4 4h-2v-6h2v6zm0-8h-2V7h2v2zm-8 8H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2z"/></svg>
                    Calc
                </button>
                <button class="tool-btn" id="btnNote" onclick="Notes.toggle()" title="Question notes" aria-label="Open question notes">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 3H5a2 2 0 00-2 2v14a2 2 0 002 2h9l7-7V5a2 2 0 00-2-2zm-4 15v-4h4l-4 4zm-7-8h7v2H8v-2zm0-4h8v2H8V6zm0 8h4v2H8v-2z"/></svg>
                    <span class="tool-label">Notes</span>
                </button>
                <button class="tool-btn" id="btnAudio" onclick="Audio.speak()" title="Read question aloud" aria-label="Read question aloud">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                    Audio
                </button>
                <button class="tool-btn" id="btnTimerAdj" onclick="App.showTimerModal()" title="Adjust timer" aria-label="Adjust timer">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
                    Timer
                </button>
            </div>
            <button class="btn-nav btn-home" onclick="App.exitToHome()">Exit</button>
            <button class="btn-nav" id="btnPrev" onclick="App.prev()" disabled>&laquo; Prev</button>
        </div>
        <div class="palette-wrap">
            <div class="palette-mini" id="paletteMini"></div>
            <button class="palette-expand-btn" id="paletteExpandBtn" onclick="App.togglePalette()">Show All</button>
            <div class="question-palette collapsed" id="questionPalette"></div>
            <div class="palette-legend" id="paletteLegend" style="display:none">
                <div class="legend-item"><div class="legend-dot lg-current"></div>Current</div>
                <div class="legend-item"><div class="legend-dot lg-answered"></div>Answered</div>
                <div class="legend-item"><div class="legend-dot lg-unanswered"></div>Not Visited</div>
                <div class="legend-item"><div class="legend-dot lg-flagged"></div>Flagged</div>
            </div>
        </div>
        <div class="nav-buttons nav-buttons-right">
            <button class="btn-nav" id="btnNext" onclick="App.next()">Next &raquo;</button>
            <button class="btn-nav btn-submit" id="btnSubmit" onclick="App.showSubmitModal()">Submit</button>
        </div>
    </div>
</div>

<!-- SUBMIT MODAL -->
<div class="modal-overlay" id="submitModal" onclick="if(event.target===this)App.hideSubmitModal()">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="submitModalTitle">
        <h2 id="submitModalTitle">Submit Test</h2>
        <p>Are you sure you want to submit?</p>
        <table>
            <thead><tr><th>Status</th><th>Count</th></tr></thead>
            <tbody>
                <tr><td>Answered</td><td id="modalAnswered">0</td></tr>
                <tr><td>Unanswered</td><td id="modalUnanswered">0</td></tr>
                <tr><td>Bookmarked</td><td id="modalBookmarked">0</td></tr>
            </tbody>
        </table>
        <div class="modal-actions">
            <button class="btn-nav" style="background:var(--gray-500);border-color:var(--gray-500)" onclick="App.hideSubmitModal()">Cancel</button>
            <button class="btn-nav btn-submit" onclick="App.submitTest()">Submit</button>
        </div>
    </div>
</div>

<!-- QUESTION COUNT PICKER MODAL -->
<div id="qCountModal" style="display:none" onclick="if(event.target===this)App.closeCountPicker()">
    <div class="modal-box">
        <h3 style="color:var(--navy);margin-bottom:4px" id="qCountTitle">How many questions?</h3>
        <p style="color:var(--gray-600);font-size:13px;margin-bottom:16px" id="qCountSubtitle"></p>
        <div class="qcount-options" id="qCountOptions"></div>
        <div style="display:flex;gap:10px;margin-top:16px;justify-content:flex-end">
            <button class="btn-nav" onclick="App.closeCountPicker()" style="background:var(--gray-300);color:var(--gray-800)">Cancel</button>
            <button class="btn-nav" id="qCountStart" onclick="App.confirmStart()" style="background:var(--blue);color:#fff">Start</button>
        </div>
    </div>
</div>

<!-- AI CHAT -->
<button class="chat-fab" id="chatFab" onclick="Chat.toggle()" title="Ask AI about this question" aria-label="Open AI tutor chat" style="display:none">?</button>
<div class="chat-panel" id="chatPanel" role="dialog" aria-modal="true" aria-labelledby="chatPanelTitle">
    <div class="chat-header">
        <h3 id="chatPanelTitle">AI Tutor</h3>
        <button class="chat-close" onclick="Chat.toggle()">&times;</button>
    </div>
    <div class="chat-messages" id="chatMessages" aria-live="polite"></div>
    <div class="chat-input-area">
        <input type="text" id="chatInput" placeholder="Ask about this question..." onkeydown="if(event.key==='Enter')Chat.send()">
        <button onclick="Chat.send()">&#9654;</button>
    </div>
</div>

<script>
// =====================================================================
// EMBEDDED FALLBACK BANK DATA (for file:// protocol)
// =====================================================================
let BANK_DATA = null; // Will be set after we try fetch

// =====================================================================
// STORAGE HELPERS
// =====================================================================
const Store = {
    get(k, def) { try { const v = localStorage.getItem('wgu_' + k); return v ? JSON.parse(v) : def; } catch { return def; } },
    set(k, v) { try { localStorage.setItem('wgu_' + k, JSON.stringify(v)); } catch(e) { if (e.name === 'QuotaExceededError') { console.warn('Storage full — data not saved for:', k); if (!this._quotaWarned) { this._quotaWarned = true; alert('Storage is full. Some data may not be saved. Export your data from Settings to avoid losing progress.'); } } } },
    remove(k) { try { localStorage.removeItem('wgu_' + k); } catch {} }
};

// =====================================================================
// HTML ESCAPING (XSS protection for AI-generated content)
// =====================================================================
function escapeHtml(str) {
    if (typeof str !== 'string') return '';
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// =====================================================================
// GAMIFICATION SYSTEM
// =====================================================================
const Gamification = {
    // XP Values for different actions
    XP_VALUES: {
        correctAnswer: 20,
        firstTryCorrect: 30,
        drillGotIt: 25,
        drillStruggled: 10,
        testComplete: 80,
        perfectTest: 350,
        comboBonus: 5,
        dailyGoalReached: 75,
        weeklyGoalReached: 225,
        loginBonus: 15
    },
    QUESTION_XP_ACTIONS: new Set(['correctAnswer', 'firstTryCorrect', 'drillGotIt', 'drillStruggled']),
    BATCH_WINDOW_MS: 8 * 60 * 1000,

    useTimeSkip() {
        const state = Gamification.getState();
        if (!state.settings.timeSkipEnabled) return;
        const inv = state.inventory.gardenItems;
        if ((inv.timeCapsule || 0) <= 0) return;
        inv.timeCapsule--;
        const boostHours = 6;
        state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 40);
        const buddy = state.studyBuddy;
        buddy.hunger = Math.min(100, (buddy.hunger ?? 0) + 25);
        buddy.happiness = Math.min(100, (buddy.happiness ?? 0) + 30);
        buddy.lastInteraction = Date.now();
        buddy.sick = buddy.hunger > 20 && buddy.happiness > 20 ? false : buddy.sick;
        state.garden.lastGrowthTick = (state.garden.lastGrowthTick || Date.now()) - (boostHours * 60 * 60 * 1000);
        state.garden.lastWaterDecay = (state.garden.lastWaterDecay || Date.now()) - (boostHours * 60 * 60 * 1000);
        Gamification.saveState(state);
        this.render();
        SoundFX.play('powerUp');
        Toast.show('Time skip activated! Garden and buddy refreshed.');
    },

    // Level titles
    TITLES: {
        1: 'Curious Beginner',
        5: 'Eager Learner',
        10: 'Knowledge Seeker',
        15: 'Pattern Finder',
        20: 'Skilled Scholar',
        25: 'Expert Explorer',
        30: 'Grand Master',
        35: 'Mythic Mentor',
        40: 'Legendary Scholar',
        45: 'Chronicle Sage',
        50: 'Ascended Oracle'
    },

    // Achievements list
    ACHIEVEMENTS: [
        { id: 'first_correct', name: 'First Steps', desc: 'Get your first correct answer', icon: '🎯', xp: 50 },
        { id: 'ten_streak', name: 'On Fire', desc: '10 correct answers in a row', icon: '🔥', xp: 100 },
        { id: 'twenty_streak', name: 'Unstoppable', desc: '20 correct answers in a row', icon: '💥', xp: 200 },
        { id: 'perfect_test', name: 'Perfectionist', desc: 'Score 100% on a test', icon: '💯', xp: 500 },
        { id: 'category_master', name: 'Category Master', desc: 'Master a category (30+ correct, 90%+)', icon: '🏆', xp: 200 },
        { id: 'week_streak', name: 'Weekly Warrior', desc: '7-day study streak', icon: '📅', xp: 300 },
        { id: 'month_streak', name: 'Dedicated Learner', desc: '30-day study streak', icon: '🗓️', xp: 1000 },
        { id: 'early_bird', name: 'Early Bird', desc: 'Study before 7am', icon: '🌅', xp: 50 },
        { id: 'night_owl', name: 'Night Owl', desc: 'Study after 11pm', icon: '🦉', xp: 50 },
        { id: 'speed_demon', name: 'Speed Demon', desc: 'Answer correctly in under 10 seconds', icon: '⚡', xp: 75 },
        { id: 'century', name: 'Century', desc: 'Answer 100 questions', icon: '💪', xp: 200 },
        { id: 'thousand', name: 'Grind Master', desc: 'Answer 1000 questions', icon: '🏋️', xp: 1000 },
        { id: 'comeback', name: 'Comeback Kid', desc: 'Return after 3+ days away', icon: '👋', xp: 100 },
        { id: 'level_5', name: 'Rising Star', desc: 'Reach level 5', icon: '⭐', xp: 100 },
        { id: 'level_10', name: 'Dedicated Student', desc: 'Reach level 10', icon: '🌟', xp: 200 },
        { id: 'level_20', name: 'True Expert', desc: 'Reach level 20', icon: '✨', xp: 500 },
        { id: 'level_30', name: 'Scholar Supreme', desc: 'Reach level 30', icon: '📘', xp: 600 },
        { id: 'level_40', name: 'Mythic Mind', desc: 'Reach level 40', icon: '🧠', xp: 900 },
        { id: 'level_50', name: 'Ascendant', desc: 'Reach level 50', icon: '🌌', xp: 1500 },
        // Garden & Pet achievements
        { id: 'green_thumb', name: 'Green Thumb', desc: 'Harvest your first plant', icon: '🌱', xp: 75 },
        { id: 'master_gardener', name: 'Master Gardener', desc: 'Harvest 10 plants', icon: '🧑‍🌾', xp: 200 },
        { id: 'garden_paradise', name: 'Garden Paradise', desc: 'Fill all 9 garden plots', icon: '🏡', xp: 300 },
        { id: 'best_friends', name: 'Best Friends', desc: 'Reach max pet evolution', icon: '🦅', xp: 250 },
        { id: 'happy_tummy', name: 'Happy Tummy', desc: 'Feed your pet 50 meals', icon: '🍖', xp: 150 },
        { id: 'window_shopper', name: 'Window Shopper', desc: 'Make your first purchase', icon: '🛒', xp: 50 },
        { id: 'big_spender', name: 'Big Spender', desc: 'Earn 1000 total coins', icon: '💰', xp: 200 },
        { id: 'rainbow_bloom', name: 'Rainbow Bloom', desc: 'Grow a Rainbow Rose', icon: '🌈', xp: 500 },
        // Battle achievements
        { id: 'first_victory', name: 'First Blood', desc: 'Win your first battle', icon: '⚔️', xp: 75 },
        { id: 'chapter_clear', name: 'Chapter Master', desc: 'Complete a full chapter', icon: '🏰', xp: 200 },
        { id: 'boss_slayer', name: 'Boss Slayer', desc: 'Defeat all 5 bosses', icon: '💀', xp: 500 },
        { id: 'flawless', name: 'Flawless Victory', desc: 'Win a battle taking no damage', icon: '✨', xp: 150 }
    ],

    // Power-ups
    POWERUPS: {
        fiftyFifty: { name: '50/50', desc: 'Eliminate 2 wrong answers', cost: 100, icon: '🎲' },
        skipQuestion: { name: 'Skip', desc: 'Skip without penalty', cost: 75, icon: '⏭️' },
        extraTime: { name: '+2 Min', desc: 'Add 2 minutes to timer', cost: 50, icon: '⏱️' },
        doubleXp: { name: '2x XP', desc: 'Double XP for next 5 questions', cost: 150, icon: '✨' },
        showHint: { name: 'Hint', desc: 'Show explanation hint', cost: 80, icon: '💡' }
    },

    LEVEL_REWARD_PACKS: {
        10: { coins: 200, powerUps: { doubleXp: 1 } },
        20: { coins: 350, items: { gardenItems: { magicDust: 1 } }, powerUps: { doubleXp: 1 } },
        30: { coins: 500, items: { gardenItems: { magicDust: 1, evoStone: 1 } } },
        40: { coins: 700, powerUps: { doubleXp: 2 }, items: { gardenItems: { evoStone: 1 } } },
        50: { coins: 1000, powerUps: { doubleXp: 2 }, items: { gardenItems: { evoStone: 2, magicDust: 2 } } }
    },

    // Level unlock requirements for shop items
    LEVEL_REQS: {
        food:        { kibble: 1, treat: 3, feast: 7, goldfish: 12 },
        seeds:       { sunflower: 1, cactus: 3, bonsai: 7, crystal: 12, rainbow: 18 },
        gardenItems: { water: 1, fertilizer: 5, magicDust: 10, evoStone: 5, healthPotion: 1, shieldCharm: 5, powerBerry: 3 },
        decorations: { fountain: 5, gnome: 1, lantern: 3, bench: 1 },
        cosmetics:   { hat: 3, crown: 10, scarf: 1, sunglasses: 3, cape: 7 }
    },

    // Garden plot auto-unlocks at these levels (additive, on top of starting 3)
    PLOT_UNLOCK_LEVELS: [5, 10, 15, 20],

    // Check if item is unlocked at current level
    isItemUnlocked(tab, itemId) {
        const state = this.getState();
        const reqs = this.LEVEL_REQS[tab];
        if (!reqs || !reqs[itemId]) return true;
        return state.level >= reqs[itemId];
    },

    // Evolution thresholds (same for all species)
    BUDDY_STAGES: [
        { stage: 1, xpNeeded: 0, careNeeded: 0 },
        { stage: 2, xpNeeded: 500, careNeeded: 30 },
        { stage: 3, xpNeeded: 2000, careNeeded: 120 },
        { stage: 4, xpNeeded: 5000, careNeeded: 360 },
        { stage: 5, xpNeeded: 15000, careNeeded: 720 }
    ],

    // Pet species — each has unique evolution line + difficulty
    PET_SPECIES: {
        bird:    { name: 'Bird',    difficulty: 1.0, unlockLevel: 1,  price: 0,
                   emojis: ['🥚','🐣','🐥','🐤','🦅'], stages: ['Egg','Hatchling','Chick','Bird','Eagle'] },
        cat:     { name: 'Cat',     difficulty: 1.2, unlockLevel: 3,  price: 200,
                   emojis: ['🥚','🐱','😺','😸','🦁'], stages: ['Egg','Kitten','Cat','Happy Cat','Lion'] },
        dragon:  { name: 'Dragon',  difficulty: 1.5, unlockLevel: 5,  price: 400,
                   emojis: ['🥚','🦎','🐊','🐉','🐲'], stages: ['Dragon Egg','Hatchling','Drake','Dragon','Elder Dragon'] },
        fox:     { name: 'Fox',     difficulty: 1.3, unlockLevel: 7,  price: 500,
                   emojis: ['🥚','🐾','🦊','🦊','🌟'], stages: ['Egg','Pup','Fox Cub','Fox','Spirit Fox'] },
        slime:   { name: 'Slime',   difficulty: 0.7, unlockLevel: 1,  price: 100,
                   emojis: ['🫧','🟢','💚','🟩','👑'], stages: ['Bubble','Tiny Slime','Slime','Big Slime','King Slime'] },
        phoenix: { name: 'Phoenix', difficulty: 2.0, unlockLevel: 15, price: 1000,
                   emojis: ['🥚','🐤','🔥','🦅','✨'], stages: ['Ember Egg','Spark','Firebird','Phoenix','Eternal Phoenix'] }
    },

    // Helpers to get species emoji/name for a pet
    getSpeciesEmoji(species, stage) {
        const sp = this.PET_SPECIES[species || 'bird'];
        return sp ? (sp.emojis[stage - 1] || '🥚') : '🥚';
    },
    getSpeciesStageName(species, stage) {
        const sp = this.PET_SPECIES[species || 'bird'];
        return sp ? (sp.stages[stage - 1] || 'Unknown') : 'Unknown';
    },
    getSpeciesDifficulty(species) {
        const sp = this.PET_SPECIES[species || 'bird'];
        return sp ? sp.difficulty : 1.0;
    },

    // Get default state
    // Coin values for different actions
    COIN_VALUES: {
        correctAnswer: 5,
        firstTryCorrect: 10,
        drillGotIt: 8,
        testComplete: 20,
        perfectTest: 100,
        dailyGoalReached: 25,
        loginBonus: 10,
        harvest: 0 // varies per plant
    },

    // Shop catalog
    SHOP: {
        food: {
            kibble:  { name: 'Kibble',    price: 10,  icon: '🍖', hunger: 10, happiness: 4,  careBonus: 4 },
            treat:   { name: 'Treat',     price: 25,  icon: '🍪', hunger: 20, happiness: 10, careBonus: 8 },
            feast:   { name: 'Feast',     price: 60,  icon: '🍗', hunger: 40, happiness: 22, careBonus: 15 },
            goldfish:{ name: 'Gold Fish', price: 100, icon: '🐟', hunger: 35, happiness: 35, careBonus: 12 }
        },
        seeds: {
            sunflower: { name: 'Sunflower',     price: 12,  icon: '🌻', gpNeeded: 9,  stages: 4, coinReward: 18,  xpReward: 35,
                         emojis: ['🫘','🌱','🌿','🌻'] },
            cactus:    { name: 'Cactus',        price: 18,  icon: '🌵', gpNeeded: 14, stages: 4, coinReward: 28,  xpReward: 55,
                         emojis: ['🫘','🌱','🪴','🌵'] },
            bonsai:    { name: 'Bonsai',        price: 32,  icon: '🌳', gpNeeded: 22, stages: 5, coinReward: 55,  xpReward: 110,
                         emojis: ['🫘','🌱','🪴','🌿','🌳'] },
            crystal:   { name: 'Crystal Bloom', price: 60,  icon: '💎', gpNeeded: 34, stages: 5, coinReward: 90,  xpReward: 180,
                         emojis: ['🫘','🌱','🪴','💠','💎'] },
            rainbow:   { name: 'Rainbow Rose',  price: 100, icon: '🌈', gpNeeded: 50, stages: 6, coinReward: 150, xpReward: 320,
                         emojis: ['🫘','🌱','🌿','🪻','🌹','🌈'] }
        },
        gardenItems: {
            water:        { name: 'Watering Can',   price: 3,   icon: '💧', desc: '+30 water level' },
            fertilizer:   { name: 'Fertilizer',     price: 15,  icon: '🧪', desc: '2x growth for 1 plant (10 questions)' },
            magicDust:    { name: 'Magic Dust',     price: 50,  icon: '✨', desc: 'Advance 1 plant by 1 stage' },
            timeCapsule:  { name: 'Time Capsule',  price: 60,  icon: '⏳', desc: 'Skip 6h: restores water + pet mood' },
            evoStone:     { name: 'Evolution Stone', price: 150, icon: '🪨', desc: '+60 care minutes for pet evolution' },
            healthPotion: { name: 'Health Potion', price: 30, icon: '🧃', desc: 'Heal pet 40 HP mid-battle' },
            shieldCharm:  { name: 'Shield Charm',  price: 50, icon: '🛡️', desc: 'Block next enemy attack 100%' },
            powerBerry:   { name: 'Power Berry',   price: 40, icon: '🫐', desc: '+50% ATK for 3 questions' }
        },
        decorations: {
            fountain: { name: 'Fountain',     price: 80,  icon: '⛲', desc: '+5 water per question (passive)', effect: 'autoWater' },
            gnome:    { name: 'Garden Gnome',  price: 25,  icon: '🧑‍🌾', desc: 'Decorative' },
            lantern:  { name: 'Lantern',       price: 35,  icon: '🏮', desc: 'Decorative' },
            bench:    { name: 'Garden Bench',  price: 40,  icon: '🪑', desc: 'Decorative' }
        },
        cosmetics: {
            hat:        { name: 'Hat',        price: 50,  icon: '🎩' },
            crown:      { name: 'Crown',      price: 100, icon: '👑' },
            scarf:      { name: 'Scarf',      price: 30,  icon: '🧣' },
            sunglasses: { name: 'Sunglasses', price: 40,  icon: '🕶️' },
            cape:       { name: 'Cape',       price: 75,  icon: '🦸' }
        },
        plotExpansion: { name: 'Garden Plot', price: 100, icon: '🟫', desc: 'Unlock 1 additional garden plot' }
    },

    // Multiplier to make pet decay more visible during short sessions (1 = real time)
    PET_DECAY_TIMESCALE: 1.5,
    CALORIES_PER_HUNGER_POINT: 5,
    ML_PER_HAPPINESS_POINT: 3,

    getDefaultState() {
        return {
            xp: 0,
            level: 1,
            coins: 0,
            totalCoinsEarned: 0,
            combo: { current: 0, best: 0, multiplier: 1.0, lastCorrectTime: null },
            achievements: {},
            powerUpInventory: { fiftyFifty: 1, skipQuestion: 1, extraTime: 2, doubleXp: 0, showHint: 1 },
            categoryMastery: {},
            studyBuddy: {
                name: 'Buddy', species: 'bird', stage: 1, totalXpFed: 0, mood: 'sleepy', lastFed: null,
                hunger: 100, happiness: 100, lastDecayCheck: null,
                careMinutes: 0, lastCareCheck: null, studyMinutes: 0,
                sick: false, lastInteraction: null,
                accessories: [], totalMealsEaten: 0
            },
            pets: [],
            activePetIdx: 0,
            garden: {
                plots: [],
                decorations: [],
                unlockedPlots: 3,
                waterLevel: 100,
                lastWaterDecay: null,
                lastGrowthTick: null,
                totalHarvests: 0
            },
            inventory: {
                petFood: { kibble: 3, treat: 1, feast: 0, goldfish: 0 },
                seeds: { sunflower: 2, cactus: 0, bonsai: 0, crystal: 0, rainbow: 0 },
                gardenItems: { water: 5, fertilizer: 0, magicDust: 0, timeCapsule: 1, evoStone: 0 },
                battleItems: { healthPotion: 0, shieldCharm: 0, powerBerry: 0 },
                decorations: [],
                petAccessories: []
            },
            battle: {
                currentChapter: 1,
                currentEnemy: 0,
                chaptersCompleted: [],
                totalWins: 0,
                totalLosses: 0,
                bestChapter: 0
            },
            currentTitle: 'Curious Beginner',
            settings: {
                enabled: true,
                sounds: true,
                confetti: true,
                xpPopups: true,
                pet: true,
                garden: true,
                coinPopups: true,
                pixelArt: false,
                petBowlsEnabled: false,
                timeSkipEnabled: false,
                compactHomeEnabled: false,
                difficultyControlsEnabled: false,
                confidenceSpacingEnabled: false,
                adaptiveXpEnabled: true,
                momentumRewardsEnabled: true,
                disastersEnabled: false,
                animatedBgEnabled: false,
                trinketsEnabled: false,
                difficultyMode: 'normal',
                difficultySlider: 50,
                volume: 50,
                buddyPosition: null,
                comboPosition: null,
                calcPosition: null,
                notePosition: null
            },
            petCare: {
                foodBowl: 0,
                waterBowl: 0,
                maxFood: 400,
                maxWater: 500
            },
            stats: {
                totalXpEarned: 0,
                questionsAnswered: 0,
                testsCompleted: 0,
                perfectTests: 0,
                longestStreak: 0,
                powerUpsUsed: 0,
                lastActiveDate: null,
                lastActiveTimestamp: null,
                momentum: { streak: 0, lastQuestionTs: 0 },
                batchSession: null,
                lastRewardMeta: null
            },
            doubleXpRemaining: 0,
            questionStartTime: null,
            questionAccumulatedMs: 0,
            questionTimerPaused: false,
            questionTimerEnabled: false
        };
    },

    getDifficultyConfig(state) {
        const settings = state?.settings || {};
        const mode = settings.difficultyMode || 'normal';
        const slider = Math.max(0, Math.min(100, settings.difficultySlider ?? 50));
        const sliderScale = 0.75 + (slider / 100) * 0.75; // 0.75 - 1.5
        const modes = {
            easy: { hunger: 0.75, happiness: 0.8, bowlEfficiency: 1.2 },
            normal: { hunger: 1.0, happiness: 1.0, bowlEfficiency: 1.0 },
            hard: { hunger: 1.25, happiness: 1.2, bowlEfficiency: 0.85 }
        };
        const base = modes[mode] || modes.normal;
        return {
            hungerDecay: base.hunger * sliderScale,
            happinessDecay: base.happiness * sliderScale,
            bowlEfficiency: base.bowlEfficiency,
            caloriesPerPoint: this.CALORIES_PER_HUNGER_POINT / (base.bowlEfficiency || 1),
            waterPerPoint: this.ML_PER_HAPPINESS_POINT / (base.bowlEfficiency || 1)
        };
    },

    _getRewardScalar(state) {
        const settings = state?.settings || {};
        if (!settings.difficultyControlsEnabled) return 1;
        const mode = settings.difficultyMode || 'normal';
        const slider = Math.max(0, Math.min(100, settings.difficultySlider ?? 50));
        const sliderScale = 0.75 + (slider / 100) * 0.75; // 0.75 - 1.5
        let base = 1;
        if (mode === 'easy') base = 0.9;
        else if (mode === 'hard') base = 1.12;
        let scalar = base;
        if (sliderScale > 1) scalar *= 1 + (sliderScale - 1) * 0.35;
        else scalar *= 1 - (1 - sliderScale) * 0.25;
        return Math.max(0.6, Math.min(1.5, scalar));
    },

    getPetBuffs(state) {
        const pet = state?.studyBuddy || {};
        const species = pet.species || 'bird';
        const hunger = pet.hunger ?? 100;
        const happiness = pet.happiness ?? 100;
        const avg = (hunger + happiness) / 2;
        let xp = 1, coins = 1, garden = 1;

        const speciesBuff = {
            cat: { coins: 1.05 },
            dog: { xp: 1.05 },
            bunny: { garden: 1.08 },
            dragon: { coins: 1.1, xp: 1.05 },
            turtle: { xp: 1.03, garden: 1.03 }
        }[species] || {};

        xp *= speciesBuff.xp || 1;
        coins *= speciesBuff.coins || 1;
        garden *= speciesBuff.garden || 1;

        if (avg >= 80) {
            xp *= 1.05; coins *= 1.05; garden *= 1.05;
        } else if (avg < 40) {
            xp *= 0.9; coins *= 0.9; garden *= 0.9;
        }

        return { xp, coins, garden };
    },

    _getBatchBonus(state, action) {
        const stats = state.stats || (state.stats = {});
        if (!stats.batchSession) {
            stats.batchSession = { count: 0, startedAt: Date.now(), lastQuestionTs: 0, multiplier: 1 };
        }
        const session = stats.batchSession;
        if (!this.QUESTION_XP_ACTIONS.has(action)) {
            return { multiplier: session.multiplier || 1, count: session.count || 0 };
        }
        const now = Date.now();
        if (!session.lastQuestionTs || (now - session.lastQuestionTs) > this.BATCH_WINDOW_MS) {
            session.count = 0;
            session.startedAt = now;
            session.multiplier = 1;
        }
        session.lastQuestionTs = now;
        session.count = (session.count || 0) + 1;
        const tier = Math.min(5, Math.floor(Math.max(0, session.count - 1) / 4));
        const bonus = 1 + tier * 0.05;
        session.multiplier = bonus;
        session.tier = tier;
        return { multiplier: bonus, count: session.count, tier };
    },

    _getBatchStatus(state) {
        const stats = state.stats || {};
        const session = stats.batchSession;
        if (!session) return { count: 0, multiplier: 1 };
        if (session.lastQuestionTs && (Date.now() - session.lastQuestionTs) > this.BATCH_WINDOW_MS) {
            session.count = 0;
            session.multiplier = 1;
            session.tier = 0;
            return { count: 0, multiplier: 1 };
        }
        return {
            count: session.count || 0,
            multiplier: session.multiplier || 1,
            tier: session.tier || 0
        };
    },

    _getMomentumBonus(state, options) {
        const stats = state.stats || (state.stats = {});
        if (!state.settings?.momentumRewardsEnabled) return { xp: 1, coins: 1 };
        const now = Date.now();
        if (!stats.momentum) stats.momentum = { streak: 0, lastQuestionTs: 0 };
        if (options?.withCombo) {
            if (stats.momentum.lastQuestionTs && (now - stats.momentum.lastQuestionTs) < 10 * 60 * 1000) {
                stats.momentum.streak = (stats.momentum.streak || 0) + 1;
            } else {
                stats.momentum.streak = 1;
            }
            stats.momentum.lastQuestionTs = now;
        }
        const bonus = 1 + Math.min((stats.momentum.streak || 0) * 0.02, 0.25);
        return { xp: bonus, coins: bonus };
    },

    _maybeTriggerDisaster(state) {
        const settings = state.settings || {};
        if (!settings.disastersEnabled || settings.difficultyMode !== 'hard') return;
        const now = Date.now();
        const lastActive = state.stats?.lastActiveTimestamp || now;
        const hoursAway = (now - lastActive) / (1000 * 60 * 60);
        if (hoursAway < 3) return;
        if (state.stats?.lastDisasterCheck && (now - state.stats.lastDisasterCheck) < 60 * 60 * 1000) return;
        state.stats.lastDisasterCheck = now;
        const chance = Math.min(0.6, 0.15 + (hoursAway / 12) * 0.2);
        if (Math.random() > chance) return;
        const coinLoss = Math.min(state.coins || 0, Math.round((state.coins || 0) * 0.08));
        state.coins = Math.max(0, (state.coins || 0) - coinLoss);
        state.garden.waterLevel = Math.max(0, (state.garden.waterLevel || 0) - 15);
        state.garden.lastWaterDecay = now;
        state.garden.lastGrowthTick = now;
        state.stats.lastDisaster = { coinLoss, at: now };
    },

    renderBowls(state) {
        const bowls = document.getElementById('gardenBowls');
        if (!bowls) return;
        const enabled = state.settings.petBowlsEnabled;
        bowls.style.display = enabled ? '' : 'none';
        if (!enabled) return;

        const care = state.petCare || { foodBowl: 0, waterBowl: 0, maxFood: 400, maxWater: 500 };
        const foodPct = Math.round(Math.min(100, (care.foodBowl / Math.max(1, care.maxFood)) * 100));
        const waterPct = Math.round(Math.min(100, (care.waterBowl / Math.max(1, care.maxWater)) * 100));
        const foodInv = state.inventory.petFood || {};
        const totalFood = Object.values(foodInv).reduce((sum, c) => sum + c, 0);
        const waterInv = state.inventory.gardenItems.water || 0;

        bowls.innerHTML = `
            <div class="pet-bowl food">
                <h4>Food Bowl (${Math.round(care.foodBowl)} / ${care.maxFood} kcal)</h4>
                <div class="pet-bowl-level"><div class="pet-bowl-fill" style="width:${foodPct}%"></div></div>
                <div class="pet-bowl-actions">
                    <button onclick="Garden.fillFoodBowl(100)" ${totalFood <= 0 ? 'disabled' : ''}>+100</button>
                    <button onclick="Garden.fillFoodBowl(200)" ${totalFood <= 0 ? 'disabled' : ''}>+200</button>
                </div>
                <div class="pet-bowl-meta">Inventory portions: ${totalFood}</div>
            </div>
            <div class="pet-bowl water">
                <h4>Water Bowl (${Math.round(care.waterBowl)} / ${care.maxWater} ml)</h4>
                <div class="pet-bowl-level"><div class="pet-bowl-fill" style="width:${waterPct}%"></div></div>
                <div class="pet-bowl-actions">
                    <button onclick="Garden.fillWaterBowl(100)" ${waterInv <= 0 ? 'disabled' : ''}>+100</button>
                    <button onclick="Garden.fillWaterBowl(200)" ${waterInv <= 0 ? 'disabled' : ''}>+200</button>
                </div>
                <div class="pet-bowl-meta">Watering cans: ${waterInv}</div>
            </div>`;
    },

    fillFoodBowl(amount) {
        const state = Gamification.getState();
        if (!state.settings.petBowlsEnabled) return;
        const inv = state.inventory.petFood || {};
        const care = state.petCare;
        const needed = Math.max(0, Math.min(amount, (care.maxFood || 400) - (care.foodBowl || 0)));
        if (needed <= 0) return;
        let remaining = needed;
        const foodOrder = Object.keys(inv);
        for (const id of foodOrder) {
            if (remaining <= 0) break;
            while (inv[id] > 0 && remaining > 0) {
                const food = Gamification.SHOP.food[id];
                const nutrition = food?.hunger || 10;
                inv[id]--;
                remaining -= nutrition;
            }
        }
        const added = needed - Math.max(0, remaining);
        care.foodBowl = Math.min(care.maxFood || 400, (care.foodBowl || 0) + added);
        Gamification.saveState(state);
        this.renderBowls(state);
    },

    fillWaterBowl(amount) {
        const state = Gamification.getState();
        if (!state.settings.petBowlsEnabled) return;
        const inv = state.inventory.gardenItems;
        const care = state.petCare;
        const needed = Math.max(0, Math.min(amount, (care.maxWater || 500) - (care.waterBowl || 0)));
        if (needed <= 0 || (inv.water || 0) <= 0) return;
        const cansNeeded = Math.ceil(needed / 30);
        const cansUsed = Math.min(cansNeeded, inv.water);
        inv.water -= cansUsed;
        care.waterBowl = Math.min(care.maxWater || 500, (care.waterBowl || 0) + cansUsed * 30);
        Gamification.saveState(state);
        this.renderBowls(state);
    },

    // In-memory state cache — prevents read-modify-write race conditions
    // when chained calls (checkAchievements → unlockAchievement → awardXp → feedBuddy)
    // each read stale copies from localStorage
    _state: null,
    _saveTimeout: null,
    _rewardToastTimer: null,

    // Get current state (reads localStorage only on first call, then returns cached)
    getState() {
        if (!this._state) {
            const defaults = this.getDefaultState();
            const saved = Store.get('gamification', {});
            try {
                const m = (d, s) => ({ ...d, ...(s && typeof s === 'object' ? s : {}) });
                const mDeep = (d, s) => {
                    const result = { ...d };
                    if (s && typeof s === 'object') {
                        for (const k of Object.keys(s)) {
                            if (typeof d[k] === 'object' && d[k] !== null && !Array.isArray(d[k]) && typeof s[k] === 'object' && s[k] !== null && !Array.isArray(s[k])) {
                                result[k] = { ...d[k], ...s[k] };
                            } else {
                                result[k] = s[k];
                            }
                        }
                    }
                    return result;
                };
                this._state = { ...defaults, ...saved,
                    combo: m(defaults.combo, saved.combo),
                    settings: m(defaults.settings, saved.settings),
                    stats: m(defaults.stats, saved.stats),
                    studyBuddy: m(defaults.studyBuddy, saved.studyBuddy),
                    powerUpInventory: m(defaults.powerUpInventory, saved.powerUpInventory),
                    garden: m(defaults.garden, saved.garden),
                    inventory: mDeep(defaults.inventory, saved.inventory),
                    battle: m(defaults.battle, saved.battle),
                    petCare: { ...defaults.petCare, ...(saved.petCare || {}) }
                };
                // Multi-pet sync: migrate and sync active pet
                const st = this._state;
                if (!st.studyBuddy.species) st.studyBuddy.species = 'bird';
                if (!st.pets || st.pets.length === 0) {
                    st.pets = [st.studyBuddy];
                    st.activePetIdx = 0;
                } else {
                    // Load active pet into studyBuddy
                    const idx = st.activePetIdx || 0;
                    if (st.pets[idx]) st.studyBuddy = st.pets[idx];
                }
            } catch (e) {
                console.error('Corrupt gamification data, resetting to defaults:', e);
                this._state = defaults;
            }
        }
        return this._state;
    },

    // Save state — updates in-memory cache immediately, debounces localStorage write
    saveState(state) {
        // Sync active pet back to pets array
        if (state.pets && state.pets.length > 0) {
            state.pets[state.activePetIdx || 0] = state.studyBuddy;
        }
        if (state.stats) {
            state.stats.lastActiveTimestamp = Date.now();
        }
        this._state = state;
        if (this._saveTimeout) clearTimeout(this._saveTimeout);
        this._saveTimeout = setTimeout(() => Store.set('gamification', state), 100);
    },

    // Flush to localStorage immediately (for beforeunload, export, etc.)
    saveStateImmediate(state) {
        if (state) this._state = state;
        if (this._state && this._state.stats) {
            this._state.stats.lastActiveTimestamp = Date.now();
        }
        if (this._saveTimeout) clearTimeout(this._saveTimeout);
        if (this._state) Store.set('gamification', this._state);
    },

    // Check if enabled
    isEnabled() {
        return this.getState().settings.enabled;
    },

    // Get level threshold (progressively harder curve)
    getLevelThreshold(level) {
        if (level <= 1) return 200;
        const quadraticRamp = 40 * level * level + 80 * level + 200;
        return Math.floor(quadraticRamp);
    },

    // Get total XP needed for level
    getTotalXpForLevel(level) {
        let total = 0;
        for (let i = 1; i < level; i++) {
            total += this.getLevelThreshold(i);
        }
        return total;
    },

    // Get title for level
    getTitleForLevel(level) {
        let title = 'Curious Beginner';
        for (const [lvl, t] of Object.entries(this.TITLES)) {
            if (level >= parseInt(lvl)) title = t;
        }
        return title;
    },

    applyLevelRewardPack(level, rewardLog, state) {
        if (!this.LEVEL_REWARD_PACKS) return;
        const pack = this.LEVEL_REWARD_PACKS[level];
        if (!pack) return;

        const notes = [];

        if (pack.coins) {
            state.coins = (state.coins || 0) + pack.coins;
            state.totalCoinsEarned = (state.totalCoinsEarned || 0) + pack.coins;
            notes.push(`+${pack.coins} Coins`);
        }

        if (pack.powerUps) {
            const powerNotes = [];
            for (const [powerId, amount] of Object.entries(pack.powerUps)) {
                if (!state.powerUpInventory[powerId]) state.powerUpInventory[powerId] = 0;
                state.powerUpInventory[powerId] += amount;
                const label = this.POWERUPS[powerId]?.name || powerId;
                powerNotes.push(`${label} x${amount}`);
            }
            if (powerNotes.length) notes.push(powerNotes.join(', '));
        }

        if (pack.items) {
            for (const [invKey, payload] of Object.entries(pack.items)) {
                if (!state.inventory[invKey]) {
                    state.inventory[invKey] = Array.isArray(payload) ? [] : {};
                }
                if (Array.isArray(payload)) {
                    payload.forEach(item => {
                        if (Array.isArray(state.inventory[invKey])) {
                            state.inventory[invKey].push(item);
                        }
                    });
                    if (payload.length) notes.push(`${invKey} +${payload.length}`);
                } else {
                    const entryNotes = [];
                    const bucket = state.inventory[invKey];
                    for (const [itemId, amount] of Object.entries(payload)) {
                        bucket[itemId] = (bucket[itemId] || 0) + amount;
                        entryNotes.push(`${itemId} x${amount}`);
                    }
                    if (entryNotes.length) notes.push(entryNotes.join(', '));
                }
            }
        }

        if (notes.length) {
            rewardLog.push(notes.join(' | '));
        }
    },

    // Award XP
    awardXp(action, options = {}) {
        if (!this.isEnabled()) return 0;

        const state = this.getState();
        this._maybeTriggerDisaster(state);
        let xpAmount = this.XP_VALUES[action] || 0;

        // Adaptive scaling hooks
        const adaptiveEnabled = !!(state.settings?.adaptiveXpEnabled);
        if (adaptiveEnabled && options.questionMeta) {
            const { difficulty = 1, noveltyScore = 1, streakPenalty = 1, confidenceFactor = 1 } = options.questionMeta;
            const baseScalar = 0.6 + (difficulty * 0.3);
            const noveltyScalar = 0.4 + (noveltyScore * 0.6);
            const streakScalar = streakPenalty;
            const confidenceScalar = confidenceFactor;
            const adaptiveScalar = Math.max(0.3, Math.min(2.5, baseScalar * noveltyScalar * streakScalar * confidenceScalar));
            xpAmount = Math.round(xpAmount * adaptiveScalar);
        }

        // Difficulty reward scalar & pet buffs
        const rewardScalar = this._getRewardScalar(state);
        const petBuffs = this.getPetBuffs(state);
        xpAmount = Math.round(xpAmount * rewardScalar * (petBuffs.xp || 1));

        // Momentum bonus (session pacing)
        const momentum = this._getMomentumBonus(state, options);
        xpAmount = Math.round(xpAmount * (momentum.xp || 1));

        // Batch size bonus
        const batch = this._getBatchBonus(state, action);
        xpAmount = Math.round(xpAmount * (batch.multiplier || 1));

        // Apply multipliers
        if (options.multiplier) xpAmount = Math.floor(xpAmount * options.multiplier);
        if (state.combo.multiplier > 1) xpAmount = Math.floor(xpAmount * state.combo.multiplier);
        if (state.doubleXpRemaining > 0) {
            xpAmount *= 2;
            state.doubleXpRemaining--;
        }

        // Add combo bonus
        if (options.withCombo && state.combo.current > 0) {
            xpAmount += this.XP_VALUES.comboBonus * state.combo.current;
        }

        const oldLevel = state.level;
        state.xp += xpAmount;
        state.stats.totalXpEarned += xpAmount;

        // Check for level up (award intermediate milestone rewards)
        const levelRewards = [];
        while (state.xp >= this.getLevelThreshold(state.level)) {
            state.xp -= this.getLevelThreshold(state.level);
            state.level++;
            state.currentTitle = this.getTitleForLevel(state.level);
            const lvlRewards = [];
            if (state.level % 5 === 0) {
                state.powerUpInventory.fiftyFifty = (state.powerUpInventory.fiftyFifty || 0) + 1;
                state.powerUpInventory.doubleXp = (state.powerUpInventory.doubleXp || 0) + 1;
                lvlRewards.push('+1 50/50, +1 2x XP');
            }
            // Auto-unlock garden plots at milestone levels
            if (this.PLOT_UNLOCK_LEVELS.includes(state.level)) {
                const maxPlots = 9;
                if ((state.garden.unlockedPlots || 3) < maxPlots) {
                    state.garden.unlockedPlots = Math.min(maxPlots, (state.garden.unlockedPlots || 3) + 1);
                    lvlRewards.push('+1 Garden Plot');
                }
            }
            // Evolution stones at levels 10, 15, 20
            if (state.level === 10 || state.level === 15 || state.level === 20) {
                state.inventory.gardenItems.evoStone = (state.inventory.gardenItems.evoStone || 0) + 1;
                lvlRewards.push('+1 Evolution Stone');
            }
            this.applyLevelRewardPack(state.level, lvlRewards, state);
            if (lvlRewards.length > 0) {
                levelRewards.push('Lv' + state.level + ': ' + lvlRewards.join(', '));
            }
        }

        this.saveState(state);

        // Show XP popup
        if (state.settings.xpPopups && xpAmount > 0) {
            this.showXpPopup(xpAmount);
        }

        // Show level up
        if (state.level > oldLevel) {
            this.showLevelUp(state.level, state.currentTitle, levelRewards.join(' | '));
            this.checkLevelAchievements(state.level);
        }

        // Update buddy
        this.feedBuddy(xpAmount);

        // Award coins alongside XP
        const coinAction = this.COIN_VALUES[action];
        if (coinAction !== undefined && coinAction > 0) {
            const coinScaled = Math.round(coinAction * rewardScalar * (petBuffs.coins || 1) * (momentum.coins || 1));
            this.awardCoins(coinScaled, action);
        }

        if (state.stats) {
            state.stats.lastRewardMeta = {
                action,
                timestamp: Date.now(),
                xpFinal: xpAmount,
                momentumStreak: state.stats.momentum?.streak || 0,
                momentumBonus: momentum.xp || 1,
                batchCount: batch.count || 0,
                batchMultiplier: batch.multiplier || 1,
                rewardScalar,
                petBuffs,
                comboMultiplier: state.combo?.multiplier || 1
            };
        }

        // Update home XP bar if visible
        this.renderXpBar();

        return xpAmount;
    },

    // Award coins
    awardCoins(amount, reason) {
        if (!this.isEnabled() || amount <= 0) return 0;

        const state = this.getState();
        state.coins = (state.coins || 0) + amount;
        state.totalCoinsEarned = (state.totalCoinsEarned || 0) + amount;
        this.saveState(state);

        if (state.totalCoinsEarned >= 1000) this.unlockAchievement('big_spender');

        if (state.settings.coinPopups) {
            this.showCoinPopup(amount);
        }

        this.renderXpBar();
        return amount;
    },

    // Spend coins (returns true if successful)
    spendCoins(amount) {
        const state = this.getState();
        if ((state.coins || 0) < amount) return false;
        state.coins -= amount;
        this.saveState(state);
        this.renderXpBar();
        return true;
    },

    // Show coin popup
    showCoinPopup(amount) {
        const popup = document.createElement('div');
        popup.className = 'coin-popup';
        popup.textContent = '+' + amount + ' coins';
        popup.style.left = (Math.random() * 40 + 50) + '%';
        popup.style.top = (window.scrollY + window.innerHeight * 0.35) + 'px';
        document.body.appendChild(popup);
        setTimeout(() => popup.remove(), 1500);
    },

    // Increment combo
    incrementCombo() {
        if (!this.isEnabled()) return;

        const state = this.getState();
        state.combo.current++;
        state.combo.lastCorrectTime = Date.now();

        // Update multiplier (max 3x at 20 streak)
        state.combo.multiplier = Math.min(3.0, 1.0 + (state.combo.current * 0.1));

        // Update best streak
        if (state.combo.current > state.combo.best) {
            state.combo.best = state.combo.current;
        }
        if (state.combo.current > state.stats.longestStreak) {
            state.stats.longestStreak = state.combo.current;
        }

        this.saveState(state);
        this.updateComboDisplay();

        // Check streak achievements
        if (state.combo.current === 10) this.unlockAchievement('ten_streak');
        if (state.combo.current === 20) this.unlockAchievement('twenty_streak');

        // Play combo sound
        if (state.settings.sounds && state.combo.current > 1) {
            SoundFX.play('combo');
        }
    },

    // Save widget position
    saveWidgetPosition(key, pos) {
        if (!key || !pos || typeof pos.left !== 'number' || typeof pos.top !== 'number') return;
        const state = this.getState();
        state.settings = state.settings || {};
        state.settings[key] = { left: pos.left, top: pos.top };
        this.saveState(state);
    },

    // Update combo display
    updateComboDisplay() {
        const state = this.getState();
        const el = document.getElementById('comboDisplay');
        if (!el) return;

        this._applyComboPosition(el, state.settings.comboPosition);
        this._ensureComboDraggable(el);

        if (state.combo.current >= 2) {
            el.classList.add('active');
            document.getElementById('comboCount').textContent = 'x' + state.combo.current;
            document.getElementById('comboMult').textContent = state.combo.multiplier.toFixed(1) + 'x';
        } else {
            el.classList.remove('active');
        }
    },

    _applyComboPosition(el, pos) {
        if (!el) return;
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
            el.style.left = pos.left + 'px';
            el.style.top = pos.top + 'px';
            el.style.transform = 'none';
        } else {
            el.style.left = '50%';
            el.style.top = '90px';
            el.style.transform = 'translateX(-50%)';
        }
    },

    _ensureComboDraggable(el) {
        if (!el || el.dataset.comboDragInit === '1') return;
        el.dataset.comboDragInit = '1';
        const self = this;
        let pointerId = null;
        let offsetX = 0;
        let offsetY = 0;
        let startX = 0;
        let startY = 0;
        let moved = false;

        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        const endDrag = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            el.releasePointerCapture(pointerId);
            pointerId = null;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', endDrag);
            document.removeEventListener('pointercancel', endDrag);
            el.classList.remove('dragging');
            moved = false;
        };

        const onPointerMove = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            e.preventDefault();
            const left = clamp(e.clientX - offsetX, 5, window.innerWidth - el.offsetWidth - 5);
            const top = clamp(e.clientY - offsetY, 40, window.innerHeight - el.offsetHeight - 5);
            el.style.left = left + 'px';
            el.style.top = top + 'px';
            el.style.transform = 'none';
            if (!moved && (Math.abs(e.clientX - startX) > 4 || Math.abs(e.clientY - startY) > 4)) {
                moved = true;
                el.classList.add('dragging');
            }
            const state = self.getState();
            self.saveWidgetPosition('comboPosition', { left, top });
        };

        el.addEventListener('pointerdown', (e) => {
            if (e.button !== 0 || pointerId !== null) return;
            pointerId = e.pointerId;
            const rect = el.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            startX = e.clientX;
            startY = e.clientY;
            moved = false;
            el.setPointerCapture(pointerId);
            document.addEventListener('pointermove', onPointerMove, { passive: false });
            document.addEventListener('pointerup', endDrag);
            document.addEventListener('pointercancel', endDrag);
        });
    },

    // Show XP popup
    showXpPopup(amount) {
        const popup = document.createElement('div');
        popup.className = 'xp-popup';
        popup.textContent = '+' + amount + ' XP';
        popup.style.left = (Math.random() * 60 + 20) + '%';
        popup.style.top = (window.scrollY + window.innerHeight * 0.4) + 'px';
        document.body.appendChild(popup);

        setTimeout(() => popup.remove(), 1500);
    },

    // Show level up modal
    showLevelUp(level, title, rewardsText) {
        document.getElementById('levelupNum').textContent = level;
        document.getElementById('levelupTitle').textContent = title;
        document.getElementById('levelupRewards').textContent = rewardsText ? 'Rewards: ' + rewardsText : '';

        document.getElementById('levelupOverlay').classList.add('active');

        // Play sound and confetti
        const state = this.getState();
        if (state.settings.sounds) SoundFX.play('levelUp');
        if (state.settings.confetti) this.triggerConfetti();
    },

    // Close level up modal
    closeLevelUp() {
        document.getElementById('levelupOverlay').classList.remove('active');
    },

    // Unlock achievement
    unlockAchievement(id) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        if (state.achievements[id]) return; // Already unlocked

        const achievement = this.ACHIEVEMENTS.find(a => a.id === id);
        if (!achievement) return;

        state.achievements[id] = Date.now();
        state.xp += achievement.xp;
        state.stats.totalXpEarned += achievement.xp;

        // Check for level up from achievement XP
        const oldLevel = state.level;
        const levelRewards = [];
        while (state.xp >= this.getLevelThreshold(state.level)) {
            state.xp -= this.getLevelThreshold(state.level);
            state.level++;
            state.currentTitle = this.getTitleForLevel(state.level);
            const lvlR = [];
            if (state.level % 5 === 0) {
                state.powerUpInventory.fiftyFifty = (state.powerUpInventory.fiftyFifty || 0) + 1;
                state.powerUpInventory.doubleXp = (state.powerUpInventory.doubleXp || 0) + 1;
                lvlR.push('+1 50/50, +1 2x XP');
            }
            if (this.PLOT_UNLOCK_LEVELS.includes(state.level)) {
                if ((state.garden.unlockedPlots || 3) < 9) {
                    state.garden.unlockedPlots = Math.min(9, (state.garden.unlockedPlots || 3) + 1);
                    lvlR.push('+1 Garden Plot');
                }
            }
            if (state.level === 10 || state.level === 15 || state.level === 20) {
                state.inventory.gardenItems.evoStone = (state.inventory.gardenItems.evoStone || 0) + 1;
                lvlR.push('+1 Evolution Stone');
            }
            this.applyLevelRewardPack(state.level, lvlR, state);
            if (lvlR.length > 0) levelRewards.push('Lv' + state.level + ': ' + lvlR.join(', '));
        }
        this.saveState(state);

        // Show toast
        this.showAchievementToast(achievement);

        // Show level up if triggered by achievement XP
        if (state.level > oldLevel) {
            this.showLevelUp(state.level, state.currentTitle, levelRewards.join(' | '));
            this.checkLevelAchievements(state.level);
        }

        // Play sound
        if (state.settings.sounds) SoundFX.play('achievement');
        if (state.settings.confetti) this.triggerConfetti();
    },

    // Show achievement toast
    showAchievementToast(achievement) {
        const toast = document.getElementById('achievementToast');
        if (!toast) return;

        document.getElementById('achIcon').textContent = achievement.icon;
        document.getElementById('achName').textContent = achievement.name;
        document.getElementById('achDesc').textContent = achievement.desc;
        document.getElementById('achXp').textContent = '+' + achievement.xp + ' XP';

        toast.classList.remove('hidden');

        setTimeout(() => toast.classList.add('hidden'), 4000);
    },

    // Check achievements after answering
    checkAchievements(isCorrect, timeSpent) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        state.stats.questionsAnswered++;
        this.saveState(state);

        // First correct
        if (isCorrect && !state.achievements['first_correct']) {
            this.unlockAchievement('first_correct');
        }

        // Speed demon
        if (isCorrect && timeSpent && timeSpent < 10000) {
            this.unlockAchievement('speed_demon');
        }

        // Century and thousand
        if (state.stats.questionsAnswered >= 100) this.unlockAchievement('century');
        if (state.stats.questionsAnswered >= 1000) this.unlockAchievement('thousand');

        // Time-based achievements
        const hour = new Date().getHours();
        if (hour < 7) this.unlockAchievement('early_bird');
        if (hour >= 23) this.unlockAchievement('night_owl');
    },

    // Check level achievements
    checkLevelAchievements(level) {
        if (level >= 5) this.unlockAchievement('level_5');
        if (level >= 10) this.unlockAchievement('level_10');
        if (level >= 20) this.unlockAchievement('level_20');
    },

    // Update category mastery
    updateCategoryMastery(category, isCorrect) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        if (!state.categoryMastery[category]) {
            state.categoryMastery[category] = { correct: 0, total: 0, level: null };
        }

        state.categoryMastery[category].total++;
        if (isCorrect) state.categoryMastery[category].correct++;

        const cm = state.categoryMastery[category];
        const accuracy = cm.total > 0 ? (cm.correct / cm.total) * 100 : 0;

        // Update mastery level
        if (cm.total >= 50 && accuracy >= 95) cm.level = 'platinum';
        else if (cm.total >= 30 && accuracy >= 90) cm.level = 'gold';
        else if (cm.total >= 20 && accuracy >= 80) cm.level = 'silver';
        else if (cm.total >= 10 && accuracy >= 70) cm.level = 'bronze';

        // Check for category master achievement (gold or platinum)
        if ((cm.level === 'gold' || cm.level === 'platinum') && !state.achievements['category_master']) {
            this.unlockAchievement('category_master');
        }

        this.saveState(state);
    },

    // Feed buddy XP
    feedBuddy(xp) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        const buddy = state.studyBuddy;
        buddy.totalXpFed += xp;
        buddy.lastFed = Date.now();
        buddy.lastInteraction = Date.now();

        // Studying gives a small happiness boost
        buddy.happiness = Math.min(100, (buddy.happiness ?? 100) + 1);

        // Accumulate study minutes (~1 min per question)
        buddy.studyMinutes = (buddy.studyMinutes || 0) + 1;
        // Study time counts 3x toward care (active study > passive time)
        buddy.careMinutes = (buddy.careMinutes || 0) + 3;

        // Studying heals sickness
        if (buddy.sick && buddy.hunger > 30 && buddy.happiness > 30) {
            buddy.sick = false;
        }

        // Check for evolution — needs BOTH enough XP AND enough care time
        for (let i = this.BUDDY_STAGES.length - 1; i >= 0; i--) {
            const req = this.BUDDY_STAGES[i];
            if (buddy.totalXpFed >= req.xpNeeded && (buddy.careMinutes || 0) >= req.careNeeded) {
                if (buddy.stage < req.stage) {
                    buddy.stage = req.stage;
                    this.showAchievementToast({
                        icon: this.getSpeciesEmoji(buddy.species, req.stage),
                        name: buddy.name + ' evolved!',
                        desc: 'Now a ' + this.getSpeciesStageName(buddy.species, req.stage),
                        xp: 0
                    });
                }
                break;
            }
        }

        this.saveState(state);
        this.updateBuddyWidget();
    },

    // Update buddy mood
    updateBuddyMood() {
        const state = this.getState();
        const buddy = state.studyBuddy;
        const h = buddy.hunger ?? 100;
        const hp = buddy.happiness ?? 100;

        if (buddy.sick) buddy.mood = 'sick';
        else if (h > 75 && hp > 75) buddy.mood = 'happy';
        else if (h > 50 && hp > 50) buddy.mood = 'content';
        else if (h < 25 || hp < 25) buddy.mood = 'miserable';
        else if (h < 50) buddy.mood = 'hungry';
        else buddy.mood = 'sad';

        this.saveState(state);
        this.updateBuddyWidget();
    },

    // Update buddy widget
    updateBuddyWidget() {
        const state = this.getState();
        const el = document.getElementById('studyBuddy');
        if (!el) return;

        if (!state.settings.pet) {
            el.classList.remove('active');
            return;
        }

        const buddy = state.studyBuddy;
        const stage = this.BUDDY_STAGES.find(s => s.stage === buddy.stage) || this.BUDDY_STAGES[0];
        const nextStage = this.BUDDY_STAGES.find(s => s.stage === buddy.stage + 1);

        el.classList.add('active');
        el.classList.remove('urgent', 'sick');
        const hunger = buddy.hunger ?? 100;
        const happiness = buddy.happiness ?? 100;
        if (buddy.sick) el.classList.add('sick');
        else if (hunger < 30 || happiness < 30) el.classList.add('urgent');

        this._applyBuddyPosition(el, state.settings.buddyPosition);
        this._ensureBuddyDraggable(el);

        const accessories = (buddy.accessories || []).map(a => {
            const item = this.SHOP?.cosmetics?.[a];
            return item ? item.icon : '';
        }).join('');
        document.getElementById('buddySprite').innerHTML = Sprites.petSprite(buddy.stage, this.getSpeciesEmoji(buddy.species, buddy.stage), 36);
        document.getElementById('buddyName').textContent = buddy.name + (accessories ? ' ' + accessories : '');
        const moodStr = buddy.mood || 'content';
        const moodDisplay = buddy.sick ? 'Sick \ud83e\udd12' : moodStr.charAt(0).toUpperCase() + moodStr.slice(1);
        document.getElementById('buddyMood').textContent = moodDisplay;

        // Progress to next stage
        if (nextStage) {
            const currentXp = buddy.totalXpFed - stage.xpNeeded;
            const neededXp = nextStage.xpNeeded - stage.xpNeeded;
            const pct = Math.min(100, Math.floor((currentXp / neededXp) * 100));
            document.getElementById('buddyProgress').style.width = pct + '%';
        } else {
            document.getElementById('buddyProgress').style.width = '100%';
        }
    },

    _applyBuddyPosition(el, pos) {
        if (!el) return;
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
            el.style.left = pos.left + 'px';
            el.style.top = pos.top + 'px';
            el.style.bottom = 'auto';
        } else {
            el.style.left = '20px';
            el.style.bottom = '100px';
            el.style.top = 'auto';
        }
    },

    _ensureBuddyDraggable(el) {
        if (!el || el.dataset.dragInit === '1') return;
        el.dataset.dragInit = '1';
        el.setAttribute('role', 'button');
        el.setAttribute('tabindex', '0');
        const self = this;
        let pointerId = null;
        let offsetX = 0;
        let offsetY = 0;
        let startX = 0;
        let startY = 0;
        let moved = false;
        let pointerDownAt = 0;

        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        const endDrag = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            el.releasePointerCapture(pointerId);
            pointerId = null;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', endDrag);
            document.removeEventListener('pointercancel', endDrag);
            el.classList.remove('dragging');
            const wasDrag = moved;
            moved = false;
            const pressDuration = Date.now() - pointerDownAt;
            pointerDownAt = 0;
            if (!wasDrag && pressDuration < 350) {
                self.showBuddyInfo();
            }
        };

        const onPointerMove = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            e.preventDefault();
            const left = clamp(e.clientX - offsetX, 5, window.innerWidth - el.offsetWidth - 5);
            const top = clamp(e.clientY - offsetY, 50, window.innerHeight - el.offsetHeight - 5);
            el.style.left = left + 'px';
            el.style.top = top + 'px';
            el.style.bottom = 'auto';
            if (!moved && (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5)) {
                moved = true;
                el.classList.add('dragging');
            }
            const state = self.getState();
            state.settings.buddyPosition = { left, top };
            self.saveState(state);
        };

        el.addEventListener('pointerdown', (e) => {
            if (e.button !== 0 || pointerId !== null) return;
            pointerId = e.pointerId;
            const rect = el.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            startX = e.clientX;
            startY = e.clientY;
            pointerDownAt = Date.now();
            moved = false;
            el.setPointerCapture(pointerId);
            document.addEventListener('pointermove', onPointerMove, { passive: false });
            document.addEventListener('pointerup', endDrag);
            document.addEventListener('pointercancel', endDrag);
        });

        el.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                self.showBuddyInfo();
            }
        });
    },

    showAnswerReward(reward) {
        if (!reward) return;
        const toast = document.getElementById('rewardToast');
        if (!toast) return;
        const iconEl = document.getElementById('rewardToastIcon');
        const titleEl = document.getElementById('rewardToastTitle');
        const breakdownEl = document.getElementById('rewardToastBreakdown');
        iconEl.textContent = reward.icon || (reward.isCorrect ? '⚔️' : '🛡️');
        titleEl.textContent = reward.title || (reward.isCorrect ? 'Great strike!' : 'Keep going!');
        const parts = [];
        if (reward.xp) parts.push(`<span>⭐ ${reward.xp} XP</span>`);
        if (reward.coins) parts.push(`<span>🪙 ${reward.coins} coins</span>`);
        if (reward.combo) parts.push(`<span>🔥 x${reward.combo.toFixed(1)} combo</span>`);
        const state = this.getState();
        const meta = state.stats?.lastRewardMeta;
        if (meta) {
            const momentumPct = Math.round(((meta.momentumBonus || 1) - 1) * 100);
            if (momentumPct > 0) {
                parts.push(`<span title="Momentum streak ${meta.momentumStreak || 0}">⚡ +${momentumPct}%</span>`);
            }
            const batchPct = Math.round(((meta.batchMultiplier || 1) - 1) * 100);
            if (batchPct > 0) {
                parts.push(`<span title="Batch x${meta.batchCount || 0}">📦 +${batchPct}%</span>`);
            }
            const petPct = Math.round(((meta.petBuffs?.xp || 1) - 1) * 100);
            if (petPct !== 0) {
                parts.push(`<span title="Buddy mood boost">🐾 ${petPct > 0 ? '+' : ''}${petPct}%</span>`);
            }
        }
        breakdownEl.innerHTML = parts.join('');
        toast.classList.add('show');
        clearTimeout(this._rewardToastTimer);
        this._rewardToastTimer = setTimeout(() => toast.classList.remove('show'), 2000);
    },

    // Show buddy info — opens garden screen with pet modal
    showBuddyInfo() {
        if (typeof Garden !== 'undefined' && this.getState().settings.garden) {
            Garden.show();
            setTimeout(() => PetModal.show(), 100);
        } else {
            PetModal.show();
        }
    },

    // Check login bonus
    checkLoginBonus() {
        if (!this.isEnabled()) return;

        const state = this.getState();
        const _d = new Date();
        const today = _d.getFullYear() + '-' + String(_d.getMonth() + 1).padStart(2, '0') + '-' + String(_d.getDate()).padStart(2, '0');

        if (state.stats.lastActiveDate !== today) {
            // Check for comeback bonus (3+ days away)
            if (state.stats.lastActiveDate) {
                const lastDate = new Date(state.stats.lastActiveDate);
                const daysDiff = Math.floor((Date.now() - lastDate.getTime()) / (1000 * 60 * 60 * 24));
                if (daysDiff >= 3) {
                    this.unlockAchievement('comeback');
                }
            }

            // Award login bonus
            this.awardXp('loginBonus');

            // awardXp already mutated the cached state, so just update lastActiveDate
            state.stats.lastActiveDate = today;
            this.saveState(state);
        }

        // Update buddy mood
        this.updateBuddyMood();
    },

    // Render XP bar on home screen
    renderXpBar() {
        const el = document.getElementById('xpBarContainer');
        if (!el) return;

        if (!this.isEnabled()) {
            el.innerHTML = '';
            return;
        }

        const state = this.getState();
        const threshold = this.getLevelThreshold(state.level);
        const pct = Math.floor((state.xp / threshold) * 100);
        const stage = this.BUDDY_STAGES.find(s => s.stage === state.studyBuddy.stage) || this.BUDDY_STAGES[0];

        const coins = state.coins || 0;
        const stats = state.stats || {};
        const metaPills = [];
        const momentumStreak = state.settings.momentumRewardsEnabled ? (stats.momentum?.streak || 0) : 0;
        const momentumBonusPct = momentumStreak > 0 ? Math.round(Math.min(momentumStreak * 2, 25)) : 0;
        if (momentumBonusPct > 0) {
            metaPills.push(`<span class="meta-pill momentum" title="Momentum streak ${momentumStreak}">Momentum +${momentumBonusPct}%</span>`);
        }
        const batchStatus = this._getBatchStatus(state);
        const batchBonusPct = Math.round(((batchStatus.multiplier || 1) - 1) * 100);
        if (batchStatus.count >= 2 && batchBonusPct > 0) {
            metaPills.push(`<span class="meta-pill batch" title="${batchStatus.count} question batch">Batch x${batchStatus.count} (+${batchBonusPct}%)</span>`);
        }
        const petBuffs = this.getPetBuffs(state);
        const petMood = Math.round(((state.studyBuddy?.hunger ?? 100) + (state.studyBuddy?.happiness ?? 100)) / 2);
        const petBonusPct = Math.round(((petBuffs.xp || 1) - 1) * 100);
        const petLabel = petBonusPct !== 0 ? ` (${petBonusPct > 0 ? '+' : ''}${petBonusPct}% XP)` : '';
        metaPills.push(`<span class="meta-pill pet" title="Buddy mood ${petMood}%">Pet ${petMood}%${petLabel}</span>`);
        const metaHtml = metaPills.length ? `<div class="xp-meta">${metaPills.join('')}</div>` : '';

        el.innerHTML = `
            <div class="xp-bar-container">
                <div class="xp-level">Lv. ${state.level}</div>
                <div class="xp-bar">
                    <div class="xp-fill" style="width: ${pct}%"></div>
                </div>
                <div class="xp-info">
                    <div class="xp-text">${state.xp.toLocaleString()} / ${threshold.toLocaleString()} XP</div>
                    <div class="xp-title">${state.currentTitle}</div>
                </div>
                <span class="coin-display" title="Coins">&#x1FA99; ${coins.toLocaleString()}</span>
                <span class="buddy-mini" onclick="event.stopPropagation();Gamification.showBuddyInfo()">${Sprites.petSprite(state.studyBuddy.stage, this.getSpeciesEmoji(state.studyBuddy.species, state.studyBuddy.stage), 24)}</span>
            </div>
            ${metaHtml}
        `;
    },

    // Trigger confetti effect
    _confettiAnimId: null,
    triggerConfetti() {
        const state = this.getState();
        if (!state.settings.confetti) return;

        const canvas = document.getElementById('confettiCanvas');
        if (!canvas) return;

        // Cancel any existing confetti animation
        if (this._confettiAnimId) cancelAnimationFrame(this._confettiAnimId);

        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const colors = ['#ff6b35', '#f7931e', '#ffd60a', '#27ae60', '#2980b9', '#9b59b6'];

        for (let i = 0; i < 100; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: -20,
                size: Math.random() * 8 + 4,
                color: colors[Math.floor(Math.random() * colors.length)],
                speedY: Math.random() * 3 + 2,
                speedX: Math.random() * 4 - 2,
                rotation: Math.random() * 360
            });
        }

        let frame = 0;
        const maxFrames = 120;
        const self = this;

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();

                p.y += p.speedY;
                p.x += p.speedX;
                p.rotation += 5;
                p.speedY += 0.1; // gravity
            });

            frame++;
            if (frame < maxFrames) {
                self._confettiAnimId = requestAnimationFrame(animate);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                self._confettiAnimId = null;
            }
        }

        animate();
    },

    // Use power-up
    usePowerUp(type) {
        if (!this.isEnabled()) return false;

        const state = this.getState();
        if (!state.powerUpInventory[type] || state.powerUpInventory[type] <= 0) return false;

        state.powerUpInventory[type]--;
        state.stats.powerUpsUsed++;
        this.saveState(state);

        if (state.settings.sounds) SoundFX.play('powerUp');

        return true;
    },

    // Apply 50/50 power-up (eliminate 2 wrong options)
    applyFiftyFifty(correctIndex, totalOptions) {
        if (!this.usePowerUp('fiftyFifty')) return [];

        const wrongIndices = [];
        for (let i = 0; i < totalOptions; i++) {
            if (i !== correctIndex) wrongIndices.push(i);
        }

        // Fisher-Yates shuffle and take 2
        for (let i = wrongIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [wrongIndices[i], wrongIndices[j]] = [wrongIndices[j], wrongIndices[i]];
        }
        return wrongIndices.slice(0, Math.min(2, wrongIndices.length));
    },

    // Apply double XP
    applyDoubleXp() {
        if (!this.usePowerUp('doubleXp')) return false;

        const state = this.getState();
        state.doubleXpRemaining = 5;
        this.saveState(state);
        return true;
    },

    // Update settings
    updateSettings() {
        const state = this.getState();

        state.settings.enabled = document.getElementById('gamifyEnabled')?.checked ?? true;
        state.settings.sounds = document.getElementById('gamifySounds')?.checked ?? true;
        state.settings.confetti = document.getElementById('gamifyConfetti')?.checked ?? true;
        state.settings.xpPopups = document.getElementById('gamifyXpPopups')?.checked ?? true;
        state.settings.pet = document.getElementById('gamifyPet')?.checked ?? true;
        state.settings.garden = document.getElementById('gamifyGarden')?.checked ?? true;
        state.settings.coinPopups = document.getElementById('gamifyCoinPopups')?.checked ?? true;
        state.settings.pixelArt = document.getElementById('gamifyPixelArt')?.checked ?? false;
        state.settings.petBowlsEnabled = document.getElementById('gamifyPetBowls')?.checked ?? false;
        state.settings.timeSkipEnabled = document.getElementById('gamifyTimeSkip')?.checked ?? false;
        state.settings.compactHomeEnabled = document.getElementById('gamifyCompactHome')?.checked ?? false;
        state.settings.difficultyControlsEnabled = document.getElementById('gamifyDifficultyControls')?.checked ?? false;
        state.settings.adaptiveXpEnabled = document.getElementById('gamifyAdaptiveXp')?.checked ?? false;
        state.settings.momentumRewardsEnabled = document.getElementById('gamifyMomentum')?.checked ?? true;
        state.settings.disastersEnabled = document.getElementById('gamifyDisasters')?.checked ?? false;
        state.settings.animatedBgEnabled = document.getElementById('gamifyAnimatedBg')?.checked ?? false;
        state.settings.trinketsEnabled = document.getElementById('gamifyTrinkets')?.checked ?? false;
        state.settings.confidenceSpacingEnabled = document.getElementById('gamifyConfidenceSpacing')?.checked ?? false;
        state.settings.volume = parseInt(document.getElementById('gamifyVolume')?.value ?? 50);

        const diffPanel = document.getElementById('difficultyControlsPanel');
        if (diffPanel) diffPanel.style.display = state.settings.difficultyControlsEnabled ? '' : 'none';
        if (state.settings.difficultyControlsEnabled) {
            const modeSelect = document.getElementById('difficultyMode');
            const sliderInput = document.getElementById('difficultySlider');
            if (modeSelect) state.settings.difficultyMode = modeSelect.value || 'normal';
            if (sliderInput) {
                const sliderVal = parseInt(sliderInput.value ?? '50', 10);
                state.settings.difficultySlider = Number.isFinite(sliderVal) ? sliderVal : 50;
                const sliderLabel = document.getElementById('difficultySliderLabel');
                if (sliderLabel) sliderLabel.textContent = state.settings.difficultySlider;
            }
        } else {
            state.settings.difficultyMode = 'normal';
            state.settings.difficultySlider = 50;
            const sliderLabel = document.getElementById('difficultySliderLabel');
            if (sliderLabel) sliderLabel.textContent = '50';
        }

        const volumeLabel = document.getElementById('gamifyVolumeLabel');
        if (volumeLabel) volumeLabel.textContent = state.settings.volume + '%';

        this.saveState(state);

        document.body.classList.toggle('compact-home', !!state.settings.compactHomeEnabled);
        document.body.classList.toggle('animated-bg', !!state.settings.animatedBgEnabled);
        document.body.classList.toggle('trinkets-enabled', !!state.settings.trinketsEnabled);

        // Update UI
        this.renderXpBar();
        this.updateBuddyWidget();
        this.updateComboDisplay();

        // Toggle garden/shop/battle buttons
        const btnGarden = document.getElementById('btnGarden');
        const btnShop = document.getElementById('btnShop');
        const btnBattle = document.getElementById('btnBattle');
        if (btnGarden) btnGarden.style.display = state.settings.garden ? '' : 'none';
        if (btnShop) btnShop.style.display = state.settings.garden ? '' : 'none';
        if (btnBattle) btnBattle.style.display = state.settings.garden ? '' : 'none';

        // Clear sprite cache when pixel art toggled
        Sprites._cache = {};

    },

    // Load settings into UI
    loadSettings() {
        const state = this.getState();

        const el1 = document.getElementById('gamifyEnabled');
        if (el1) el1.checked = state.settings.enabled;

        const el2 = document.getElementById('gamifySounds');
        if (el2) el2.checked = state.settings.sounds;

        const el3 = document.getElementById('gamifyConfetti');
        if (el3) el3.checked = state.settings.confetti;

        const el4 = document.getElementById('gamifyXpPopups');
        if (el4) el4.checked = state.settings.xpPopups;

        const el5 = document.getElementById('gamifyPet');
        if (el5) el5.checked = state.settings.pet;

        const el5b = document.getElementById('gamifyGarden');
        if (el5b) el5b.checked = state.settings.garden !== false;

        const el5c = document.getElementById('gamifyCoinPopups');
        if (el5c) el5c.checked = state.settings.coinPopups !== false;

        const el8 = document.getElementById('gamifyPixelArt');
        if (el8) el8.checked = state.settings.pixelArt;
        const el9 = document.getElementById('gamifyPetBowls');
        if (el9) el9.checked = state.settings.petBowlsEnabled;
        const el10 = document.getElementById('gamifyTimeSkip');
        if (el10) el10.checked = state.settings.timeSkipEnabled;
        const el11 = document.getElementById('gamifyCompactHome');
        if (el11) el11.checked = state.settings.compactHomeEnabled;
        const el12 = document.getElementById('gamifyDifficultyControls');
        if (el12) el12.checked = state.settings.difficultyControlsEnabled;
        const el13 = document.getElementById('gamifyAdaptiveXp');
        if (el13) el13.checked = state.settings.adaptiveXpEnabled;
        const el14 = document.getElementById('gamifyMomentum');
        if (el14) el14.checked = state.settings.momentumRewardsEnabled;
        const el15 = document.getElementById('gamifyDisasters');
        if (el15) el15.checked = state.settings.disastersEnabled;
        const el16 = document.getElementById('gamifyAnimatedBg');
        if (el16) el16.checked = state.settings.animatedBgEnabled;
        const el17 = document.getElementById('gamifyTrinkets');
        if (el17) el17.checked = state.settings.trinketsEnabled;
        const el18 = document.getElementById('gamifyConfidenceSpacing');
        if (el18) el18.checked = state.settings.confidenceSpacingEnabled;

        const el6 = document.getElementById('gamifyVolume');
        if (el6) el6.value = state.settings.volume;

        const volumeLabel = document.getElementById('gamifyVolumeLabel');
        if (volumeLabel) volumeLabel.textContent = state.settings.volume + '%';

        const diffPanel = document.getElementById('difficultyControlsPanel');
        if (diffPanel) diffPanel.style.display = state.settings.difficultyControlsEnabled ? '' : 'none';
        const diffMode = document.getElementById('difficultyMode');
        if (diffMode) diffMode.value = state.settings.difficultyMode || 'normal';
        const diffSlider = document.getElementById('difficultySlider');
        const sliderVal = state.settings.difficultySlider ?? 50;
        if (diffSlider) diffSlider.value = sliderVal;
        const sliderLabel = document.getElementById('difficultySliderLabel');
        if (sliderLabel) sliderLabel.textContent = sliderVal;

        document.body.classList.toggle('compact-home', !!state.settings.compactHomeEnabled);
    },

    // Reset progress
    resetProgress() {
        if (!confirm('Are you sure? This will reset all XP, levels, achievements, and power-ups.')) return;

        this._state = null; // Clear cache so getState re-reads defaults
        Store.remove('gamification');
        this.loadSettings();
        this.renderXpBar();
        this.updateBuddyWidget();
        this.updateComboDisplay();
        alert('Gamification data reset!');
    },

    // Start tracking question time
    startQuestionTimer() {
        const state = this.getState();
        state.questionTimerEnabled = true;
        state.questionTimerPaused = false;
        state.questionAccumulatedMs = 0;
        state.questionStartTime = Date.now();
        this.saveState(state);
    },

    pauseQuestionTimer(options = {}) {
        const state = this.getState();
        if (!state.questionTimerEnabled) return;
        if (state.questionStartTime) {
            state.questionAccumulatedMs = (state.questionAccumulatedMs || 0) + (Date.now() - state.questionStartTime);
            state.questionStartTime = null;
        }
        state.questionTimerPaused = true;
        if (!options.auto) {
            state.questionTimerEnabled = false;
        }
        this.saveState(state);
    },

    resumeQuestionTimer() {
        const state = this.getState();
        if (!state.questionTimerEnabled || !state.questionTimerPaused) return;
        state.questionTimerPaused = false;
        state.questionStartTime = Date.now();
        this.saveState(state);
    },

    // Get time spent on question
    getQuestionTime() {
        const state = this.getState();
        const acc = state.questionAccumulatedMs || 0;
        if (state.questionStartTime) {
            return acc + (Date.now() - state.questionStartTime);
        }
        return acc;
    },

    // Record test completion
    recordTestComplete(score, isPerfect) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        state.stats.testsCompleted++;
        if (isPerfect) state.stats.perfectTests++;
        this.saveState(state);

        // Award XP based on score
        this.awardXp('testComplete', { multiplier: score / 100 });

        if (isPerfect) {
            this.awardXp('perfectTest');
            this.unlockAchievement('perfect_test');
        }
    },

    // Check daily streak achievements
    checkStreakAchievements(streakDays) {
        if (streakDays >= 7) this.unlockAchievement('week_streak');
        if (streakDays >= 30) this.unlockAchievement('month_streak');
    },

    // Initialize on app start
    init() {
        this.checkLoginBonus();
        this.loadSettings();
        this.renderXpBar();
        this.updateBuddyWidget();
        this.updateComboDisplay();
    }
};

// =====================================================================
// SPRITE SYSTEM — Inline SVG pixel art for pet + plants
// =====================================================================
const Sprites = {
    _cache: {},

    // Returns pixel art if enabled, otherwise emoji
    petSprite(stageNum, emoji, size) {
        if (Gamification.getState().settings.pixelArt) return this.get('pet', stageNum, size || 48);
        return `<span style="font-size:${size ? size+'px' : 'inherit'}">${emoji}</span>`;
    },

    plantSprite(seedType, stageIdx, emoji, size) {
        if (Gamification.getState().settings.pixelArt) return this.get('plant', seedType + '_' + stageIdx, size || 48);
        return `<span style="font-size:${size ? size+'px' : 'inherit'}">${emoji}</span>`;
    },

    // Returns an <svg> HTML string at the requested size
    get(type, id, size) {
        const key = type + '_' + id + '_' + size;
        if (this._cache[key]) return this._cache[key];
        const svg = this._build(type, id, size);
        this._cache[key] = svg;
        return svg;
    },

    // Helper: render a pixel grid into an SVG. grid = 2D array of hex colors (null = transparent)
    _gridToSvg(grid, size) {
        const rows = grid.length;
        const cols = grid[0].length;
        const px = Math.floor(size / Math.max(rows, cols));
        const w = cols * px;
        const h = rows * px;
        let rects = '';
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const c = grid[y][x];
                if (c) rects += `<rect x="${x*px}" y="${y*px}" width="${px}" height="${px}" fill="${c}"/>`;
            }
        }
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="image-rendering:pixelated">${rects}</svg>`;
    },

    _build(type, id, size) {
        if (type === 'pet') return this._pet(id, size);
        if (type === 'plant') return this._plant(id, size);
        return '';
    },

    // Pet sprites — 12x12 pixel grids
    _pet(stageNum, size) {
        const _ = null;
        const W = '#fff', K = '#222', B = '#3b82f6', Y = '#fbbf24', O = '#f97316', Br = '#92400e', G = '#6b7280', Gy = '#9ca3af';
        const grids = {
            1: [ // Egg
                [_,_,_,_,W,W,W,W,_,_,_,_],
                [_,_,_,W,W,W,W,W,W,_,_,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,Y,Y,W,W,W,W,Y,Y,W,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,W,W,Y,Y,Y,Y,W,W,W,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,_,_,W,W,W,W,W,W,_,_,_],
                [_,_,_,_,W,W,W,W,_,_,_,_]
            ],
            2: [ // Hatchling — cracked egg with eyes
                [_,_,_,_,_,Y,Y,_,_,_,_,_],
                [_,_,_,_,Y,Y,Y,Y,_,_,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,Y,Y,K,Y,Y,K,Y,Y,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,Y,Y,Y,O,O,Y,Y,Y,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,W,W,Gy,Gy,Gy,Gy,W,W,_,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,_,_,_,W,W,W,W,_,_,_,_]
            ],
            3: [ // Chick — round yellow bird
                [_,_,_,_,Y,Y,Y,Y,_,_,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,Y,Y,K,Y,Y,Y,K,Y,Y,Y,_],
                [_,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,_],
                [_,Y,Y,Y,Y,O,O,Y,Y,Y,Y,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,_,_,O,_,_,O,_,_,_,_],
                [_,_,_,O,O,_,_,O,O,_,_,_]
            ],
            4: [ // Bird — sleeker, has wings
                [_,_,_,_,B,B,B,_,_,_,_,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,_,B,B,W,B,W,B,B,_,_,_],
                [_,_,B,B,K,B,K,B,B,_,_,_],
                [_,_,B,B,B,O,B,B,B,_,_,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,B,B,B,B,B,B,B,B,B,_,_],
                [B,B,B,B,B,B,B,B,B,B,B,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,_,_,_,O,_,O,_,_,_,_,_],
                [_,_,_,O,O,_,O,O,_,_,_,_]
            ],
            5: [ // Eagle — majestic, spread wings
                [_,_,_,_,_,Br,Br,_,_,_,_,_],
                [_,_,_,_,Br,Br,Br,Br,_,_,_,_],
                [_,_,_,Br,W,Br,W,Br,Br,_,_,_],
                [_,_,_,Br,K,Br,K,Br,Br,_,_,_],
                [_,_,_,Br,Br,Y,Br,Br,Br,_,_,_],
                [Br,Br,Br,Br,Br,Br,Br,Br,Br,Br,Br,_],
                [_,Br,Br,Br,Br,Br,Br,Br,Br,Br,_,Br],
                [_,_,Br,Br,Br,Br,Br,Br,Br,_,_,_],
                [_,_,_,Br,Br,Br,Br,Br,_,_,_,_],
                [_,_,_,Br,Br,Br,Br,Br,_,_,_,_],
                [_,_,_,_,Y,_,_,Y,_,_,_,_],
                [_,_,_,Y,Y,_,_,Y,Y,_,_,_]
            ]
        };
        const grid = grids[stageNum] || grids[1];
        return this._gridToSvg(grid, size || 48);
    },

    // Plant sprites — 10x12 pixel grids per stage
    _plant(key, size) {
        // key = "seedType_stageIdx" e.g. "sunflower_0"
        const [seedType, stageStr] = key.split('_');
        const stageIdx = parseInt(stageStr) || 0;
        const _ = null;
        const G = '#22c55e', DG = '#15803d', Br = '#92400e', Y = '#fbbf24', O = '#f97316';
        const LG = '#86efac', P = '#a855f7', LP = '#c084fc', Pk = '#ec4899', R = '#ef4444';
        const Cy = '#06b6d4', LB = '#7dd3fc', W = '#fff', Gy = '#6b7280';

        const plants = {
            sunflower: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,Br,Br,_,_,_,_],
                    [_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,G,G,G,G,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // stem with leaves
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,G,G,G,G,_,_,_],
                    [_,_,G,G,G,G,G,G,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,G,G,_],
                    [_,_,_,_,G,G,G,G,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // bloom
                    [_,_,_,Y,Y,Y,Y,_,_,_],
                    [_,_,Y,Y,Y,Y,Y,Y,_,_],
                    [_,Y,Y,Y,Br,Br,Y,Y,Y,_],
                    [_,Y,Y,Br,Br,Br,Br,Y,Y,_],
                    [_,_,Y,Y,Br,Br,Y,Y,_,_],
                    [_,_,_,Y,Y,Y,Y,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,G,G,_],
                    [_,_,_,_,G,G,G,G,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            cactus: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],
                    [_,_,_,DG,DG,DG,DG,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // small cactus
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],
                    [_,_,_,_,DG,DG,_,_,_,_],[_,DG,DG,_,DG,DG,_,_,_,_],[_,_,DG,DG,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,DG,DG,_],
                    [_,_,_,_,DG,DG,DG,DG,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // full cactus with flower
                    [_,_,_,_,Pk,Pk,_,_,_,_],[_,_,_,Pk,Y,Pk,Pk,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],
                    [_,_,_,_,DG,DG,_,_,_,_],[_,DG,DG,_,DG,DG,_,_,_,_],[_,_,DG,DG,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,DG,DG,_],
                    [_,_,_,_,DG,DG,DG,DG,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            bonsai: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,G,G,G,G,_,_,_],
                    [_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // small tree
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,G,G,G,G,G,_,_],[_,_,G,G,G,G,G,G,G,_],
                    [_,_,_,G,G,G,G,G,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,_,Br,Br,_,Br,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // medium tree
                    [_,_,_,G,G,G,G,_,_,_],[_,_,G,G,DG,G,DG,G,_,_],[_,G,G,DG,G,G,G,DG,G,_],[_,_,G,G,G,G,G,G,G,_],
                    [_,_,_,G,G,G,G,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,_,Br,Br,_,Br,_,_],[_,Br,_,_,Br,Br,_,_,Br,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // full bonsai
                    [_,G,G,G,G,G,G,G,G,_],[G,G,DG,G,DG,G,DG,G,DG,G],[G,DG,G,G,G,G,G,G,DG,G],[_,G,G,G,G,G,G,G,G,_],
                    [_,_,G,G,G,G,G,G,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,_,Br,Br,_,Br,_,_],[_,Br,_,_,Br,Br,_,_,Br,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            crystal: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Gy,Gy,_,_,_,_],[_,_,_,Gy,Gy,Gy,Gy,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,Cy,LB,Cy,Cy,_,_,_],
                    [_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // growing crystal
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Cy,_,_,_,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],
                    [_,_,_,Cy,LB,Cy,_,_,_,_],[_,_,Cy,LB,W,LB,Cy,_,_,_],[_,_,_,Cy,LB,Cy,_,Cy,_,_],[_,_,_,_,Cy,_,Cy,LB,Cy,_],
                    [_,_,_,_,Cy,_,_,Cy,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // large crystal
                    [_,_,_,_,Cy,_,_,_,_,_],[_,_,_,Cy,LB,Cy,_,_,Cy,_],[_,_,Cy,LB,W,LB,Cy,Cy,LB,_],[_,_,Cy,W,W,W,LB,LB,Cy,_],
                    [_,_,_,Cy,W,LB,Cy,Cy,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],[_,_,Cy,LB,W,LB,Cy,_,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],
                    [_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // crystal bloom (glowing)
                    [_,_,W,_,Cy,W,_,_,W,_],[_,_,_,Cy,W,Cy,_,Cy,LB,_],[_,Cy,Cy,W,W,W,Cy,LB,W,Cy],[_,Cy,W,W,W,W,W,W,Cy,_],
                    [_,_,Cy,W,W,W,Cy,Cy,_,_],[_,_,_,Cy,W,Cy,_,_,_,_],[_,_,Cy,W,W,W,Cy,_,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],
                    [_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            rainbow: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,G,LG,G,G,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // stem
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,G,LG,G,G,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // bud
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,G,Pk,G,G,_,_,_],[_,_,_,G,Pk,Pk,G,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // rose
                    [_,_,_,R,R,R,R,_,_,_],[_,_,R,Pk,R,R,Pk,R,_,_],[_,R,Pk,R,R,R,R,Pk,R,_],[_,R,R,R,Pk,Pk,R,R,R,_],
                    [_,_,R,R,R,R,R,R,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // rainbow bloom
                    [_,_,R,O,Y,G,B,P,_,_],[_,R,O,Y,G,B,P,Pk,R,_],[R,O,Y,G,W,W,B,P,Pk,R],[R,O,Y,W,W,W,W,P,Pk,R],
                    [_,R,O,Y,G,B,P,Pk,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ]
        };

        const stages = plants[seedType];
        if (!stages) return '';
        const grid = stages[Math.min(stageIdx, stages.length - 1)];
        if (!grid) return '';
        return this._gridToSvg(grid, size || 48);
    }
};

// =====================================================================
// SOUND EFFECTS (Web Audio API)
// =====================================================================
const SoundFX = {
    audioContext: null,

    // Initialize audio context
    init() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            // Web Audio API not supported
        }
    },

    // Play a sound
    play(type) {
        if (!this.audioContext) this.init();
        if (!this.audioContext) return;
        if (this.audioContext.state === 'suspended') this.audioContext.resume();

        const state = Gamification.getState();
        if (!state.settings.sounds) return;

        const volume = state.settings.volume / 100;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        gainNode.gain.value = volume * 0.3;

        switch (type) {
            case 'correct':
                oscillator.frequency.value = 523.25; // C5
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
                break;

            case 'incorrect':
                oscillator.frequency.value = 220; // A3
                oscillator.type = 'sawtooth';
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
                break;

            case 'combo':
                oscillator.frequency.value = 659.25; // E5
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.15);
                break;

            case 'levelUp':
                // Play arpeggio
                [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.1 + 0.3);
                    osc.start(this.audioContext.currentTime + i * 0.1);
                    osc.stop(this.audioContext.currentTime + i * 0.1 + 0.3);
                });
                break;

            case 'achievement':
                // Fanfare
                [392, 523.25, 659.25].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'triangle';
                    gain.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime + i * 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.15 + 0.4);
                    osc.start(this.audioContext.currentTime + i * 0.15);
                    osc.stop(this.audioContext.currentTime + i * 0.15 + 0.4);
                });
                break;

            case 'powerUp':
                oscillator.frequency.value = 440;
                oscillator.type = 'square';
                oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.2);
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.25);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.25);
                break;

            case 'purchase':
                // Quick ascending cha-ching
                [523.25, 659.25, 783.99].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = 'sine';
                    gain.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime + i * 0.06);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.06 + 0.15);
                    osc.start(this.audioContext.currentTime + i * 0.06);
                    osc.stop(this.audioContext.currentTime + i * 0.06 + 0.15);
                });
                break;

            case 'petFeed':
                // Gentle chirp
                oscillator.frequency.value = 600;
                oscillator.type = 'sine';
                oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(700, this.audioContext.currentTime + 0.2);
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.25);
                oscillator.start(); oscillator.stop(this.audioContext.currentTime + 0.25);
                break;

            case 'harvest':
                // Satisfying pluck + sparkle
                [392, 523.25, 783.99, 1046.5].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = i < 2 ? 'triangle' : 'sine';
                    gain.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.08 + 0.3);
                    osc.start(this.audioContext.currentTime + i * 0.08);
                    osc.stop(this.audioContext.currentTime + i * 0.08 + 0.3);
                });
                break;

            case 'plant':
                // Soft pop
                oscillator.frequency.value = 300;
                oscillator.type = 'sine';
                oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.05);
                oscillator.frequency.exponentialRampToValueAtTime(350, this.audioContext.currentTime + 0.15);
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                oscillator.start(); oscillator.stop(this.audioContext.currentTime + 0.2);
                break;

            case 'battleHit':
                // Sharp saw wave attack
                oscillator.frequency.value = 200;
                oscillator.type = 'sawtooth';
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.05);
                oscillator.frequency.exponentialRampToValueAtTime(150, this.audioContext.currentTime + 0.15);
                gainNode.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                oscillator.start(); oscillator.stop(this.audioContext.currentTime + 0.15);
                break;

            case 'battleWin':
                // Ascending 4-note victory fanfare
                [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = 'triangle';
                    gain.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime + i * 0.12);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.12 + 0.4);
                    osc.start(this.audioContext.currentTime + i * 0.12);
                    osc.stop(this.audioContext.currentTime + i * 0.12 + 0.4);
                });
                break;

            case 'battleLose':
                // Descending 2-note sad horn
                [392, 293.66].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime + i * 0.25);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.25 + 0.4);
                    osc.start(this.audioContext.currentTime + i * 0.25);
                    osc.stop(this.audioContext.currentTime + i * 0.25 + 0.4);
                });
                break;
        }
    }
};

// =====================================================================
// SHOP SYSTEM
// =====================================================================
const Shop = {
    currentTab: 'food',
    TABS: ['food','seeds','gardenItems','decorations','cosmetics','adoptPet'],
    TAB_LABELS: { food:'Food', seeds:'Seeds', gardenItems:'Garden', decorations:'Decor', cosmetics:'Cosmetics', adoptPet:'Pets' },
    TAB_ICONS: { food:'🍖', seeds:'🌱', gardenItems:'💧', decorations:'⛲', cosmetics:'🎩', adoptPet:'🐾' },

    show() {
        this.render();
        showScreen('shop');
    },

    render() {
        const state = Gamification.getState();
        document.getElementById('shopCoins').innerHTML = '&#x1FA99; ' + (state.coins || 0).toLocaleString();
        this.renderTabs();
        this.renderItems();
    },

    renderTabs() {
        const el = document.getElementById('shopTabs');
        el.innerHTML = this.TABS.map(t =>
            `<button class="shop-tab${this.currentTab === t ? ' active' : ''}" onclick="Shop.switchTab('${t}')">${this.TAB_ICONS[t]} ${this.TAB_LABELS[t]}</button>`
        ).join('') + `<button class="shop-tab${this.currentTab === 'plots' ? ' active' : ''}" onclick="Shop.switchTab('plots')">🟫 Plots</button>`;
    },

    switchTab(tab) {
        this.currentTab = tab;
        this.renderTabs();
        this.renderItems();
    },

    renderItems() {
        const el = document.getElementById('shopItems');
        const state = Gamification.getState();
        const coins = state.coins || 0;

        if (this.currentTab === 'plots') {
            const unlocked = state.garden.unlockedPlots || 3;
            const maxPlots = 9;
            const canBuy = unlocked < maxPlots;
            const price = Gamification.SHOP.plotExpansion.price;
            el.innerHTML = `
                <div class="shop-section">
                    <h3>Garden Plots (${unlocked}/${maxPlots})</h3>
                    <div class="shop-grid">
                        <div class="shop-item${!canBuy ? ' sold-out' : ''}${coins < price ? ' cant-afford' : ''}">
                            <div class="shop-item-icon">🟫</div>
                            <div class="shop-item-name">${canBuy ? 'Unlock Plot' : 'All Unlocked!'}</div>
                            <div class="shop-item-desc">${canBuy ? 'Expand your garden' : 'You have all 9 plots'}</div>
                            ${canBuy ? `<button class="shop-buy-btn" onclick="Shop.buyPlot()" ${coins < price ? 'disabled' : ''}>&#x1FA99; ${price}</button>` : ''}
                        </div>
                    </div>
                </div>`;
            return;
        }

        if (this.currentTab === 'adoptPet') {
            this.renderAdoptTab(el, state, coins);
            return;
        }

        const catalog = Gamification.SHOP[this.currentTab];
        if (!catalog) { el.innerHTML = ''; return; }

        let html = '<div class="shop-grid">';
        for (const [id, item] of Object.entries(catalog)) {
            const price = item.price;
            const owned = this.getOwned(this.currentTab, id, state);
            const canAfford = coins >= price;
            const unlocked = Gamification.isItemUnlocked(this.currentTab, id);
            const reqLevel = (Gamification.LEVEL_REQS[this.currentTab] || {})[id] || 1;
            html += `
                <div class="shop-item${!unlocked ? ' locked-item' : ''}${!canAfford && unlocked ? ' cant-afford' : ''}">
                    <div class="shop-item-icon">${this.currentTab === 'seeds' ? Sprites.plantSprite(id, (item.stages || 4) - 1, item.icon, 36) : item.icon}</div>
                    <div class="shop-item-name">${item.name}</div>
                    ${item.desc ? `<div class="shop-item-desc">${item.desc}</div>` : ''}
                    ${!unlocked ? `<div class="shop-item-lock">Unlocks at Lv. ${reqLevel}</div>` : ''}
                    ${owned !== null && unlocked ? `<div class="shop-item-owned">Owned: ${owned}</div>` : ''}
                    ${unlocked ? `<button class="shop-buy-btn" onclick="Shop.buy('${this.currentTab}','${id}')" ${!canAfford ? 'disabled' : ''}>&#x1FA99; ${price}</button>` : ''}
                </div>`;
        }
        html += '</div>';
        el.innerHTML = html;
    },

    getOwned(tab, id, state) {
        if (tab === 'food') return state.inventory.petFood[id] || 0;
        if (tab === 'seeds') return state.inventory.seeds[id] || 0;
        if (tab === 'gardenItems') return state.inventory.gardenItems[id] || 0;
        if (tab === 'decorations') return state.inventory.decorations.filter(d => d === id).length;
        if (tab === 'cosmetics') return state.inventory.petAccessories.includes(id) ? 'Yes' : null;
        return null;
    },

    buy(tab, id) {
        const catalog = Gamification.SHOP[tab];
        const item = catalog[id];
        if (!item) return;

        if (!Gamification.spendCoins(item.price)) {
            return;
        }

        const state = Gamification.getState();

        if (tab === 'food') {
            state.inventory.petFood[id] = (state.inventory.petFood[id] || 0) + 1;
        } else if (tab === 'seeds') {
            state.inventory.seeds[id] = (state.inventory.seeds[id] || 0) + 1;
        } else if (tab === 'gardenItems') {
            if (id === 'healthPotion' || id === 'shieldCharm' || id === 'powerBerry') {
                state.inventory.battleItems[id] = (state.inventory.battleItems[id] || 0) + 1;
            } else if (id === 'evoStone') {
                // Evolution stone: apply care minutes directly
                state.studyBuddy.careMinutes = (state.studyBuddy.careMinutes || 0) + 60;
                // Re-check evolution
                for (let i = Gamification.BUDDY_STAGES.length - 1; i >= 0; i--) {
                    const req = Gamification.BUDDY_STAGES[i];
                    if (state.studyBuddy.totalXpFed >= req.xpNeeded && (state.studyBuddy.careMinutes || 0) >= req.careNeeded) {
                        if (state.studyBuddy.stage < req.stage) {
                            state.studyBuddy.stage = req.stage;
                            Gamification.showAchievementToast({ icon: Gamification.getSpeciesEmoji(state.studyBuddy.species, req.stage), name: state.studyBuddy.name + ' evolved!', desc: 'Now a ' + Gamification.getSpeciesStageName(state.studyBuddy.species, req.stage), xp: 0 });
                        }
                        break;
                    }
                }
                Gamification.updateBuddyWidget();
            } else {
                state.inventory.gardenItems[id] = (state.inventory.gardenItems[id] || 0) + 1;
                if (id === 'water' && typeof Garden !== 'undefined' && Garden && typeof Garden._dismissWaterPrompt === 'function') {
                    Garden._dismissWaterPrompt();
                }
            }
        } else if (tab === 'decorations') {
            state.inventory.decorations.push(id);
        } else if (tab === 'cosmetics') {
            if (!state.inventory.petAccessories.includes(id)) {
                state.inventory.petAccessories.push(id);
            }
        }

        Gamification.saveState(state);
        SoundFX.play('purchase');
        Gamification.unlockAchievement('window_shopper');
        this.render();
    },

    buyPlot() {
        const state = Gamification.getState();
        if (state.garden.unlockedPlots >= 9) return;
        if (!Gamification.spendCoins(Gamification.SHOP.plotExpansion.price)) return;
        state.garden.unlockedPlots++;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.render();
    },

    renderAdoptTab(el, state, coins) {
        const pets = state.pets || [];
        const ownedSpecies = pets.map(p => p.species);
        const maxPets = 4;
        let html = `<div class="shop-section"><h3>Your Pets (${pets.length}/${maxPets})</h3>`;

        // Show owned pets
        if (pets.length > 0) {
            html += '<div class="pet-roster">';
            pets.forEach((pet, idx) => {
                const sp = Gamification.PET_SPECIES[pet.species] || Gamification.PET_SPECIES.bird;
                const isActive = idx === (state.activePetIdx || 0);
                html += `<div class="pet-roster-item${isActive ? ' active' : ''}" onclick="Shop.switchPet(${idx})">
                    <span class="pet-roster-emoji">${Gamification.getSpeciesEmoji(pet.species, pet.stage)}</span>
                    <span class="pet-roster-name">${pet.name}</span>
                    <span class="pet-roster-info">${sp.name} Lv${pet.stage}</span>
                    ${isActive ? '<span class="pet-roster-active">Active</span>' : ''}
                </div>`;
            });
            html += '</div>';
        }

        // Show adoptable species
        html += '<h3>Adopt New Pet</h3><div class="shop-grid">';
        for (const [id, sp] of Object.entries(Gamification.PET_SPECIES)) {
            const owned = ownedSpecies.includes(id);
            const levelOk = state.level >= sp.unlockLevel;
            const canAfford = coins >= sp.price;
            const full = pets.length >= maxPets;
            const disabled = owned || !levelOk || !canAfford || full;
            html += `<div class="shop-item${!levelOk ? ' locked-item' : ''}${owned ? ' sold-out' : ''}${!canAfford && levelOk && !owned ? ' cant-afford' : ''}">
                <div class="shop-item-icon">${sp.emojis[sp.emojis.length - 1]}</div>
                <div class="shop-item-name">${sp.name}</div>
                <div class="shop-item-desc">Difficulty: ${'★'.repeat(Math.ceil(sp.difficulty * 2))}${'☆'.repeat(4 - Math.ceil(sp.difficulty * 2))}</div>
                <div class="shop-item-desc">${sp.stages.join(' → ')}</div>
                ${!levelOk ? `<div class="shop-item-lock">Unlocks at Lv. ${sp.unlockLevel}</div>` : ''}
                ${owned ? '<div class="shop-item-owned">Owned</div>' : ''}
                ${full && !owned ? '<div class="shop-item-lock">Pet roster full (${maxPets})</div>' : ''}
                ${!disabled ? `<button class="shop-buy-btn" onclick="Shop.adoptPet('${id}')">${sp.price > 0 ? '&#x1FA99; ' + sp.price : 'Free!'}</button>` : ''}
            </div>`;
        }
        html += '</div></div>';
        el.innerHTML = html;
    },

    adoptPet(speciesId) {
        const sp = Gamification.PET_SPECIES[speciesId];
        if (!sp) return;
        const state = Gamification.getState();
        const pets = state.pets || [];
        if (pets.length >= 4) return;
        if (pets.some(p => p.species === speciesId)) return;
        if (state.level < sp.unlockLevel) return;
        if (sp.price > 0 && !Gamification.spendCoins(sp.price)) return;

        const name = prompt('Name your new ' + sp.name + ':') || sp.name;
        const newPet = {
            name: name.slice(0, 20), species: speciesId, stage: 1, totalXpFed: 0,
            mood: 'sleepy', lastFed: null, hunger: 100, happiness: 100,
            lastDecayCheck: Date.now(), careMinutes: 0, lastCareCheck: null,
            studyMinutes: 0, sick: false, lastInteraction: Date.now(),
            accessories: [], totalMealsEaten: 0
        };
        state.pets.push(newPet);
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.render();
    },

    switchPet(idx) {
        const state = Gamification.getState();
        if (idx < 0 || idx >= (state.pets || []).length) return;
        // Save current active pet back
        state.pets[state.activePetIdx || 0] = state.studyBuddy;
        // Switch
        state.activePetIdx = idx;
        state.studyBuddy = state.pets[idx];
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        Gamification.renderXpBar();
        this.render();
    }
};

// =====================================================================
// BATTLE SYSTEM (PVE Story Campaign)
// =====================================================================
const Battle = {
    active: false,
    petHP: 0,
    petMaxHP: 0,
    enemyHP: 0,
    enemyMaxHP: 0,
    currentQuestion: null,
    answered: false,
    shieldActive: false,
    powerBerryLeft: 0,
    comboCount: 0,
    damageTaken: 0,

    CHAPTERS: [
        { name: 'Enchanted Forest', icon: '\u{1F332}', unlockLevel: 1,
          enemies: [
            { name: 'Rat', emoji: '\u{1F400}' }, { name: 'Spider', emoji: '\u{1F577}\uFE0F' },
            { name: 'Snake', emoji: '\u{1F40D}' }, { name: 'Mushroom', emoji: '\u{1F344}' },
            { name: 'Wolf', emoji: '\u{1F43A}' },
            { name: 'Forest Guardian', emoji: '\u{1F333}', boss: true }
          ]},
        { name: 'Crystal Cave', icon: '\u{1F987}', unlockLevel: 5,
          enemies: [
            { name: 'Bat', emoji: '\u{1F987}' }, { name: 'Slime', emoji: '\u{1F7E2}' },
            { name: 'Golem', emoji: '\u{1FAA8}' }, { name: 'Scorpion', emoji: '\u{1F982}' },
            { name: 'Shadow', emoji: '\u{1F47B}' },
            { name: 'Cave Troll', emoji: '\u{1F9CC}', boss: true }
          ]},
        { name: 'Storm Mountain', icon: '\u26F0\uFE0F', unlockLevel: 10,
          enemies: [
            { name: 'Hawk', emoji: '\u{1F985}' }, { name: 'Yeti', emoji: '\u2744\uFE0F' },
            { name: 'Lightning Bug', emoji: '\u26A1' }, { name: 'Rock Worm', emoji: '\u{1FAB1}' },
            { name: 'Ice Wolf', emoji: '\u{1F43A}' },
            { name: 'Storm Giant', emoji: '\u{1F329}\uFE0F', boss: true }
          ]},
        { name: 'Dark Castle', icon: '\u{1F3F0}', unlockLevel: 15,
          enemies: [
            { name: 'Ghost', emoji: '\u{1F47B}' }, { name: 'Knight', emoji: '\u2694\uFE0F' },
            { name: 'Mage', emoji: '\u{1F9D9}' }, { name: 'Archer', emoji: '\u{1F3F9}' },
            { name: 'Gargoyle', emoji: '\u{1F5FF}' },
            { name: 'Dark King', emoji: '\u{1F451}', boss: true }
          ]},
        { name: 'Volcanic Core', icon: '\u{1F30B}', unlockLevel: 20,
          enemies: [
            { name: 'Fire Imp', emoji: '\u{1F525}' }, { name: 'Lava Snake', emoji: '\u{1F40D}' },
            { name: 'Demon', emoji: '\u{1F479}' }, { name: 'Hellhound', emoji: '\u{1F415}' },
            { name: 'Wyvern', emoji: '\u{1F432}' },
            { name: 'Ancient Dragon', emoji: '\u{1F409}', boss: true }
          ]}
    ],

    getEnemyStats(chapterIdx, enemyIdx) {
        const ch = chapterIdx + 1;
        const enemy = this.CHAPTERS[chapterIdx].enemies[enemyIdx];
        const isBoss = enemy.boss || false;
        let hp = 40 + (ch * 25) + (enemyIdx * 8);
        let atk = 8 + (ch * 6) + (enemyIdx * 2);
        let def = 2 + (ch * 3);
        if (isBoss) { hp = Math.round(hp * 2); atk = Math.round(atk * 1.3); def = Math.round(def * 1.5); }
        return { hp, atk, def, name: enemy.name, emoji: enemy.emoji, boss: isBoss };
    },

    getPetStats() {
        const state = Gamification.getState();
        const pet = state.studyBuddy;
        const stage = pet.stage || 1;
        const hunger = Math.min(100, Math.max(0, pet.hunger || 0));
        const happiness = Math.min(100, Math.max(0, pet.happiness || 0));
        const diff = Gamification.getSpeciesDifficulty(pet.species);
        const hp = Math.round(50 + (stage * 30) + (hunger / 5) + (happiness / 5));
        const atk = Math.round(10 + (stage * 8) + (diff * 5));
        const def = Math.round(3 + (stage * 3) + (happiness / 10));
        const emoji = Gamification.getSpeciesEmoji(pet.species, stage);
        const name = pet.name || 'Pet';
        return { hp, atk, def, emoji, name, stage };
    },

    show() {
        this.renderChapterSelect();
        showScreen('battle');
    },

    goHome() {
        this.active = false;
        showScreen('home');
        Home.render();
    },

    renderChapterSelect() {
        const state = Gamification.getState();
        const level = state.level || 1;
        const battleState = state.battle || {};
        const completed = battleState.chaptersCompleted || [];
        document.getElementById('battleTitle').textContent = 'Battle - Story Campaign';
        document.getElementById('battleStars').textContent = '';

        let html = '<div class="chapter-select">';
        this.CHAPTERS.forEach((ch, idx) => {
            const chNum = idx + 1;
            const unlocked = level >= ch.unlockLevel;
            const isCompleted = completed.includes(chNum);
            const isCurrent = chNum === (battleState.currentChapter || 1) && !isCompleted;
            const enemyProgress = (isCurrent && battleState.currentEnemy > 0) ? battleState.currentEnemy : 0;
            const stars = isCompleted ? '\u2605\u2605\u2605' : (enemyProgress > 0 ? '\u2605'.repeat(Math.min(enemyProgress, 3)) + '\u2606'.repeat(3 - Math.min(enemyProgress, 3)) : '\u2606\u2606\u2606');

            html += `<div class="chapter-card${unlocked ? '' : ' locked'}${isCurrent ? ' current' : ''}" ${unlocked ? `onclick="Battle.selectChapter(${idx})"` : ''}>
                <span class="ch-icon">${ch.icon}</span>
                <div class="ch-info">
                    <div class="ch-name">Ch.${chNum}: ${ch.name}</div>
                    <div class="ch-progress">${isCompleted ? 'Completed!' : unlocked ? (enemyProgress > 0 ? `Enemy ${enemyProgress + 1}/6` : 'Ready to begin') : `Requires Lv ${ch.unlockLevel}`}</div>
                    <div class="ch-stars">${stars}</div>
                </div>
                ${unlocked ? '' : '<span class="ch-lock">\u{1F512}</span>'}
            </div>`;
        });
        html += '</div>';
        document.getElementById('battleContent').innerHTML = html;
    },

    selectChapter(chapterIdx) {
        const state = Gamification.getState();
        const battleState = state.battle;
        const chNum = chapterIdx + 1;
        battleState.currentChapter = chNum;
        // If chapter already completed, restart from enemy 0
        if (battleState.chaptersCompleted.includes(chNum)) {
            battleState.currentEnemy = 0;
        }
        Gamification.saveState(state);
        this.startBattle(chapterIdx, battleState.currentEnemy || 0);
    },

    startBattle(chapterIdx, enemyIdx) {
        this.active = true;
        this.answered = false;
        this.shieldActive = false;
        this.powerBerryLeft = 0;
        this.comboCount = 0;
        this.damageTaken = 0;

        const petStats = this.getPetStats();
        const enemyStats = this.getEnemyStats(chapterIdx, enemyIdx);

        this.petHP = petStats.hp;
        this.petMaxHP = petStats.hp;
        this.enemyHP = enemyStats.hp;
        this.enemyMaxHP = enemyStats.hp;
        this._chapterIdx = chapterIdx;
        this._enemyIdx = enemyIdx;
        this._petStats = petStats;
        this._enemyStats = enemyStats;

        const ch = this.CHAPTERS[chapterIdx];
        document.getElementById('battleTitle').textContent = `Ch.${chapterIdx + 1} ${ch.name}`;
        document.getElementById('battleStars').textContent = '';

        this.loadQuestion();
        this.render();
    },

    render() {
        const pet = this._petStats;
        const enemy = this._enemyStats;
        const petHpPct = Math.max(0, (this.petHP / this.petMaxHP) * 100);
        const enemyHpPct = Math.max(0, (this.enemyHP / this.enemyMaxHP) * 100);

        const hpClass = (pct) => pct > 50 ? 'hp-high' : pct > 25 ? 'hp-mid' : 'hp-low';

        const state = Gamification.getState();
        const inv = state.inventory.battleItems || {};

        let qHTML = '';
        if (this.currentQuestion) {
            const q = this.currentQuestion;
            qHTML = `<div class="battle-question">
                <div class="bq-text">${q.text}</div>
                <div class="bq-options">
                    ${q.options.map((opt, i) => `<button class="bq-opt${this.answered ? (i === q.correctAnswer ? ' correct' : (i === this._selectedIdx ? ' wrong' : '')) + ' disabled' : ''}" ${this.answered ? 'disabled' : `onclick="Battle.checkAnswer(${i})"`}>${opt}</button>`).join('')}
                </div>
            </div>`;
        }

        const html = `
            <div class="battle-arena">
                <div class="battle-combatant enemy-side" id="battleEnemy">
                    <span class="combatant-sprite" style="${enemy.boss ? 'font-size:64px' : ''}">${enemy.emoji}</span>
                    <span class="combatant-name">${enemy.name}${enemy.boss ? ' (BOSS)' : ''}</span>
                    <div class="battle-hp">
                        <span>HP</span>
                        <div class="battle-hp-bar"><div class="battle-hp-fill ${hpClass(enemyHpPct)}" style="width:${enemyHpPct}%"></div></div>
                        <span>${Math.max(0, this.enemyHP)}/${this.enemyMaxHP}</span>
                    </div>
                    <div class="battle-stats-row"><span>ATK ${enemy.atk}</span><span>DEF ${enemy.def}</span></div>
                </div>
                <div class="battle-vs">\u2694\uFE0F</div>
                <div class="battle-combatant pet-side" id="battlePet">
                    <span class="combatant-sprite">${pet.emoji}</span>
                    <span class="combatant-name">${pet.name}</span>
                    <span class="combatant-level">Stage ${pet.stage} | ATK ${pet.atk + (this.powerBerryLeft > 0 ? Math.round(pet.atk * 0.5) : 0)} | DEF ${pet.def}</span>
                    <div class="battle-hp">
                        <span>HP</span>
                        <div class="battle-hp-bar"><div class="battle-hp-fill ${hpClass(petHpPct)}" style="width:${petHpPct}%"></div></div>
                        <span>${Math.max(0, this.petHP)}/${this.petMaxHP}</span>
                    </div>
                    ${this.shieldActive ? '<div style="font-size:11px;color:var(--blue);">\u{1F6E1}\uFE0F Shield Active</div>' : ''}
                    ${this.powerBerryLeft > 0 ? `<div style="font-size:11px;color:var(--green);">\u{1FAD0} Power Berry (${this.powerBerryLeft} left)</div>` : ''}
                </div>
            </div>
            ${qHTML}
            <div class="battle-items-bar">
                <button class="battle-item-btn" ${(inv.healthPotion || 0) < 1 || this.answered ? 'disabled' : ''} onclick="Battle.useItem('healthPotion')">
                    \u{1F9C3} Heal <span class="item-count">${inv.healthPotion || 0}</span>
                </button>
                <button class="battle-item-btn" ${(inv.shieldCharm || 0) < 1 || this.shieldActive || this.answered ? 'disabled' : ''} onclick="Battle.useItem('shieldCharm')">
                    \u{1F6E1}\uFE0F Shield <span class="item-count">${inv.shieldCharm || 0}</span>
                </button>
                <button class="battle-item-btn" ${(inv.powerBerry || 0) < 1 || this.powerBerryLeft > 0 || this.answered ? 'disabled' : ''} onclick="Battle.useItem('powerBerry')">
                    \u{1FAD0} Power <span class="item-count">${inv.powerBerry || 0}</span>
                </button>
            </div>
            <div class="battle-log" id="battleLog">${this.comboCount > 1 ? '\u{1F525} Combo x' + this.comboCount + '!' : 'Answer the question to attack!'}</div>`;

        document.getElementById('battleContent').innerHTML = html;
        // Render math in question text
        if (window.renderMathInElement) {
            try { renderMathInElement(document.getElementById('battleContent'), { delimiters: [{ left: '$$', right: '$$', display: true }, { left: '$', right: '$', display: false }, { left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true }] }); } catch {}
        }
    },

    loadQuestion() {
        // Pull random question from current bank
        const bank = BankManager.banks[0];
        if (!bank || !bank.questions || bank.questions.length === 0) return;
        const q = bank.questions[Math.floor(Math.random() * bank.questions.length)];
        this.currentQuestion = q;
        this.answered = false;
        this._selectedIdx = -1;
    },

    checkAnswer(idx) {
        if (this.answered || !this.currentQuestion) return;
        this.answered = true;
        this._selectedIdx = idx;
        const q = this.currentQuestion;
        const isCorrect = idx === q.correctAnswer;

        // Still award XP/coins/care through normal gamification
        Gamification.awardXp(isCorrect ? 10 : 2);
        if (isCorrect) Gamification.awardCoins(5);
        DailyGoal.recordQuestion();
        if (isCorrect) Garden.grow(1);

        // Re-render to show correct/wrong highlighting
        this.render();

        if (isCorrect) {
            this.comboCount++;
            SoundFX.play('correct');
            setTimeout(() => this.petAttack(), 600);
        } else {
            this.comboCount = 0;
            SoundFX.play('incorrect');
            setTimeout(() => this.enemyAttack(), 600);
        }
    },

    petAttack() {
        const pet = this._petStats;
        const enemy = this._enemyStats;
        let dmg = Math.max(1, pet.atk - enemy.def);
        // Combo crit
        if (this.comboCount >= 3) dmg = Math.round(dmg * 1.5);
        // Power berry boost
        if (this.powerBerryLeft > 0) {
            dmg = Math.round(dmg * 1.5);
            this.powerBerryLeft--;
        }

        this.enemyHP -= dmg;
        SoundFX.play('battleHit');

        // Animate enemy shake
        const el = document.getElementById('battleEnemy');
        if (el) { el.classList.add('battle-shake'); setTimeout(() => el.classList.remove('battle-shake'), 400); }
        // Damage popup
        this._showDmgPopup('battleEnemy', `-${dmg}`, false);

        if (this.enemyHP <= 0) {
            this.enemyHP = 0;
            this.render();
            setTimeout(() => this.enemyDefeated(), 500);
        } else {
            this.render();
            // Load next question after brief pause
            setTimeout(() => {
                this.loadQuestion();
                this.render();
            }, 400);
        }
    },

    enemyAttack() {
        if (this.shieldActive) {
            this.shieldActive = false;
            this._showDmgPopup('battlePet', 'BLOCKED!', true);
            SoundFX.play('powerUp');
            setTimeout(() => {
                this.loadQuestion();
                this.render();
            }, 600);
            return;
        }

        const pet = this._petStats;
        const enemy = this._enemyStats;
        const dmg = Math.max(1, enemy.atk - pet.def);
        this.petHP -= dmg;
        this.damageTaken += dmg;
        SoundFX.play('battleHit');

        // Animate pet flash
        const el = document.getElementById('battlePet');
        if (el) { el.classList.add('battle-flash'); setTimeout(() => el.classList.remove('battle-flash'), 500); }
        this._showDmgPopup('battlePet', `-${dmg}`, false);

        if (this.petHP <= 0) {
            this.petHP = 0;
            this.render();
            setTimeout(() => this.petKO(), 500);
        } else {
            this.render();
            setTimeout(() => {
                this.loadQuestion();
                this.render();
            }, 400);
        }
    },

    _showDmgPopup(containerId, text, isHeal) {
        const container = document.getElementById(containerId);
        if (!container) return;
        const popup = document.createElement('div');
        popup.className = 'battle-dmg-popup' + (isHeal ? ' heal' : '');
        popup.textContent = text;
        container.appendChild(popup);
        setTimeout(() => popup.remove(), 800);
    },

    useItem(itemId) {
        if (this.answered) return;
        const state = Gamification.getState();
        const inv = state.inventory.battleItems;
        if (!inv[itemId] || inv[itemId] < 1) return;

        inv[itemId]--;
        Gamification.saveState(state);

        if (itemId === 'healthPotion') {
            this.petHP = Math.min(this.petMaxHP, this.petHP + 40);
            this._showDmgPopup('battlePet', '+40 HP', true);
            SoundFX.play('petFeed');
        } else if (itemId === 'shieldCharm') {
            this.shieldActive = true;
            SoundFX.play('powerUp');
        } else if (itemId === 'powerBerry') {
            this.powerBerryLeft = 3;
            SoundFX.play('powerUp');
        }
        this.render();
    },

    enemyDefeated() {
        const state = Gamification.getState();
        const bs = state.battle;
        const ch = this._chapterIdx;
        const ei = this._enemyIdx;
        const enemy = this._enemyStats;
        const chapterData = this.CHAPTERS[ch];

        // Calculate rewards
        const baseCoins = 10 + ((ch + 1) * 5);
        const coins = enemy.boss ? baseCoins * 3 : baseCoins;
        const xp = enemy.boss ? 100 : 30;

        Gamification.awardCoins(coins);
        Gamification.awardXp(xp);
        bs.totalWins = (bs.totalWins || 0) + 1;

        SoundFX.play('battleWin');

        // Check achievements
        if (bs.totalWins === 1) Gamification.unlockAchievement('first_victory');
        if (this.damageTaken === 0) Gamification.unlockAchievement('flawless');

        const nextEnemy = ei + 1;
        if (nextEnemy >= chapterData.enemies.length) {
            // Chapter complete!
            if (!bs.chaptersCompleted.includes(ch + 1)) {
                bs.chaptersCompleted.push(ch + 1);
            }
            bs.bestChapter = Math.max(bs.bestChapter || 0, ch + 1);
            bs.currentEnemy = 0;
            if (ch + 1 < this.CHAPTERS.length) {
                bs.currentChapter = ch + 2;
            }
            Gamification.unlockAchievement('chapter_clear');
            // Check boss slayer (all 5 completed)
            if (bs.chaptersCompleted.length >= 5) {
                Gamification.unlockAchievement('boss_slayer');
            }
            Gamification.saveState(state);
            this.showResult(true, coins, xp, true);
        } else {
            bs.currentEnemy = nextEnemy;
            Gamification.saveState(state);
            this.showResult(true, coins, xp, false);
        }
    },

    petKO() {
        const state = Gamification.getState();
        state.battle.totalLosses = (state.battle.totalLosses || 0) + 1;
        Gamification.saveState(state);
        SoundFX.play('battleLose');
        this.showResult(false, 0, 0, false);
    },

    showResult(won, coins, xp, chapterDone) {
        const overlay = document.createElement('div');
        overlay.className = 'battle-result-overlay';
        overlay.id = 'battleResultOverlay';

        const enemy = this._enemyStats;
        let body = '';
        if (won) {
            body = `<div class="result-icon">\u{1F389}</div>
                <h2>${chapterDone ? 'Chapter Complete!' : 'Victory!'}</h2>
                <p>${enemy.name} defeated!</p>
                <div class="result-rewards">
                    <div>\u{1FA99} +${coins} Coins</div>
                    <div>\u2B50 +${xp} XP</div>
                    ${this.damageTaken === 0 ? '<div>\u2728 Flawless!</div>' : ''}
                </div>
                <button class="btn-primary" onclick="Battle.dismissResult(true, ${chapterDone})">${chapterDone ? 'Back to Chapters' : 'Next Enemy'}</button>
                <button class="btn-secondary" onclick="Battle.dismissResult(false, false)">Home</button>`;
        } else {
            body = `<div class="result-icon">\u{1F4A5}</div>
                <h2>Defeated!</h2>
                <p>${enemy.name} was too strong...</p>
                <div class="result-rewards" style="color:var(--gray-500)">Your pet recovers with full HP on retry.</div>
                <button class="btn-primary" onclick="Battle.dismissResult(true, false)">Try Again</button>
                <button class="btn-secondary" onclick="Battle.dismissResult(false, false)">Home</button>`;
        }

        overlay.innerHTML = `<div class="battle-result-modal">${body}</div>`;
        overlay.addEventListener('click', (e) => { if (e.target === overlay) Battle.dismissResult(false, false); });
        document.body.appendChild(overlay);
    },

    dismissResult(continuePlay, chapterDone) {
        const el = document.getElementById('battleResultOverlay');
        if (el) el.remove();

        if (!continuePlay) {
            this.goHome();
            return;
        }

        if (chapterDone) {
            this.renderChapterSelect();
        } else {
            const state = Gamification.getState();
            const bs = state.battle;
            this.startBattle(this._chapterIdx, bs.currentEnemy || 0);
        }
    }
};

// =====================================================================
// GARDEN SYSTEM
// =====================================================================
const Garden = {
    _meterPulseTimer: null,
    _waterPromptEl: null,
    show() {
        this.render();
        showScreen('garden');
    },

    render() {
        const state = Gamification.getState();
        if (!state.settings.garden) return;

        // Update header coins
        document.getElementById('gardenCoins').innerHTML = '&#x1FA99; ' + (state.coins || 0).toLocaleString();

        // Water-based scene effects
        const water = state.garden.waterLevel || 0;
        const scene = document.getElementById('gardenScene');
        if (scene) {
            scene.classList.toggle('water-low', water > 0 && water < 25);
            scene.classList.toggle('water-critical', water <= 0);
        }

        this.updateWaterMeter(state);

        // Update watering can count
        const waterCount = document.getElementById('gardenWaterCount');
        if (waterCount) waterCount.textContent = state.inventory.gardenItems.water || 0;
        const skipCount = document.getElementById('gardenSkipCount');
        const skipBtn = document.getElementById('gardenSkipBtn');
        const skips = state.inventory.gardenItems.timeCapsule || 0;
        if (skipCount) skipCount.textContent = skips;
        if (skipBtn) {
            const showSkip = state.settings.timeSkipEnabled;
            skipBtn.style.display = showSkip ? '' : 'none';
            skipBtn.classList.toggle('disabled', skips <= 0);
        }
        if ((state.inventory.gardenItems.water || 0) <= 0) {
            this._promptWaterPurchase();
        } else {
            this._dismissWaterPrompt();
        }

        this.renderGrid(state);
        this.renderDecos(state);
        this.renderPet(state);
        this.renderBowls(state);
    },

    renderGrid(state) {
        const el = document.getElementById('gardenGrid');
        const plots = state.garden.plots || [];
        const unlocked = state.garden.unlockedPlots || 3;
        const outOfWater = (state.inventory.gardenItems.water || 0) <= 0;
        let html = '';

        for (let i = 0; i < 9; i++) {
            if (i >= unlocked) {
                html += `<div class="garden-plot locked" onclick="Shop.show();Shop.switchTab('plots')"><span class="plot-lock">\u{1F512}</span></div>`;
                continue;
            }
            const plot = plots[i];
            if (!plot || !plot.seedType) {
                html += `<div class="garden-plot empty" onclick="Garden.showSeedPickerModal(${i})"><span class="plot-empty-icon">\u{1F573}\u{FE0F}</span></div>`;
            } else {
                const seed = Gamification.SHOP.seeds[plot.seedType];
                if (!seed) { html += `<div class="garden-plot empty"></div>`; continue; }
                const stageIdx = Math.min(plot.currentStage || 0, seed.emojis.length - 1);
                const isReady = plot.currentStage >= seed.stages - 1;
                html += `<div class="garden-plot planted${isReady ? ' harvestable' : ''}" onclick="${isReady ? `Garden.harvest(${i})` : `Garden.showPlotInfoModal(${i})`}">
                    <span class="plot-plant${isReady ? ' glow-bounce' : ''}">${Sprites.plantSprite(plot.seedType, stageIdx, seed.emojis[stageIdx], 40)}</span>
                    ${!isReady ? `<div class="plot-progress-bar"><div class="plot-progress-fill" style="width:${Math.floor(((plot.growthPoints || 0) / seed.gpNeeded) * 100)}%"></div></div>` : '<div class="plot-ready">\u2728 Harvest!</div>'}
                    <div class="plot-label">${seed.name}</div>
                    ${!isReady ? `<button class="plot-water-btn" ${outOfWater ? 'disabled' : ''} onclick="event.stopPropagation();Garden.waterPlot(${i})">\u{1F4A7} Water</button>` : ''}
                    ${plot.fertilized ? '<span class="plot-fertilized" title="Fertilized">\u{1F9EA}</span>' : ''}
                </div>`;
            }
        }

        el.innerHTML = html;
    },

    renderDecos(state) {
        const el = document.getElementById('gardenDecos');
        if (!el) return;
        const decos = state.garden.decorations || [];
        if (decos.length === 0) { el.innerHTML = ''; return; }
        let html = '';
        decos.forEach(d => {
            const item = Gamification.SHOP.decorations[d];
            if (item) html += `<span class="garden-deco" title="${item.name}">${item.icon}</span>`;
        });
        el.innerHTML = html;
    },

    renderPet(state) {
        const el = document.getElementById('gardenPet');
        if (!el) return;
        const buddy = state.studyBuddy;
        const accessories = buddy.accessories || [];
        const moodText = this.getMoodLabel(buddy);
        el.innerHTML = `
            <div class="garden-pet-mood-bubble">${moodText}</div>
            <div class="garden-pet-sprite">
                <span class="garden-pet-emoji">${Sprites.petSprite(buddy.stage, Gamification.getSpeciesEmoji(buddy.species, buddy.stage), 44)}</span>
                ${accessories.map(a => {
                    const item = Gamification.SHOP.cosmetics[a];
                    return item ? `<span class="pet-accessory">${item.icon}</span>` : '';
                }).join('')}
            </div>
            <div class="garden-pet-name">${buddy.name}</div>
        `;
    },

    getMoodLabel(buddy) {
        const h = buddy.hunger ?? 100;
        const hp = buddy.happiness ?? 100;
        if (h > 75 && hp > 75) return 'Happy 😊';
        if (h > 50 && hp > 50) return 'Content 🙂';
        if (h < 25 || hp < 25) return 'Miserable 😢';
        if (h < 50) return 'Hungry 😕';
        return 'Sad 😔';
    },

    dismissModal() {
        const overlay = document.querySelector('.garden-modal-overlay');
        if (overlay) overlay.remove();
    },

    showSeedPickerModal(plotIdx) {
        const state = Gamification.getState();
        const inv = state.inventory.seeds;
        const available = Object.entries(inv).filter(([id, count]) => count > 0 && Gamification.isItemUnlocked('seeds', id));

        if (available.length === 0) {
            alert('No seeds available! Buy some from the Shop or level up to unlock more.');
            return;
        }

        let seedsHtml = '';
        available.forEach(([id, count]) => {
            const seed = Gamification.SHOP.seeds[id];
            seedsHtml += `<div class="seed-option" onclick="Garden.plantSeed(${plotIdx},'${id}')">
                <span class="seed-option-icon">${seed.icon}</span>
                <div class="seed-option-info">
                    <div class="seed-option-name">${seed.name}</div>
                    <div class="seed-option-meta">${seed.gpNeeded} GP \u2022 ${seed.coinReward} coins \u2022 ${seed.xpReward} XP</div>
                </div>
                <span class="seed-option-count">x${count}</span>
            </div>`;
        });

        const overlay = document.createElement('div');
        overlay.className = 'garden-modal-overlay';
        overlay.onclick = e => { if (e.target === overlay) Garden.dismissModal(); };
        overlay.innerHTML = `<div class="garden-modal">
            <button class="garden-modal-close" onclick="Garden.dismissModal()">\u2715</button>
            <h3>\u{1F331} Pick a Seed</h3>
            ${seedsHtml}
        </div>`;
        document.body.appendChild(overlay);
    },

    plantSeed(plotIdx, seedId) {
        this.dismissModal();
        const state = Gamification.getState();
        state.inventory.seeds[seedId]--;

        while (state.garden.plots.length <= plotIdx) state.garden.plots.push(null);
        state.garden.plots[plotIdx] = {
            seedType: seedId,
            currentStage: 0,
            growthPoints: 0,
            plantedAt: Date.now(),
            fertilized: false,
            fertilizedRemaining: 0
        };

        Gamification.saveState(state);
        SoundFX.play('plant');

        const filledPlots = state.garden.plots.filter(p => p && p.seedType).length;
        if (filledPlots >= 9) Gamification.unlockAchievement('garden_paradise');

        this.render();
    },

    showPlotInfoModal(plotIdx) {
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot) return;
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (!seed) return;

        const gp = plot.growthPoints || 0;
        const needed = seed.gpNeeded;
        const stage = (plot.currentStage || 0) + 1;
        const pct = Math.floor((gp / needed) * 100);
        const inv = state.inventory.gardenItems;
        const hasFert = inv.fertilizer > 0 && !plot.fertilized;
        const hasDust = inv.magicDust > 0 && plot.currentStage < seed.stages - 1;

        const overlay = document.createElement('div');
        overlay.className = 'garden-modal-overlay';
        overlay.onclick = e => { if (e.target === overlay) Garden.dismissModal(); };
        overlay.innerHTML = `<div class="garden-modal">
            <button class="garden-modal-close" onclick="Garden.dismissModal()">\u2715</button>
            <div class="plot-info-header">
                <div class="plot-info-emoji">${Sprites.plantSprite(plot.seedType, Math.min(plot.currentStage || 0, seed.emojis.length - 1), seed.emojis[Math.min(plot.currentStage || 0, seed.emojis.length - 1)], 48)}</div>
                <div class="plot-info-name">${seed.name}</div>
            </div>
            <div class="plot-info-stats">
                <div class="plot-info-stat"><span>Stage</span><span>${stage} / ${seed.stages}</span></div>
                <div class="plot-info-stat"><span>Growth</span><span>${gp} / ${needed} GP</span></div>
                ${plot.fertilized ? `<div class="plot-info-stat"><span>\u{1F9EA} Fertilized</span><span>${plot.fertilizedRemaining} Q left</span></div>` : ''}
                <div class="plot-info-stat"><span>Reward</span><span>${seed.coinReward} coins + ${seed.xpReward} XP</span></div>
            </div>
            <div class="plot-info-progress"><div class="plot-info-progress-fill" style="width:${pct}%"></div></div>
            <div class="plot-info-actions">
                <button class="plot-info-action" onclick="Garden.applyFertilizer(${plotIdx})" ${hasFert ? '' : 'disabled'}>
                    <span class="plot-info-action-icon">\u{1F9EA}</span>
                    <div><div class="plot-info-action-label">Fertilizer${hasFert ? ` (x${inv.fertilizer})` : ''}</div><div class="plot-info-action-desc">2x growth for next 10 questions</div></div>
                </button>
                <button class="plot-info-action" onclick="Garden.applyMagicDust(${plotIdx})" ${hasDust ? '' : 'disabled'}>
                    <span class="plot-info-action-icon">\u2728</span>
                    <div><div class="plot-info-action-label">Magic Dust${hasDust ? ` (x${inv.magicDust})` : ''}</div><div class="plot-info-action-desc">Instantly advance +1 stage</div></div>
                </button>
            </div>
        </div>`;
        document.body.appendChild(overlay);
    },

    applyFertilizer(plotIdx) {
        this.dismissModal();
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot || plot.fertilized || state.inventory.gardenItems.fertilizer <= 0) return;
        state.inventory.gardenItems.fertilizer--;
        plot.fertilized = true;
        plot.fertilizedRemaining = 10;
        Gamification.saveState(state);
        this.render();
    },

    applyMagicDust(plotIdx) {
        this.dismissModal();
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot) return;
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (!seed || state.inventory.gardenItems.magicDust <= 0 || plot.currentStage >= seed.stages - 1) return;
        state.inventory.gardenItems.magicDust--;
        plot.currentStage++;
        Gamification.saveState(state);
        this.render();
    },

    harvest(plotIdx) {
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot) return;
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (!seed) return;

        // Award coins and XP
        Gamification.awardCoins(seed.coinReward, 'harvest');
        Gamification.awardXp('correctAnswer', { multiplier: seed.xpReward / 25 });

        // Pet happiness boost from harvest
        state.studyBuddy.hunger = Math.min(100, (state.studyBuddy.hunger || 0) + 10);
        state.studyBuddy.happiness = Math.min(100, (state.studyBuddy.happiness || 0) + 10);

        state.garden.totalHarvests = (state.garden.totalHarvests || 0) + 1;

        // Clear the plot
        state.garden.plots[plotIdx] = null;
        Gamification.saveState(state);

        SoundFX.play('harvest');
        Gamification.triggerConfetti();

        // Check achievements
        if (state.garden.totalHarvests === 1) Gamification.unlockAchievement('green_thumb');
        if (state.garden.totalHarvests >= 10) Gamification.unlockAchievement('master_gardener');
        if (plot.seedType === 'rainbow') Gamification.unlockAchievement('rainbow_bloom');

        this.render();
    },

    // Called when user answers correctly — grows all plants
    grow(points) {
        const state = Gamification.getState();
        if (!state.settings.garden) return;
        if ((state.garden.waterLevel || 0) <= 0) return; // No water = no growth

        // Check for fountain decoration (auto-water)
        const hasFountain = (state.garden.decorations || []).includes('fountain');
        if (hasFountain) {
            state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 5);
        }

        // Decay water slightly per question
        state.garden.waterLevel = Math.max(0, (state.garden.waterLevel || 100) - 1);

        const plots = state.garden.plots || [];
        const now = Date.now();
        for (let i = 0; i < plots.length; i++) {
            const plot = plots[i];
            if (!plot || !plot.seedType) continue;
            const seed = Gamification.SHOP.seeds[plot.seedType];
            if (!seed) continue;
            if ((plot.currentStage || 0) >= seed.stages - 1) continue; // Already ready

            let gp = points;
            if (plot.fertilized && plot.fertilizedRemaining > 0) {
                gp *= 2;
                plot.fertilizedRemaining--;
                if (plot.fertilizedRemaining <= 0) plot.fertilized = false;
            }

            plot.growthPoints = (plot.growthPoints || 0) + gp;

            // Check for stage advancement
            const gpPerStage = seed.gpNeeded / Math.max(1, (seed.stages - 1));
            const newStage = Math.min(seed.stages - 1, Math.floor(plot.growthPoints / gpPerStage));
            if (newStage > (plot.currentStage || 0)) {
                plot.currentStage = newStage;
            }
        }

        state.garden.lastGrowthTick = now;
        Gamification.saveState(state);
    },

    // Use watering can from inventory
    useWater() {
        const state = Gamification.getState();
        if ((state.inventory.gardenItems.water || 0) <= 0) {
            this._promptWaterPurchase();
            return;
        }
        state.inventory.gardenItems.water--;
        state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 30);
        Gamification.saveState(state);
        this.render();
        this.flashWaterMeter();
        this._dismissWaterPrompt();
    },

    waterPlot(plotIdx) {
        const state = Gamification.getState();
        const plot = state.garden.plots?.[plotIdx];
        if (!plot || !plot.seedType) return;
        if ((state.inventory.gardenItems.water || 0) <= 0) {
            this._promptWaterPurchase();
            return;
        }
        state.inventory.gardenItems.water--;
        state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 15);
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (seed) {
            const bonus = Math.max(2, Math.ceil(seed.gpNeeded * 0.12));
            plot.growthPoints = (plot.growthPoints || 0) + bonus;
            const gpPerStage = seed.gpNeeded / (seed.stages - 1);
            const newStage = Math.min(seed.stages - 1, Math.floor(plot.growthPoints / gpPerStage));
            if (newStage > (plot.currentStage || 0)) {
                plot.currentStage = newStage;
            }
        }
        state.garden.lastGrowthTick = Date.now();
        Gamification.saveState(state);
        this.render();
        this.flashWaterMeter();
        this._dismissWaterPrompt();
    },

    // Decay water over time (called on init and periodically)
    decayWater() {
        const state = Gamification.getState();
        const now = Date.now();
        const last = state.garden.lastWaterDecay || now;
        const hoursPassed = (now - last) / (1000 * 60 * 60);

        if (hoursPassed >= 1) {
            const decay = Math.floor(hoursPassed * 3.5);
            state.garden.waterLevel = Math.max(0, (state.garden.waterLevel || 100) - decay);
            state.garden.lastWaterDecay = now;

            // Check for plant stage loss if water at 0 for >48h
            if (state.garden.waterLevel <= 0 && hoursPassed >= 48) {
                const plots = state.garden.plots || [];
                plots.forEach(plot => {
                    if (plot && plot.currentStage > 0) {
                        plot.currentStage--;
                        plot.growthPoints = Math.max(0, (plot.growthPoints || 0) - 5);
                    }
                });
            }

            Gamification.saveState(state);
        }
    },

    idleGrow() {
        const state = Gamification.getState();
        if (!state.settings.garden) return;
        const now = Date.now();
        const last = state.garden.lastGrowthTick || now;
        const hoursPassed = (now - last) / (1000 * 60 * 60);
        if (hoursPassed < 1 / 60) return; // run roughly once per minute of elapsed time

        state.garden.lastGrowthTick = now;

        if ((state.garden.waterLevel || 0) <= 0) {
            Gamification.saveState(state);
            return;
        }

        const isTesting = typeof App !== 'undefined' && App && App.mode === 'test';
        const growthRatePerHour = isTesting ? 2.8 : 1.8; // GP-equivalent per hour
        const gpBonus = hoursPassed * growthRatePerHour;
        if (gpBonus <= 0) {
            Gamification.saveState(state);
            return;
        }

        let changed = false;
        const plots = state.garden.plots || [];
        plots.forEach(plot => {
            if (!plot || !plot.seedType) return;
            const seed = Gamification.SHOP.seeds[plot.seedType];
            if (!seed) return;
            if ((plot.currentStage || 0) >= seed.stages - 1) return;

            let gp = gpBonus;
            if (plot.fertilized && plot.fertilizedRemaining > 0) {
                gp *= 2;
                const fertDrain = Math.max(1, Math.round(gpBonus));
                plot.fertilizedRemaining = Math.max(0, (plot.fertilizedRemaining || 0) - fertDrain);
                if (plot.fertilizedRemaining === 0) plot.fertilized = false;
            }

            plot.growthPoints = (plot.growthPoints || 0) + gp;
            const gpPerStage = seed.gpNeeded / (seed.stages - 1);
            const newStage = Math.min(seed.stages - 1, Math.floor(plot.growthPoints / gpPerStage));
            if (newStage > (plot.currentStage || 0)) {
                plot.currentStage = newStage;
            }
            changed = true;
        });
        Gamification.saveState(state);
        if (changed) this.render();
    },

    decayPetStats() {
        const state = Gamification.getState();
        const now = Date.now();
        const timeScale = Math.max(1, Gamification.PET_DECAY_TIMESCALE || 1);
        const diffConfig = this.getDifficultyConfig(state);
        const pets = state.pets || [state.studyBuddy];
        const petCount = pets.length;
        const care = state.petCare || { foodBowl: 0, waterBowl: 0, maxFood: 400, maxWater: 500 };

        let anyChanged = false;
        const lastActiveTs = state.stats?.lastActiveTimestamp || now;
        pets.forEach(pet => {
            const baseline = pet.lastDecayCheck ?? lastActiveTs;
            const rawHours = (now - baseline) / (1000 * 60 * 60);
            const scaledHours = rawHours * timeScale;

            if (scaledHours < 0.01) {
                pet.lastDecayCheck = now;
                return; // ~1 min minimum
            }

            const diff = Gamification.getSpeciesDifficulty(pet.species);
            const crowdPenalty = 1 + (petCount - 1) * 0.15;
            const stageMultiplier = 1 + Math.max(0, (pet.stage || 1) - 1) * 0.25;
            const decayRate = diff * crowdPenalty * stageMultiplier;

            const hungerDecay = scaledHours * 12 * decayRate * diffConfig.hungerDecay;
            const happyDecay = scaledHours * 8 * decayRate * diffConfig.happinessDecay;

            pet.hunger = Math.max(0, (pet.hunger ?? 100) - hungerDecay);
            pet.happiness = Math.max(0, (pet.happiness ?? 100) - happyDecay);

            if (state.settings.petBowlsEnabled && care.foodBowl > 0 && (pet.hunger ?? 0) < 100) {
                const needed = 100 - (pet.hunger ?? 0);
                const caloriesNeeded = needed * diffConfig.caloriesPerPoint;
                const consumed = Math.min(caloriesNeeded, care.foodBowl);
                care.foodBowl -= consumed;
                pet.hunger = Math.min(100, (pet.hunger ?? 0) + consumed / diffConfig.caloriesPerPoint);
            }
            if (state.settings.petBowlsEnabled && care.waterBowl > 0 && (pet.happiness ?? 0) < 100) {
                const neededHappy = 100 - (pet.happiness ?? 0);
                const waterNeeded = neededHappy * diffConfig.waterPerPoint;
                const consumedWater = Math.min(waterNeeded, care.waterBowl);
                care.waterBowl -= consumedWater;
                pet.happiness = Math.min(100, (pet.happiness ?? 0) + consumedWater / diffConfig.waterPerPoint);
            }

            // Passive care minutes (1 per real hour)
            const passiveCare = Math.min(scaledHours * 1.25, 30);
            pet.careMinutes = (pet.careMinutes || 0) + passiveCare;

            // Sickness at both below 15
            if (pet.hunger < 15 && pet.happiness < 15) pet.sick = true;
            if (pet.sick) {
                pet.hunger = Math.max(0, pet.hunger - scaledHours * 4 * decayRate);
                pet.happiness = Math.max(0, pet.happiness - scaledHours * 4 * decayRate);
            }

            pet.lastDecayCheck = now;
            anyChanged = true;
        });

        // Bonuses (active pet only)
        const buddy = state.studyBuddy;
        const bLast = buddy.lastDecayCheck || now;
        const bRaw = (now - bLast) / (1000 * 60 * 60);
        const bH = bRaw * timeScale;
        const growingCount = (state.garden.plots || []).filter(p => p && p.seedType).length;
        if (growingCount >= 3 && bH > 0) {
            buddy.happiness = Math.min(100, (buddy.happiness ?? 0) + bH * 5);
        }
        if ((buddy.happiness ?? 0) > 75 && bH > 0) {
            state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + bH * 3.5);
        }

        if (anyChanged) {
            Gamification.saveState(state);
            Gamification.updateBuddyWidget();
        }
    }
    ,

    updateWaterMeter(state) {
        const meter = document.getElementById('gardenWaterMeter');
        if (!meter) return;
        const fill = meter.querySelector('.water-meter-fill');
        const text = meter.querySelector('.water-meter-text');
        const level = Math.max(0, Math.min(100, Math.round(state.garden.waterLevel || 0)));
        if (fill) fill.style.width = level + '%';
        let status = 'Hydrated';
        let statusClass = '';
        if (level <= 10) {
            status = 'Critical';
            statusClass = 'critical';
        } else if (level <= 30) {
            status = 'Low';
            statusClass = 'low';
        }
        meter.classList.toggle('pulse', statusClass !== '');
        if (text) {
            text.textContent = level + '% ' + status;
            text.classList.remove('low', 'critical');
            if (statusClass) text.classList.add(statusClass);
        }
    },

    flashWaterMeter() {
        const meter = document.getElementById('gardenWaterMeter');
        if (!meter) return;
        meter.classList.add('pulse');
        if (this._meterPulseTimer) clearTimeout(this._meterPulseTimer);
        this._meterPulseTimer = setTimeout(() => meter.classList.remove('pulse'), 600);
    },

    _promptWaterPurchase() {
        if (this._waterPromptEl) return;
        const prompt = document.createElement('div');
        prompt.className = 'garden-water-prompt';
        prompt.innerHTML = `
            <p>Out of water! Restock watering cans to keep plants growing.</p>
            <div class="garden-water-prompt-actions">
                <button class="prompt-primary">Go to Shop</button>
                <button class="prompt-secondary">Not now</button>
            </div>`;
        const [primary, secondary] = prompt.querySelectorAll('button');
        if (primary) primary.onclick = () => this._gotoWaterShop();
        if (secondary) secondary.onclick = () => this._dismissWaterPrompt();
        document.body.appendChild(prompt);
        this._waterPromptEl = prompt;
    },

    _dismissWaterPrompt() {
        if (this._waterPromptEl) {
            this._waterPromptEl.remove();
            this._waterPromptEl = null;
        }
    },

    _gotoWaterShop() {
        this._dismissWaterPrompt();
        if (typeof Shop !== 'undefined' && Shop) {
            Shop.show();
            Shop.switchTab('gardenItems');
        }
    }
};

// =====================================================================
// PET MODAL
// =====================================================================
const PetModal = {
    show() {
        const state = Gamification.getState();
        const buddy = state.studyBuddy;
        const stage = Gamification.BUDDY_STAGES.find(s => s.stage === buddy.stage) || Gamification.BUDDY_STAGES[0];
        const nextStage = Gamification.BUDDY_STAGES.find(s => s.stage === buddy.stage + 1);

        const hunger = buddy.hunger ?? 100;
        const happiness = buddy.happiness ?? 100;
        const accessories = buddy.accessories || [];

        let progressInfo = '';
        if (nextStage) {
            const currentXp = buddy.totalXpFed - stage.xpNeeded;
            const neededXp = nextStage.xpNeeded - stage.xpNeeded;
            const xpPct = Math.min(100, Math.floor((currentXp / neededXp) * 100));
            const currentCare = (buddy.careMinutes || 0) - (stage.careNeeded || 0);
            const neededCare = (nextStage.careNeeded || 0) - (stage.careNeeded || 0);
            const carePct = neededCare > 0 ? Math.min(100, Math.floor((currentCare / neededCare) * 100)) : 100;
            progressInfo = `<div class="pet-meter"><span>XP Progress</span><div class="pet-meter-bar"><div class="pet-meter-fill evolution" style="width:${xpPct}%"></div></div><span>${xpPct}%</span></div>`;
            progressInfo += `<div class="pet-meter"><span>Care Time</span><div class="pet-meter-bar"><div class="pet-meter-fill care" style="width:${carePct}%"></div></div><span>${carePct}%</span></div>`;

            // Evolution timer estimate
            const remainXp = Math.max(0, neededXp - currentXp);
            const remainCare = Math.max(0, neededCare - currentCare);
            // ~25 avg XP per question (correctAnswer), 3 care min per question
            const questionsForXp = Math.ceil(remainXp / 25);
            const questionsForCare = Math.ceil(remainCare / 3);
            const questionsNeeded = Math.max(questionsForXp, questionsForCare);
            // ~2 min per question average
            const minutesNeeded = questionsNeeded * 2;
            const evoHours = Math.floor(minutesNeeded / 60);
            const evoMins = minutesNeeded % 60;
            const timeStr = evoHours > 0 ? `~${evoHours}h ${evoMins}m` : `~${evoMins}m`;
            progressInfo += `<div class="pet-evo-timer">Next evolution: ~${questionsNeeded} questions (${timeStr} of study)</div>`;
        } else {
            progressInfo = '<div class="pet-meter"><span>Max Evolution!</span></div>';
        }

        const sickBanner = buddy.sick ? '<div class="pet-sick-banner">Your pet is sick! Feed and study to heal.</div>' : '';

        // Food inventory
        const inv = state.inventory.petFood;
        let foodHtml = '<div class="pet-food-grid">';
        for (const [id, item] of Object.entries(Gamification.SHOP.food)) {
            const count = inv[id] || 0;
            foodHtml += `<button class="pet-food-btn" onclick="PetModal.feed('${id}')" ${count <= 0 ? 'disabled' : ''} title="+${item.hunger} hunger, +${item.happiness} happy, +${item.careBonus || 0} growth">${item.icon} ${item.name} <span class="pet-food-count">x${count}</span>${item.careBonus ? '<span class="food-growth">+' + item.careBonus + ' growth</span>' : ''}</button>`;
        }
        foodHtml += '</div>';

        // Accessories
        let accessoryHtml = '<div class="pet-accessory-grid">';
        const owned = state.inventory.petAccessories || [];
        for (const id of owned) {
            const item = Gamification.SHOP.cosmetics[id];
            if (!item) continue;
            const equipped = accessories.includes(id);
            accessoryHtml += `<button class="pet-accessory-btn${equipped ? ' equipped' : ''}" onclick="PetModal.toggleAccessory('${id}')">${item.icon}${equipped ? ' ✓' : ''}</button>`;
        }
        if (owned.length === 0) accessoryHtml += '<span style="color:var(--gray-500);font-size:12px">Buy accessories in the Shop!</span>';
        accessoryHtml += '</div>';

        // Pet selector (if multiple pets)
        const pets = state.pets || [];
        let petSelectorHtml = '';
        if (pets.length > 1) {
            petSelectorHtml = '<div class="pet-selector">';
            pets.forEach((p, i) => {
                const isActive = i === (state.activePetIdx || 0);
                const sp = Gamification.PET_SPECIES[p.species] || Gamification.PET_SPECIES.bird;
                const statusIcon = p.sick ? '\ud83e\udd12' : ((p.hunger ?? 100) < 30 ? '\u26a0\ufe0f' : '');
                petSelectorHtml += `<button class="pet-sel-btn${isActive ? ' active' : ''}" onclick="PetModal.switchAndShow(${i})" title="${p.name}">${Gamification.getSpeciesEmoji(p.species, p.stage)} ${statusIcon}</button>`;
            });
            petSelectorHtml += '</div>';
        }

        const spInfo = Gamification.PET_SPECIES[buddy.species] || Gamification.PET_SPECIES.bird;

        const html = `
            <div class="pet-modal-content">
                <button class="pet-modal-close" onclick="PetModal.close()">&times;</button>
                ${petSelectorHtml}
                <div class="pet-modal-sprite">
                    <span class="pet-modal-emoji">${Sprites.petSprite(buddy.stage, Gamification.getSpeciesEmoji(buddy.species, buddy.stage), 64)}</span>
                    ${accessories.map(a => { const it = Gamification.SHOP.cosmetics[a]; return it ? `<span class="pet-modal-acc">${it.icon}</span>` : ''; }).join('')}
                </div>
                <div class="pet-modal-name" onclick="PetModal.rename()">${buddy.name} ✏️</div>
                <div class="pet-modal-stage">${Gamification.getSpeciesStageName(buddy.species, buddy.stage)}${buddy.sick ? ' \ud83e\udd12' : ''} <span style="font-size:11px;color:var(--gray-500)">(${spInfo.name})</span></div>
                ${sickBanner}
                <div class="pet-meters">
                    <div class="pet-meter"><span>Hunger</span><div class="pet-meter-bar"><div class="pet-meter-fill hunger" style="width:${hunger}%"></div></div><span>${Math.round(hunger)}%</span></div>
                    <div class="pet-meter"><span>Happiness</span><div class="pet-meter-bar"><div class="pet-meter-fill happiness" style="width:${happiness}%"></div></div><span>${Math.round(happiness)}%</span></div>
                    ${progressInfo}
                </div>
                <h4>Feed</h4>
                ${foodHtml}
                <h4>Accessories</h4>
                ${accessoryHtml}
                <div class="pet-modal-stats">
                    <span>Meals eaten: ${buddy.totalMealsEaten || 0}</span>
                    <span>Total XP fed: ${buddy.totalXpFed.toLocaleString()}</span>
                    <span>Study time: ${Math.floor((buddy.studyMinutes || 0) / 60)}h ${(buddy.studyMinutes || 0) % 60}m</span>
                    <span>Care time: ${Math.floor((buddy.careMinutes || 0) / 60)}h ${(buddy.careMinutes || 0) % 60}m</span>
                </div>
            </div>`;

        let overlay = document.getElementById('petModalOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'petModalOverlay';
            overlay.className = 'modal-overlay';
            overlay.onclick = function(e) { if (e.target === overlay) PetModal.close(); };
            document.body.appendChild(overlay);
        }
        overlay.innerHTML = html;
        overlay.classList.add('active');
    },

    close() {
        const overlay = document.getElementById('petModalOverlay');
        if (overlay) overlay.classList.remove('active');
    },

    switchAndShow(idx) {
        const state = Gamification.getState();
        if (idx < 0 || idx >= (state.pets || []).length) return;
        state.pets[state.activePetIdx || 0] = state.studyBuddy;
        state.activePetIdx = idx;
        state.studyBuddy = state.pets[idx];
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        this.show();
    },

    rename() {
        const state = Gamification.getState();
        const name = prompt('Name your buddy (max 20 chars):', state.studyBuddy.name);
        if (!name || name.trim().length === 0) return;
        state.studyBuddy.name = name.trim().slice(0, 20);
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        this.show(); // Re-render modal
    },

    feed(foodId) {
        const state = Gamification.getState();
        const inv = state.inventory.petFood;
        if ((inv[foodId] || 0) <= 0) return;

        const item = Gamification.SHOP.food[foodId];
        if (!item) return;

        inv[foodId]--;
        const buddy = state.studyBuddy;
        buddy.hunger = Math.min(100, (buddy.hunger ?? 0) + item.hunger);
        buddy.happiness = Math.min(100, (buddy.happiness ?? 0) + item.happiness);
        buddy.totalMealsEaten = (buddy.totalMealsEaten || 0) + 1;
        buddy.lastFed = Date.now();
        buddy.lastInteraction = Date.now();

        // Feeding gives care minutes toward evolution
        if (item.careBonus) {
            buddy.careMinutes = (buddy.careMinutes || 0) + item.careBonus;
            // Check evolution
            for (let i = Gamification.BUDDY_STAGES.length - 1; i >= 0; i--) {
                const req = Gamification.BUDDY_STAGES[i];
                if (buddy.totalXpFed >= req.xpNeeded && (buddy.careMinutes || 0) >= req.careNeeded) {
                    if (buddy.stage < req.stage) {
                        buddy.stage = req.stage;
                        Gamification.showAchievementToast({
                            icon: Gamification.getSpeciesEmoji(buddy.species, req.stage),
                            name: buddy.name + ' evolved!',
                            desc: 'Now a ' + Gamification.getSpeciesStageName(buddy.species, req.stage),
                            xp: 0
                        });
                    }
                    break;
                }
            }
        }

        // Feeding can heal sickness
        if (buddy.sick && buddy.hunger > 30 && buddy.happiness > 30) {
            buddy.sick = false;
        }

        Gamification.updateBuddyMood();
        Gamification.saveState(state);
        SoundFX.play('petFeed');
        Gamification.updateBuddyWidget();

        // Check achievements
        if (state.studyBuddy.totalMealsEaten >= 50) Gamification.unlockAchievement('happy_tummy');
        if (state.studyBuddy.stage >= 5) Gamification.unlockAchievement('best_friends');

        this.show(); // Re-render
    },

    toggleAccessory(id) {
        const state = Gamification.getState();
        const acc = state.studyBuddy.accessories || [];
        const idx = acc.indexOf(id);
        if (idx >= 0) {
            acc.splice(idx, 1);
        } else {
            acc.push(id);
        }
        state.studyBuddy.accessories = acc;
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        this.show();
    }
};

// =====================================================================
// SESSION STATE PERSISTENCE (survives page refresh)
// =====================================================================
const SessionState = {
    STORAGE_KEY: 'wgu_session_state',

    // Save current session state to sessionStorage
    save() {
        try {
            const state = {
                timestamp: Date.now(),
                // App state (test/practice mode)
                app: {
                    screen: this._getCurrentScreen(),
                    mode: App.mode,
                    bankId: App.bank ? App.bank.bankId : null,
                    questionIndices: App._questionIndices || null,
                    currentQ: App.currentQ,
                    answers: App.answers,
                    bookmarked: App.bookmarked,
                    visited: App.visited,
                    practiceChecked: App.practiceChecked,
                    practiceResults: App.practiceResults,
                    timerSeconds: App.timerSeconds,
                    initialTimerSeconds: App.initialTimerSeconds,
                    countdown: App.countdown,
                    timerPaused: App.timerPaused || false,
                    submitted: App.submitted,
                    startTime: App.startTime,
                    answerHistory: App.answerHistory,
                    confidence: App.confidence,
                    eliminatedOptions: App._eliminatedOptions || {}
                },
                // Drill state
                drill: {
                    bankId: Drill.bank ? Drill.bank.bankId : null,
                    sessionCount: Drill.sessionCount,
                    sessionCorrect: Drill.sessionCorrect,
                    showingAnswer: Drill.showingAnswer,
                    selectedOption: Drill.selectedOption,
                    currentQuestionId: Drill.current ? Drill.current.question.id : null,
                    queueIds: (Drill.queue || []).map(item => item.question.id)
                },
                // AI Practice state
                aiPractice: {
                    bankId: AIPractice.bank ? AIPractice.bank.bankId : null,
                    currentQuestion: AIPractice.currentQuestion,
                    selectedOption: AIPractice.selectedOption,
                    isChecked: AIPractice.isChecked,
                    sessionStats: AIPractice.sessionStats,
                    weakCategories: AIPractice.weakCategories,
                    currentCategory: AIPractice.currentCategory,
                    currentDifficulty: AIPractice.currentDifficulty,
                    startingWeakness: AIPractice.startingWeakness
                },
                // Metrics state
                metrics: {
                    questionTimes: Metrics.questionTimes,
                    currentStart: Metrics.currentStart
                }
            };
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            console.error('SessionState.save failed:', e.name, e.message);
        }
    },

    // Get saved session state
    get() {
        try {
            const data = localStorage.getItem(this.STORAGE_KEY);
            if (!data) return null;
            const state = JSON.parse(data);
            // Check if state is too old (e.g., > 4 hours)
            if (Date.now() - state.timestamp > 4 * 60 * 60 * 1000) {
                this.clear();
                return null;
            }
            return state;
        } catch (e) {
            // SessionState.get failed silently
            return null;
        }
    },

    // Check if there's a saved session
    hasSavedSession() {
        const state = this.get();
        if (!state) return false;
        // Must have either app, drill, or ai-practice state with a valid bank
        return (state.app && state.app.bankId && state.app.screen !== 'home') ||
               (state.drill && state.drill.bankId && state.app && state.app.screen === 'drill') ||
               (state.aiPractice && state.aiPractice.bankId && state.app && state.app.screen === 'ai-practice');
    },

    // Clear saved session state
    clear() {
        try {
            localStorage.removeItem(this.STORAGE_KEY);
        } catch (e) {
            // SessionState.clear failed silently
        }
    },

    // Restore App state from saved session
    restoreApp(state) {
        if (!state || !state.app || !state.app.bankId) return false;

        const bank = BankManager.getBank(state.app.bankId);
        if (!bank) return false;

        try {
            Session.start();
            App.bank = bank;
            // Restore shuffled subset if indices were saved
            if (state.app.questionIndices && Array.isArray(state.app.questionIndices)) {
                App.questions = state.app.questionIndices.map(i => bank.questions[i]).filter(Boolean);
                App._questionIndices = state.app.questionIndices;
            } else {
                App.questions = [...bank.questions];
                App._questionIndices = null;
            }
            App.mode = state.app.mode || 'test';
            App.currentQ = state.app.currentQ || 0;
            App.answers = state.app.answers || {};
            App.bookmarked = state.app.bookmarked || {};
            App.visited = state.app.visited || { 0: true };
            App.practiceChecked = state.app.practiceChecked || {};
            App.practiceResults = state.app.practiceResults || {};
            App.timerSeconds = state.app.timerSeconds || 0;
            App.initialTimerSeconds = state.app.initialTimerSeconds || null;
            App.countdown = state.app.countdown !== undefined ? state.app.countdown : true;
            App.submitted = state.app.submitted || false;
            App.startTime = state.app.startTime || Date.now();
            App.answerHistory = state.app.answerHistory || {};
            App.confidence = state.app.confidence || {};
            App._eliminatedOptions = state.app.eliminatedOptions || {};

            // Restore Metrics
            if (state.metrics) {
                Metrics.questionTimes = state.metrics.questionTimes || {};
                Metrics.currentStart = state.metrics.currentStart || 0;
            }

            // Restore UI
            document.getElementById('testNameBar').textContent = bank.title;
            document.getElementById('modeTab').textContent =
                App.mode === 'test' ? 'Test Mode' :
                App.mode === 'practice' ? 'Practice Mode' : 'Review';
            document.getElementById('btnSubmit').style.display = (App.mode === 'test' || App.mode === 'practice') && !App.submitted ? '' : 'none';
            document.getElementById('btnCheck').style.display = App.mode === 'practice' ? '' : 'none';
            document.getElementById('btnTimerAdj').style.display = App.mode === 'test' ? '' : 'none';

            App.buildPalette();
            showScreen('exam', true, true);
            App.renderQuestion();

            // Only restart timer if not submitted
            if (!App.submitted) {
                App.timerPaused = state.app.timerPaused || false;
                App.startTimer();
                // If timer was paused when saved, re-pause it
                if (App.timerPaused) {
                    App.timerPaused = false; // startTimer resets this; toggle will set it
                    App.toggleTimer();
                }
            }

            // Chat context
            Chat.clearHistory();
            document.getElementById('chatFab').classList.add('has-context');

            return true;
        } catch (e) {
            console.error('Session restore failed:', e);
            return false;
        }
    },

    // Restore Drill state from saved session
    restoreDrill(state) {
        if (!state || !state.drill || !state.drill.bankId) return false;

        const bank = BankManager.getBank(state.drill.bankId);
        if (!bank) return false;

        try {
            Session.start();
            Drill.bank = bank;
            Drill.sessionCount = state.drill.sessionCount || 0;
            Drill.sessionCorrect = state.drill.sessionCorrect || 0;
            Drill.showingAnswer = state.drill.showingAnswer || false;
            Drill.selectedOption = state.drill.selectedOption;

            // Rebuild queue from saved question IDs
            const queueIds = state.drill.queueIds || [];
            Drill.queue = queueIds.map(id => {
                const question = bank.questions.find(q => q.id === id);
                if (!question) return null;
                const progress = Drill.getProgress(id);
                return { question, progress, priority: 1 };
            }).filter(item => item !== null);

            // Restore current question if it exists
            if (state.drill.currentQuestionId) {
                const currentQ = bank.questions.find(q => q.id === state.drill.currentQuestionId);
                if (currentQ) {
                    Drill.current = {
                        question: currentQ,
                        progress: Drill.getProgress(state.drill.currentQuestionId),
                        priority: 1
                    };
                }
            }

            showScreen('drill', false, false);
            document.getElementById('chatFab').style.display = '';
            Chat.clearHistory();

            // Re-render current card or show session done
            if (Drill.current) {
                Gamification.startQuestionTimer();
                const dueCount = Drill.queue.length + 1;
                document.getElementById('drillProgress').innerHTML =
                    `<span class="due-count">${dueCount}</span> questions remaining | ${Drill.sessionCount} completed (${Drill.sessionCorrect} correct)`;

                const q = Drill.current.question;
                document.getElementById('drillCard').innerHTML = `
                    <div class="question-text">${escapeHtml(q.text).replace(/\n/g, '<br>')}</div>
                    <ul class="options-list" id="drillOptions">
                        ${q.options.map((opt, i) => `
                            <li class="option-item${Drill.selectedOption === i ? ' selected' : ''}${Drill.showingAnswer && i === q.correctAnswer ? ' correct-answer' : ''}${Drill.showingAnswer && Drill.selectedOption === i && i !== q.correctAnswer ? ' wrong-answer' : ''}" onclick="Drill.selectOption(${i})" id="dropt-${i}">
                                <input type="radio" name="drill" value="${i}"${Drill.selectedOption === i ? ' checked' : ''}>
                                <span class="option-label">${escapeHtml(opt)}</span>
                            </li>
                        `).join('')}
                    </ul>
                    <div class="drill-answer${Drill.showingAnswer ? ' show' : ''}" id="drillAnswer">
                        <div class="correct-label" id="drillResultLabel"${Drill.showingAnswer ? ` style="color:${Drill.selectedOption === q.correctAnswer ? 'var(--green)' : 'var(--red)'}">` + (Drill.selectedOption === q.correctAnswer ? 'Correct!' : (Drill.selectedOption !== null ? 'Incorrect' : 'Not answered')) + '</div>' : '>'}
                        <div class="explanation">${escapeHtml(q.explanation || '')}</div>
                        <div class="drill-buttons">
                            <button class="drill-btn btn-missed" onclick="Drill.rate(1)">Missed it (1)</button>
                            <button class="drill-btn btn-struggled" onclick="Drill.rate(3)">Struggled (3)</button>
                            <button class="drill-btn btn-got-it" onclick="Drill.rate(5)">Got it! (5)</button>
                        </div>
                    </div>
                    <div style="text-align:center;margin-top:16px">
                        <button class="drill-btn btn-show" id="drillShowBtn" onclick="Drill.showAnswer()"${Drill.showingAnswer ? ' style="display:none"' : ''}>Show Answer</button>
                    </div>
                `;

                if (Drill.showingAnswer) {
                    document.getElementById('drillAnswer').classList.add('show');
                }

                // Render inline chart if question has graphData
                if (q.graphData) {
                    const qtEl = document.querySelector('#drillCard .question-text');
                    if (qtEl) InlineChart.renderInElement(qtEl, q.graphData);
                }

                document.getElementById('chatFab').classList.add('has-context');
                Drill.renderMath();
            } else if (Drill.queue.length > 0) {
                Drill.nextCard();
            } else {
                Drill.showSessionDone();
            }

            return true;
        } catch (e) {
            console.error('Drill restore failed:', e);
            return false;
        }
    },

    // Restore AI Practice state from saved session
    restoreAIPractice(state) {
        if (!state || !state.aiPractice || !state.aiPractice.bankId) return false;

        const bank = BankManager.getBank(state.aiPractice.bankId);
        if (!bank) return false;

        try {
            Session.start();
            AIPractice.bank = bank;
            AIPractice.currentQuestion = state.aiPractice.currentQuestion || null;
            AIPractice.selectedOption = state.aiPractice.selectedOption;
            AIPractice.isChecked = state.aiPractice.isChecked || false;
            AIPractice.isGenerating = false;
            AIPractice.sessionStats = state.aiPractice.sessionStats || { total: 0, correct: 0, byCategory: {} };
            AIPractice.weakCategories = state.aiPractice.weakCategories || [];
            AIPractice.currentCategory = state.aiPractice.currentCategory || null;
            AIPractice.currentDifficulty = state.aiPractice.currentDifficulty || 2;
            AIPractice.startingWeakness = state.aiPractice.startingWeakness || {};

            showScreen('ai-practice', false, false);
            document.getElementById('chatFab').style.display = '';
            Chat.clearHistory();
            document.getElementById('chatFab').classList.add('has-context');

            AIPractice.renderProgress();
            if (AIPractice.currentQuestion) {
                AIPractice.renderQuestion();
            } else {
                AIPractice.generateNext();
            }

            return true;
        } catch (e) {
            console.error('AI Practice restore failed:', e);
            return false;
        }
    },

    // Get the current active screen name
    _getCurrentScreen() {
        const activeScreen = document.querySelector('.screen.active');
        if (!activeScreen) return 'home';
        const id = activeScreen.id;
        return id.replace('screen-', '');
    },

    // Auto-resume saved session (no prompt)
    showResumePrompt() {
        return new Promise((resolve) => {
            const state = this.get();
            if (!state) {
                resolve(false);
                return;
            }
            const screen = state.app ? state.app.screen : 'unknown';
            const mode = state.app ? state.app.mode : '';
            resolve(confirm(`Resume your previous ${mode || screen} session?`));
        });
    }
};

// =====================================================================
// SESSION TIMER
// =====================================================================
const Session = {
    startTime: 0,
    stateChangedAt: 0,
    activeMs: 0,
    idleMs: 0,
    currentState: 'idle',
    lastActivityTs: 0,
    idleThresholdMs: 60000,
    isRunning: false,
    monitorReady: false,

    start() {
        if (this.isRunning) this.end();
        this._ensureMonitor();
        const now = Date.now();
        this.startTime = now;
        this.stateChangedAt = now;
        this.activeMs = 0;
        this.idleMs = 0;
        this.currentState = 'active';
        this.lastActivityTs = now;
        this.isRunning = true;
    },

    end() {
        if (!this.isRunning) return;
        const now = Date.now();
        this._accumulateState(now);
        this.isRunning = false;

        const activeMins = Math.round(this.activeMs / 60000);
        const idleMins = Math.round(this.idleMs / 60000);

        if (activeMins > 0 || idleMins > 0) {
            const stats = Store.get('globalStats', DailyGoal.getDefaultStats());
            stats.totalStudyMins = (stats.totalStudyMins || 0) + activeMins;
            stats.totalIdleMins = (stats.totalIdleMins || 0) + idleMins;
            Store.set('globalStats', stats);

            const today = this._getDayKey();
            const studyByDay = Store.get('studyByDay', {});
            const existing = this.normalizeDayEntry(studyByDay[today]);
            studyByDay[today] = {
                active: existing.active + activeMins,
                idle: existing.idle + idleMins
            };
            Store.set('studyByDay', studyByDay);
        }

        this.startTime = 0;
        this.stateChangedAt = 0;
        this.activeMs = 0;
        this.idleMs = 0;
        this.currentState = 'idle';
        this.lastActivityTs = 0;
    },

    markActive() {
        if (!this.isRunning) return;
        this.lastActivityTs = Date.now();
        if (this.currentState === 'idle') {
            this._transition('active');
        }
    },

    markIdle() {
        if (!this.isRunning) return;
        if (this.currentState !== 'idle') {
            this._transition('idle');
        }
    },

    getTodayMins() {
        return this.getTodayBreakdown().active;
    },

    getTodayBreakdown() {
        const studyByDay = Store.get('studyByDay', {});
        return this.normalizeDayEntry(studyByDay[this._getDayKey()]);
    },

    normalizeDayEntry(entry) {
        if (entry === undefined || entry === null) return { active: 0, idle: 0 };
        if (typeof entry === 'number') return { active: entry, idle: 0 };
        return {
            active: Math.max(0, entry.active || 0),
            idle: Math.max(0, entry.idle || 0)
        };
    },

    _transition(nextState) {
        const now = Date.now();
        this._accumulateState(now);
        this.currentState = nextState;
        this.stateChangedAt = now;
        if (nextState === 'idle') {
            Gamification.pauseQuestionTimer({ auto: true });
        } else if (nextState === 'active') {
            Gamification.resumeQuestionTimer();
        }
    },

    _accumulateState(now) {
        if (!this.currentState || !this.stateChangedAt) {
            this.stateChangedAt = now;
            return;
        }
        const delta = Math.max(0, now - this.stateChangedAt);
        if (this.currentState === 'active') {
            this.activeMs += delta;
        } else if (this.currentState === 'idle') {
            this.idleMs += delta;
        }
    },

    _getDayKey(date = new Date()) {
        return date.getFullYear() + '-' + String(date.getMonth() + 1).padStart(2, '0') + '-' + String(date.getDate()).padStart(2, '0');
    },

    _ensureMonitor() {
        if (this.monitorReady) return;
        ActivityMonitor.init();
        this.monitorReady = true;
    }
};

const ActivityMonitor = {
    initialized: false,
    lastMouseMove: 0,
    mouseThrottleMs: 1500,
    idleCheckTimer: null,

    init() {
        if (this.initialized) return;
        const activityHandler = () => Session.markActive();
        ['pointerdown', 'pointerup', 'keydown', 'touchstart', 'wheel'].forEach(evt => {
            document.addEventListener(evt, activityHandler, { passive: true });
        });
        document.addEventListener('mousemove', this._onMouseMove.bind(this), { passive: true });
        window.addEventListener('focus', activityHandler);
        window.addEventListener('blur', () => Session.markIdle());
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                Session.markIdle();
            } else {
                Session.markActive();
            }
        });

        this.idleCheckTimer = setInterval(() => {
            if (!Session.isRunning) return;
            if (document.hidden) {
                Session.markIdle();
                return;
            }
            if (Date.now() - Session.lastActivityTs >= Session.idleThresholdMs) {
                Session.markIdle();
            }
        }, 10000);

        this.initialized = true;
    },

    _onMouseMove() {
        const now = Date.now();
        if (now - this.lastMouseMove < this.mouseThrottleMs) return;
        this.lastMouseMove = now;
        Session.markActive();
    }
};

// =====================================================================
// STREAK & DAILY GOAL SYSTEM
// =====================================================================
const DailyGoal = {
    getTodayStr() { const d = new Date(); return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0'); },
    getDefaultStats() { return { testsCompleted: 0, avgScore: 0, drillStreak: 0, totalStudyMins: 0, totalIdleMins: 0, streak: 0, lastStudyDate: null, dailyGoal: 10, questionsToday: 0, todayDate: null }; },
    getStats() { const defaults = this.getDefaultStats(); const stats = Store.get('globalStats', defaults); return { ...defaults, ...stats }; },
    saveStats(stats) { Store.set('globalStats', stats); },
    checkDateReset(stats) { const today = this.getTodayStr(); if (stats.todayDate !== today) { stats.questionsToday = 0; stats.todayDate = today; } return stats; },
    updateStreak(stats) { const today = this.getTodayStr(); const lastDate = stats.lastStudyDate; if (!lastDate) { stats.streak = 1; } else if (lastDate !== today) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.getFullYear() + '-' + String(yesterday.getMonth() + 1).padStart(2, '0') + '-' + String(yesterday.getDate()).padStart(2, '0'); stats.streak = (lastDate === yesterdayStr) ? stats.streak + 1 : 1; } stats.lastStudyDate = today; return stats; },
    recordQuestion() { return this.recordQuestions(1); },
    recordQuestions(count) {
        let stats = this.getStats();
        stats = this.checkDateReset(stats);
        const wasGoalMet = stats.questionsToday >= stats.dailyGoal;
        stats.questionsToday += count;
        const isGoalMet = stats.questionsToday >= stats.dailyGoal;
        if (!wasGoalMet && isGoalMet) {
            stats = this.updateStreak(stats);
            Gamification.awardXp('dailyGoalReached');
            Gamification.triggerConfetti();
            Gamification.checkStreakAchievements(stats.streak);
            if (stats.streak > 0 && stats.streak % 7 === 0) {
                Gamification.awardXp('weeklyGoalReached');
            }
        }
        this.saveStats(stats);
        this.refreshUI();
        return !wasGoalMet && isGoalMet;
    },
    setGoal(goal) {
        let stats = this.getStats();
        stats.dailyGoal = goal;
        this.saveStats(stats);
        this.refreshUI();
    },
    checkStreakOnLoad() { let stats = this.getStats(); stats = this.checkDateReset(stats); const today = this.getTodayStr(); const lastDate = stats.lastStudyDate; if (lastDate && lastDate !== today) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.getFullYear() + '-' + String(yesterday.getMonth() + 1).padStart(2, '0') + '-' + String(yesterday.getDate()).padStart(2, '0'); if (lastDate !== yesterdayStr) { stats.streak = 0; this.saveStats(stats); } } return stats; },
    renderStreakBanner(statsOverride) {
        const el = document.getElementById('streakBanner');
        if (!el) return;
        const stats = statsOverride ? { ...statsOverride } : this.checkStreakOnLoad();
        const streak = stats.streak || 0;
        const hasStreak = streak > 0;
        el.innerHTML = '<div class="streak-banner ' + (hasStreak ? '' : 'no-streak') + '"><span class="streak-flame">\uD83D\uDD25</span><div class="streak-info"><div class="streak-count">' + streak + ' day' + (streak !== 1 ? 's' : '') + '</div><div class="streak-label">' + (hasStreak ? 'Study Streak' : 'Start your streak today!') + '</div></div></div>';
    },
    renderDailyGoalCard(statsOverride) {
        const el = document.getElementById('dailyGoalCard');
        if (!el) return;
        const stats = statsOverride ? { ...statsOverride } : this.getStats();
        const today = this.getTodayStr();
        let questionsToday = stats.questionsToday || 0;
        if (stats.todayDate !== today) { questionsToday = 0; }
        const goal = stats.dailyGoal || 10;
        const pct = Math.round((Math.min(questionsToday, goal) / goal) * 100);
        const isComplete = questionsToday >= goal;
        el.innerHTML = '<div class="daily-goal-card"><h3>\uD83C\uDFAF Daily Goal</h3><div class="goal-progress"><div class="goal-bar"><div class="goal-bar-fill ' + (isComplete ? 'complete' : '') + '" style="width:' + pct + '%"></div></div><div class="goal-text ' + (isComplete ? 'complete' : '') + '">' + questionsToday + '/' + goal + ' questions</div></div>' + (isComplete ? '<div class="goal-celebration">Goal reached! Great job today!</div>' : '') + '</div>';
    },
    refreshUI() {
        const stats = this.getStats();
        this.renderDailyGoalCard(stats);
        this.renderStreakBanner(stats);
        const select = document.getElementById('settingDailyGoal');
        if (select && String(stats.dailyGoal || 10) !== select.value) {
            select.value = String(stats.dailyGoal || 10);
        }
    }
};

// =====================================================================
// BANK MANAGER
// =====================================================================
const BankManager = {
    banks: [],
    manifest: [
        { id: 'algebra-fxo1', file: 'banks/algebra-fxo1.json', title: 'Applied Algebra - FXO1', fallback: true }
    ],

    async loadAll() {
        for (const entry of this.manifest) {
            let bank = null;
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);
                const resp = await fetch(entry.file, { signal: controller.signal });
                clearTimeout(timeout);
                if (resp.ok) bank = await resp.json();
            } catch {}
            if (!bank && entry.fallback && BANK_DATA) {
                bank = BANK_DATA;
            }
            if (bank) {
                this.banks.push(bank);
            }
        }
        if (this.banks.length === 0 && BANK_DATA) {
            this.banks.push(BANK_DATA);
        }
    },

    getBank(id) {
        return this.banks.find(b => b.bankId === id);
    }
};

// =====================================================================
// SCREEN ROUTER
// =====================================================================
function showScreen(name, showSubheader, showFooter) {
    // End session timer when returning home
    if (name === 'home') {
        Session.end();
    }

    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const el = document.getElementById('screen-' + name);
    if (el) el.classList.add('active');
    document.getElementById('subheader').style.display = showSubheader ? '' : 'none';
    document.getElementById('footerNav').style.display = showFooter ? '' : 'none';

    const chatFab = document.getElementById('chatFab');
    if (name === 'exam' || name === 'drill' || name === 'ai-practice') {
        chatFab.style.display = '';
    } else {
        chatFab.style.display = 'none';
        Chat.close();
    }
}

// =====================================================================
// HOME SCREEN
// =====================================================================
const Home = {
    render() {
        DailyGoal.renderStreakBanner();
        DailyGoal.renderDailyGoalCard();
        this.renderStats();
        this.renderBanks();
    },

    renderStats() {
        const stats = DailyGoal.getStats();
        const drillData = Store.get('drillProgress', {});
        const totalQ = Object.keys(drillData).length;
        const mastered = Object.values(drillData).filter(d => d.ef >= 2.5 && d.reps >= 3).length;
        const masteryPct = totalQ > 0 ? Math.round((mastered / totalQ) * 100) : 0;
        const todayBreakdown = Session.getTodayBreakdown();
        const todayActive = todayBreakdown.active;
        const todayIdle = todayBreakdown.idle;
        const totalActive = stats.totalStudyMins || 0;
        const totalIdle = stats.totalIdleMins || 0;

        document.getElementById('homeStats').innerHTML = `
            <div class="stat-card"><div class="stat-val">${todayActive}m</div><div class="stat-lbl">Today (Active)</div><div class="stat-sub">Idle ${todayIdle}m</div></div>
            <div class="stat-card"><div class="stat-val">${totalActive}m</div><div class="stat-lbl">Lifetime Active</div><div class="stat-sub">Idle ${totalIdle}m</div></div>
            <div class="stat-card"><div class="stat-val">${stats.testsCompleted}</div><div class="stat-lbl">Tests Taken</div></div>
            <div class="stat-card"><div class="stat-val">${Math.round(stats.avgScore || 0)}%</div><div class="stat-lbl">Avg Score</div></div>
            <div class="stat-card"><div class="stat-val">${masteryPct}%</div><div class="stat-lbl">Mastery</div></div>
            <div class="stat-card"><div class="stat-val">${stats.drillStreak}</div><div class="stat-lbl">Drill Streak</div></div>
        `;
    },

    renderBanks() {
        const el = document.getElementById('bankList');
        if (BankManager.banks.length === 0) {
            el.innerHTML = '<p style="text-align:center;color:var(--gray-600);padding:40px">No question banks loaded. Check that banks/ folder exists.</p>';
            return;
        }
        el.innerHTML = BankManager.banks.map(bank => {
            const history = Store.get('testHistory_' + bank.bankId, []);
            const best = history.length > 0 ? Math.max(...history.map(h => h.pct)) : null;
            return `
            <div class="bank-card">
                <h2>${escapeHtml(bank.title)}</h2>
                <div class="bank-desc">${escapeHtml(bank.description || '')}</div>
                <div class="bank-meta">
                    <span>${bank.questions.length} questions</span>
                    <span>Time: ${Math.floor((bank.timeLimit||5400)/60)} min</span>
                    <span>Pass: ${bank.passingScore||70}%</span>
                    ${best !== null ? `<span>Best: <strong>${best}%</strong></span>` : ''}
                </div>
                <div class="mode-buttons">
                    <button class="mode-btn m-test" onclick="App.start('${escapeHtml(bank.bankId)}','test')">
                        <h3>Test Mode</h3><p>Timed, Cengage-style. No feedback until submit.</p>
                    </button>
                    <button class="mode-btn m-practice" onclick="App.start('${escapeHtml(bank.bankId)}','practice')">
                        <h3>Practice Mode</h3><p>Check each answer. See explanations instantly.</p>
                    </button>
                    <button class="mode-btn m-drill" onclick="Drill.start('${escapeHtml(bank.bankId)}')">
                        <h3>Drill Mode</h3><p>Spaced repetition. Focus on weak spots.</p>
                    </button>
                    <button class="mode-btn m-review" onclick="Review.start('${escapeHtml(bank.bankId)}')">
                        <h3>Review Mode</h3><p>Browse all questions with answers.</p>
                    </button>
                    <button class="mode-btn m-ai" onclick="AIPractice.start('${escapeHtml(bank.bankId)}')">
                        <h3>AI Practice</h3><p>AI generates new questions targeting your weak areas.</p>
                    </button>
                </div>
                ${Home.renderWeakAreasBadge(bank)}
            </div>`;
        }).join('');
    },

    renderWeakAreasBadge(bank) {
        const cats = QuestionTracker.getCategoryAccuracy();
        const weakCats = Object.entries(cats)
            .filter(([_, d]) => d.total >= 3 && (d.correct / d.total) < 0.6)
            .sort((a, b) => (a[1].correct / a[1].total) - (b[1].correct / b[1].total))
            .slice(0, 3);
        if (weakCats.length === 0) return '';
        const weakQIds = [];
        for (const q of bank.questions) {
            if (weakCats.some(([cat]) => (q.category || 'General') === cat)) weakQIds.push(q.id);
        }
        if (weakQIds.length === 0) return '';
        const badges = weakCats.map(([cat, d]) => {
            const pct = Math.round((d.correct / d.total) * 100);
            return `<span style="display:inline-block;background:var(--red-light);color:#fff;padding:3px 10px;border-radius:12px;font-size:11px;margin:2px">${escapeHtml(cat)} (${pct}%)</span>`;
        }).join('');
        return `<div style="margin-top:12px;padding:12px;background:#fdf2f2;border:1px solid var(--red-light);border-radius:8px">
            <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px">
                <div><strong style="color:var(--red);font-size:13px">Weak Areas:</strong> ${badges}</div>
                <button class="btn-nav" style="background:var(--red);font-size:12px;padding:6px 14px" onclick="Drill.start('${escapeHtml(bank.bankId)}', [${weakQIds.join(',')}])">Drill Weak Areas</button>
            </div>
        </div>`;
    }
};

// =====================================================================
// MAIN APP (Test & Practice Engine)
// =====================================================================
const App = {
    bank: null,
    questions: [],
    mode: 'test', // 'test' | 'practice' | 'review-after'
    currentQ: 0,
    answers: {},
    bookmarked: {},
    visited: {},
    practiceChecked: {},  // { qIndex: true } for practice mode
    practiceResults: {},  // { qIndex: 'correct'|'incorrect'|'skipped' }
    timerSeconds: 0,
    timerInterval: null,
    timerPaused: false,
    countdown: true,
    submitted: false,
    startTime: 0,
    answerHistory: {},    // { qIndex: [firstAnswer, ...changesArray] }
    confidence: {},       // { qIndex: 1|2|3 } (1=Maybe, 2=Probably, 3=Definitely)
    _recentQuestionLimit: 80,

    // Pending start state for question count picker
    _pendingBankId: null,
    _pendingMode: null,
    _pendingCount: null,

    start(bankId, mode) {
        const bank = BankManager.getBank(bankId);
        if (!bank || !bank.questions || bank.questions.length === 0) return;
        const total = bank.questions.length;

        // If 15 or fewer questions, skip the picker
        if (total <= 15) {
            this._startWithCount(bankId, mode, total);
            return;
        }

        // Show question count picker
        this._pendingBankId = bankId;
        this._pendingMode = mode;
        this._pendingCount = 10; // default selection

        const subtitle = document.getElementById('qCountSubtitle');
        subtitle.textContent = `${bank.title} - ${total} questions available`;
        const title = document.getElementById('qCountTitle');
        title.textContent = mode === 'test' ? 'Test Mode - How many questions?' : 'Practice Mode - How many questions?';

        // Build options - filter out counts larger than total, always include All
        const opts = [10, 20, 30, 50].filter(n => n < total);
        opts.push(total); // "All" option

        const container = document.getElementById('qCountOptions');
        container.innerHTML = opts.map(n => {
            const label = n === total ? 'All' : n;
            const sublabel = n === total ? `${total} questions` : 'Random';
            const sel = n === 10 ? ' selected' : '';
            return `<button class="qcount-opt${sel}" data-count="${n}" onclick="App.selectCount(${n}, this)">
                <div>${label}</div>
                <div class="qcount-label">${sublabel}</div>
            </button>`;
        }).join('');

        document.getElementById('qCountModal').style.display = 'flex';
    },

    selectCount(n, btn) {
        this._pendingCount = n;
        document.querySelectorAll('.qcount-opt').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
    },

    closeCountPicker() {
        document.getElementById('qCountModal').style.display = 'none';
        this._pendingBankId = null;
        this._pendingMode = null;
    },

    confirmStart() {
        document.getElementById('qCountModal').style.display = 'none';
        this._startWithCount(this._pendingBankId, this._pendingMode, this._pendingCount);
    },

    _startWithCount(bankId, mode, count) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;
        this._reviewFilter = null;
        Session.start(); // Start session timer

        // Clear any saved session so we don't restore stale state on reload
        SessionState.clear();

        const indices = this._buildQuestionSelection(this.bank, count);
        this._questionIndices = indices;
        this.questions = indices.map(i => this.bank.questions[i]);
        this._recordRecentQuestions(this.bank.bankId, this.questions.map(q => q.id));

        // Shuffle answer options for each question (keeps correctAnswer mapping)
        this._optionMaps = {};
        this.questions.forEach((q, qi) => {
            const optIndices = q.options.map((_, i) => i);
            for (let i = optIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [optIndices[i], optIndices[j]] = [optIndices[j], optIndices[i]];
            }
            this._optionMaps[qi] = optIndices;
            q._shuffledOptions = optIndices.map(i => q.options[i]);
            q._shuffledCorrect = optIndices.indexOf(q.correctAnswer);
        });

        this.mode = mode;
        this.currentQ = 0;
        this.answers = {};
        this.bookmarked = {};
        this.visited = { 0: true };
        this.practiceChecked = {};
        this.practiceResults = {};
        this.submitted = false;
        this.startTime = Date.now();
        this.answerHistory = {};
        this.confidence = {};
        this._eliminatedOptions = {};

        // Timer setup - scale time proportionally if subset
        if (mode === 'test') {
            this.countdown = true;
            const fullTime = this.bank.timeLimit || 5400;
            const ratio = this.questions.length / this.bank.questions.length;
            this.timerSeconds = Math.round(fullTime * ratio);
            this.initialTimerSeconds = this.timerSeconds;
        } else {
            this.countdown = false;
            this.timerSeconds = 0;
        }

        // Reset metrics and start tracking first question
        Metrics.reset();
        Metrics.startQuestion(0);
        Gamification.startQuestionTimer();

        // UI
        document.getElementById('testNameBar').textContent = this.bank.title;
        document.getElementById('modeTab').textContent = mode === 'test' ? 'Test Mode' : 'Practice Mode';
        document.getElementById('btnSubmit').style.display = (mode === 'test' || mode === 'practice') ? '' : 'none';
        document.getElementById('btnCheck').style.display = mode === 'practice' ? '' : 'none';
        document.getElementById('btnTimerAdj').style.display = mode === 'test' ? '' : 'none';

        this.buildPalette();
        showScreen('exam', true, true);
        this.renderQuestion();
        this.startTimer();

        // Chat context
        Chat.clearHistory();
        document.getElementById('chatFab').classList.add('has-context');
    },

    _buildQuestionSelection(bank, requestedCount) {
        if (!bank || !bank.questions || bank.questions.length === 0) return [];
        const total = bank.questions.length;
        const target = Math.min(requestedCount || total, total);
        const weakCategories = this._getWeakCategories();
        const recents = this._getRecentQuestions(bank.bankId);
        const recentIndex = new Map();
        recents.forEach((id, idx) => recentIndex.set(id, idx));
        const gamifyState = Gamification.getState ? Gamification.getState() : null;
        const confSpacingEnabled = !!(gamifyState && gamifyState.settings && gamifyState.settings.confidenceSpacingEnabled);
        const trackerData = confSpacingEnabled && QuestionTracker.getAll ? QuestionTracker.getAll() : null;
        const now = Date.now();

        const items = bank.questions.map((q, idx) => {
            const category = q.category || 'General';
            const isWeak = weakCategories.has(category);
            let weight = 1;
            if (isWeak) weight += 2;
            const recentPos = recentIndex.get(q.id);
            if (recentPos === undefined) {
                weight += 1.5;
            } else {
                const penalty = Math.max(0.2, 1 - (recentPos / Math.max(recents.length, 1)));
                weight *= penalty;
            }

            if (confSpacingEnabled && trackerData && q.id) {
                const entry = trackerData[q.id];
                if (entry && entry.history && entry.history.length > 0) {
                    const streak = entry.highConfidenceStreak || 0;
                    const last = entry.history[entry.history.length - 1];
                    const lastDate = last?.date || now;
                    const hoursSince = (now - lastDate) / (1000 * 60 * 60);
                    if (streak >= 4 && hoursSince < 96 && last.confidenceLevel === 3 && last.correct) {
                        weight *= 0.15;
                    } else if (streak >= 3 && hoursSince < 72 && last.confidenceLevel === 3 && last.correct) {
                        weight *= 0.25;
                    } else if (streak >= 2 && hoursSince < 48 && last.confidenceLevel === 3 && last.correct) {
                        weight *= 0.4;
                    } else if (streak >= 2 && hoursSince < 72 && last.confidenceLevel === 3 && last.correct) {
                        weight *= 0.6;
                    }
                }
            }

            weight = Math.max(weight, 0.05);
            return { idx, id: q.id, category, weak: isWeak, weight: Math.max(weight, 0.1) };
        });

        if (!items.length) return [];

        const weakPool = items.filter(item => item.weak);
        const desiredWeak = Math.min(weakPool.length, Math.max(1, Math.round(target * 0.3)));

        const selectedItems = [];
        if (desiredWeak > 0) {
            selectedItems.push(...this._weightedSample(weakPool, desiredWeak));
        }

        const selectedIdx = new Set(selectedItems.map(item => item.idx));
        const remainingNeeded = target - selectedItems.length;
        if (remainingNeeded > 0) {
            const remainingPool = items.filter(item => !selectedIdx.has(item.idx));
            selectedItems.push(...this._weightedSample(remainingPool, remainingNeeded));
        }

        if (selectedItems.length < target) {
            const unused = items.filter(item => !selectedIdx.has(item.idx) && !selectedItems.some(sel => sel.idx === item.idx));
            while (selectedItems.length < target && unused.length > 0) {
                const rand = Math.floor(Math.random() * unused.length);
                const [picked] = unused.splice(rand, 1);
                selectedItems.push(picked);
            }
        }

        return selectedItems.slice(0, target).map(item => item.idx);
    },

    _weightedSample(pool, count) {
        if (!pool || pool.length === 0 || count <= 0) return [];
        const working = pool.map(item => ({ ...item }));
        const picks = [];
        while (picks.length < count && working.length > 0) {
            const totalWeight = working.reduce((sum, item) => sum + Math.max(item.weight || 0, 0.0001), 0);
            let r = Math.random() * totalWeight;
            let pickIndex = 0;
            for (; pickIndex < working.length; pickIndex++) {
                r -= Math.max(working[pickIndex].weight || 0, 0.0001);
                if (r <= 0) break;
            }
            if (pickIndex >= working.length) pickIndex = working.length - 1;
            const [picked] = working.splice(pickIndex, 1);
            picks.push(picked);
        }
        return picks;
    },

    _getWeakCategories() {
        const cats = QuestionTracker.getCategoryAccuracy();
        const weak = new Set();
        Object.entries(cats).forEach(([cat, data]) => {
            if (data.total >= 3 && (data.correct / data.total) < 0.6) {
                weak.add(cat);
            }
        });
        return weak;
    },

    _getRecentQuestions(bankId) {
        if (!bankId) return [];
        return Store.get('recentQs_' + bankId, []);
    },

    _recordRecentQuestions(bankId, questionIds) {
        if (!bankId || !Array.isArray(questionIds)) return;
        const prev = this._getRecentQuestions(bankId);
        const merged = questionIds.concat(prev.filter(id => !questionIds.includes(id)));
        Store.set('recentQs_' + bankId, merged.slice(0, this._recentQuestionLimit));
    },

    paletteExpanded: false,

    buildPalette() {
        const pal = document.getElementById('questionPalette');
        pal.innerHTML = '';
        for (let i = 0; i < this.questions.length; i++) {
            const btn = document.createElement('div');
            btn.className = 'q-num';
            btn.textContent = i + 1;
            btn.onclick = () => this.goTo(i);
            btn.id = 'qp-' + i;
            pal.appendChild(btn);
        }
        this.paletteExpanded = false;
        document.getElementById('questionPalette').className = 'question-palette collapsed';
        document.getElementById('paletteLegend').style.display = 'none';
        document.getElementById('paletteExpandBtn').textContent = 'Show All';
    },

    buildMiniPalette() {
        const mini = document.getElementById('paletteMini');
        const cur = this.currentQ;
        const total = this.questions.length;
        let html = '';

        // Show: current + next 5, then ... [70]
        const show = [];
        for (let i = cur; i < Math.min(cur + 6, total); i++) show.push(i);

        // Add last question if not already shown
        const lastIdx = total - 1;
        const showsLast = show.includes(lastIdx);

        for (let i = 0; i < show.length; i++) {
            const idx = show[i];
            const cls = this._getPaletteClass(idx);
            html += `<div class="q-num ${cls}" onclick="App.goTo(${idx})">${idx + 1}</div>`;
        }

        if (!showsLast) {
            html += '<span class="pm-ellipsis">...</span>';
            const cls = this._getPaletteClass(lastIdx);
            html += `<div class="q-num ${cls}" onclick="App.goTo(${lastIdx})">${total}</div>`;
        }

        mini.innerHTML = html;
    },

    _getPaletteClass(i) {
        let cls = '';
        if (this.mode === 'practice' && this.practiceResults[i]) {
            cls = 'p-' + this.practiceResults[i];
        } else if (i === this.currentQ) {
            cls = 'current';
        } else if (this.answers[i] !== undefined) {
            cls = 'answered';
        } else if (this.visited[i]) {
            cls = 'visited';
        }
        if (this.bookmarked[i]) cls += ' flagged';
        return cls;
    },

    togglePalette() {
        this.paletteExpanded = !this.paletteExpanded;
        document.getElementById('questionPalette').className = 'question-palette ' + (this.paletteExpanded ? 'expanded' : 'collapsed');
        document.getElementById('paletteLegend').style.display = this.paletteExpanded ? '' : 'none';
        document.getElementById('paletteExpandBtn').textContent = this.paletteExpanded ? 'Hide' : 'Show All';
    },

    renderQuestion() {
        const q = this.questions[this.currentQ];
        document.getElementById('questionNumber').textContent = `Question ${this.currentQ + 1} of ${this.questions.length}`;
        const qtEl = document.getElementById('questionText');
        qtEl.innerHTML = escapeHtml(q.text).replace(/\n/g, '<br>');
        // Render inline chart/table if provided
        if (q.graphData) InlineChart.renderInElement(qtEl, q.graphData);
        if (q.tableData) InlineTable.renderInElement(qtEl, q.tableData);
        // Render power-up bar
        this.renderPowerups();

        const list = document.getElementById('optionsList');
        list.innerHTML = '';
        const isChecked = this.practiceChecked[this.currentQ];
        const isReview = this.mode === 'review-after';

        const eliminated = (this._eliminatedOptions && this._eliminatedOptions[this.currentQ]) || [];
        const displayOptions = q._shuffledOptions || q.options;
        const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
        displayOptions.forEach((opt, i) => {
            const li = document.createElement('li');
            let cls = 'option-item';
            if (this.answers[this.currentQ] === i) cls += ' selected';

            if (isReview || isChecked) {
                if (i === correctIdx) cls += ' correct-answer';
                if (this.answers[this.currentQ] === i && i !== correctIdx) cls += ' wrong-answer';
            }

            const isEliminated = eliminated.includes(i);
            li.className = cls + (isEliminated ? ' disabled' : '');
            if (isEliminated) { li.style.opacity = '0.3'; li.style.pointerEvents = 'none'; }
            const disabled = this.submitted || isChecked || isReview || isEliminated;
            li.innerHTML = `<input type="radio" name="q${this.currentQ}" value="${i}" ${this.answers[this.currentQ]===i?'checked':''} ${disabled?'disabled':''}>
                <span class="option-label" ${eliminated.includes(i) ? 'style="text-decoration:line-through;opacity:.4"' : ''}>${escapeHtml(opt)}</span>`;
            if (!disabled) {
                li.onclick = () => this.selectOption(i);
            }
            list.appendChild(li);
        });

        // Practice check button
        const btnCheck = document.getElementById('btnCheck');
        if (this.mode === 'practice') {
            btnCheck.style.display = isChecked ? 'none' : '';
            btnCheck.disabled = this.answers[this.currentQ] === undefined;
        } else {
            btnCheck.style.display = 'none';
        }

        // Confidence panel (Practice mode only, after selecting an answer)
        const confPanel = document.getElementById('confidencePanel');
        if (this.mode === 'practice' && this.answers[this.currentQ] !== undefined && !isChecked) {
            confPanel.style.display = 'flex';
            // Update selected state of buttons
            const currentConf = this.confidence[this.currentQ] || 0;
            confPanel.querySelectorAll('.confidence-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            if (currentConf > 0) {
                const confClasses = ['conf-maybe', 'conf-probably', 'conf-definitely'];
                confPanel.querySelector('.' + confClasses[currentConf - 1]).classList.add('selected');
            }
        } else {
            confPanel.style.display = 'none';
        }

        // Explanation panel
        const expPanel = document.getElementById('explanationPanel');
        if ((isChecked || isReview) && q.explanation) {
            const isCorrect = this.answers[this.currentQ] === correctIdx;
            expPanel.className = 'explanation-panel show' + (isCorrect ? '' : ' incorrect');
            expPanel.innerHTML = `<h4>${isCorrect ? 'Correct!' : (this.answers[this.currentQ] !== undefined ? 'Incorrect' : 'Not answered')}</h4><p>${escapeHtml(q.explanation)}</p>`;
        } else {
            expPanel.className = 'explanation-panel';
        }

        // Bookmark button
        const bmBtn = document.getElementById('btnBookmark');
        bmBtn.className = 'btn-bookmark' + (this.bookmarked[this.currentQ] ? ' flagged' : '');
        bmBtn.textContent = this.bookmarked[this.currentQ] ? 'Bookmarked' : 'Bookmark';

        // Nav buttons
        document.getElementById('btnPrev').disabled = this.currentQ === 0;

        // Load note for current question
        Notes.updateQuestionMeta();
        Notes.load();
        Notes.close(); // Close note panel when navigating

        this.updatePalette();
        this.renderMath();
    },

    selectOption(i) {
        if (this.submitted || this.practiceChecked[this.currentQ]) return;
        const qIdx = this.currentQ;
        const prevAnswer = this.answers[qIdx];

        // Track answer history
        if (!this.answerHistory[qIdx]) {
            // First selection for this question
            this.answerHistory[qIdx] = [i];
        } else if (prevAnswer !== undefined && prevAnswer !== i) {
            // Answer changed (not just first selection)
            this.answerHistory[qIdx].push(i);
        }

        this.answers[qIdx] = i;
        this.renderQuestion();
        SessionState.save();
    },

    clearAnswer() {
        if (this.submitted || this.practiceChecked[this.currentQ]) return;
        delete this.answers[this.currentQ];
        this.renderQuestion();
        SessionState.save();
    },

    toggleBookmark() {
        this.bookmarked[this.currentQ] = !this.bookmarked[this.currentQ];
        if (!this.bookmarked[this.currentQ]) delete this.bookmarked[this.currentQ];
        this.renderQuestion();
        SessionState.save();
    },

    checkAnswer() {
        if (this.answers[this.currentQ] === undefined) return;
        if (this.practiceChecked[this.currentQ]) return; // Prevent double-click
        this.practiceChecked[this.currentQ] = true;
        const q = this.questions[this.currentQ];
        const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
        const isCorrect = this.answers[this.currentQ] === correctIdx;
        this.practiceResults[this.currentQ] = isCorrect ? 'correct' : 'incorrect';

        // Gamification hooks
        const timeSpent = Gamification.getQuestionTime();
        if (isCorrect) {
            Gamification.incrementCombo();
            const trackerData = QuestionTracker._getData();
            const isFirstTry = !trackerData[q.id] || trackerData[q.id].attempts === 0;
            const questionMeta = QuestionTracker.getAdaptiveMeta(q.id, q.difficulty);
            const adaptiveMeta = {
                difficulty: questionMeta.difficulty,
                noveltyScore: questionMeta.noveltyScore,
                streakPenalty: questionMeta.streakPenalty,
                confidenceFactor: questionMeta.confidenceFactor
            };
            Gamification.awardXp(isFirstTry ? 'firstTryCorrect' : 'correctAnswer', { withCombo: true, questionMeta: adaptiveMeta });
            SoundFX.play('correct');
        } else {
            Gamification.resetCombo();
            SoundFX.play('incorrect');
        }
        Gamification.checkAchievements(isCorrect, timeSpent);
        Gamification.updateCategoryMastery(q.category || 'General', isCorrect);
        Gamification.startQuestionTimer(); // Start timer for next question
        if (isCorrect) Garden.grow(1);

        DailyGoal.recordQuestion();
        const confidenceLevel = this.confidence[this.currentQ] || null;
        const questionMeta = QuestionTracker.getAdaptiveMeta(q.id, q.difficulty);
        QuestionTracker.recordSingle(q.id, q.category || 'General', isCorrect, timeSpent, { confidenceLevel });
        const adaptiveMeta = {
            difficulty: questionMeta.difficulty,
            noveltyScore: questionMeta.noveltyScore,
            streakPenalty: questionMeta.streakPenalty,
            confidenceFactor: questionMeta.confidenceFactor
        };
        Gamification.awardXp(isCorrect ? (questionMeta.isFirstTry ? 'firstTryCorrect' : 'correctAnswer') : 'drillStruggled', { withCombo: true, questionMeta: adaptiveMeta });
        this.renderQuestion();
        SessionState.save();
    },

    setConfidence(level) {
        // level: 1 = Maybe, 2 = Probably, 3 = Definitely
        if (this.mode !== 'practice' || this.answers[this.currentQ] === undefined) return;
        this.confidence[this.currentQ] = level;
        this.renderQuestion();
        SessionState.save();
    },

    renderPowerups() {
        const bar = document.getElementById('powerupBar');
        if (!bar) return;
        const isReview = this.mode === 'review-after';
        const isChecked = this.practiceChecked[this.currentQ];
        if (isReview || isChecked || !Gamification.isEnabled()) {
            bar.style.display = 'none';
            return;
        }
        const state = Gamification.getState();
        const inv = state.powerUpInventory;
        const pups = Gamification.POWERUPS;
        let html = '';
        for (const [type, pu] of Object.entries(pups)) {
            const count = inv[type] || 0;
            html += `<button class="powerup-btn" onclick="App.usePowerup('${type}')" ${count <= 0 ? 'disabled' : ''} title="${pu.desc}"><span class="pu-icon">${pu.icon}</span>${pu.name}<span class="pu-count">${count}</span></button>`;
        }
        bar.innerHTML = html;
        bar.style.display = html ? 'flex' : 'none';
    },

    usePowerup(type) {
        const q = this.questions[this.currentQ];
        if (!q) return;
        if (type === 'fiftyFifty') {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            const eliminated = Gamification.applyFiftyFifty(correctIdx, q.options.length);
            if (eliminated.length > 0) {
                this._eliminatedOptions = this._eliminatedOptions || {};
                this._eliminatedOptions[this.currentQ] = eliminated;
                this.renderQuestion();
            }
        } else if (type === 'skipQuestion') {
            if (Gamification.usePowerUp('skipQuestion')) {
                this.practiceResults[this.currentQ] = 'skipped';
                Metrics.endQuestion(this.currentQ);
                this.next();
            }
        } else if (type === 'extraTime') {
            if (this.countdown && Gamification.usePowerUp('extraTime')) {
                this.timerSeconds += 120;
                this.initialTimerSeconds = (this.initialTimerSeconds || this.timerSeconds) + 120;
                if (this.timerSeconds >= 300) document.getElementById('timerDisplay').classList.remove('warning');
                this.updateTimerDisplay();
            }
        } else if (type === 'doubleXp') {
            Gamification.applyDoubleXp();
            this.renderPowerups();
        } else if (type === 'showHint') {
            if (q.explanation && Gamification.usePowerUp('showHint')) {
                const hint = q.explanation.substring(0, Math.min(80, q.explanation.indexOf('.') + 1 || 80)) + '...';
                const panel = document.getElementById('explanationPanel');
                panel.innerHTML = `<h4>Hint</h4><p>${escapeHtml(hint)}</p>`;
                panel.classList.add('show');
                this.renderPowerups();
            }
        }
    },

    goTo(idx) {
        // Track time on current question before switching
        Metrics.endQuestion(this.currentQ);
        this.currentQ = idx;
        this.visited[idx] = true;
        // Start tracking time on new question
        Metrics.startQuestion(idx);
        this.renderQuestion();
        document.getElementById('questionContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
        SessionState.save();
    },

    prev() {
        if (this._reviewFilter) {
            const idx = this._reviewFilter.indexOf(this.currentQ);
            if (idx > 0) this.goTo(this._reviewFilter[idx - 1]);
        } else if (this.currentQ > 0) this.goTo(this.currentQ - 1);
    },
    next() {
        if (this._reviewFilter) {
            const idx = this._reviewFilter.indexOf(this.currentQ);
            if (idx < this._reviewFilter.length - 1) this.goTo(this._reviewFilter[idx + 1]);
        } else if (this.currentQ < this.questions.length - 1) this.goTo(this.currentQ + 1);
    },

    updatePalette() {
        // Update full palette
        for (let i = 0; i < this.questions.length; i++) {
            const el = document.getElementById('qp-' + i);
            if (!el) continue;
            el.className = 'q-num ' + this._getPaletteClass(i);
        }
        // Update mini palette
        this.buildMiniPalette();
    },

    // Timer
    startTimer() {
        this.stopTimer();
        this.timerPaused = false;
        document.getElementById('timerDisplay').style.visibility = 'visible';
        document.getElementById('timerDisplay').style.opacity = '1';
        document.getElementById('timerToggle').textContent = 'Pause Timer';
        this.updateTimerDisplay();
        this.timerInterval = setInterval(() => {
            if (this.countdown) {
                this.timerSeconds--;
                if (this.timerSeconds <= 300) {
                    document.getElementById('timerDisplay').classList.add('warning');
                }
                if (this.timerSeconds <= 0) {
                    this.timerSeconds = 0;
                    this.submitTest();
                    return;
                }
            } else {
                this.timerSeconds++;
            }
            this.updateTimerDisplay();
            // Save session state every 10 seconds to preserve timer progress
            if (this.timerSeconds % 10 === 0) {
                SessionState.save();
            }
        }, 1000);
    },

    stopTimer() {
        if (this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = null;
        document.getElementById('timerDisplay').classList.remove('warning');
    },

    updateTimerDisplay() {
        const s = this.timerSeconds;
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;
        document.getElementById('timerDisplay').textContent =
            `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    },

    toggleTimer() {
        if (this.timerInterval) {
            // Pause: stop interval but keep timerSeconds
            clearInterval(this.timerInterval);
            this.timerInterval = null;
            this.timerPaused = true;
            document.getElementById('timerToggle').textContent = 'Resume Timer';
            document.getElementById('timerDisplay').style.opacity = '0.5';
        } else if (this.timerPaused) {
            // Resume: restart interval from where we left off
            this.timerPaused = false;
            document.getElementById('timerToggle').textContent = 'Pause Timer';
            document.getElementById('timerDisplay').style.opacity = '1';
            this.timerInterval = setInterval(() => {
                if (this.countdown) {
                    this.timerSeconds--;
                    if (this.timerSeconds <= 300) {
                        document.getElementById('timerDisplay').classList.add('warning');
                    }
                    if (this.timerSeconds <= 0) {
                        this.timerSeconds = 0;
                        this.submitTest();
                        return;
                    }
                } else {
                    this.timerSeconds++;
                }
                this.updateTimerDisplay();
                if (this.timerSeconds % 10 === 0) SessionState.save();
            }, 1000);
        }
    },

    // Submit
    showSubmitModal() {
        const answered = Object.keys(this.answers).length;
        document.getElementById('modalAnswered').textContent = answered;
        document.getElementById('modalUnanswered').textContent = this.questions.length - answered;
        document.getElementById('modalBookmarked').textContent = Object.keys(this.bookmarked).length;
        document.getElementById('submitModal').classList.add('active');
    },

    hideSubmitModal() {
        document.getElementById('submitModal').classList.remove('active');
    },

    submitTest() {
        if (this.submitted) return; // Prevent double-click
        this.hideSubmitModal();
        this.submitted = true;
        this.stopTimer();
        Audio.stop();
        Metrics.endQuestion(this.currentQ);
        Session.end();
        SessionState.clear();

        let correct = 0;
        const catScores = {};
        this.questions.forEach((q, i) => {
            const cat = q.category || 'General';
            if (!catScores[cat]) catScores[cat] = { correct: 0, total: 0 };
            catScores[cat].total++;
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (this.answers[i] === correctIdx) {
                correct++;
                catScores[cat].correct++;
            }
        });

        const total = this.questions.length;
        const answered = Object.keys(this.answers).length;
        const pct = Math.round((correct / total) * 1000) / 10;
        const pass = pct >= (this.bank.passingScore || 70);
        const elapsed = Math.round((Date.now() - this.startTime) / 1000);
        const timeStr = this.mode === 'test'
            ? this.formatTime((this.initialTimerSeconds || this.bank.timeLimit || 5400) - this.timerSeconds)
            : this.formatTime(elapsed);

        // Score display
        document.getElementById('scoreBig').textContent = pct + '%';
        document.getElementById('scoreBig').className = 'score-big ' + (pass ? 'pass' : 'fail');
        document.getElementById('scoreLabel').textContent = pass ? 'PASS' : 'NOT YET';
        document.getElementById('scoreCorrect').textContent = correct;
        document.getElementById('scoreIncorrect').textContent = answered - correct;
        document.getElementById('scoreUnanswered').textContent = total - answered;
        document.getElementById('scoreTotal').textContent = total;
        document.getElementById('scoreTime').textContent = timeStr;

        // Category breakdown
        const catHtml = Object.entries(catScores).map(([cat, d]) => {
            if (d.total === 0) return '';
            const p = Math.round((d.correct / d.total) * 100);
            const cls = p >= 70 ? 'good' : p >= 50 ? 'warn' : 'bad';
            return `<div class="cat-row"><span style="min-width:160px">${escapeHtml(cat)}</span><div class="cat-bar"><div class="cat-fill ${cls}" style="width:${p}%"></div></div><span style="min-width:60px;text-align:right">${d.correct}/${d.total} (${p}%)</span></div>`;
        }).join('');
        document.getElementById('categoryBreakdown').innerHTML = '<h3>Category Breakdown</h3>' + catHtml + Metrics.buildMetricsSummary(this.questions, this.answers);

        // Build per-question results for this test
        const questionResults = this.questions.map((q, i) => {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            return {
                qId: q.id,
                category: q.category || 'General',
                correct: this.answers[i] === correctIdx,
                answered: this.answers[i] !== undefined,
                chosen: this.answers[i] !== undefined ? this.answers[i] : null,
                correctAnswer: correctIdx,
                timeSpent: Metrics.questionTimes[i] ? Metrics.questionTimes[i].total : 0,
                confidence: this.confidence[i] || 0
            };
        });

        // Save history with full detail (cap at 50 entries to prevent localStorage bloat)
        const history = Store.get('testHistory_' + this.bank.bankId, []);
        history.push({
            date: new Date().toISOString(), pct, correct, total, time: timeStr,
            mode: this.mode, questions: questionResults
        });
        if (history.length > 50) history.splice(0, history.length - 50);
        Store.set('testHistory_' + this.bank.bankId, history);

        // Update persistent per-question performance tracking — only in test mode (practice already records per-check)
        if (this.mode === 'test') {
            QuestionTracker.recordResults(questionResults);
        }

        // Update global stats
        const stats = DailyGoal.getStats();
        stats.testsCompleted++;
        stats.avgScore = stats.avgScore || 0;
        stats.avgScore = ((stats.avgScore * (stats.testsCompleted - 1)) + pct) / stats.testsCompleted;
        DailyGoal.saveStats(stats);

        // Record questions for daily goal — only in test mode (practice mode already records per-check)
        if (this.mode === 'test') {
            DailyGoal.recordQuestions(answered);
        }

        // Gamification: record test completion
        const isPerfect = pct === 100;
        Gamification.recordTestComplete(pct, isPerfect);

        showScreen('score', false, false);
    },

    startReview() {
        this.stopTimer();
        Audio.stop();
        this.mode = 'review-after';
        this._reviewFilter = null;
        this.currentQ = 0;
        document.getElementById('btnSubmit').style.display = 'none';
        document.getElementById('btnCheck').style.display = 'none';
        document.getElementById('modeTab').textContent = 'Review';
        showScreen('exam', true, true);
        this.renderQuestion();
    },

    reviewWrongOnly() {
        this.stopTimer();
        Audio.stop();
        this.mode = 'review-after';
        // Find first wrong question
        const wrongIndices = [];
        this.questions.forEach((q, i) => {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (this.answers[i] !== correctIdx) wrongIndices.push(i);
        });
        if (wrongIndices.length === 0) { alert('No wrong answers!'); return; }
        this._reviewFilter = wrongIndices;
        this.currentQ = wrongIndices[0];
        document.getElementById('btnSubmit').style.display = 'none';
        document.getElementById('btnCheck').style.display = 'none';
        document.getElementById('modeTab').textContent = 'Review (Wrong Only)';
        showScreen('exam', true, true);
        this.renderQuestion();
    },

    drillWrongOnly() {
        if (!this.bank) return;
        const wrongQIds = [];
        this.questions.forEach((q, i) => {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (this.answers[i] !== correctIdx) wrongQIds.push(q.id);
        });
        if (wrongQIds.length === 0) { alert('No wrong answers!'); return; }
        Drill.start(this.bank.bankId, wrongQIds);
    },

    retakeTest() {
        if (this.bank) this.start(this.bank.bankId, 'test');
    },

    exitToHome() {
        this.stopTimer();
        Audio.stop();
        Metrics.endQuestion(this.currentQ);
        if (!this.submitted && this.mode === 'test' && Object.keys(this.answers).length > 0) {
            if (!confirm('Leave without submitting? Your progress will be lost.')) return;
        }
        SessionState.clear();
        showScreen('home');
        Home.render();
    },

    // Timer adjustment modal
    showTimerModal() {
        const mins = Math.floor(this.timerSeconds / 60);
        document.getElementById('timerMinutes').value = mins;
        document.getElementById('timerModal').classList.add('active');
    },

    hideTimerModal() {
        document.getElementById('timerModal').classList.remove('active');
    },

    applyTimerChange() {
        const mins = Math.max(1, Math.min(300, parseInt(document.getElementById('timerMinutes').value) || 90));
        const newSeconds = mins * 60;
        const delta = newSeconds - this.timerSeconds;
        this.initialTimerSeconds = (this.initialTimerSeconds || this.timerSeconds) + delta;
        this.timerSeconds = newSeconds;
        this.updateTimerDisplay();
        this.hideTimerModal();
    },

    formatTime(s) {
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    },

    renderMath() {
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('questionContainer'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                        { left: "$$", right: "$$", display: true },
                        { left: "$", right: "$", display: false },
                    ]
                });
            } catch {}
        }
    },

    // Get current question context for chat
    getQuestionContext() {
        if (!this.questions[this.currentQ]) return null;
        const q = this.questions[this.currentQ];
        const displayOptions = q._shuffledOptions || q.options;
        return {
            number: this.currentQ + 1,
            text: q.text,
            options: displayOptions,
            correctAnswer: q.correctAnswer,
            correctText: q.options[q.correctAnswer],
            explanation: q.explanation,
            userAnswer: this.answers[this.currentQ],
            userAnswerText: this.answers[this.currentQ] !== undefined ? displayOptions[this.answers[this.currentQ]] : null
        };
    }
};

// =====================================================================
// DRILL MODE (SM-2 Spaced Repetition)
// =====================================================================
const Drill = {
    bank: null,
    queue: [],
    current: null,
    sessionCount: 0,
    sessionCorrect: 0,
    showingAnswer: false,
    questionStart: 0,
    SESSION_LIMIT: 20,

    start(bankId, focusQIds) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;
        this._focusQIds = focusQIds || null;
        Session.start(); // Start session timer
        this.sessionCount = 0;
        this.sessionCorrect = 0;
        this.buildQueue();

        if (this.queue.length === 0) {
            showScreen('drill', false, false);
            document.getElementById('drillCard').innerHTML = `
                <div class="drill-session-done">
                    <h2>All caught up!</h2>
                    <p>No questions due for review right now.</p>
                    <button class="btn-nav" style="margin-top:20px" onclick="showScreen('home');Home.render()">Home</button>
                </div>`;
            document.getElementById('drillProgress').textContent = '';
            document.getElementById('chatFab').style.display = '';
            return;
        }

        showScreen('drill', false, false);
        document.getElementById('chatFab').style.display = '';
        Chat.clearHistory();
        this.nextCard();
    },

    getProgress(qId) {
        const all = Store.get('drillProgress', {});
        return all[qId] || { ef: 2.5, interval: 0, reps: 0, nextReview: 0 };
    },

    saveProgress(qId, data) {
        const all = Store.get('drillProgress', {});
        all[qId] = data;
        Store.set('drillProgress', all);
    },

    buildQueue() {
        const now = Date.now();
        const questions = this._focusQIds
            ? this.bank.questions.filter(q => this._focusQIds.includes(q.id))
            : this.bank.questions;
        const scored = questions.map(q => {
            const p = this.getProgress(q.id);
            let priority = 0;
            if (this._focusQIds) priority = 3; // forced focus mode — all high priority
            else if (p.nextReview && p.nextReview <= now) priority = 3;
            else if (p.reps === 0) priority = 2;
            else if (p.ef < 2.0) priority = 1;
            else priority = 0;
            return { question: q, progress: p, priority };
        }).filter(s => s.priority > 0)
          .sort((a, b) => b.priority - a.priority || a.progress.ef - b.progress.ef);

        this.queue = scored.slice(0, this.SESSION_LIMIT);
    },

    nextCard() {
        if (this.queue.length === 0 || this.sessionCount >= this.SESSION_LIMIT) {
            this.showSessionDone();
            return;
        }

        this.current = this.queue.shift();
        this.showingAnswer = false;
        this.selectedOption = null;
        this.questionStart = Date.now();
        Gamification.startQuestionTimer();

        const dueCount = this.queue.length + 1;
        document.getElementById('drillProgress').innerHTML =
            `<span class="due-count">${dueCount}</span> questions remaining | ${this.sessionCount} completed (${this.sessionCorrect} correct)`;

        const q = this.current.question;
        document.getElementById('drillCard').innerHTML = `
            <div class="question-text">${escapeHtml(q.text).replace(/\n/g, '<br>')}</div>
            <ul class="options-list" id="drillOptions">
                ${q.options.map((opt, i) => `
                    <li class="option-item" onclick="Drill.selectOption(${i})" id="dropt-${i}">
                        <input type="radio" name="drill" value="${i}">
                        <span class="option-label">${escapeHtml(opt)}</span>
                    </li>
                `).join('')}
            </ul>
            <div class="drill-answer" id="drillAnswer">
                <div class="correct-label" id="drillResultLabel"></div>
                <div class="explanation">${escapeHtml(q.explanation || '')}</div>
                <div class="drill-buttons">
                    <button class="drill-btn btn-missed" onclick="Drill.rate(1)">Missed it (1)</button>
                    <button class="drill-btn btn-struggled" onclick="Drill.rate(3)">Struggled (3)</button>
                    <button class="drill-btn btn-got-it" onclick="Drill.rate(5)">Got it! (5)</button>
                </div>
            </div>
            <div style="text-align:center;margin-top:16px">
                <button class="drill-btn btn-show" id="drillShowBtn" onclick="Drill.showAnswer()">Show Answer</button>
            </div>
        `;

        // Render inline chart if question has graphData
        if (q.graphData) {
            const qtEl = document.querySelector('#drillCard .question-text');
            if (qtEl) InlineChart.renderInElement(qtEl, q.graphData);
        }

        // Update chat context
        document.getElementById('chatFab').classList.add('has-context');
        this.renderMath();
        SessionState.save();
    },

    selectedOption: null,

    selectOption(i) {
        if (this.showingAnswer) return;
        this.selectedOption = i;
        document.querySelectorAll('#drillOptions .option-item').forEach((el, idx) => {
            el.className = 'option-item' + (idx === i ? ' selected' : '');
        });
        SessionState.save();
    },

    showAnswer() {
        if (!this.current) return;
        this.showingAnswer = true;
        const q = this.current.question;

        // Highlight correct/wrong
        q.options.forEach((_, i) => {
            const el = document.getElementById('dropt-' + i);
            if (i === q.correctAnswer) el.classList.add('correct-answer');
            if (this.selectedOption === i && i !== q.correctAnswer) el.classList.add('wrong-answer');
        });

        const isCorrect = this.selectedOption === q.correctAnswer;
        document.getElementById('drillResultLabel').textContent = isCorrect ? 'Correct!' : (this.selectedOption !== null ? 'Incorrect' : 'Not answered');
        document.getElementById('drillResultLabel').style.color = isCorrect ? 'var(--green)' : 'var(--red)';
        document.getElementById('drillAnswer').classList.add('show');
        document.getElementById('drillShowBtn').style.display = 'none';
    },

    rate(quality) {
        if (!this.current) return;
        const q = this.current.question;
        const p = this.current.progress;

        // SM-2 algorithm
        let ef = p.ef + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
        if (ef < 1.3) ef = 1.3;

        let interval, reps;
        if (quality < 3) {
            reps = 0;
            interval = 1;
        } else {
            reps = p.reps + 1;
            if (reps === 1) interval = 1;
            else if (reps === 2) interval = 6;
            else interval = Math.round(p.interval * ef);
        }

        const nextReview = Date.now() + interval * 86400000;
        this.saveProgress(q.id, { ef, interval, reps, nextReview });

        this.sessionCount++;
        const isCorrect = this.selectedOption === q.correctAnswer;
        if (isCorrect) this.sessionCorrect++;

        // Gamification hooks — gate XP on actual correctness, not self-rating
        const timeSpent = Gamification.getQuestionTime();
        if (isCorrect) {
            Gamification.incrementCombo();
            if (quality >= 5) {
                const trackerData = QuestionTracker._getData();
                const isFirstTry = !trackerData[q.id] || trackerData[q.id].attempts === 0;
                Gamification.awardXp(isFirstTry ? 'firstTryCorrect' : 'drillGotIt', { withCombo: true });
            } else {
                Gamification.awardXp('drillStruggled');
            }
            SoundFX.play('correct');
        } else {
            Gamification.resetCombo();
            SoundFX.play('incorrect');
        }
        Gamification.checkAchievements(isCorrect, timeSpent);
        Gamification.updateCategoryMastery(q.category || 'General', isCorrect);
        Gamification.startQuestionTimer();
        if (isCorrect) Garden.grow(1);

        // Update drill streak (require actual correctness, not just self-rating)
        const stats = DailyGoal.getStats();
        if (isCorrect && quality >= 3) stats.drillStreak++;
        else stats.drillStreak = 0;
        DailyGoal.saveStats(stats);

        // Record question for daily goal
        DailyGoal.recordQuestion();

        // Track per-question performance (AFTER firstTry check above)
        const qMeta = QuestionTracker.getAdaptiveMeta(q.id, q.difficulty);
        QuestionTracker.recordSingle(q.id, q.category || 'General', isCorrect, timeSpent);
        const adaptiveMeta = {
            difficulty: qMeta.difficulty,
            noveltyScore: qMeta.noveltyScore,
            streakPenalty: qMeta.streakPenalty,
            confidenceFactor: qMeta.confidenceFactor
        };
        Gamification.awardXp(isCorrect ? (qMeta.isFirstTry ? 'firstTryCorrect' : 'drillGotIt') : 'drillStruggled', { withCombo: true, questionMeta: adaptiveMeta });

        SessionState.save();
        this.nextCard();
    },

    showSessionDone() {
        Session.end();
        SessionState.clear();
        document.getElementById('drillProgress').textContent = '';
        document.getElementById('drillCard').innerHTML = `
            <div class="drill-session-done">
                <h2>Session Complete!</h2>
                <p>${this.sessionCount} questions reviewed</p>
                <p>${this.sessionCorrect} correct (${this.sessionCount > 0 ? Math.round(this.sessionCorrect/this.sessionCount*100) : 0}%)</p>
                <div style="margin-top:20px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
                    <button class="drill-btn btn-show" onclick="Drill.start('${escapeHtml(this.bank.bankId)}')">Drill Again</button>
                    <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Home</button>
                </div>
            </div>`;
    },

    renderMath() {
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('drillCard'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                        { left: "$$", right: "$$", display: true },
                        { left: "$", right: "$", display: false },
                    ]
                });
            } catch {}
        }
    },

    getQuestionContext() {
        if (!this.current) return null;
        const q = this.current.question;
        return {
            number: q.id,
            text: q.text,
            options: q.options,
            correctAnswer: q.correctAnswer,
            correctText: q.options[q.correctAnswer],
            explanation: q.explanation,
            userAnswer: this.selectedOption,
            userAnswerText: this.selectedOption !== null ? q.options[this.selectedOption] : null
        };
    }
};

// =====================================================================
// REVIEW MODE
// =====================================================================
const Review = {
    bank: null,

    start(bankId) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;
        Session.start(); // Start session timer

        // Populate category filter
        const cats = [...new Set(this.bank.questions.map(q => q.category || 'General'))];
        const catSelect = document.getElementById('reviewCatFilter');
        catSelect.innerHTML = '<option value="">All Categories</option>' + cats.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
        document.getElementById('reviewSearch').value = '';
        document.getElementById('reviewDiffFilter').value = '';

        showScreen('review');
        this.render();
    },

    render() {
        if (!this.bank) return;
        const catFilter = document.getElementById('reviewCatFilter').value;
        const diffFilter = document.getElementById('reviewDiffFilter').value;
        const search = document.getElementById('reviewSearch').value.toLowerCase();

        let filtered = this.bank.questions.filter(q => {
            if (catFilter && (q.category || 'General') !== catFilter) return false;
            if (diffFilter && String(q.difficulty) !== diffFilter) return false;
            if (search && !q.text.toLowerCase().includes(search) && !q.options.some(o => o.toLowerCase().includes(search))) return false;
            return true;
        });

        // Group by category
        const groups = {};
        filtered.forEach(q => {
            const cat = q.category || 'General';
            if (!groups[cat]) groups[cat] = [];
            groups[cat].push(q);
        });

        const drillData = Store.get('drillProgress', {});
        const diffLabels = { 1: 'Easy', 2: 'Medium', 3: 'Hard' };
        const notesData = Store.get(`notes_${this.bank.bankId}`, {});

        let html = '';
        Object.entries(groups).forEach(([cat, questions]) => {
            html += `<div class="review-category">
                <h3 tabindex="0" role="button" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none';this.querySelector('.toggle-arrow').classList.toggle('collapsed')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();this.click()}">
                    ${escapeHtml(cat)} (${questions.length})
                    <span class="toggle-arrow">&#9660;</span>
                </h3>
                <div>`;
            questions.forEach(q => {
                const mastery = drillData[q.id];
                const masteryLabel = mastery ? (mastery.ef >= 2.5 && mastery.reps >= 3 ? 'Mastered' : mastery.reps > 0 ? 'Learning' : 'New') : 'New';
                const note = notesData[q.id] || '';
                html += `<div class="review-q">
                    <div class="rq-text" data-qid="${q.id}"><strong>Q${q.id}.</strong> ${escapeHtml(q.text).replace(/\n/g, '<br>')}</div>
                    <ul class="rq-options">
                        ${q.options.map((opt, i) => `<li class="rq-opt ${i === q.correctAnswer ? 'rq-correct' : ''}">${String.fromCharCode(65+i)}. ${escapeHtml(opt)}</li>`).join('')}
                    </ul>
                    ${q.explanation ? `<div class="rq-explanation">${escapeHtml(q.explanation)}</div>` : ''}
                    ${note ? `<div class="rq-note"><div class="rq-note-label">Your Note:</div>${escapeHtml(note).replace(/\n/g, '<br>')}</div>` : ''}
                    <div class="rq-meta">
                        <span class="rq-tag">${diffLabels[q.difficulty] || 'Medium'}</span>
                        <span class="rq-tag">${masteryLabel}</span>
                        ${(q.tags || []).map(t => `<span class="rq-tag">${escapeHtml(t)}</span>`).join('')}
                    </div>
                </div>`;
            });
            html += '</div></div>';
        });

        if (html === '') html = '<p style="text-align:center;color:var(--gray-600);padding:40px">No questions match your filters.</p>';
        document.getElementById('reviewContent').innerHTML = html;

        // Render inline charts in review mode
        filtered.forEach(q => {
            if (q.graphData) {
                const el = document.querySelector(`.rq-text[data-qid="${q.id}"]`);
                if (el) InlineChart.renderInElement(el, q.graphData);
            }
        });

        // Render math
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('reviewContent'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                        { left: "$$", right: "$$", display: true },
                        { left: "$", right: "$", display: false },
                    ]
                });
            } catch {}
        }
    }
};

// =====================================================================
// SETTINGS
// =====================================================================
// =====================================================================
// THEME MANAGEMENT
// =====================================================================
const Theme = {
    THEMES: ['system', 'light', 'dark', 'cengage-light', 'cengage-dark', 'synthwave'],

    // Apply theme
    apply(theme) {
        const root = document.documentElement;
        const body = document.body;

        // Remove any existing theme attribute
        root.removeAttribute('data-theme');
        body.removeAttribute('data-theme');

        if (theme !== 'system') {
            root.setAttribute('data-theme', theme);
            body.setAttribute('data-theme', theme);
        }
        // 'system' = no data-theme attribute, CSS handles it via prefers-color-scheme

        // Save preference
        Store.set('theme', theme);

        // Update select if it exists (may not on initial load)
        const select = document.getElementById('settingTheme');
        if (select && select.value !== theme) {
            select.value = theme;
        }
    },

    // Load and apply saved theme preference
    load() {
        const saved = Store.get('theme', 'system');
        this.apply(saved);
        return saved;
    },

    // Get current effective theme (for components that need to know)
    getCurrent() {
        const saved = Store.get('theme', 'system');
        if (saved !== 'system') return saved;
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    },

    // Check if current theme is dark-variant (for graph colors, etc.)
    isDark() {
        const t = this.getCurrent();
        return t === 'dark' || t === 'cengage-dark' || t === 'synthwave';
    }
};


// =====================================================================
// AI PRACTICE MODE
// =====================================================================
const AIPractice = {
    bank: null,
    currentQuestion: null,
    selectedOption: null,
    isChecked: false,
    isGenerating: false,
    sessionStats: { total: 0, correct: 0, byCategory: {} },
    weakCategories: [],
    currentCategory: null,
    currentDifficulty: 2,
    startingWeakness: {},

    async start(bankId) {
        if (this.isGenerating) return; // Prevent double-start while generating
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;

        // Check for API key
        const provider = Store.get('provider', 'anthropic');
        const apiKey = provider === 'openai' ? Store.get('openaiKey', '') : Store.get('anthropicKey', '');
        if (!apiKey) {
            alert(`Please set your ${provider === 'openai' ? 'OpenAI' : 'Anthropic'} API key in Settings first to use AI Practice mode.`);
            return;
        }

        Session.start();
        this.sessionStats = { total: 0, correct: 0, byCategory: {} };
        this.currentQuestion = null;
        this.selectedOption = null;
        this.isChecked = false;
        this.currentDifficulty = 2;

        this.analyzeWeakAreas();
        this.startingWeakness = {};
        this.weakCategories.forEach(wc => {
            this.startingWeakness[wc.category] = wc.score;
        });

        showScreen('ai-practice', false, false);
        document.getElementById('chatFab').style.display = '';
        Chat.clearHistory();
        document.getElementById('chatFab').classList.add('has-context');

        await this.generateNext();
    },

    analyzeWeakAreas() {
        const drillData = Store.get('drillProgress', {});
        const testHistory = Store.get('testHistory_' + this.bank.bankId, []);
        const catScores = {};

        // Guard against empty or missing questions
        const questions = this.bank?.questions || [];
        if (questions.length === 0) {
            this.weakCategories = [{ category: 'General', score: 50, questionCount: 0 }];
            return;
        }

        // Initialize categories from bank
        const categories = [...new Set(questions.map(q => q.category || 'General'))];
        categories.forEach(cat => {
            catScores[cat] = { drillEF: [], testScores: [], questionCount: 0 };
        });

        // Gather drill EF scores per category
        questions.forEach(q => {
            const cat = q.category || 'General';
            catScores[cat].questionCount++;
            const prog = drillData[q.id];
            if (prog && prog.reps > 0) {
                catScores[cat].drillEF.push(prog.ef);
            }
        });

        // Gather test history category scores from per-question results
        testHistory.slice(-5).forEach(test => {
            if (test.questions) {
                const catResults = {};
                test.questions.forEach(q => {
                    const cat = q.category || 'General';
                    if (!catResults[cat]) catResults[cat] = { correct: 0, total: 0 };
                    catResults[cat].total++;
                    if (q.correct) catResults[cat].correct++;
                });
                Object.entries(catResults).forEach(([cat, d]) => {
                    const score = d.total > 0 ? Math.round((d.correct / d.total) * 100) : 0;
                    if (catScores[cat]) catScores[cat].testScores.push(score);
                });
            }
        });

        // Calculate weakness score for each category
        // Lower is weaker (needs more practice)
        const weaknessScores = [];
        Object.entries(catScores).forEach(([cat, data]) => {
            let score = 50; // Default neutral score

            // Factor in drill EF (0-5 scale, higher is better)
            if (data.drillEF.length > 0) {
                const avgEF = data.drillEF.reduce((a, b) => a + b, 0) / data.drillEF.length;
                score = (avgEF / 5) * 100; // Convert to 0-100
            }

            // Factor in test scores
            if (data.testScores.length > 0) {
                const avgTestScore = data.testScores.reduce((a, b) => a + b, 0) / data.testScores.length;
                if (data.drillEF.length > 0) {
                    score = (score + avgTestScore) / 2;
                } else {
                    score = avgTestScore;
                }
            }

            // Penalize categories with less practice
            const practiceRatio = data.drillEF.length / Math.max(data.questionCount, 1);
            if (practiceRatio < 0.5) {
                score *= 0.8; // 20% penalty for low practice
            }

            weaknessScores.push({ category: cat, score, questionCount: data.questionCount });
        });

        // Sort by score (lowest first = weakest)
        weaknessScores.sort((a, b) => a.score - b.score);
        this.weakCategories = weaknessScores;
    },

    pickNextCategory() {
        // Prioritize weak categories but occasionally mix in stronger ones
        const sessionCatStats = this.sessionStats.byCategory;

        // Check if any weak categories are still below 80% in this session
        for (const wc of this.weakCategories) {
            const sessionData = sessionCatStats[wc.category];
            if (!sessionData) return wc.category; // Not attempted yet

            const sessionPct = sessionData.total > 0 ?
                (sessionData.correct / sessionData.total) * 100 : 0;
            if (sessionPct < 80 || sessionData.total < 3) {
                return wc.category;
            }
        }

        // If all are at 80%+, pick the weakest with fewest attempts
        const byAttempts = [...this.weakCategories].sort((a, b) => {
            const aAttempts = sessionCatStats[a.category]?.total || 0;
            const bAttempts = sessionCatStats[b.category]?.total || 0;
            return aAttempts - bAttempts;
        });
        return byAttempts[0]?.category || this.weakCategories[0]?.category || 'General';
    },

    adjustDifficulty() {
        const cat = this.currentCategory;
        const catStats = this.sessionStats.byCategory[cat];

        if (!catStats || catStats.total < 2) {
            this.currentDifficulty = 2;
            return;
        }

        const recentAccuracy = catStats.correct / catStats.total;

        // Adaptive difficulty
        if (recentAccuracy >= 0.8 && this.currentDifficulty < 3) {
            this.currentDifficulty = Math.min(3, this.currentDifficulty + 1);
        } else if (recentAccuracy < 0.5 && this.currentDifficulty > 1) {
            this.currentDifficulty = Math.max(1, this.currentDifficulty - 1);
        }
    },

    async generateNext() {
        if (!navigator.onLine) {
            this.renderError('You are offline. AI Practice requires an internet connection.');
            return;
        }
        this.isGenerating = true;
        this.currentQuestion = null;
        this.selectedOption = null;
        this.isChecked = false;

        this.currentCategory = this.pickNextCategory();
        this.adjustDifficulty();

        this.renderProgress();
        this.renderLoading();

        try {
            const question = await this.generateQuestion(this.currentCategory, this.currentDifficulty);
            if (question) {
                this.currentQuestion = question;
                this.renderQuestion();
                Gamification.startQuestionTimer();
            } else {
                throw new Error('Failed to generate question');
            }
            SessionState.save();
        } catch (err) {
            // AI Practice error handled in UI
            this.renderError(err.message || 'Failed to generate question. Please try again.');
        }

        this.isGenerating = false;
    },

    async generateQuestion(category, difficulty) {
        // Gentle pacing: small delay to simulate deliberation
        await new Promise(res => setTimeout(res, 250));
        const provider = Store.get('provider', 'anthropic');
        const apiKey = provider === 'openai' ? Store.get('openaiKey', '') : Store.get('anthropicKey', '');

        // Get sample questions from this category to understand the style
        const sampleQuestions = this.bank.questions
            .filter(q => (q.category || 'General') === category)
            .slice(0, 3)
            .map(q => `Q: ${q.text.substring(0, 200)}...`);

        const difficultyLabel = difficulty === 1 ? 'Easy' : difficulty === 2 ? 'Medium' : 'Hard';
        const bankCategories = this.bank.categories || [];

        const systemPrompt = `You are generating practice questions for WGU Applied Algebra assessments.

CATEGORY: ${category}
DIFFICULTY: ${difficultyLabel} (${difficulty}/3)
BANK CATEGORIES: ${bankCategories.join(', ')}

${sampleQuestions.length > 0 ? `SAMPLE QUESTIONS FROM THIS CATEGORY (use similar style):
${sampleQuestions.join('\n')}` : ''}

INSTRUCTIONS:
1. Generate ONE multiple choice question about "${category}"
2. Match the style of WGU pre-assessment questions
3. Include realistic scenarios when appropriate (business contexts, real-world applications)
4. For ${difficultyLabel} difficulty:
   ${difficulty === 1 ? '- Use straightforward calculations or interpretations\n   - Clear, direct questions' : ''}
   ${difficulty === 2 ? '- Include multi-step reasoning\n   - May require interpretation of data or graphs' : ''}
   ${difficulty === 3 ? '- Complex scenarios with multiple concepts\n   - Requires deep understanding and careful analysis' : ''}
5. Make distractors (wrong answers) plausible but clearly incorrect
6. Provide a thorough explanation of why the correct answer is right

You MUST respond with ONLY valid JSON in this EXACT format (no markdown, no extra text):
{
    "question": "The full question text here",
    "options": ["Option A text", "Option B text", "Option C text", "Option D text"],
    "correctAnswer": 0,
    "explanation": "Detailed explanation of why the correct answer is right and why others are wrong..."
}

IMPORTANT: correctAnswer is a 0-based index (0 for first option, 1 for second, etc.)`;

        const userMessage = `Generate a ${difficultyLabel.toLowerCase()} difficulty question about "${category}" for Applied Algebra.`;

        try {
            let responseText;
            if (provider === 'openai') {
                responseText = await this._callOpenAI(apiKey, systemPrompt, userMessage);
            } else {
                responseText = await this._callAnthropic(apiKey, systemPrompt, userMessage);
            }

            // Parse JSON response
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('Invalid response format from AI');
            }

            let parsed;
            try {
                parsed = JSON.parse(jsonMatch[0]);
            } catch (jsonErr) {
                throw new Error('AI returned malformed JSON. Please try again.');
            }

            // Validate response structure
            if (!parsed.question || !Array.isArray(parsed.options) || parsed.options.length < 2 ||
                typeof parsed.correctAnswer !== 'number' || !parsed.explanation) {
                throw new Error('Incomplete question generated');
            }

            // Validate correctAnswer is within bounds
            if (parsed.correctAnswer < 0 || parsed.correctAnswer >= parsed.options.length) {
                throw new Error('Invalid correct answer index from AI');
            }

            return {
                question: parsed.question,
                options: parsed.options,
                correctAnswer: parsed.correctAnswer,
                explanation: parsed.explanation,
                category: category,
                difficulty: difficulty
            };
        } catch (err) {
            // Question generation error handled in UI
            throw err;
        }
    },

    async _callAnthropic(apiKey, systemPrompt, userMessage) {
        const model = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
                model,
                max_tokens: 1500,
                system: systemPrompt,
                messages: [{ role: 'user', content: userMessage }]
            })
        });
        clearTimeout(timeout);

        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`API error: ${err.error?.message || resp.statusText}`);
        }

        const data = await resp.json();
        return data.content?.[0]?.text || '';
    },

    async _callOpenAI(apiKey, systemPrompt, userMessage) {
        const model = Store.get('openaiModel', 'gpt-4o-mini');
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify({
                model,
                max_tokens: 1500,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMessage }
                ]
            })
        });
        clearTimeout(timeout);

        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`API error: ${err.error?.message || resp.statusText}`);
        }

        const data = await resp.json();
        return data.choices?.[0]?.message?.content || '';
    },

    selectOption(i) {
        if (this.isChecked || this.isGenerating) return;
        this.selectedOption = i;
        this.renderQuestion();
        SessionState.save();
    },

    checkAnswer() {
        if (this.selectedOption === null || this.isChecked) return;

        this.isChecked = true;
        const isCorrect = this.selectedOption === this.currentQuestion.correctAnswer;

        // Gamification hooks
        const timeSpent = Gamification.getQuestionTime();
        if (isCorrect) {
            Gamification.incrementCombo();
            Gamification.awardXp('correctAnswer', { withCombo: true });
            SoundFX.play('correct');
        } else {
            Gamification.resetCombo();
            SoundFX.play('incorrect');
        }
        Gamification.checkAchievements(isCorrect, timeSpent);
        Gamification.updateCategoryMastery(this.currentCategory || 'General', isCorrect);
        Gamification.startQuestionTimer();
        if (isCorrect) Garden.grow(1);

        // Update session stats
        this.sessionStats.total++;
        if (isCorrect) this.sessionStats.correct++;

        const cat = this.currentCategory;
        if (!this.sessionStats.byCategory[cat]) {
            this.sessionStats.byCategory[cat] = { correct: 0, total: 0 };
        }
        this.sessionStats.byCategory[cat].total++;
        if (isCorrect) this.sessionStats.byCategory[cat].correct++;

        // Record question for daily goal
        DailyGoal.recordQuestion();

        // Track per-question performance
        const qId = this.currentQuestion.id || ('ai_' + this.sessionStats.total);
        const qMeta = QuestionTracker.getAdaptiveMeta(qId, this.currentQuestion.difficulty);
        QuestionTracker.recordSingle(
            qId,
            this.currentCategory || 'General', isCorrect, timeSpent,
            { confidenceLevel: null }
        );
        const adaptiveMeta = {
            difficulty: qMeta.difficulty,
            noveltyScore: qMeta.noveltyScore,
            streakPenalty: qMeta.streakPenalty,
            confidenceFactor: qMeta.confidenceFactor
        };
        Gamification.awardXp(isCorrect ? (qMeta.isFirstTry ? 'firstTryCorrect' : 'correctAnswer') : 'drillStruggled', { withCombo: true, questionMeta: adaptiveMeta });

        const globalStats = Store.get('globalStats', {});
        globalStats.aiPracticeTotal = (globalStats.aiPracticeTotal || 0) + 1;
        globalStats.aiPracticeCorrect = (globalStats.aiPracticeCorrect || 0) + (isCorrect ? 1 : 0);
        Store.set('globalStats', globalStats);

        this.renderProgress();
        this.renderQuestion();
        SessionState.save();
    },

    saveSessionStats() {
        const sessionKey = 'aiPracticeSession_' + this.bank.bankId;
        const sessions = Store.get(sessionKey, []);
        const currentSession = {
            date: new Date().toISOString(),
            stats: { ...this.sessionStats }
        };

        // Keep last 20 sessions
        sessions.push(currentSession);
        if (sessions.length > 20) sessions.shift();
        Store.set(sessionKey, sessions);
    },

    checkMastery() {
        // Check if all weak categories have reached 80%+ with at least 3 attempts
        for (const wc of this.weakCategories.slice(0, 5)) { // Focus on top 5 weakest
            const catStats = this.sessionStats.byCategory[wc.category];
            if (!catStats || catStats.total < 3) return false;
            if ((catStats.correct / catStats.total) < 0.8) return false;
        }
        return this.sessionStats.total >= 10; // At least 10 questions
    },

    endSession() {
        Session.end();
        this.saveSessionStats();
        SessionState.clear();
        this.renderSummary();
    },

    renderProgress() {
        const el = document.getElementById('aiProgress');
        const pct = this.sessionStats.total > 0 ?
            Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) : 0;

        let weakCatsHtml = '<div class="weak-areas"><strong>Targeting weak areas:</strong> ';
        this.weakCategories.slice(0, 5).forEach(wc => {
            const isCurrent = wc.category === this.currentCategory;
            weakCatsHtml += `<span class="weak-cat${isCurrent ? ' current' : ''}">${escapeHtml(wc.category)}</span>`;
        });
        weakCatsHtml += '</div>';

        el.innerHTML = `
            <div class="targeting">AI Practice Mode</div>
            <div class="session-stats">
                <div class="session-stat">
                    <div class="val">${this.sessionStats.correct}</div>
                    <div class="lbl">Correct</div>
                </div>
                <div class="session-stat">
                    <div class="val">${this.sessionStats.total}</div>
                    <div class="lbl">Total</div>
                </div>
                <div class="session-stat">
                    <div class="val">${pct}%</div>
                    <div class="lbl">Accuracy</div>
                </div>
            </div>
            ${weakCatsHtml}
        `;
    },

    renderLoading() {
        const el = document.getElementById('aiCard');
        el.innerHTML = `
            <div class="ai-loading">
                <div class="spinner"></div>
                <p>Generating a new question about <strong>${escapeHtml(this.currentCategory)}</strong>...</p>
                <p style="font-size:12px;color:var(--gray-500);margin-top:8px">
                    Difficulty: ${this.currentDifficulty === 1 ? 'Easy' : this.currentDifficulty === 2 ? 'Medium' : 'Hard'}
                </p>
            </div>
        `;
    },

    renderQuestion() {
        if (!this.currentQuestion) return;

        const q = this.currentQuestion;
        const el = document.getElementById('aiCard');

        // Reset chat context per question to avoid stale threads
        if (Chat && Chat.clearHistory) {
            Chat.clearHistory();
            const fab = document.getElementById('chatFab');
            if (fab) fab.classList.remove('has-context');
        }

        // Difficulty indicator
        let diffHtml = '<div class="ai-difficulty"><span>Difficulty:</span><div class="diff-indicator">';
        for (let i = 1; i <= 3; i++) {
            diffHtml += `<span class="diff-dot${i <= q.difficulty ? ' filled' : ''}"></span>`;
        }
        diffHtml += '</div><span>' + (q.difficulty === 1 ? 'Easy' : q.difficulty === 2 ? 'Medium' : 'Hard') + '</span></div>';

        // Options
        let optionsHtml = '<ul class="options-list">';
        q.options.forEach((opt, i) => {
            let cls = 'option-item';
            if (this.selectedOption === i) cls += ' selected';
            if (this.isChecked) {
                cls += ' disabled';
                if (i === q.correctAnswer) cls += ' correct-answer';
                if (this.selectedOption === i && i !== q.correctAnswer) cls += ' wrong-answer';
            }
            optionsHtml += `
                <li class="${cls}" onclick="AIPractice.selectOption(${i})">
                    <input type="radio" name="aiopt" value="${i}" ${this.selectedOption === i ? 'checked' : ''} ${this.isChecked ? 'disabled' : ''}>
                    <span class="option-label">${escapeHtml(opt)}</span>
                </li>
            `;
        });
        optionsHtml += '</ul>';

        // Explanation
        let explanationHtml = '';
        if (this.isChecked) {
            const isCorrect = this.selectedOption === q.correctAnswer;
            explanationHtml = `
                <div class="ai-explanation${isCorrect ? '' : ' incorrect'}">
                    <h4>${isCorrect ? 'Correct!' : 'Incorrect'}</h4>
                    <p>${escapeHtml(q.explanation)}</p>
                </div>
            `;
        }

        // Buttons
        let buttonsHtml = '<div class="ai-buttons">';
        if (!this.isChecked) {
            buttonsHtml += `
                <button class="ai-btn btn-check" onclick="AIPractice.checkAnswer()" ${this.selectedOption === null ? 'disabled' : ''}>Check Answer</button>
                <button class="ai-btn btn-end" onclick="AIPractice.endSession()">End Session</button>
            `;
        } else {
            const masteryReached = this.checkMastery();
            if (masteryReached) {
                buttonsHtml += `
                    <button class="ai-btn btn-next" onclick="AIPractice.endSession()" style="background:var(--green)">
                        Mastery Reached! View Summary
                    </button>
                `;
            } else {
                buttonsHtml += `
                    <button class="ai-btn btn-next" onclick="AIPractice.generateNext()">Next Question</button>
                    <button class="ai-btn btn-end" onclick="AIPractice.endSession()">End Session</button>
                `;
            }
        }
        buttonsHtml += '</div>';

        el.innerHTML = `
            ${diffHtml}
            <div class="question-text">${escapeHtml(q.question).replace(/\n/g, '<br>')}</div>
            ${optionsHtml}
            ${explanationHtml}
            ${buttonsHtml}
        `;

        // Render math if present
        if (window.renderMathInElement) {
            try {
                renderMathInElement(el, {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                        { left: "$$", right: "$$", display: true },
                        { left: "$", right: "$", display: false },
                    ]
                });
            } catch {}
        }
    },

    renderError(message) {
        const el = document.getElementById('aiCard');
        el.innerHTML = `
            <div class="ai-error">
                <h3>Generation Failed</h3>
                <p>${escapeHtml(message)}</p>
                <div class="ai-buttons">
                    <button class="ai-btn btn-next" onclick="AIPractice.generateNext()">Try Again</button>
                    <button class="ai-btn btn-end" onclick="SessionState.clear();showScreen('home');Home.render()">Back to Home</button>
                </div>
            </div>
        `;
    },

    renderSummary() {
        const pct = this.sessionStats.total > 0 ?
            Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) : 0;

        // Category improvements
        let catImprovementsHtml = '';
        Object.entries(this.sessionStats.byCategory).forEach(([cat, data]) => {
            const sessionPct = data.total > 0 ? Math.round((data.correct / data.total) * 100) : 0;
            const startingScore = this.startingWeakness[cat] || 50;
            const diff = sessionPct - startingScore;
            const diffClass = diff > 0 ? 'improved' : diff < 0 ? 'declined' : '';
            const diffText = diff > 0 ? `+${diff}%` : diff < 0 ? `${diff}%` : '0%';

            catImprovementsHtml += `
                <div class="cat-improvement">
                    <span class="cat-name">${escapeHtml(cat)}</span>
                    <span class="cat-score">${sessionPct}%</span>
                    <span class="cat-score ${diffClass}">(${diffText})</span>
                </div>
            `;
        });

        const el = document.getElementById('aiCard');
        el.innerHTML = `
            <div class="ai-session-summary">
                <h2>Session Complete!</h2>
                <div class="summary-score">${pct}%</div>
                <div class="summary-label">${this.sessionStats.correct} correct out of ${this.sessionStats.total} questions</div>

                <div class="summary-details">
                    <table>
                        <tr><td class="label-col">Questions Attempted</td><td class="value-col">${this.sessionStats.total}</td></tr>
                        <tr><td class="label-col">Correct Answers</td><td class="value-col">${this.sessionStats.correct}</td></tr>
                        <tr><td class="label-col">Incorrect Answers</td><td class="value-col">${this.sessionStats.total - this.sessionStats.correct}</td></tr>
                        <tr><td class="label-col">Categories Covered</td><td class="value-col">${Object.keys(this.sessionStats.byCategory).length}</td></tr>
                    </table>
                </div>

                ${catImprovementsHtml ? `
                    <div class="category-improvements">
                        <h3>Performance by Category</h3>
                        ${catImprovementsHtml}
                    </div>
                ` : ''}

                <div class="summary-actions">
                    <button style="background:#9b59b6" onclick="AIPractice.start('${escapeHtml(this.bank.bankId)}')">Practice Again</button>
                    <button style="background:var(--gray-700)" onclick="showScreen('home');Home.render()">Back to Home</button>
                </div>
            </div>
        `;
    },

    getQuestionContext() {
        if (!this.currentQuestion) return null;
        const q = this.currentQuestion;
        return {
            number: 'AI-' + this.sessionStats.total,
            text: q.question,
            options: q.options,
            correctAnswer: q.correctAnswer,
            correctText: q.options[q.correctAnswer],
            explanation: q.explanation,
            userAnswer: this.selectedOption,
            userAnswerText: this.selectedOption !== null ? q.options[this.selectedOption] : null
        };
    }
};


// =====================================================================
// PROGRESS DASHBOARD
// =====================================================================
const Progress = {
    show() {
        showScreen('progress');
        this.render();
    },

    render() {
        const content = document.getElementById('progressContent');
        content.innerHTML = this.renderOverallStats() + this.renderScoreTrend() + this.renderTestHistory() + this.renderMostMissed() + this.renderCategoryAccuracy() + this.renderCategoryPerformance() + this.renderMasteryProgress() + this.renderStudyTime();
        this._drawTrendChart();
    },

    renderScoreTrend() {
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        if (allHistory.length < 2) return '';
        allHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        const recent = allHistory.slice(-20);
        return '<div class="progress-section"><h3>Score Trend</h3>' +
            '<canvas id="trendChart" width="600" height="180" style="width:100%;max-height:180px;border-radius:8px;background:var(--white);border:1px solid var(--gray-200)"></canvas>' +
            '<p style="font-size:11px;color:var(--gray-600);text-align:center;margin-top:4px">Last ' + recent.length + ' tests</p></div>';
    },

    _drawTrendChart() {
        const canvas = document.getElementById('trendChart');
        if (!canvas) return;
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        allHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        const data = allHistory.slice(-20).map(h => h.pct);
        if (data.length < 2) return;

        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = canvas.offsetWidth, h = canvas.offsetHeight;
        const pad = { top: 20, right: 20, bottom: 30, left: 40 };
        const plotW = w - pad.left - pad.right;
        const plotH = h - pad.top - pad.bottom;

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
            (document.documentElement.getAttribute('data-theme') !== 'light' && window.matchMedia('(prefers-color-scheme:dark)').matches);

        ctx.fillStyle = isDark ? '#16213e' : '#fff';
        ctx.fillRect(0, 0, w, h);

        // Grid lines
        ctx.strokeStyle = isDark ? '#374151' : '#eee';
        ctx.lineWidth = 1;
        for (let pct of [0, 25, 50, 70, 100]) {
            const y = pad.top + plotH - (pct / 100) * plotH;
            ctx.beginPath();
            ctx.moveTo(pad.left, y);
            ctx.lineTo(w - pad.right, y);
            ctx.stroke();
            ctx.fillStyle = isDark ? '#9ca3af' : '#999';
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(pct + '%', pad.left - 4, y + 3);
        }

        // Pass line at 70%
        const passY = pad.top + plotH - (70 / 100) * plotH;
        ctx.strokeStyle = isDark ? '#4ade80' : '#27ae60';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(pad.left, passY);
        ctx.lineTo(w - pad.right, passY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Data line
        const points = data.map((pct, i) => ({
            x: pad.left + (i / (data.length - 1)) * plotW,
            y: pad.top + plotH - (pct / 100) * plotH
        }));

        // Gradient fill
        const gradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
        gradient.addColorStop(0, isDark ? 'rgba(59,130,246,.3)' : 'rgba(41,128,185,.15)');
        gradient.addColorStop(1, isDark ? 'rgba(59,130,246,0)' : 'rgba(41,128,185,0)');
        ctx.beginPath();
        ctx.moveTo(points[0].x, pad.top + plotH);
        points.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(points[points.length - 1].x, pad.top + plotH);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // Line
        ctx.strokeStyle = isDark ? '#3b82f6' : '#2980b9';
        ctx.lineWidth = 2.5;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        ctx.stroke();

        // Dots
        points.forEach((p, i) => {
            const color = data[i] >= 70 ? (isDark ? '#4ade80' : '#27ae60') : (isDark ? '#ef4444' : '#c0392b');
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = isDark ? '#16213e' : '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // X axis labels
        ctx.fillStyle = isDark ? '#9ca3af' : '#999';
        ctx.font = '9px Arial';
        ctx.textAlign = 'center';
        const step = Math.max(1, Math.floor(data.length / 6));
        for (let i = 0; i < data.length; i += step) {
            ctx.fillText('#' + (i + 1), points[i].x, h - 6);
        }
        ctx.fillText('#' + data.length, points[points.length - 1].x, h - 6);
    },

    renderOverallStats() {
        const summary = QuestionTracker.getSummary();
        if (summary.totalAttempts === 0) return '';
        const avgTime = summary.totalAttempts > 0 ? Metrics._formatTime(summary.totalTime / summary.totalAttempts) : '0s';
        return '<div class="progress-section"><h3>Overall Performance</h3><div class="mastery-grid">' +
            '<div class="mastery-item mastered"><div class="value">' + summary.accuracy + '%</div><div class="label">Accuracy</div></div>' +
            '<div class="mastery-item learning"><div class="value">' + summary.totalAttempts + '</div><div class="label">Total Attempts</div></div>' +
            '<div class="mastery-item new"><div class="value">' + summary.questionsTracked + '</div><div class="label">Questions Seen</div></div>' +
            '<div class="mastery-item mastered"><div class="value">' + avgTime + '</div><div class="label">Avg Time/Q</div></div>' +
            '</div></div>';
    },

    renderMostMissed() {
        const missed = QuestionTracker.getMostMissed(8);
        if (missed.length === 0) return '';
        const rows = missed.map(m => {
            const found = QuestionTracker.findQuestion(m.qId);
            const label = found ? found.question.text.substring(0, 60) + (found.question.text.length > 60 ? '...' : '') : m.qId;
            const pct = Math.round(m.missRate * 100);
            const trend = QuestionTracker.getTrend(m.qId, 3);
            let trendIcon = '';
            if (trend) trendIcon = trend.improving ? ' <span style="color:var(--green)">&#9650;</span>' : ' <span style="color:var(--red)">&#9660;</span>';
            return '<tr><td style="max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + escapeHtml(found ? found.question.text : '') + '">' + escapeHtml(label) + '</td>' +
                '<td>' + escapeHtml(m.category) + '</td>' +
                '<td style="color:var(--red)">' + pct + '%</td>' +
                '<td>' + m.incorrect + '/' + m.attempts + trendIcon + '</td></tr>';
        }).join('');
        return '<div class="progress-section"><h3>Most Missed Questions</h3>' +
            '<table class="progress-table"><thead><tr><th>Question</th><th>Category</th><th>Miss Rate</th><th>Wrong/Total</th></tr></thead><tbody>' + rows + '</tbody></table></div>';
    },

    renderCategoryAccuracy() {
        const cats = QuestionTracker.getCategoryAccuracy();
        const entries = Object.entries(cats).filter(([_, d]) => d.total > 0);
        if (entries.length === 0) return '';
        entries.sort((a, b) => (a[1].correct / a[1].total) - (b[1].correct / b[1].total));
        const gamState = Gamification.isEnabled() ? Gamification.getState() : null;
        const badgeColors = { bronze: '#cd7f32', silver: '#c0c0c0', gold: '#ffd700', platinum: '#e5e4e2' };
        const bars = entries.map(([cat, d]) => {
            const pct = Math.round((d.correct / d.total) * 100);
            const colorClass = pct >= 70 ? 'good' : pct >= 50 ? 'warn' : 'bad';
            let badge = '';
            if (gamState && gamState.categoryMastery[cat] && gamState.categoryMastery[cat].level) {
                const lvl = gamState.categoryMastery[cat].level;
                badge = ' <span style="display:inline-block;background:' + badgeColors[lvl] + ';color:#333;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold">' + lvl.charAt(0).toUpperCase() + lvl.slice(1) + '</span>';
            }
            return '<div class="chart-row"><span class="chart-label">' + escapeHtml(cat) + badge + '</span><div class="chart-bar-bg"><div class="chart-bar-fill ' + colorClass + '" style="width:' + pct + '%"></div></div><span class="chart-value">' + d.correct + '/' + d.total + ' (' + pct + '%)</span></div>';
        }).join('');
        return '<div class="progress-section"><h3>Category Accuracy (All Modes)</h3><p style="font-size:12px;color:var(--gray-600);margin-bottom:8px">Combined from tests, drills, and AI practice</p><div class="progress-chart">' + bars + '</div></div>';
    },

    renderTestHistory() {
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history.map(h => ({ ...h, bankTitle: bank.title })));
        }
        allHistory.sort((a, b) => new Date(b.date) - new Date(a.date));
        const recent = allHistory.slice(0, 10);

        if (recent.length === 0) {
            return '<div class="progress-section"><h3>Test History</h3><p style="color:var(--gray-600)">No tests completed yet.</p></div>';
        }

        const rows = recent.map((h, idx) => {
            const date = new Date(h.date);
            const dateStr = date.toLocaleDateString();
            const scoreClass = h.pct >= 70 ? 'good' : h.pct >= 50 ? 'warn' : 'bad';
            const colorVar = scoreClass === 'good' ? 'green' : scoreClass === 'warn' ? 'orange' : 'red';
            const hasDetail = h.questions && h.questions.length > 0;
            const expandBtn = hasDetail ? ' <button onclick="event.stopPropagation();Progress.toggleDetail(this.closest(\'tr\').nextElementSibling)" style="background:none;border:none;cursor:pointer;font-size:11px;color:var(--gray-600)">&#9660;</button>' : '';
            let detailRow = '';
            if (hasDetail) {
                const wrongQs = h.questions.filter(q => q.answered && !q.correct);
                const skippedQs = h.questions.filter(q => !q.answered);
                let detail = '<div style="font-size:12px;padding:8px">';
                if (wrongQs.length > 0) {
                    detail += '<strong style="color:var(--red)">Missed (' + wrongQs.length + '):</strong><ul style="margin:4px 0 8px 16px">';
                    wrongQs.forEach(wq => {
                        const found = QuestionTracker.findQuestion(wq.qId);
                        const label = found ? found.question.text.substring(0, 80) : wq.qId;
                        detail += '<li>' + escapeHtml(wq.category) + ': ' + escapeHtml(label) + '</li>';
                    });
                    detail += '</ul>';
                }
                if (skippedQs.length > 0) {
                    detail += '<strong style="color:var(--orange)">Skipped (' + skippedQs.length + '):</strong> ' + skippedQs.map(q => escapeHtml(q.category)).join(', ');
                }
                detail += '</div>';
                detailRow = '<tr class="test-detail-row" style="display:none"><td colspan="4">' + detail + '</td></tr>';
            }
            return '<tr style="cursor:' + (hasDetail ? 'pointer' : 'default') + '"' + (hasDetail ? ' onclick="Progress.toggleDetail(this.nextElementSibling)"' : '') + '><td>' + dateStr + expandBtn + '</td><td><span style="color:var(--' + colorVar + ')">' + h.pct + '%</span></td><td>' + (h.mode || 'test') + '</td><td>' + (h.time || '-') + '</td></tr>' + detailRow;
        }).join('');

        return '<div class="progress-section"><h3>Test History (Last 10)</h3><table class="progress-table"><thead><tr><th>Date</th><th>Score</th><th>Mode</th><th>Time</th></tr></thead><tbody>' + rows + '</tbody></table></div>';
    },

    renderCategoryPerformance() {
        const catStats = {};
        const drillData = Store.get('drillProgress', {});
        for (const bank of BankManager.banks) {
            for (const q of bank.questions) {
                const cat = q.category || 'General';
                if (!catStats[cat]) catStats[cat] = { correct: 0, total: 0 };
                const prog = drillData[q.id];
                if (prog && prog.reps > 0) {
                    catStats[cat].total++;
                    if (prog.ef >= 2.5) catStats[cat].correct++;
                }
            }
        }

        const cats = Object.keys(catStats).filter(c => catStats[c].total > 0);
        if (cats.length === 0) {
            return '<div class="progress-section"><h3>Category Performance</h3><p style="color:var(--gray-600)">Complete some drills to see category performance.</p></div>';
        }

        const bars = cats.map(cat => {
            const pct = Math.round((catStats[cat].correct / catStats[cat].total) * 100);
            const colorClass = pct >= 70 ? 'good' : pct >= 50 ? 'warn' : 'bad';
            return '<div class="chart-row"><span class="chart-label">' + escapeHtml(cat) + '</span><div class="chart-bar-bg"><div class="chart-bar-fill ' + colorClass + '" style="width:' + pct + '%"></div></div><span class="chart-value">' + pct + '%</span></div>';
        }).join('');

        return '<div class="progress-section"><h3>Category Performance</h3><div class="progress-chart">' + bars + '</div></div>';
    },

    renderMasteryProgress() {
        const drillData = Store.get('drillProgress', {});
        let totalQ = 0;
        for (const bank of BankManager.banks) {
            totalQ += bank.questions.length;
        }

        const entries = Object.values(drillData);
        const mastered = entries.filter(d => d.ef >= 2.5 && d.reps >= 3).length;
        const learning = entries.filter(d => d.reps > 0 && !(d.ef >= 2.5 && d.reps >= 3)).length;
        const newQ = totalQ - mastered - learning;

        return '<div class="progress-section"><h3>Mastery Progress</h3><div class="mastery-grid"><div class="mastery-item mastered"><div class="value">' + mastered + '</div><div class="label">Mastered</div></div><div class="mastery-item learning"><div class="value">' + learning + '</div><div class="label">Learning</div></div><div class="mastery-item new"><div class="value">' + newQ + '</div><div class="label">New</div></div></div></div>';
    },

    toggleDetail(row) {
        if (!row || !row.classList.contains('test-detail-row')) return;
        row.style.display = row.style.display === 'none' ? '' : 'none';
    },

    renderStudyTime() {
        const stats = Store.get('globalStats', { totalStudyMins: 0, totalIdleMins: 0 });
        const studyByDay = Store.get('studyByDay', {});

        const days = [];
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        for (let i = 6; i >= 0; i--) {
            const d = new Date();
            d.setDate(d.getDate() - i);
            const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
            const dayName = dayNames[d.getDay()];
            const entry = Session.normalizeDayEntry(studyByDay[key]);
            days.push({ key, dayName, active: entry.active, idle: entry.idle });
        }

        const maxMins = Math.max(...days.map(d => d.active + d.idle), 1);
        const bars = days.map(d => {
            const totalHeight = Math.round(((d.active + d.idle) / maxMins) * 70);
            const idleHeight = totalHeight > 0 ? Math.round((d.idle / Math.max(d.active + d.idle, 1)) * totalHeight) : 0;
            const activeHeight = totalHeight - idleHeight;
            return `<div class="study-day" title="Active ${d.active}m | Idle ${d.idle}m"><div class="bar"><div class="bar-seg idle" style="height:${idleHeight}px"></div><div class="bar-seg active" style="height:${activeHeight}px"></div></div><span class="day-label">${d.dayName}</span></div>`;
        }).join('');

        return `<div class="progress-section"><h3>Study Time (Last 7 Days)</h3><p style="font-size:12px;color:var(--gray-600);margin:0">Blue = Active · Orange = Idle</p><div class="study-bars">${bars}</div><p style="text-align:center;font-size:12px;color:var(--gray-600);margin-top:8px">Active Total: ${stats.totalStudyMins || 0} m • Idle Logged: ${stats.totalIdleMins || 0} m</p></div>`;
    }
};

const Settings = {
    load() {
        document.getElementById('settingAnthropicKey').value = Store.get('anthropicKey', '');
        document.getElementById('settingAnthropicModel').value = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        document.getElementById('settingOpenaiKey').value = Store.get('openaiKey', '');
        document.getElementById('settingOpenaiModel').value = Store.get('openaiModel', 'gpt-4o-mini');
        document.getElementById('settingProvider').value = Store.get('provider', 'anthropic');
        // Load theme setting
        document.getElementById('settingTheme').value = Store.get('theme', 'system');
        // Load daily goal setting
        const stats = DailyGoal.getStats();
        document.getElementById('settingDailyGoal').value = stats.dailyGoal || 10;
        const eldenEnabled = Store.get('eldenModeEnabled', false);
        const eldenSelect = document.getElementById('settingEldenMode');
        if (eldenSelect) eldenSelect.value = eldenEnabled ? 'on' : 'off';
        this._applyEldenModeClass(eldenEnabled);
    },
    save() {
        Store.set('anthropicKey', document.getElementById('settingAnthropicKey').value.trim());
        Store.set('anthropicModel', document.getElementById('settingAnthropicModel').value);
        Store.set('openaiKey', document.getElementById('settingOpenaiKey').value.trim());
        Store.set('openaiModel', document.getElementById('settingOpenaiModel').value);
        Store.set('provider', document.getElementById('settingProvider').value);
        // Theme is already saved on change via Theme.apply()
        alert('Settings saved!');
    },
    setEldenMode(enabled) {
        Store.set('eldenModeEnabled', !!enabled);
        this._applyEldenModeClass(!!enabled);
    },
    isEldenModeEnabled() {
        return !!Store.get('eldenModeEnabled', false);
    },
    _applyEldenModeClass(enabled) {
        document.body.classList.toggle('elden-enabled', !!enabled);
    },
    exportAll() {
        // Flush gamification cache to localStorage before exporting
        Gamification.saveStateImmediate();
        const sensitiveKeys = ['wgu_anthropicKey', 'wgu_openaiKey', 'wgu_session_state'];
        const data = {};
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wgu_') && !sensitiveKeys.includes(key)) {
                try { data[key] = JSON.parse(localStorage.getItem(key)); }
                catch { data[key] = localStorage.getItem(key); }
            }
        }
        data._exportDate = new Date().toISOString();
        data._version = 1;
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'xoopers-battleground-backup-' + new Date().toISOString().split('T')[0] + '.json';
        a.click();
        URL.revokeObjectURL(url);
    },

    importAll(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (!data || typeof data !== 'object') throw new Error('Invalid format');
                const importSensitive = ['wgu_anthropicKey', 'wgu_openaiKey', 'wgu_session_state'];
                let imported = 0;
                for (const key in data) {
                    if (key.startsWith('_')) continue;
                    if (!key.startsWith('wgu_')) continue;
                    if (importSensitive.includes(key)) continue;
                    localStorage.setItem(key, typeof data[key] === 'string' ? data[key] : JSON.stringify(data[key]));
                    imported++;
                }
                alert('Imported ' + imported + ' data entries. Reloading...');
                Gamification._state = null; // Prevent beforeunload from overwriting imported data
                location.reload();
            } catch (err) {
                alert('Import failed: ' + err.message);
            }
        };
        reader.readAsText(file);
        input.value = '';
    },

    clearProgress() {
        if (!confirm('Clear ALL progress data? This cannot be undone.')) return;
        // Save settings BEFORE clearing
        const ak = Store.get('anthropicKey', '');
        const ok = Store.get('openaiKey', '');
        const provider = Store.get('provider', 'anthropic');
        const theme = Store.get('theme', 'system');
        const anthropicModel = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        const openaiModel = Store.get('openaiModel', 'gpt-4o-mini');
        const dailyGoal = (Store.get('globalStats', {}) || {}).dailyGoal || 10;
        const gamSettings = (Store.get('gamification', {}) || {}).settings;
        // Clear all wgu_ keys (preserve notes)
        const preservePrefixes = ['wgu_notes_'];
        const savedNotes = {};
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wgu_')) {
                if (preservePrefixes.some(p => key.startsWith(p))) {
                    savedNotes[key] = localStorage.getItem(key);
                } else {
                    keysToRemove.push(key);
                }
            }
        }
        keysToRemove.forEach(k => localStorage.removeItem(k));
        Object.entries(savedNotes).forEach(([k, v]) => localStorage.setItem(k, v));
        // Restore settings
        if (ak) Store.set('anthropicKey', ak);
        if (ok) Store.set('openaiKey', ok);
        Store.set('provider', provider);
        Store.set('theme', theme);
        Store.set('anthropicModel', anthropicModel);
        Store.set('openaiModel', openaiModel);
        const restoredStats = Store.get('globalStats', {});
        restoredStats.dailyGoal = dailyGoal;
        Store.set('globalStats', restoredStats);
        if (gamSettings) { const gs = Store.get('gamification', {}); gs.settings = gamSettings; Store.set('gamification', gs); }
        Gamification._state = null; // Invalidate cache after clearing storage
        Settings.load();
        alert('All progress cleared. Settings preserved.');
        Home.render();
    }
};

// =====================================================================
// NOTES
// =====================================================================
const Notes = {
    saveTimeout: null,
    isOpen: false,

    // Get storage key for current bank
    _getKey() {
        return App.bank ? `notes_${App.bank.bankId}` : null;
    },

    // Get all notes for current bank
    getAll() {
        const key = this._getKey();
        return key ? Store.get(key, {}) : {};
    },

    // Get note for specific question
    get(questionId) {
        const notes = this.getAll();
        return notes[questionId] || '';
    },

    // Save note for current question
    save() {
        const key = this._getKey();
        if (!key || !App.questions) return;

        const q = App.questions[App.currentQ];
        if (!q) return;

        const textarea = document.getElementById('noteTextarea');
        const text = textarea.value.trim();
        const notes = this.getAll();

        if (text) {
            notes[q.id] = text;
        } else {
            delete notes[q.id];
        }

        Store.set(key, notes);
        this._showSaved();
        this._updateUI();
    },

    // Debounced auto-save on input
    onInput() {
        if (this.saveTimeout) clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => this.save(), 1000);
    },

    // Show "Note saved" indicator
    _showSaved() {
        const el = document.getElementById('noteSaved');
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 2000);
    },

    // Toggle note panel visibility
    toggle() {
        this.isOpen = !this.isOpen;
        document.getElementById('notePanel').classList.toggle('open', this.isOpen);
        if (this.isOpen) {
            document.getElementById('noteTextarea').focus();
        }
    },

    // Close note panel
    close() {
        this.isOpen = false;
        document.getElementById('notePanel').classList.remove('open');
    },

    // Load note for current question
    load() {
        if (!App.questions) return;
        const q = App.questions[App.currentQ];
        if (!q) return;

        const note = this.get(q.id);
        document.getElementById('noteTextarea').value = note;
        this._updateUI();
    },

    // Update note button and palette indicators
    _updateUI() {
        if (!App.questions) return;
        const q = App.questions[App.currentQ];
        const hasNote = q && this.get(q.id);

        // Update note button
        const btn = document.getElementById('btnNote');
        if (btn) {
            btn.classList.toggle('has-note', !!hasNote);
            const label = btn.querySelector('.tool-label');
            if (label) label.textContent = hasNote ? 'Notes *' : 'Notes';
        }

        // Update palette indicators
        this._updatePaletteIndicators();
    },

    // Update palette buttons to show note indicators
    _updatePaletteIndicators() {
        if (!App.questions) return;
        const notes = this.getAll();

        for (let i = 0; i < App.questions.length; i++) {
            const q = App.questions[i];
            const el = document.getElementById('qp-' + i);
            if (el) {
                el.classList.toggle('has-note', !!notes[q.id]);
            }
        }
    },

    // Check if a question has a note
    hasNote(questionId) {
        return !!this.get(questionId);
    },

    // Export all notes as JSON
    exportAll() {
        const allNotes = {};
        let hasNotes = false;

        // Collect notes from all banks
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wgu_notes_')) {
                try {
                    const bankId = key.replace('wgu_notes_', '');
                    const notes = JSON.parse(localStorage.getItem(key));
                    if (Object.keys(notes).length > 0) {
                        allNotes[bankId] = notes;
                        hasNotes = true;
                    }
                } catch {}
            }
        }

        if (!hasNotes) {
            alert('No notes to export.');
            return;
        }

        // Create and download JSON file
        const blob = new Blob([JSON.stringify(allNotes, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `wgu-notes-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }
};

// =====================================================================
// AI CHAT
// =====================================================================
const Chat = {
    history: [],
    isOpen: false,

    toggle() {
        this.isOpen = !this.isOpen;
        if (!this.isOpen) this.stopSpeech();
        document.getElementById('chatPanel').classList.toggle('open', this.isOpen);
        document.getElementById('chatFab').style.display = this.isOpen ? 'none' : '';
        if (this.isOpen && this.history.length === 0) {
            this.addMessage('system', 'Ask me anything about the current question. I can explain concepts, walk through solutions, or clarify options.');
        }
    },

    close() {
        this.isOpen = false;
        document.getElementById('chatPanel').classList.remove('open');
        this.stopSpeech();
    },

    clearHistory() {
        this.history = [];
        document.getElementById('chatMessages').innerHTML = '';
    },

    addMessage(role, content, skipTts) {
        const div = document.createElement('div');
        div.className = 'chat-msg ' + role;
        // Strip markdown formatting from assistant messages
        const cleanContent = role === 'assistant' ? this._stripMarkdown(content) : content;
        div.textContent = cleanContent;
        // Add TTS button to assistant messages
        if (role === 'assistant' && cleanContent !== 'Thinking...') {
            const ttsBtn = document.createElement('button');
            ttsBtn.className = 'chat-tts-btn';
            ttsBtn.innerHTML = '&#128264;';
            ttsBtn.title = 'Read aloud';
            ttsBtn.onclick = (e) => { e.stopPropagation(); Chat.speakMessage(cleanContent, ttsBtn); };
            div.style.position = 'relative';
            div.appendChild(ttsBtn);
        }
        document.getElementById('chatMessages').appendChild(div);
        document.getElementById('chatMessages').scrollTop = 999999;
    },

    _stripMarkdown(text) {
        return text
            .replace(/\*\*([^*]+)\*\*/g, '$1')   // **bold**
            .replace(/\*([^*]+)\*/g, '$1')         // *italic*
            .replace(/__([^_]+)__/g, '$1')         // __bold__
            .replace(/_([^_]+)_/g, '$1')           // _italic_
            .replace(/^#{1,6}\s+/gm, '')           // # headings
            .replace(/^[-*+]\s+/gm, '- ')          // bullet lists keep dash
            .replace(/^\d+\.\s+/gm, (m) => m)     // numbered lists stay
            .replace(/`([^`]+)`/g, '$1')           // `code`
            .replace(/```[\s\S]*?```/g, (m) => m.replace(/```\w*\n?/g, '').trim()) // code blocks
            .trim();
    },

    async send() {
        const input = document.getElementById('chatInput');
        const text = input.value.trim();
        if (!text) return;
        input.value = '';

        if (!navigator.onLine) {
            this.addMessage('system', 'You are offline. Chat requires an internet connection.');
            return;
        }

        const provider = Store.get('provider', 'anthropic');
        const apiKey = provider === 'openai' ? Store.get('openaiKey', '') : Store.get('anthropicKey', '');
        if (!apiKey) {
            this.addMessage('system', `Please set your ${provider === 'openai' ? 'OpenAI' : 'Anthropic'} API key in Settings first.`);
            return;
        }

        this.addMessage('user', text);

        // Build context
        let ctx = App.getQuestionContext() || Drill.getQuestionContext() || AIPractice.getQuestionContext();
        let systemPrompt = 'You are a WGU tutor helping a student study for their assessment. Be concise and conversational. Use plain text only - no markdown, no asterisks, no bullet points, no bold/italic formatting. Write like you are talking to a friend. Keep explanations simple and easy to follow. If the student asks about a specific question, reference the question context provided.';

        if (ctx) {
            systemPrompt += `\n\nCurrent question (#${ctx.number}):\n"${ctx.text}"\n\nOptions:\n${ctx.options.map((o, i) => `${String.fromCharCode(65+i)}. ${o}`).join('\n')}\n\nCorrect answer: ${String.fromCharCode(65+ctx.correctAnswer)}. ${ctx.correctText}`;
            if (ctx.explanation) systemPrompt += `\n\nExplanation: ${ctx.explanation}`;
            if (ctx.userAnswer !== undefined && ctx.userAnswer !== null) {
                systemPrompt += `\n\nStudent selected: ${String.fromCharCode(65+ctx.userAnswer)}. ${ctx.userAnswerText}`;
            }
        }

        this.history.push({ role: 'user', content: text });
        const messages = this.history.slice(-20);

        try {
            this.addMessage('assistant', 'Thinking...');
            const lastMsg = document.getElementById('chatMessages').lastChild;

            let reply;
            if (provider === 'openai') {
                reply = await this._sendOpenAI(apiKey, systemPrompt, messages);
            } else {
                reply = await this._sendAnthropic(apiKey, systemPrompt, messages);
            }

            const cleanReply = this._stripMarkdown(reply);
            lastMsg.textContent = cleanReply;
            // Add TTS button to the response
            const ttsBtn = document.createElement('button');
            ttsBtn.className = 'chat-tts-btn';
            ttsBtn.innerHTML = '&#128264;';
            ttsBtn.title = 'Read aloud';
            ttsBtn.onclick = (e) => { e.stopPropagation(); Chat.speakMessage(cleanReply, ttsBtn); };
            lastMsg.style.position = 'relative';
            lastMsg.appendChild(ttsBtn);
            this.history.push({ role: 'assistant', content: reply });
        } catch (err) {
            const msgs = document.getElementById('chatMessages');
            if (msgs.lastChild) {
                msgs.lastChild.textContent = err.message || 'Connection error. Check your API key and internet.';
                msgs.lastChild.className = 'chat-msg system';
            }
        }
    },

    async _sendAnthropic(apiKey, systemPrompt, messages) {
        const model = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({ model, max_tokens: 1024, system: systemPrompt, messages })
        });
        clearTimeout(timeout);
        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`Claude error: ${err.error?.message || resp.statusText}`);
        }
        const data = await resp.json();
        return data.content?.[0]?.text || 'No response';
    },

    async _sendOpenAI(apiKey, systemPrompt, messages) {
        const model = Store.get('openaiModel', 'gpt-4o-mini');
        const oaiMessages = [{ role: 'system', content: systemPrompt }, ...messages];
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify({ model, max_tokens: 1024, messages: oaiMessages })
        });
        clearTimeout(timeout);
        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`OpenAI error: ${err.error?.message || resp.statusText}`);
        }
        const data = await resp.json();
        return data.choices?.[0]?.message?.content || 'No response';
    },

    speakMessage(text, btn) {
        if (!('speechSynthesis' in window)) return;
        if (speechSynthesis.speaking) {
            speechSynthesis.cancel();
            document.querySelectorAll('.chat-tts-btn.speaking').forEach(b => b.classList.remove('speaking'));
            if (btn && btn.classList.contains('speaking')) { btn.classList.remove('speaking'); return; }
        }
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.95;
        utterance.pitch = 1;
        if (btn) btn.classList.add('speaking');
        utterance.onend = () => { if (btn) btn.classList.remove('speaking'); };
        utterance.onerror = () => { if (btn) btn.classList.remove('speaking'); };
        speechSynthesis.speak(utterance);
    },

    stopSpeech() {
        if (!('speechSynthesis' in window)) return;
        if (speechSynthesis.speaking || speechSynthesis.pending) {
            speechSynthesis.cancel();
            document.querySelectorAll('.chat-tts-btn.speaking').forEach(b => b.classList.remove('speaking'));
        }
    }
};

// =====================================================================
// CALCULATOR
// =====================================================================
const Calc = {
    isOpen: false,
    expr: '',
    panel: null,
    display: null,
    dragHandle: null,

    init() {
        if (this.panel) return;
        this.panel = document.getElementById('calcPanel');
        this.display = document.getElementById('calcDisplay');
        if (!this.panel) return;
        this.dragHandle = this.panel.querySelector('.calc-header');
        this._restorePosition();
        this._ensureDraggable();
    },

    toggle(forceState) {
        if (!this.panel) this.init();
        const nextState = typeof forceState === 'boolean' ? forceState : !this.isOpen;
        this.isOpen = nextState;
        if (this.panel) this.panel.classList.toggle('open', this.isOpen);
        const btn = document.getElementById('btnCalc');
        if (btn) btn.classList.toggle('active', this.isOpen);
    },

    clear() {
        this.expr = '';
        if (!this.display) this.display = document.getElementById('calcDisplay');
        if (this.display) this.display.textContent = '0';
    },

    input(val) {
        this.expr += val;
        if (!this.display) this.display = document.getElementById('calcDisplay');
        if (this.display) this.display.textContent = this.expr || '0';
    },

    backspace() {
        this.expr = this.expr.slice(0, -1);
        if (!this.display) this.display = document.getElementById('calcDisplay');
        if (this.display) this.display.textContent = this.expr || '0';
    },

    equals() {
        try {
            // Safe eval using Function constructor
            const sanitized = this.expr.replace(/[^0-9+\-*/().]/g, '');
            const result = Function('"use strict"; return (' + sanitized + ')')();
            if (!isFinite(result)) {
                if (!this.display) this.display = document.getElementById('calcDisplay');
                if (this.display) this.display.textContent = 'Error';
                this.expr = '';
                return;
            }
            const rounded = Math.round(result * 1000000) / 1000000;
            if (!this.display) this.display = document.getElementById('calcDisplay');
            if (this.display) this.display.textContent = rounded;
            this.expr = String(rounded);
        } catch {
            if (!this.display) this.display = document.getElementById('calcDisplay');
            if (this.display) this.display.textContent = 'Error';
            this.expr = '';
        }
    },

    _restorePosition() {
        const state = Gamification.getState?.();
        const pos = state?.settings?.calcPosition;
        if (!this.panel) return;
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
            this.panel.style.left = pos.left + 'px';
            this.panel.style.top = pos.top + 'px';
            this.panel.style.bottom = 'auto';
            this.panel.style.right = 'auto';
        }
    },

    _ensureDraggable() {
        if (!this.panel || !this.dragHandle || this.dragHandle.dataset.dragInit === '1') return;
        this.dragHandle.dataset.dragInit = '1';

        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
        let pointerId = null;
        let offsetX = 0;
        let offsetY = 0;

        const onPointerMove = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            e.preventDefault();
            const maxLeft = Math.max(8, window.innerWidth - this.panel.offsetWidth - 8);
            const maxTop = Math.max(8, window.innerHeight - this.panel.offsetHeight - 8);
            const left = clamp(e.clientX - offsetX, 8, maxLeft);
            const top = clamp(e.clientY - offsetY, 8, maxTop);
            this.panel.style.left = left + 'px';
            this.panel.style.top = top + 'px';
            this.panel.style.right = 'auto';
            this.panel.style.bottom = 'auto';
            Gamification.saveWidgetPosition('calcPosition', { left, top });
        };

        const endDrag = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            this.dragHandle.releasePointerCapture(pointerId);
            pointerId = null;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', endDrag);
            document.removeEventListener('pointercancel', endDrag);
            this.panel.classList.remove('dragging');
        };

        this.dragHandle.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            pointerId = e.pointerId;
            const rect = this.panel.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            this.dragHandle.setPointerCapture(pointerId);
            this.panel.classList.add('dragging');
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', endDrag);
            document.addEventListener('pointercancel', endDrag);
        });
    }
};

// =====================================================================
// INLINE CHART RENDERER (Canvas 2D)
// =====================================================================
const InlineChart = {
    // Replace [Graph: ...] placeholders with rendered charts
    renderInElement(el, graphData) {
        if (!graphData || !el) return;
        const html = el.innerHTML;
        if (!html.includes('[Graph:')) return;

        // Replace placeholder with canvas container
        el.innerHTML = html.replace(/\[Graph:[^\]]*\]/g, () => {
            const id = 'chart-' + Math.random().toString(36).substr(2, 9);
            return `<div class="inline-chart-wrap"><canvas id="${id}" width="560" height="320"></canvas></div>`;
        });

        // Render after DOM update
        requestAnimationFrame(() => {
            const canvases = el.querySelectorAll('canvas');
            canvases.forEach(canvas => this.draw(canvas, graphData));
        });
    },

    draw(canvas, gd) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.clientWidth || 560;
        const h = canvas.clientHeight || 320;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.scale(dpr, dpr);

        // Colors based on theme
        const isDark = Theme.isDark();
        const colors = isDark
            ? { bg: '#16213e', axes: '#9ca3af', grid: '#374151', text: '#d1d5db', title: '#93c5fd', line1: '#60a5fa', line2: '#f59e0b', dot: '#60a5fa', dot2: '#f59e0b', fill: 'rgba(96,165,250,0.15)', regLine: '#ef4444' }
            : { bg: '#ffffff', axes: '#555', grid: '#e5e5e5', text: '#555', title: '#1a3a5c', line1: '#2980b9', line2: '#e67e22', dot: '#2980b9', dot2: '#e67e22', fill: 'rgba(41,128,185,0.1)', regLine: '#c0392b' };

        // Margins
        const m = { top: 36, right: 20, bottom: 44, left: 56 };
        const pw = w - m.left - m.right;
        const ph = h - m.top - m.bottom;

        // Background
        ctx.fillStyle = colors.bg;
        ctx.fillRect(0, 0, w, h);

        // Data bounds
        const series = gd.series || [{ data: gd.data || [] }];
        let allPts = series.flatMap(s => s.data || []);
        if (allPts.length === 0) return;

        let xMin = gd.xMin != null ? gd.xMin : Math.min(...allPts.map(p => p.x));
        let xMax = gd.xMax != null ? gd.xMax : Math.max(...allPts.map(p => p.x));
        let yMin = gd.yMin != null ? gd.yMin : Math.min(...allPts.map(p => p.y));
        let yMax = gd.yMax != null ? gd.yMax : Math.max(...allPts.map(p => p.y));

        // Add padding
        if (xMin === xMax) { xMin -= 1; xMax += 1; }
        if (yMin === yMax) { yMin -= 1; yMax += 1; }
        const xPad = (xMax - xMin) * 0.05;
        const yPad = (yMax - yMin) * 0.08;
        if (gd.xMin == null) xMin -= xPad;
        if (gd.xMax == null) xMax += xPad;
        if (gd.yMin == null) yMin -= yPad;
        if (gd.yMax == null) yMax += yPad;

        const sx = v => m.left + ((v - xMin) / (xMax - xMin)) * pw;
        const sy = v => m.top + ph - ((v - yMin) / (yMax - yMin)) * ph;

        // Grid lines
        ctx.strokeStyle = colors.grid;
        ctx.lineWidth = 0.5;
        const xTicks = this._niceTicks(xMin, xMax, 8);
        const yTicks = this._niceTicks(yMin, yMax, 6);
        const xTickFormatter = this._normalizeTickFormatter(gd.xTickFormat);
        const yTickFormatter = this._normalizeTickFormatter(gd.yTickFormat);

        xTicks.forEach(v => {
            ctx.beginPath(); ctx.moveTo(sx(v), m.top); ctx.lineTo(sx(v), m.top + ph); ctx.stroke();
        });
        yTicks.forEach(v => {
            ctx.beginPath(); ctx.moveTo(m.left, sy(v)); ctx.lineTo(m.left + pw, sy(v)); ctx.stroke();
        });

        // Axes
        ctx.strokeStyle = colors.axes;
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(m.left, m.top); ctx.lineTo(m.left, m.top + ph); ctx.lineTo(m.left + pw, m.top + ph); ctx.stroke();

        // Tick labels
        ctx.fillStyle = colors.text;
        ctx.font = '11px Arial';
        ctx.textAlign = 'center';
        xTicks.forEach(v => {
            const label = xTickFormatter ? xTickFormatter(v) : this._fmtNum(v);
            ctx.fillText(label, sx(v), m.top + ph + 16);
        });
        ctx.textAlign = 'right';
        yTicks.forEach(v => {
            const label = yTickFormatter ? yTickFormatter(v) : this._fmtNum(v);
            ctx.fillText(label, m.left - 6, sy(v) + 4);
        });

        // Axis labels
        ctx.fillStyle = colors.text;
        ctx.font = '12px Arial';
        ctx.textAlign = 'center';
        if (gd.xLabel) ctx.fillText(gd.xLabel, m.left + pw / 2, h - 4);
        ctx.save();
        ctx.translate(14, m.top + ph / 2);
        ctx.rotate(-Math.PI / 2);
        if (gd.yLabel) ctx.fillText(gd.yLabel, 0, 0);
        ctx.restore();

        // Title
        ctx.fillStyle = colors.title;
        ctx.font = 'bold 13px Arial';
        ctx.textAlign = 'center';
        if (gd.title) ctx.fillText(gd.title, w / 2, 18);

        // Horizontal asymptotes
        if (gd.asymptotes) {
            ctx.setLineDash([6, 4]);
            ctx.strokeStyle = colors.regLine;
            ctx.lineWidth = 1;
            gd.asymptotes.forEach(a => {
                const y = sy(a.y);
                ctx.beginPath(); ctx.moveTo(m.left, y); ctx.lineTo(m.left + pw, y); ctx.stroke();
                if (a.label) {
                    ctx.fillStyle = colors.regLine;
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(a.label, m.left + pw - 60, y - 4);
                }
            });
            ctx.setLineDash([]);
        }

        // Draw each series
        const seriesColors = [colors.line1, colors.line2, '#2ecc71', '#9b59b6'];
        const dotColors = [colors.dot, colors.dot2, '#27ae60', '#8e44ad'];

        series.forEach((s, si) => {
            const data = s.data || [];
            if (data.length === 0) return;
            const sorted = [...data].sort((a, b) => a.x - b.x);
            const col = seriesColors[si % seriesColors.length];
            const dcol = dotColors[si % dotColors.length];
            const type = s.type || gd.type || 'line';

            if (type === 'line' || type === 'curve') {
                // Area fill
                if (si === 0 && !gd.noFill) {
                    ctx.fillStyle = colors.fill;
                    ctx.beginPath();
                    ctx.moveTo(sx(sorted[0].x), sy(yMin > 0 ? yMin : 0));
                    sorted.forEach(p => ctx.lineTo(sx(p.x), sy(p.y)));
                    ctx.lineTo(sx(sorted[sorted.length - 1].x), sy(yMin > 0 ? yMin : 0));
                    ctx.closePath();
                    ctx.fill();
                }

                // Line
                ctx.strokeStyle = col;
                ctx.lineWidth = 2.5;
                ctx.setLineDash(s.dashed ? [8, 4] : []);
                ctx.beginPath();
                if (type === 'curve' && sorted.length > 2) {
                    // Smooth curve using cardinal spline
                    ctx.moveTo(sx(sorted[0].x), sy(sorted[0].y));
                    for (let i = 0; i < sorted.length - 1; i++) {
                        const p0 = sorted[Math.max(0, i - 1)];
                        const p1 = sorted[i];
                        const p2 = sorted[i + 1];
                        const p3 = sorted[Math.min(sorted.length - 1, i + 2)];
                        const cp1x = sx(p1.x) + (sx(p2.x) - sx(p0.x)) / 6;
                        const cp1y = sy(p1.y) + (sy(p2.y) - sy(p0.y)) / 6;
                        const cp2x = sx(p2.x) - (sx(p3.x) - sx(p1.x)) / 6;
                        const cp2y = sy(p2.y) - (sy(p3.y) - sy(p1.y)) / 6;
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, sx(p2.x), sy(p2.y));
                    }
                } else {
                    sorted.forEach((p, i) => i === 0 ? ctx.moveTo(sx(p.x), sy(p.y)) : ctx.lineTo(sx(p.x), sy(p.y)));
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Dots
                sorted.forEach(p => {
                    ctx.fillStyle = dcol;
                    ctx.beginPath();
                    ctx.arc(sx(p.x), sy(p.y), 3.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            } else if (type === 'scatter') {
                // Scatter dots
                data.forEach(p => {
                    ctx.fillStyle = dcol;
                    ctx.beginPath();
                    ctx.arc(sx(p.x), sy(p.y), 4.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = col;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            } else if (type === 'bar') {
                const barW = Math.max(8, pw / data.length * 0.6);
                data.forEach(p => {
                    ctx.fillStyle = col;
                    const x0 = sx(p.x) - barW / 2;
                    const y0 = sy(Math.max(p.y, 0));
                    const yBase = sy(0);
                    ctx.fillRect(x0, Math.min(y0, yBase), barW, Math.abs(yBase - y0));
                });
            }

            // Series label
            if (s.label) {
                ctx.fillStyle = col;
                ctx.font = '11px Arial';
                ctx.textAlign = 'left';
                const lastP = sorted[sorted.length - 1];
                ctx.fillText(s.label, sx(lastP.x) + 6, sy(lastP.y) + 4);
            }
        });

        // Regression line
        if (gd.regression) {
            const r = gd.regression;
            ctx.strokeStyle = colors.regLine;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 3]);
            if (r.type === 'linear') {
                const x1 = xMin, x2 = xMax;
                ctx.beginPath();
                ctx.moveTo(sx(x1), sy(r.slope * x1 + r.intercept));
                ctx.lineTo(sx(x2), sy(r.slope * x2 + r.intercept));
                ctx.stroke();
            } else if (r.type === 'exponential' && r.fn) {
                ctx.beginPath();
                const steps = 80;
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * (i / steps);
                    const y = r.fn(x);
                    i === 0 ? ctx.moveTo(sx(x), sy(y)) : ctx.lineTo(sx(x), sy(y));
                }
                ctx.stroke();
            } else if (r.type === 'polynomial' && r.fn) {
                ctx.beginPath();
                const steps = 80;
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * (i / steps);
                    const y = r.fn(x);
                    i === 0 ? ctx.moveTo(sx(x), sy(y)) : ctx.lineTo(sx(x), sy(y));
                }
                ctx.stroke();
            } else if (r.type === 'logistic' && r.fn) {
                ctx.beginPath();
                const steps = 80;
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * (i / steps);
                    const y = r.fn(x);
                    i === 0 ? ctx.moveTo(sx(x), sy(y)) : ctx.lineTo(sx(x), sy(y));
                }
                ctx.stroke();
            }
            ctx.setLineDash([]);
            if (r.r2 != null) {
                ctx.fillStyle = colors.regLine;
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('r\u00B2 = ' + r.r2.toFixed(2), m.left + pw - 4, m.top + 16);
            }
        }

        // Annotations
        if (gd.annotations) {
            gd.annotations.forEach(a => {
                ctx.fillStyle = colors.regLine;
                ctx.font = '10px Arial';
                ctx.textAlign = a.align || 'left';
                ctx.fillText(a.text, sx(a.x) + (a.dx || 4), sy(a.y) + (a.dy || -8));
                // Dot marker
                ctx.beginPath();
                ctx.arc(sx(a.x), sy(a.y), 5, 0, Math.PI * 2);
                ctx.fillStyle = colors.regLine;
                ctx.fill();
            });
        }
    },

    _niceTicks(min, max, count) {
        const range = max - min;
        const rough = range / count;
        const mag = Math.pow(10, Math.floor(Math.log10(rough)));
        let step;
        const norm = rough / mag;
        if (norm <= 1.5) step = 1 * mag;
        else if (norm <= 3) step = 2 * mag;
        else if (norm <= 7) step = 5 * mag;
        else step = 10 * mag;
        const start = Math.ceil(min / step) * step;
        const ticks = [];
        for (let v = start; v <= max + step * 0.01; v += step) {
            ticks.push(Math.round(v * 1e10) / 1e10);
        }
        return ticks;
    },

    _fmtNum(v) {
        if (!Number.isFinite(v)) return '0';
        const abs = Math.abs(v);
        if (abs >= 1e9) {
            return (v / 1e9).toFixed(abs >= 1e10 ? 1 : 2).replace(/\.0+$/, '') + 'B';
        }
        if (abs >= 1e6) {
            return (v / 1e6).toFixed(abs >= 1e7 ? 1 : 2).replace(/\.0+$/, '') + 'M';
        }
        if (Number.isInteger(v) && abs >= 1000) {
            return Math.round(v).toString();
        }
        if (Number.isInteger(v)) return v.toString();
        const precision = abs >= 100 ? 1 : 2;
        return v.toFixed(precision).replace(/\.0+$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
    },

    _normalizeTickFormatter(format) {
        if (!format) return null;
        if (typeof format === 'function') return format;
        if (typeof format === 'string') {
            const key = format.trim().toLowerCase();
            if (['militaryclock', 'military', '24h', '24hour', 'hundreds', 'hundredsclock', 'time-24h'].includes(key)) {
                return (v) => this._formatHundredsClock(v);
            }
        }
        return null;
    },

    _formatHundredsClock(value) {
        if (!Number.isFinite(value)) return '00:00';
        const isNegative = value < 0;
        const absVal = Math.abs(Math.round(value));
        let hours = Math.floor(absVal / 100);
        let minutes = absVal % 100;
        if (minutes >= 60) {
            hours += Math.floor(minutes / 60);
            minutes = minutes % 60;
        }
        hours = hours % 24;
        const prefix = isNegative ? '-' : '';
        return `${prefix}${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    }
};

// =====================================================================
// AUDIO (Text-to-Speech)
// =====================================================================
const Audio = {
    speaking: false,

    speak() {
        if (!('speechSynthesis' in window)) {
            alert('Text-to-speech not supported in this browser.');
            return;
        }

        if (this.speaking) {
            speechSynthesis.cancel();
            this.speaking = false;
            document.getElementById('btnAudio').classList.remove('active');
            return;
        }

        // Get current question text
        let text = '';
        const screen = document.getElementById('screen-exam');
        if (screen.classList.contains('active')) {
            const q = App.questions[App.currentQ];
            if (q) {
                text = `Question ${App.currentQ + 1}. ${this._cleanText(q.text)}. `;
                text += 'Options: ';
                q.options.forEach((opt, i) => {
                    text += `${String.fromCharCode(65 + i)}: ${this._cleanText(opt)}. `;
                });
            }
        } else if (document.getElementById('screen-drill').classList.contains('active') && Drill.current) {
            const q = Drill.current.question;
            text = `${this._cleanText(q.text)}. Options: `;
            q.options.forEach((opt, i) => {
                text += `${String.fromCharCode(65 + i)}: ${this._cleanText(opt)}. `;
            });
        } else if (document.getElementById('screen-ai-practice').classList.contains('active') && AIPractice.currentQuestion) {
            const q = AIPractice.currentQuestion;
            text = `${this._cleanText(q.question)}. Options: `;
            q.options.forEach((opt, i) => {
                text += `${String.fromCharCode(65 + i)}: ${this._cleanText(opt)}. `;
            });
        }

        if (!text) {
            alert('No question to read.');
            return;
        }

        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = 0.95;
        utterance.pitch = 1;
        utterance.onend = () => {
            this.speaking = false;
            document.getElementById('btnAudio').classList.remove('active');
        };
        utterance.onerror = () => {
            this.speaking = false;
            document.getElementById('btnAudio').classList.remove('active');
        };

        this.speaking = true;
        document.getElementById('btnAudio').classList.add('active');
        speechSynthesis.speak(utterance);
    },

    _cleanText(text) {
        // Remove HTML tags and simplify for speech
        return text
            .replace(/<[^>]*>/g, '')
            .replace(/\[Graph[^\]]*\]/gi, 'See the graph provided.')
            .replace(/\$(\d[\d,.]*)/g, '$1 dollars')  // $50 → "50 dollars"
            .replace(/\$/g, '')                         // Remove remaining $ (LaTeX delimiters)
            .replace(/\n/g, '. ')
            .trim();
    },

    stop() {
        if (this.speaking) {
            speechSynthesis.cancel();
            this.speaking = false;
            const btn = document.getElementById('btnAudio');
            if (btn) btn.classList.remove('active');
        }
    }
};

// =====================================================================
// METRICS TRACKING
// =====================================================================
const Metrics = {
    questionTimes: {},  // { qIndex: { start, end, total } }
    currentStart: 0,

    startQuestion(qIndex) {
        if (!this.questionTimes[qIndex]) {
            this.questionTimes[qIndex] = { total: 0, visits: 0 };
        }
        this.currentStart = Date.now();
        this.questionTimes[qIndex].visits++;
    },

    endQuestion(qIndex) {
        if (this.currentStart && this.questionTimes[qIndex]) {
            this.questionTimes[qIndex].total += Date.now() - this.currentStart;
        }
        this.currentStart = 0;
    },

    getTimeSpent(qIndex) {
        const data = this.questionTimes[qIndex];
        if (!data) return 0;
        let time = data.total;
        if (this.currentStart && App.currentQ === qIndex) {
            time += Date.now() - this.currentStart;
        }
        return time;
    },

    getTotalTime() {
        let total = 0;
        for (const qIndex in this.questionTimes) {
            total += this.getTimeSpent(parseInt(qIndex));
        }
        return total;
    },

    getAvgTimePerQuestion() {
        const visited = Object.keys(this.questionTimes).length;
        return visited > 0 ? this.getTotalTime() / visited : 0;
    },

    reset() {
        this.questionTimes = {};
        this.currentStart = 0;
    },

    // Get stats by category
    getCategoryStats(questions, answers) {
        const catStats = {};
        questions.forEach((q, i) => {
            const cat = q.category || 'General';
            if (!catStats[cat]) {
                catStats[cat] = { correct: 0, total: 0, time: 0, answered: 0 };
            }
            catStats[cat].total++;
            if (answers[i] !== undefined) {
                catStats[cat].answered++;
                const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
                if (answers[i] === correctIdx) catStats[cat].correct++;
            }
            catStats[cat].time += this.getTimeSpent(i);
        });
        return catStats;
    },

    // Get answer change statistics
    getAnswerChangeStats(questions, answers, answerHistory) {
        let totalChanges = 0;
        let changedQuestions = 0;
        const changedFromCorrect = [];  // Questions where first answer was correct but final was wrong
        const changedToCorrect = [];    // Questions where first answer was wrong but final was correct

        for (const qIdx in answerHistory) {
            const history = answerHistory[qIdx];
            if (history.length > 1) {
                changedQuestions++;
                totalChanges += history.length - 1;

                const q = questions[qIdx];
                const firstAnswer = history[0];
                const finalAnswer = answers[qIdx];
                const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;

                if (firstAnswer === correctIdx && finalAnswer !== correctIdx) {
                    changedFromCorrect.push(parseInt(qIdx));
                } else if (firstAnswer !== correctIdx && finalAnswer === correctIdx) {
                    changedToCorrect.push(parseInt(qIdx));
                }
            }
        }
        return { totalChanges, changedQuestions, changedFromCorrect, changedToCorrect };
    },

    // Get first attempt accuracy statistics
    getFirstAttemptStats(questions, answers, answerHistory) {
        let firstAttemptCorrect = 0;
        let finalCorrect = 0;
        let answeredCount = 0;

        for (const qIdx in answers) {
            const q = questions[qIdx];
            const finalAnswer = answers[qIdx];
            answeredCount++;

            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (finalAnswer === correctIdx) {
                finalCorrect++;
            }

            // Check first attempt
            const history = answerHistory[qIdx];
            if (history && history.length > 0) {
                if (history[0] === correctIdx) {
                    firstAttemptCorrect++;
                }
            }
        }

        return {
            firstAttemptCorrect,
            finalCorrect,
            answeredCount,
            firstAccuracy: answeredCount > 0 ? Math.round((firstAttemptCorrect / answeredCount) * 100) : 0,
            finalAccuracy: answeredCount > 0 ? Math.round((finalCorrect / answeredCount) * 100) : 0
        };
    },

    // Get confidence vs accuracy correlation
    getConfidenceStats(questions, answers, confidence) {
        const stats = {
            1: { correct: 0, total: 0, label: 'Maybe' },
            2: { correct: 0, total: 0, label: 'Probably' },
            3: { correct: 0, total: 0, label: 'Definitely' }
        };

        for (const qIdx in confidence) {
            const level = confidence[qIdx];
            if (answers[qIdx] !== undefined && stats[level]) {
                stats[level].total++;
                if (answers[qIdx] === questions[qIdx].correctAnswer) {
                    stats[level].correct++;
                }
            }
        }

        return stats;
    },

    // Get questions with multiple revisits
    getRevisitedQuestions() {
        const revisited = [];
        for (const qIdx in this.questionTimes) {
            const visits = this.questionTimes[qIdx].visits;
            if (visits > 1) {
                revisited.push({ index: parseInt(qIdx), visits });
            }
        }
        return revisited.sort((a, b) => b.visits - a.visits);
    },

    // Build metrics summary HTML for score screen
    buildMetricsSummary(questions, answers) {
        const totalTime = this.getTotalTime();
        const avgTime = this.getAvgTimePerQuestion();
        const catStats = this.getCategoryStats(questions, answers);

        // New metrics
        const answerChangeStats = this.getAnswerChangeStats(questions, answers, App.answerHistory);
        const firstAttemptStats = this.getFirstAttemptStats(questions, answers, App.answerHistory);
        const confidenceStats = this.getConfidenceStats(questions, answers, App.confidence);
        const revisitedQuestions = this.getRevisitedQuestions();

        // Find slowest and fastest questions
        const times = [];
        for (let i = 0; i < questions.length; i++) {
            times.push({ index: i, time: this.getTimeSpent(i) });
        }
        times.sort((a, b) => b.time - a.time);
        const slowest = times.slice(0, 3).filter(t => t.time > 0);

        let html = '<div class="metrics-summary"><h3>Performance Metrics</h3>';
        html += '<div class="metrics-grid">';
        html += `<div class="metric-item"><div class="metric-val">${this._formatTime(totalTime)}</div><div class="metric-lbl">Total Time</div></div>`;
        html += `<div class="metric-item"><div class="metric-val">${this._formatTime(avgTime)}</div><div class="metric-lbl">Avg per Question</div></div>`;
        html += `<div class="metric-item"><div class="metric-val">${Object.keys(this.questionTimes).length}</div><div class="metric-lbl">Questions Viewed</div></div>`;
        html += `<div class="metric-item"><div class="metric-val">${answerChangeStats.totalChanges}</div><div class="metric-lbl">Answer Changes</div></div>`;
        html += '</div>';

        // First Attempt vs Final Accuracy
        if (firstAttemptStats.answeredCount > 0) {
            html += '<div class="time-per-q" style="margin-top:16px"><strong>First Attempt vs Final Accuracy:</strong>';
            html += '<table><tr><th>Metric</th><th>Correct</th><th>Accuracy</th></tr>';
            html += `<tr><td>First Attempt</td><td>${firstAttemptStats.firstAttemptCorrect}/${firstAttemptStats.answeredCount}</td><td>${firstAttemptStats.firstAccuracy}%</td></tr>`;
            html += `<tr><td>Final Answer</td><td>${firstAttemptStats.finalCorrect}/${firstAttemptStats.answeredCount}</td><td>${firstAttemptStats.finalAccuracy}%</td></tr>`;
            html += '</table>';

            // Show if changing answers helped or hurt
            if (answerChangeStats.changedQuestions > 0) {
                const helpedCount = answerChangeStats.changedToCorrect.length;
                const hurtCount = answerChangeStats.changedFromCorrect.length;
                html += `<p style="font-size:12px;color:var(--gray-600);margin-top:8px">Changed answers on ${answerChangeStats.changedQuestions} questions: `;
                html += `<span style="color:var(--green)">${helpedCount} helped</span>, `;
                html += `<span style="color:var(--red)">${hurtCount} hurt</span></p>`;

                if (answerChangeStats.changedFromCorrect.length > 0) {
                    html += `<p style="font-size:11px;color:var(--red);margin-top:4px">Changed FROM correct: Q${answerChangeStats.changedFromCorrect.map(i => i + 1).join(', Q')}</p>`;
                }
            }
            html += '</div>';
        }

        // Confidence vs Accuracy (only in Practice mode)
        const totalConfidenceRatings = Object.values(confidenceStats).reduce((sum, s) => sum + s.total, 0);
        if (totalConfidenceRatings > 0) {
            html += '<div class="time-per-q" style="margin-top:16px"><strong>Confidence vs Accuracy:</strong>';
            html += '<table><tr><th>Confidence</th><th>Correct</th><th>Accuracy</th></tr>';
            for (const level of [1, 2, 3]) {
                const s = confidenceStats[level];
                if (s.total > 0) {
                    const accuracy = Math.round((s.correct / s.total) * 100);
                    const color = accuracy >= 70 ? 'var(--green)' : accuracy >= 50 ? 'var(--orange)' : 'var(--red)';
                    html += `<tr><td>${s.label}</td><td>${s.correct}/${s.total}</td><td style="color:${color}">${accuracy}%</td></tr>`;
                }
            }
            html += '</table>';

            // Calculate calibration hint
            const maybeAcc = confidenceStats[1].total > 0 ? confidenceStats[1].correct / confidenceStats[1].total : 0;
            const defAcc = confidenceStats[3].total > 0 ? confidenceStats[3].correct / confidenceStats[3].total : 0;
            if (confidenceStats[1].total >= 2 && confidenceStats[3].total >= 2) {
                if (maybeAcc > defAcc + 0.1) {
                    html += '<p style="font-size:11px;color:var(--orange);margin-top:4px">You perform better when unsure - trust your instincts more!</p>';
                } else if (defAcc >= 0.8 && maybeAcc < 0.5) {
                    html += '<p style="font-size:11px;color:var(--green);margin-top:4px">Good calibration! Your confidence matches your accuracy.</p>';
                }
            }
            html += '</div>';
        }

        // Questions with multiple revisits
        if (revisitedQuestions.length > 0) {
            const topRevisited = revisitedQuestions.slice(0, 5);
            html += '<div class="time-per-q" style="margin-top:16px"><strong>Most Revisited Questions:</strong>';
            html += '<table><tr><th>Q#</th><th>Visits</th><th>Result</th></tr>';
            topRevisited.forEach(r => {
                const q = questions[r.index];
                const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
                const isCorrect = answers[r.index] === correctIdx;
                const wasAnswered = answers[r.index] !== undefined;
                const result = !wasAnswered ? 'Unanswered' : (isCorrect ? 'Correct' : 'Incorrect');
                const resultColor = !wasAnswered ? 'var(--orange)' : (isCorrect ? 'var(--green)' : 'var(--red)');
                html += `<tr><td>${r.index + 1}</td><td>${r.visits}</td><td style="color:${resultColor}">${result}</td></tr>`;
            });
            html += '</table></div>';
        }

        if (slowest.length > 0) {
            html += '<div class="time-per-q" style="margin-top:16px"><strong>Most Time Spent:</strong><table><tr><th>Q#</th><th>Time</th><th>Category</th></tr>';
            slowest.forEach(s => {
                const q = questions[s.index];
                html += `<tr><td>${s.index + 1}</td><td>${this._formatTime(s.time)}</td><td>${escapeHtml(q.category || 'General')}</td></tr>`;
            });
            html += '</table></div>';
        }

        // Category time breakdown
        html += '<div class="time-per-q" style="margin-top:16px"><strong>Time by Category:</strong><table><tr><th>Category</th><th>Time</th><th>Avg/Q</th></tr>';
        Object.entries(catStats).sort((a, b) => b[1].time - a[1].time).forEach(([cat, data]) => {
            const avgCatTime = data.total > 0 ? data.time / data.total : 0;
            html += `<tr><td>${escapeHtml(cat)}</td><td>${this._formatTime(data.time)}</td><td>${this._formatTime(avgCatTime)}</td></tr>`;
        });
        html += '</table></div>';

        html += '</div>';
        return html;
    },

    _formatTime(ms) {
        const secs = Math.round(ms / 1000);
        if (secs < 60) return secs + 's';
        const mins = Math.floor(secs / 60);
        const remainSecs = secs % 60;
        return mins + 'm ' + remainSecs + 's';
    }
};

// =====================================================================
// PER-QUESTION PERFORMANCE TRACKER
// =====================================================================
const QuestionTracker = {
    _key: 'questionTracker',

    _getData() {
        return Store.get(this._key, {});
    },

    _save(data) {
        Store.set(this._key, data);
    },

    // Record an array of question results (from test submission or single answers)
    recordResults(results) {
        const data = this._getData();
        const now = Date.now();
        for (const r of results) {
            if (!r.qId) continue;
            if (!data[r.qId]) {
                data[r.qId] = {
                    attempts: 0, correct: 0, incorrect: 0, skipped: 0,
                    totalTime: 0, category: r.category || 'General',
                    history: [],
                    highConfidenceStreak: 0
                };
            }
            const entry = data[r.qId];
            entry.attempts++;
            if (!r.answered) { entry.skipped++; }
            else if (r.correct) { entry.correct++; }
            else { entry.incorrect++; }
            entry.totalTime += r.timeSpent || 0;
            if (r.category) entry.category = r.category;
            const highConfCorrect = r.confidenceLevel === 3 && r.correct;
            if (r.confidenceLevel === 3) {
                entry.highConfidenceStreak = highConfCorrect ? (entry.highConfidenceStreak || 0) + 1 : 0;
            } else if (entry.highConfidenceStreak === undefined) {
                entry.highConfidenceStreak = 0;
            }
        }
        this._save(data);
    },

    getMostMissed(limit) {
        limit = limit || 10;
        const data = this._getData();
        const entries = [];
        for (const qId in data) {
            const d = data[qId];
            if (d.attempts < 2) continue;
            const missRate = d.incorrect / d.attempts;
            if (missRate > 0) {
                entries.push({ qId, missRate, ...d });
            }
        }
        entries.sort((a, b) => b.missRate - a.missRate || b.attempts - a.attempts);
        return entries.slice(0, limit);
    },

    // Get category accuracy from tracked data
    getCategoryAccuracy() {
        const data = this._getData();
        const cats = {};
        for (const qId in data) {
            const d = data[qId];
            const cat = d.category || 'General';
            if (!cats[cat]) cats[cat] = { correct: 0, total: 0, time: 0 };
            cats[cat].correct += d.correct;
            cats[cat].total += d.attempts;
            cats[cat].time += d.totalTime;
        }
        return cats;
    },

    // Get improvement trend (compare last N attempts vs previous N)
    getTrend(qId, lookback) {
        lookback = lookback || 5;
        const data = this._getData();
        const d = data[qId];
        if (!d || d.history.length < lookback * 2) return null;
        const recent = d.history.slice(-lookback);
        const previous = d.history.slice(-lookback * 2, -lookback);
        const recentAcc = recent.filter(h => h.correct).length / lookback;
        const prevAcc = previous.filter(h => h.correct).length / lookback;
        return { recentAcc, prevAcc, improving: recentAcc > prevAcc };
    },

    // Get overall stats summary
    getSummary() {
        const data = this._getData();
        let totalAttempts = 0, totalCorrect = 0, totalTime = 0, questionsTracked = 0;
        for (const qId in data) {
            const d = data[qId];
            questionsTracked++;
            totalAttempts += d.attempts;
            totalCorrect += d.correct;
            totalTime += d.totalTime;
        }
        return {
            questionsTracked, totalAttempts, totalCorrect,
            accuracy: totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0,
            totalTime
        };
    },

    // Find question text by ID from loaded banks
    findQuestion(qId) {
        for (const bank of BankManager.banks) {
            const q = bank.questions.find(q => q.id === qId);
            if (q) return { question: q, bankTitle: bank.title };
        }
        return null;
    },

    // Adaptive XP metadata helper
    getAdaptiveMeta(qId, difficulty = 1) {
        const data = this._getData();
        const entry = data[qId];
        const attempts = entry ? entry.attempts : 0;
        const correct = entry ? entry.correct : 0;
        const history = entry?.history || [];
        const last = history.length ? history[history.length - 1] : null;
        const hoursSince = last ? (Date.now() - last.date) / (1000 * 60 * 60) : Infinity;

        // Novelty: new questions are rewarded more; mild decay with attempts
        const noveltyScore = attempts === 0 ? 1.4 : Math.max(0.6, 1.2 - attempts * 0.1);

        // Streak penalty for repeated recent high-confidence correct answers
        let streakPenalty = 1.0;
        if (entry && entry.highConfidenceStreak >= 3 && last && last.confidenceLevel === 3 && last.correct && hoursSince < 72) {
            streakPenalty = 0.55;
        } else if (entry && entry.highConfidenceStreak >= 2 && last && last.confidenceLevel === 3 && last.correct && hoursSince < 48) {
            streakPenalty = 0.7;
        }

        // Confidence factor slightly rewards higher certainty
        const confidenceFactor = last && last.confidenceLevel ? (1 + (last.confidenceLevel - 1) * 0.08) : 1.0;

        return {
            difficulty: Math.max(0.5, difficulty || 1),
            noveltyScore,
            streakPenalty,
            confidenceFactor,
            isFirstTry: attempts === 0,
            accuracy: attempts > 0 ? correct / attempts : 0
        };
    }
};

// =====================================================================
// KEYBOARD SHORTCUTS
// =====================================================================
document.addEventListener('keydown', (e) => {
    // Help modal shortcut (? key) works globally
    if ((e.key === '?' || (e.shiftKey && e.key === '/')) && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        document.getElementById('helpModal').classList.toggle('active');
        return;
    }
    // Escape closes help modal
    if (e.key === 'Escape' && document.getElementById('helpModal').classList.contains('active')) {
        document.getElementById('helpModal').classList.remove('active');
        return;
    }
    // Calculator shortcut works globally
    if (e.key === 'c' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
        Calc.toggle();
        return;
    }
    // Escape closes calculator
    if (e.key === 'Escape' && Calc.isOpen) {
        Calc.toggle();
        return;
    }

    // Only in exam screen
    if (!document.getElementById('screen-exam').classList.contains('active')) return;
    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

    if (e.key === 'ArrowRight' || e.key === 'n') App.next();
    if (e.key === 'ArrowLeft' || e.key === 'p') App.prev();
    if (e.key === 'b') App.toggleBookmark();
    if (e.key === 't') Notes.toggle();
    if (e.key >= '1' && e.key <= '4' && !App.submitted && !App.practiceChecked[App.currentQ]) {
        const optIdx = parseInt(e.key) - 1;
        const q = App.questions[App.currentQ];
        if (q && q.options && optIdx < q.options.length) App.selectOption(optIdx);
    }
    if (e.key === 'Enter' && App.mode === 'practice' && !App.practiceChecked[App.currentQ]) {
        App.checkAnswer();
    }
});

// =====================================================================
// INIT
// =====================================================================
async function init() {
    // Load theme early to prevent flash of wrong theme
    Theme.load();
    Settings.load();

    // Initialize gamification system
    Gamification.init();

    // Initialize garden decay timers — checks every 60s for live feel
    Garden.decayWater();
    Garden.decayPetStats();
    Garden.idleGrow();
    setInterval(() => { Garden.decayWater(); Garden.decayPetStats(); Garden.idleGrow(); }, 15 * 1000);

    // Hide garden/shop/battle buttons if garden disabled
    const gState = Gamification.getState();
    const btnGarden = document.getElementById('btnGarden');
    const btnShop = document.getElementById('btnShop');
    const btnBattle = document.getElementById('btnBattle');
    if (btnGarden) btnGarden.style.display = gState.settings.garden ? '' : 'none';
    if (btnShop) btnShop.style.display = gState.settings.garden ? '' : 'none';
    if (btnBattle) btnBattle.style.display = gState.settings.garden ? '' : 'none';

    // Try loading the embedded fallback
    try {
        const script = document.getElementById('bankFallback');
        if (script) BANK_DATA = JSON.parse(script.textContent);
    } catch {}

    await BankManager.loadAll();

    // If no banks loaded via fetch and no embedded data, try to load from BANK_DATA global
    if (BankManager.banks.length === 0) {
        // Last resort: show error
        document.getElementById('bankList').innerHTML = '<p style="text-align:center;color:var(--red);padding:40px">Could not load question banks. If using file:// protocol, the embedded bank data is needed.</p>';
    }

    // Check for saved session and offer to resume
    if (SessionState.hasSavedSession()) {
        const shouldResume = await SessionState.showResumePrompt();
        if (shouldResume) {
            const state = SessionState.get();
            if (state) {
                // Determine which mode to restore based on screen
                const screen = state.app ? state.app.screen : 'home';
                if (screen === 'drill') {
                    if (SessionState.restoreDrill(state)) {
                        return; // Successfully restored drill session
                    }
                } else if (screen === 'exam') {
                    if (SessionState.restoreApp(state)) {
                        return; // Successfully restored app session
                    }
                } else if (screen === 'ai-practice') {
                    if (SessionState.restoreAIPractice(state)) {
                        return; // Successfully restored AI Practice session
                    }
                }
            }
            // If restoration failed, clear and show home
            SessionState.clear();
        }
    }

    Home.render();
}

document.addEventListener('DOMContentLoaded', init);

// Flush gamification cache to localStorage before page unload
window.addEventListener('beforeunload', () => { Session.end(); Gamification.saveStateImmediate(); });
</script>

<!-- EMBEDDED BANK DATA FALLBACK (for file:// protocol) -->
<script id="bankFallback" type="application/json">
{"bankId":"algebra-fxo1","title":"Applied Algebra - FXO1","description":"WGU Applied Algebra pre-assessment practice (70 questions)","timeLimit":5400,"passingScore":70,"categories":["Function Notation","Graph Reading","Rate of Change","Linear Functions","Exponential & Logistic","Regression & Predictions","Concavity & Curvature"],"questions":[{"id":1,"text":"A local business is looking to become a franchise. The company wants to predict the number of franchises, F, given a certain number of years, Y. This prediction is modeled by the function F(Y).\n What can be concluded by F(5) = 10?","options":["Every 5 years, 10 stores will be opened.","Every 10 years, 5 stores will be opened.","In 5 years, there will be 10 open stores.","In 10 years, there will be 5 open stores."],"correctAnswer":2,"explanation":"F(5) = 10 means when Y = 5 (the input, years), F = 10 (the output, franchises). This reads as: in 5 years, there will be 10 open stores. The other options either swap the input/output or misinterpret function notation as a rate.","category":"Function Notation","tags":["function-notation","interpret-output","franchise"],"difficulty":1},{"id":2,"text":"A bank begins a marketing campaign to increase its number of customers. Each month, all new customers are put into a drawing. One customer then receives a $50 credit in a checking account.\n The amount of money given away in the drawing, G, is a function of the number of months, M, the drawing has been going on for.\n What is the correct function notation to represent the amount of money given away after the drawing has been going on for 5 months?","options":["G(250) = 5","G(5) = 10","G(5) = 250","G(10) = 5"],"correctAnswer":2,"explanation":"G is a function of M (months). After 5 months, $50 is given away each month, so the total is $50 x 5 = $250. The correct notation places the input (5 months) inside the parentheses and the output ($250) on the right: G(5) = 250.","category":"Function Notation","tags":["function-notation","evaluate","money"],"difficulty":1},{"id":3,"text":"The volume of calls, V(h), at a particular customer service center can be written as a function of the number of hours after opening each day, h.\n What would the ordered pair (6,8) represent for this function?","options":["There were 8 calls 6 hours after opening.","There were 6 calls 8 hours after opening.","There were h calls 6 hours after opening.","There were 8 calls V hours after opening."],"correctAnswer":0,"explanation":"In the ordered pair (6, 8), the first value is the input h = 6 (hours after opening) and the second value is the output V = 8 (number of calls). So there were 8 calls 6 hours after opening.","category":"Function Notation","tags":["function-notation","ordered-pair","interpret"],"difficulty":1},{"id":4,"text":"A company has developed two functions, L(t) and M(t), that determine the least amount and most amount, respectively, of revenue it will make in any given month in dollars (with t = 1 corresponding to January).\n What can the company reasonably conclude if L(2) = 3,000 and M(2) = 5,000?","options":["In February, it will make $2,000.","It cannot make more than $3,000 in February but can make up to $5,000 after February.","In February, it will make between $3,000 and $5,000.","It will make more money in February if it uses M(t) instead of L(t)."],"correctAnswer":2,"explanation":"L(2) = 3,000 gives the least revenue in February and M(2) = 5,000 gives the most. Therefore, actual revenue in February will fall between these bounds: between $3,000 and $5,000.","category":"Function Notation","tags":["function-notation","bounds","revenue"],"difficulty":1},{"id":5,"text":"A server at a restaurant has realized that tips, T, in dollars are related to the number of hours, h, that have been worked on any given day. Tips can be modeled by the function T(h) = X.\n How can this function be interpreted?","options":["If the server works T hours, the tips will be $h.","If the server works h hours, the tips will be $X.","If the server works h hours, the tips will be $T(X).","If the server works X hours, the tips will be $T."],"correctAnswer":1,"explanation":"T(h) = X means the input is h (hours worked) and the output is X (dollar amount of tips). So if the server works h hours, the tips will be $X. The function T takes hours as input and returns tip dollars as output.","category":"Function Notation","tags":["function-notation","interpret","real-world"],"difficulty":1},{"id":6,"text":"A company pays its employees a base salary each month plus a commission, C, based on the number of sales, s, made by an employee during the month. An employee made 8 sales in the last month and received a commission of $1,600.\n How would this be represented in function notation?","options":["C(8) = 1600","C(1600) = 8","s(1600) = 8","s(8) = 1600"],"correctAnswer":0,"explanation":"Commission C is a function of sales s. With 8 sales (input) producing $1,600 commission (output), the correct notation is C(8) = 1600. The function name is C, the input is the number of sales, and the output is the commission amount.","category":"Function Notation","tags":["function-notation","write-notation","commission"],"difficulty":1},{"id":7,"text":"Below is a growth graph of a business. It compares gross growth and net growth.\n [Graph: Gross vs Net Growth 2010-2016]\n What can be said about the growth between the years of 2012 and 2014?","options":["Both gross and net growth decreased.","Both gross and net growth increased.","The gross growth decreased while the net growth increased.","The gross growth increased while the net growth decreased."],"correctAnswer":3,"explanation":"Between 2012 and 2014, the gross growth line trends upward while the net growth line trends downward. This means the company's total revenue grew, but after expenses, the net growth actually declined.","category":"Graph Reading","tags":["graph-reading","compare-trends","growth"],"difficulty":2},{"id":8,"text":"The graph below shows the three-month average percentage year-on-year growth for real total pay for the years 2010-2016, along with the Office for Budget Responsibility's (OBR's) growth forecast for the years 2016-2021.\n [Graph: Real Total Pay Growth]\n What can be concluded from this graph?","options":["The real total pay growth outturn exceeded 3% at some point between 2010 and 2016.","The real total pay growth outturn remained between -2% and 2% from 2010 and 2016.","The OBR forecasts the growth will remain above 1% between 2016 and 2021.","The OBR forecasts the growth will remain between 1% and 2% between 2016 and 2021."],"correctAnswer":1,"explanation":"Reading the graph carefully, the real total pay growth outturn line stays within the range of -2% to 2% throughout the 2010-2016 period. It never exceeds 3%, and the OBR forecast does not consistently stay above 1%.","category":"Graph Reading","tags":["graph-reading","range","pay-growth"],"difficulty":2},{"id":9,"text":"The following graph shows the profits of a company for the last fiscal year.\n [Graph: Company Profits]\n Approximately how much have the company's profits increased over the last year?","options":["50%","30%","110%","80%"],"correctAnswer":3,"explanation":"Reading the graph, the profits approximately doubled from around $1 million to $1.8 million over the year. The percentage increase is roughly (1.8 - 1.0)/1.0 = 80%. This is closest to 80% among the choices.","category":"Graph Reading","tags":["graph-reading","percent-change","profit"],"difficulty":2},{"id":10,"text":"Black Monday occurred on October 19, 1987, and represents the single largest decline of the Dow Jones average in history.\n The function f represents a seven-month period during which Black Monday occurred. The function value f(1) represents the Dow Jones average in June of 1987.\n [Graph: Dow Jones 1987]\n Which function value represents the Dow Jones average during the month when Black Monday occurred?","options":["f(6)","f(4)","f(5)","f(10)"],"correctAnswer":2,"explanation":"If f(1) = June 1987, then f(2) = July, f(3) = August, f(4) = September, and f(5) = October. Since Black Monday occurred in October 1987, the answer is f(5).","category":"Function Notation","tags":["function-notation","counting","historical"],"difficulty":2},{"id":11,"text":"The unemployment rate in Poland for the time period from 1990 to 2012 is shown in the graph below using the function U(t) (measured as a percentage), where t is the year.\n [Graph: Poland Unemployment Rate]\n What can be concluded based on this graph?","options":["The two lowest unemployment rates were U(1998) and U(2008).","The largest two-year increase in unemployment was from 1990 to 1992.","U(1992) was the same as U(2002).","The largest two-year decrease in unemployment was from 1996 to 1998."],"correctAnswer":0,"explanation":"Reading the graph, the unemployment rate hits its lowest points (troughs) around 1998 and 2008. These two years represent the local minimums on the graph, making them the two lowest unemployment rates in the period shown.","category":"Graph Reading","tags":["graph-reading","minimum","unemployment"],"difficulty":2},{"id":12,"text":"The graph of the function C below represents the number of coal miners in the United States from 1985 to 2015.\n C(y) represents the number of coal miners in the United States in the year y.\n [Graph: US Coal Miners]\n Which interpretation of the function C is accurate?","options":["C(2015) represents 68 coal miners in 2015.","C(1990) represents 140,000 coal miners in 1990.","C(1995) represents 100 coal miners in 1995.","C(2000) represents 70,000 coal miners in 2000."],"correctAnswer":1,"explanation":"Reading the graph at year 1990, the value is approximately 140,000 coal miners. The graph measures in thousands, so C(1990) = 140,000 is correct. The other options either misread the scale or confuse units.","category":"Graph Reading","tags":["graph-reading","scale","interpret-value"],"difficulty":2},{"id":13,"text":"The following table compares the number of employees hired and the number of employees dismissed over an 11-year period for a certain business.\n Year: 2007-2017, Hired vs Dismissed data provided.\n What can be concluded from this table?","options":["Fewer employees were hired than dismissed each year.","More employees were hired in 2007 and 2008 than in 2010 and 2011.","More employees were dismissed in 2016 and 2017 than in 2014 and 2015.","More employees were hired than dismissed each year."],"correctAnswer":3,"explanation":"Checking each year: 2007 (50>10), 2008 (20>10), 2009 (30>5), 2010 (21>17), 2011 (60>30), 2012 (70>15), 2013 (40>20), 2014 (15>5), 2015 (20>6), 2016 (10>2), 2017 (10>7). In every year, more employees were hired than dismissed.","category":"Graph Reading","tags":["table-reading","compare","employees"],"difficulty":1},{"id":14,"text":"A company has the following information on last quarter's sales (month 7 refers to July):\n Month 7: $303K, Month 8: $328K, Month 9: $333K\n What was the average rate of change over the entire quarter (from July to September)?","options":["Sales increased an average of $6,285.71 per month.","Sales increased an average of $10,000 per month.","Sales increased an average of $37,000 per month.","Sales increased an average of $15,000 per month."],"correctAnswer":3,"explanation":"Average rate of change = (333 - 303)/(9 - 7) = 30/2 = 15 thousand dollars per month. Since sales are in thousands, this is $15,000 per month. The rate is calculated over the entire interval from July (month 7) to September (month 9).","category":"Rate of Change","tags":["rate-of-change","average","sales"],"difficulty":1},{"id":15,"text":"An IT firm generates the following numbers to estimate its revenue in thousands of dollars based on the number of employees working on a project.\n Employees: 10,20,30,40,50 | Revenue: $12.40K, $21.99K, $30.74K, $36.01K, $38.43K\n Which conclusion can be made by examining the average rate of change between consecutive rows?","options":["The revenue is increasing steadily in relation to the number of employees.","The revenue is increasing at slower and slower rates in relation to the number of employees.","The revenue is not increasing in relation to the number of employees.","The revenue is increasing at faster and faster rates in relation to the number of employees."],"correctAnswer":1,"explanation":"Computing the rate of change between consecutive rows: (21.99-12.40)/10 = 0.959, (30.74-21.99)/10 = 0.875, (36.01-30.74)/10 = 0.527, (38.43-36.01)/10 = 0.242. Each successive rate is smaller, meaning revenue increases at slower and slower rates.","category":"Rate of Change","tags":["rate-of-change","decreasing-rate","revenue"],"difficulty":2},{"id":16,"text":"An airplane was cruising at an altitude of 39,000 feet and descended as shown in the table below.\n Time (min): 0,10,20,30,40,50,60 | Altitude (ft): 39000,33000,27000,21000,15000,9000,3000\n What can be concluded from this table?","options":["The airplane had a descent rate of 600 ft./min.","At minute 70, the airplane landed.","At minute 60, the airplane landed.","The airplane had a descent rate of 6,000 ft./min."],"correctAnswer":0,"explanation":"The altitude drops by 6,000 feet every 10 minutes: (39000 - 33000)/10 = 600 ft/min. This is a constant descent rate. At minute 60 the plane is still at 3,000 feet (not landed), and 6,000 ft/min would be far too fast.","category":"Rate of Change","tags":["rate-of-change","constant","descent"],"difficulty":1},{"id":17,"text":"The function table below shows a company's revenue function (R) and expense function (E) for each month.\n Monthly Revenues and Expenses for months 1-12 provided.\n Which conclusion can be made about this function table?","options":["Since R(11) is $10,234 and E(11) is $3,786, there was not a profit in November.","The lowest profit occurred during May.","Since R(2) is $3,220 and E(2) is $3,957, there was a profit in February.","The highest profit occurred during October."],"correctAnswer":3,"explanation":"Profit = Revenue - Expenses. For October: R(10) - E(10) = $12,337 - $927 = $11,410. Checking other months confirms this is the highest profit. February actually had a loss ($3,220 - $3,957 = -$737), and November had a profit ($10,234 - $3,786 = $6,448).","category":"Rate of Change","tags":["table-reading","profit","compute"],"difficulty":2},{"id":18,"text":"The original value of a company car bought in January of 2006 was $22,800. Below is a function table that tracks the value of the car V(y) as it depreciates from 2006 to 2015.\n Which other conclusion can be reached from this table?","options":["V(y) decreases the most from 2006 to 2007.","V(y) decreases by the same amount each year.","V(2013) = $22,800 - $6,879","V($4,970) = 2015"],"correctAnswer":0,"explanation":"From 2006 to 2007: $22,800 - $18,240 = $4,560 decrease. From 2007 to 2008: $18,240 - $15,504 = $2,736. Each subsequent year's decrease is smaller than $4,560, so the largest single-year decrease is from 2006 to 2007.","category":"Rate of Change","tags":["rate-of-change","depreciation","maximum-change"],"difficulty":2},{"id":19,"text":"The salvage or depreciated value, V, of a new truck purchased for $58,000 is given by the linear function V(t) = 58,000 - 4,000t, where t is the time in years between 0 and 10.\n What is the correct interpretation of V(3)?","options":["The truck's depreciated value after 5 years is $54,000.","The truck's depreciated value after 3 years is $46,000.","The truck's depreciated value after 5 years is $42,000.","The truck's depreciated value after 3 years is $50,000."],"correctAnswer":1,"explanation":"V(3) = 58,000 - 4,000(3) = 58,000 - 12,000 = $46,000. Plugging t = 3 into the function gives the truck's value after 3 years. The truck depreciates by $4,000 each year.","category":"Linear Functions","tags":["linear","evaluate","depreciation"],"difficulty":1},{"id":20,"text":"In the function C(x) = 21.25 + 0.25x, C(x) represents the total cost, in dollars, for a passenger to ride a shuttle service for x miles.\n What is the total cost for a passenger to ride the shuttle for 50 miles?","options":["$33.75","$12.50","$26.25","$50.25"],"correctAnswer":0,"explanation":"C(50) = 21.25 + 0.25(50) = 21.25 + 12.50 = $33.75. The base fare is $21.25, plus $0.25 per mile for 50 miles adds $12.50 to the total.","category":"Linear Functions","tags":["linear","evaluate","cost"],"difficulty":1},{"id":21,"text":"A company's total monthly cost is given by the linear function C(x) = 11,000 + 550x, where C is the total monthly cost and x is the number of units produced each month.\n What does the y-intercept represent in this situation?","options":["If 0 items are produced, the monthly cost is $550.00.","If 0 items are produced, the monthly cost is $11,000.00.","If 550 items are produced, the monthly cost is $0.00.","If 11,000 items are produced, the monthly cost is $0.00."],"correctAnswer":1,"explanation":"The y-intercept occurs when x = 0. C(0) = 11,000 + 550(0) = $11,000. This represents the fixed monthly cost when no items are produced. The $550 is the slope (cost per additional unit), not the y-intercept.","category":"Linear Functions","tags":["linear","y-intercept","fixed-cost"],"difficulty":1},{"id":22,"text":"A cable company, a satellite dish company, and a streaming service all offer TV viewing plans based on the number of channels, c.\n Cable: P(c) = 3c + 60\n Satellite dish: P(c) = 4c + 35\n Streaming service: P(c) = 5c + 50\n Which company's cost per additional channel is most expensive?","options":["Satellite dish company","Cable company","Streaming service","All have the same cost per channel"],"correctAnswer":2,"explanation":"The cost per additional channel is the slope of each linear function. Cable = $3/channel, Satellite = $4/channel, Streaming = $5/channel. The streaming service has the highest slope at $5 per channel, making it the most expensive per additional channel.","category":"Linear Functions","tags":["linear","slope","compare"],"difficulty":1},{"id":23,"text":"The number of gym memberships since January 1, 2015, for a particular gym is given by the function N(x) = 100 + 11x, where N is the number of gym members x months after January 1, 2015.\n How can the slope be interpreted?","options":["Each month, 100 members join the gym.","Each month, 11 members cancel their membership.","Each month, 100 members cancel their membership.","Each month, 11 members join the gym."],"correctAnswer":3,"explanation":"In N(x) = 100 + 11x, the slope is 11, meaning the number of members increases by 11 each month. The 100 is the y-intercept (starting members). A positive slope of 11 means 11 new members join per month.","category":"Linear Functions","tags":["linear","slope-interpretation","membership"],"difficulty":1},{"id":24,"text":"The pricing models of four contractors are given below, where t is the number of hours worked and P is the total cost of the job.\n Contractor A: P(t) = 100 + 20t\n Contractor B: P(t) = 99 + 25t\n Contractor C: P(t) = 50 + 35t\n Contractor D: P(t) = 80 + 25t\n Which contractor gives the cheapest hourly rate?","options":["Contractor B","Contractor D","Contractor C","Contractor A"],"correctAnswer":3,"explanation":"The hourly rate is the slope (coefficient of t) in each function. A = $20/hr, B = $25/hr, C = $35/hr, D = $25/hr. Contractor A has the lowest hourly rate at $20 per hour, even though their flat fee ($100) is the highest.","category":"Linear Functions","tags":["linear","slope","compare-rates"],"difficulty":1},{"id":25,"text":"An appliance manufacturer has determined that the profit, P(x), that it makes in manufacturing and selling x dishwashers can be determined from the function in the graph below.\n [Graph: Profit vs Dishwashers]\n How many dishwashers must the company manufacture and sell in order to make a profit of $80,000?","options":["30","130","140","120"],"correctAnswer":1,"explanation":"Reading the graph at P(x) = $80,000 on the y-axis and tracing horizontally to the curve, then down to the x-axis, the value lands at approximately 130 dishwashers. This is where the profit function reaches $80,000.","category":"Graph Reading","tags":["graph-reading","find-input","profit"],"difficulty":2},{"id":26,"text":"The profit function P(x) gives a company's total profit (in millions of U.S. dollars) for x products produced (in thousands). The graph of P(x) is below.\n [Graph: Profit Function]\n At which number of products produced does the company stop being profitable?","options":["About 1,000 items","About 3,000 items","About 2,500 items","About 4,500 items"],"correctAnswer":3,"explanation":"The company stops being profitable when P(x) = 0 (the graph crosses the x-axis from positive to negative). Reading the graph, this zero-crossing occurs at approximately x = 4.5 (in thousands), which is about 4,500 items.","category":"Graph Reading","tags":["graph-reading","zero","break-even"],"difficulty":2},{"id":27,"text":"A big box store found its number of customers, C, in thousands on Saturday is predicted by the time of day in hours, t. t = 0 corresponds to midnight.\n [Graph: Customers vs Time]\n How should the average rate of change from t = 8 to t = 10 be interpreted?","options":["There are, on average, 1,000 more customers per hour.","There are, on average, 2,000 fewer customers per hour.","There are, on average, 2,000 more customers per hour.","There are, on average, 1,000 fewer customers per hour."],"correctAnswer":0,"explanation":"Reading the graph: C(8) = 1 thousand and C(10) = 3 thousand. Average rate of change = (3 - 1)/(10 - 8) = 2/2 = 1 thousand customers per hour. Since the values are in thousands, this means 1,000 more customers per hour on average.","category":"Rate of Change","tags":["rate-of-change","average","customers"],"difficulty":2},{"id":28,"text":"The profit for a manufacturer of a certain product is given by the function P(x) = -4x^3 + 12x^2 + 16x, where P is the total profit (in thousands of dollars) for x items produced (in thousands).\n What is the average rate of change from x = 4 to x = 8?","options":["Profit increases by $288,000 per 1,000 items produced.","Profit decreases by $1,152,000 per 1,000 items produced.","Profit decreases by $288,000 per 1,000 items produced.","The profit neither increases nor decreases per 1,000 items produced."],"correctAnswer":2,"explanation":"P(4) = -4(64) + 12(16) + 16(4) = -256 + 192 + 64 = 0. P(8) = -4(512) + 12(64) + 16(8) = -2048 + 768 + 128 = -1152. Average rate = (-1152 - 0)/(8 - 4) = -1152/4 = -288 thousand dollars per thousand items. Profit decreases by $288,000 per 1,000 items.","category":"Rate of Change","tags":["rate-of-change","polynomial","compute"],"difficulty":3},{"id":29,"text":"The graph below represents the projected year-end assets, A(t), in the Social Security trust fund in trillions of dollars, where t represents the number of years since 2000.\n [Graph: Social Security Trust Fund]\n At which value of t is the fund increasing the most rapidly?","options":["About t = 45","About t = 7","About t = 30","About t = 0"],"correctAnswer":1,"explanation":"The fund is increasing most rapidly where the graph has its steepest positive slope. Looking at the graph, the steepest upward section occurs around t = 7 (approximately year 2007), where the curve is rising most sharply before it begins to flatten and eventually decline.","category":"Graph Reading","tags":["graph-reading","steepest-slope","social-security"],"difficulty":2},{"id":30,"text":"A local coffee shop found that its number of customers, N, can be predicted by the time of day in hours, t. The opening time of 5:00 a.m. corresponds to t = 0.\n [Graph: Coffee Shop Customers]\n How should the graph be interpreted between t = 5.5 and t = 9?","options":["Between 10:30 a.m. and 2:00 p.m., the number of customers is increasing slower and slower and then increasing faster and faster.","Between 10:30 a.m. and 2:00 p.m., the number of customers is increasing faster and faster and then decreasing slower and slower.","Between 10:30 a.m. and 2:00 p.m., the number of customers is increasing faster and faster and then increasing slower and slower.","Between 10:30 a.m. and 2:00 p.m., the number of customers is decreasing faster and faster and then increasing slower and slower."],"correctAnswer":2,"explanation":"Since t = 0 is 5:00 a.m., t = 5.5 is 10:30 a.m. and t = 9 is 2:00 p.m. The graph shows an S-shaped increase in this region: first concave up (increasing faster and faster), then an inflection point, then concave down (increasing slower and slower).","category":"Concavity & Curvature","tags":["concavity","inflection","interpret-graph"],"difficulty":3},{"id":31,"text":"The total profit, P(x), in thousands of dollars from the production of x thousands of laptop computers is given by the graph below. For this graph, x must be greater than or equal to 5.\n [Graph: Laptop Profit]\n How many laptops must be produced to maximize the profit?","options":["700,000","10","10,000","700"],"correctAnswer":2,"explanation":"Reading the graph, the maximum profit occurs at approximately x = 10. Since x is measured in thousands of laptops, x = 10 means 10,000 laptops. The peak of the profit curve is at this production level.","category":"Graph Reading","tags":["graph-reading","maximum","units"],"difficulty":2},{"id":32,"text":"For the years since a department store has been open, its annual revenue, R, (in millions of dollars) can be modeled by the function graphed below, where t is the number of years since the store opened.\n [Graph: Department Store Revenue]\n How should the maximum revenue be interpreted?","options":["About 4 years after the department store opened, the store earned a maximum revenue of about $1,600,000.00.","About 6 years after the department store opened, the store earned a maximum revenue of about $1,400,000.00.","About 14 years after the department store opened, the store earned a maximum revenue of about $1,400,000.00.","About 6 years after the department store opened, the store earned a maximum revenue of about $1,600,000.00."],"correctAnswer":3,"explanation":"Reading the graph, the peak (maximum) of the revenue curve occurs at approximately t = 6 years, with R approximately equal to 1.6 million dollars ($1,600,000). The revenue rises to this peak and then declines afterward.","category":"Graph Reading","tags":["graph-reading","maximum","revenue"],"difficulty":2},{"id":33,"text":"The population of the United States in millions of people can be estimated with the function P(t) = 282(1.01)^t, where t = 0 represents the population, P, in the year 2000, and t is measured in years.\n What does P(-2) represent?","options":["P(-2) represents the opposite of the population in 2002, which was approximately 250 million people.","P(-2) represents the population in 2002, which was approximately 288 million people.","P(-2) represents the population in 1998, which was approximately 276 million people.","P(-2) represents twice the population of 2000, which was approximately 564 million people."],"correctAnswer":2,"explanation":"Since t = 0 is the year 2000, t = -2 is two years before 2000, which is 1998. P(-2) = 282(1.01)^(-2) = 282/1.0201 = approximately 276 million people. Negative t values go backward in time from the reference year.","category":"Exponential & Logistic","tags":["exponential","negative-input","population"],"difficulty":2},{"id":34,"text":"A high-interest loan company uses the function L(d) = 100e^(0.02d) to calculate late fees, L, for payments overdue by d days.\n What does L(67) represent?","options":["L(67) is the average number of days a person waits to make a payment, which would be 67.","L(67) is the number of days that a payment is overdue, which would be 382 days.","L(67) is the overall amount due when a payment is 67 days overdue, which would be $67.","L(67) is the amount due in late fees for a payment that is 67 days overdue, which would be $381.90."],"correctAnswer":3,"explanation":"L(d) calculates late fees for d days overdue. L(67) = 100e^(0.02 x 67) = 100e^(1.34) = 100 x 3.819 = approximately $381.90. This is the late fee amount when the payment is 67 days overdue.","category":"Exponential & Logistic","tags":["exponential","evaluate","late-fees"],"difficulty":2},{"id":35,"text":"A bank uses the function A(t) = 1000(1.023)^t to calculate an account balance, A, after t years.\nWhat is the average rate of change of the account balance from t = 2 to t = 12?","options":["The account will decrease by $26.72, on average, each year.","The account will increase by $267.21, on average, each year.","The account will increase by $26.72, on average, each year.","The account will decrease by $267.21, on average, each year."],"correctAnswer":2,"explanation":"A(2) = 1000(1.023)^2 = 1046.53. A(12) = 1000(1.023)^12 = 1313.74. Average rate of change = (1313.74 - 1046.53)/(12 - 2) = 267.21/10 = $26.72 per year. The account balance increases on average by $26.72 each year over this period.","category":"Rate of Change","tags":["rate-of-change","exponential","banking"],"difficulty":2},{"id":36,"text":"A scientist found a sample of carbon-14 and knows the graph below models the exponential decay of carbon-14, where t is time measured in years and y is the amount of carbon-14 left in the sample in grams.\n [Graph: Carbon-14 Decay]\n What would the average rate of change over the time interval of t = 100 to t = 700 represent, and would that rate be positive or negative?","options":["It represents the annual change in the number of grams of carbon-14 between 100 and 700 years. The rate is negative.","It represents the annual change in 600 years per the number of grams of carbon-14. The rate is positive.","It represents the annual change in the number of grams of carbon-14 between 100 and 700 years. The rate is positive.","It represents the annual change in 600 years per the number of grams of carbon-14. The rate is negative."],"correctAnswer":0,"explanation":"The average rate of change = (y(700) - y(100))/(700 - 100), which gives the annual change in grams of carbon-14 over this 600-year interval. Since carbon-14 decays over time (decreasing function), y(700) < y(100), making the rate negative.","category":"Rate of Change","tags":["rate-of-change","decay","sign"],"difficulty":2},{"id":37,"text":"A company uses the function C = 15e^(-n) + 10, which is shown in the graph below, to model the average cost per toy produced, C, where n is the number of toys produced.\n [Graph: Cost per Toy]\n How should this horizontal asymptote be interpreted?","options":["As the number of toys produced increases, the average cost per toy tends toward $10.","As the cost of producing toys increases, the number of toys produced tends toward 10.","As the cost of producing toys increases, the number of toys produced tends toward 15.","As the number of toys produced increases, the average cost per toy tends toward $15."],"correctAnswer":0,"explanation":"As n approaches infinity, e^(-n) approaches 0, so C = 15(0) + 10 = 10. The horizontal asymptote is C = 10, meaning as more toys are produced, the average cost per toy approaches $10 but never quite reaches it.","category":"Exponential & Logistic","tags":["asymptote","exponential","cost"],"difficulty":2},{"id":38,"text":"Two medical operations are being compared to determine which is better for patients. Below is a graph of the chance of infection after operation (in percentage) for the first option (solid curve) and the second option (dashed curve), shown over time since 1950.\n [Graph: Infection Rates]\n As time has gone on, which is the better operation?","options":["Operation 1 is better because the chance of infection has dropped to a steady 15% since around the year 2000.","Operation 2 is better because the chance of infection has dropped to a steady 10% since around the year 2000.","Operation 2 is better because the chance of infection has dropped to a steady 15% since around the year 2000.","Operation 1 is better because the chance of infection has dropped to a steady 10% since around the year 2000."],"correctAnswer":1,"explanation":"Reading the graph, Operation 2 (dashed curve) has its infection rate leveling off at approximately 10% by around the year 2000, which is lower than Operation 1's steady rate of approximately 15%. Lower infection rate means a better operation.","category":"Graph Reading","tags":["graph-reading","asymptote","compare"],"difficulty":2},{"id":39,"text":"A factory with an assembly line can produce more automobiles per week as more employees are working at a given time, limited by the capacity of the assembly line. The model follows the function A(w) = 100/(1 + 25e^(-0.06w)) - 4, where A is the number of automobiles per week, and w is the number of workers.\n How many workers are needed to produce 50 automobiles per week?","options":["41 workers","57 workers","80 workers","96 workers"],"correctAnswer":1,"explanation":"Set A(w) = 50: 50 = 100/(1 + 25e^(-0.06w)) - 4, so 54 = 100/(1 + 25e^(-0.06w)). Then 1 + 25e^(-0.06w) = 100/54 = 1.852, so 25e^(-0.06w) = 0.852, e^(-0.06w) = 0.0341, -0.06w = ln(0.0341) = -3.378, w = 56.3, approximately 57 workers.","category":"Exponential & Logistic","tags":["logistic","solve","factory"],"difficulty":3},{"id":40,"text":"A cat population in a small town can be modeled with a logistic function and estimated with the table below, where t = 0 represents the cat population, P, in the year 2000, and t is measured in years.\n t: 1,2,3,4 | P(t): 24,55,103,150\n When does the cat population reach 110?","options":["During 2004","During 2001","During 2002","During 2003"],"correctAnswer":3,"explanation":"At t = 3, P(3) = 103 and at t = 4, P(4) = 150. Since 110 falls between 103 and 150, the population reaches 110 sometime between t = 3 and t = 4. Since t = 3 corresponds to year 2003, the population reaches 110 during 2003.","category":"Exponential & Logistic","tags":["logistic","table","interpolate"],"difficulty":2},{"id":41,"text":"A factory with an assembly line can produce more automobiles per week as more employees are working at a given time, limited by the capacity of the assembly line. The model follows the function A(w) = 100/(1 + 25e^(-0.06w)) - 4.\n The instantaneous rate of change at w = 50 is 1.\n How should this be interpreted?","options":["When the factory has 50 workers, the factory will produce 10 fewer cars for each worker added.","When the factory has 50 workers, the factory will produce 10 more cars for each worker added.","When the factory has 50 workers, the factory will produce 1 more car for each worker added.","When the factory has 50 workers, the factory will produce 1 fewer car for each worker added."],"correctAnswer":2,"explanation":"The instantaneous rate of change at w = 50 is 1, meaning the derivative A'(50) = 1. This means at exactly 50 workers, each additional worker adds approximately 1 more automobile per week to production.","category":"Exponential & Logistic","tags":["logistic","instantaneous-rate","interpret"],"difficulty":2},{"id":42,"text":"A rabbit population can be estimated with the function P(t) = 117/(1 + 5e^(-0.2t)), where t = 0 represents the rabbit population, P, in the year 2010, and t is measured in years.\n What is the average rate of change of the rabbit population from 2020 to 2040?","options":["The rabbit population is decreasing by about 115.57 rabbits per year during this time.","The rabbit population is increasing by about 115.57 rabbits per year during this time.","The rabbit population is increasing by about 2.29 rabbits per year during this time.","The rabbit population is decreasing by about 2.29 rabbits per year during this time."],"correctAnswer":2,"explanation":"2020 is t = 10 and 2040 is t = 30. P(10) = 117/(1 + 5e^(-2)) = 117/(1 + 0.677) = 69.79. P(30) = 117/(1 + 5e^(-6)) = 117/(1 + 0.0124) = 115.57. Average rate = (115.57 - 69.79)/20 = 45.78/20 = approximately 2.29 rabbits per year.","category":"Rate of Change","tags":["rate-of-change","logistic","population"],"difficulty":2},{"id":43,"text":"A factory with an assembly line produces automobiles and is limited by the capacity of its assembly line.\n [Graph: Automobile Production - Logistic Curve]\n What happens as additional workers between 10 workers and 40 workers are added?","options":["Adding additional workers increases the number of automobiles produced slower and slower.","Adding additional workers increases the number of automobiles produced faster and faster.","Adding additional workers decreases the number of automobiles produced faster and faster.","Adding additional workers decreases the number of automobiles produced slower and slower."],"correctAnswer":1,"explanation":"Between 10 and 40 workers on a logistic curve, we are in the early growth phase (before the inflection point). In this region, the curve is concave up, meaning production increases at an accelerating rate -- faster and faster with each additional worker.","category":"Concavity & Curvature","tags":["concavity","logistic","concave-up"],"difficulty":2},{"id":44,"text":"The function C(x), modeling cell phone price versus supply, is a decreasing logistic model (where C is the cost, and x is the number of cell phones available).\n [Graph: Cell Phone Cost - Decreasing Logistic]\n What is happening from x = 100 to x = 300?","options":["The cost of the phone is decreasing faster and faster.","The cost of the phone is increasing slower and slower.","The cost of the phone is increasing faster and faster.","The cost of the phone is decreasing slower and slower."],"correctAnswer":3,"explanation":"In a decreasing logistic model, the region from x = 100 to x = 300 is past the inflection point. The cost is still decreasing but the curve is flattening out (concave up for a decreasing function), meaning the cost decreases slower and slower as it approaches its lower asymptote.","category":"Concavity & Curvature","tags":["concavity","logistic","decreasing"],"difficulty":2},{"id":45,"text":"A factory with an assembly line can produce more automobiles per week as more employees are working at a given time, limited by the capacity of the assembly line. The model follows the function A(w) = 100/(1 + 25e^(-0.06w)) - 4.\n [Graph: Automobile Production]\n How should the upper horizontal asymptote be interpreted?","options":["The factory can produce a maximum of approximately 140 automobiles per week.","The factory can produce a maximum of approximately 95 automobiles per week.","The upper asymptote has no real world meaning in this scenario.","If there is a negative number of workers, then the number of automobiles produced is negative."],"correctAnswer":1,"explanation":"As w approaches infinity, e^(-0.06w) approaches 0, so A = 100/(1 + 0) - 4 = 100 - 4 = 96, which is approximately 95. The upper asymptote represents the maximum production capacity of the assembly line, regardless of how many workers are added.","category":"Exponential & Logistic","tags":["logistic","asymptote","capacity"],"difficulty":2},{"id":46,"text":"The rate that a rumor spreads through a middle school can be determined using the graph below, where R is the number of people who have heard the rumor after d days.\n [Graph: Rumor Spread]\n When should approximately 25% of the maximum number of people hear the rumor?","options":["On day 7","On day 1","On day 3","On day 5"],"correctAnswer":2,"explanation":"Reading the logistic growth graph, the maximum number of people who hear the rumor is the upper asymptote. 25% of that maximum corresponds to the early growth phase. Tracing the graph to where it reaches approximately one quarter of its maximum value leads to approximately day 3.","category":"Graph Reading","tags":["graph-reading","logistic","percentage"],"difficulty":2},{"id":47,"text":"The following graph shows the number of page views for a company's website over time (in months).\n [Graph: Page Views]\n During which month were there approximately 100 page views?","options":["July","February","June","March"],"correctAnswer":2,"explanation":"Reading the graph at y = 100 page views and tracing horizontally to the curve, then down to the x-axis, the month that corresponds to approximately 100 page views is June.","category":"Graph Reading","tags":["graph-reading","find-input","page-views"],"difficulty":1},{"id":48,"text":"The following graph measures revenue from vending machines at a large business on a typical day. The y-axis shows revenue in dollars, and the x-axis shows time based on the 24-hour clock. Revenue was measured every 15 minutes from 7:00 a.m. (700) to 8:00 p.m. (2000).\n [Graph: Vending Machine Revenue]\n What indicates that a shift ends at 5:00 p.m. (1700)?","options":["The vending machine revenues spike around 5:00 p.m. to about $55.","The vending machine revenues fall around 5:00 p.m. to about $20.","The vending machine revenues spike around 5:00 p.m. to about $100.","The vending machine revenues fall around 5:00 p.m. to about $40."],"correctAnswer":0,"explanation":"When a shift ends, employees take breaks and use vending machines before leaving, causing a spike in revenue. The graph shows a revenue spike around 5:00 p.m. reaching approximately $55, indicating the end of a work shift.","category":"Graph Reading","tags":["graph-reading","spike","interpret-event"],"difficulty":2},{"id":49,"text":"The following graph shows the price of the stock of a company x months after December 2014.\n [Graph: Stock Price]\n A program is set to automatically buy this stock on the first day of the month, provided the price is below $20. What month would it have first bought this stock, and would the investment have increased in value the following month?","options":["August 2016; yes, the stock would have increased in value the next month.","November 2015; no, the stock would not have increased in value the next month.","February 2015; no, the stock would not have increased in value the next month.","September 2015; yes, the stock would have increased in value the next month."],"correctAnswer":3,"explanation":"Reading the graph, the stock first drops below $20 at September 2015 (9 months after December 2014). Looking at the next month (October 2015), the stock price increased. So the program would have first bought in September 2015, and the investment would have gained value.","category":"Graph Reading","tags":["graph-reading","threshold","stock"],"difficulty":2},{"id":50,"text":"The following graph shows the number of page views for a company's website over time (in months).\n [Graph: Page Views Over Time]\n Estimate and interpret the average rate of change for the company's page views between March and August.","options":["The average rate of change was about -400 page views per month between these times, which means that the company's page views went down 400 on average each month between these times.","The average rate of change was about 240 page views per month between these times, which means that the company's page views went up 240 on average each month between these times.","The average rate of change was about -240 page views per month between these times, which means that the company's page views went down 240 on average each month between these times.","The average rate of change was about 400 page views per month between these times, which means that the company's page views went up 400 on average each month between these times."],"correctAnswer":2,"explanation":"Reading the graph: March page views are approximately 1,400 and August page views are approximately 200. Average rate of change = (200 - 1400)/(8 - 3) = -1200/5 = -240 page views per month. The negative sign indicates page views decreased on average.","category":"Rate of Change","tags":["rate-of-change","average","negative"],"difficulty":2},{"id":51,"text":"A chain of stores started out as 100 stores the first year, then increased by 400 stores the following year, and then increased each year for the next six years.\n [Graph: Store Growth]\n Which statement about the average rate of change is correct?","options":["The average rate of change from years 1 to 7 is 6 stores per year.","The average rate of change from years 1 to 4 is less than the average rate of change for years 4 to 7.","The average rate of change from years 1 to 7 is 1,200 stores per year.","The average rate of change from years 1 to 4 is greater than the average rate of change from years 4 to 7."],"correctAnswer":1,"explanation":"The graph shows accelerating growth (concave up). When growth is accelerating, the average rate of change over later intervals is greater than over earlier intervals. Therefore, the rate from years 4 to 7 is greater than from years 1 to 4, meaning the rate from years 1 to 4 is less than from years 4 to 7.","category":"Rate of Change","tags":["rate-of-change","compare-intervals","accelerating"],"difficulty":2},{"id":52,"text":"Each point on the following graph represents the revenue returned from a project with a specified marketing budget. The y-axis measures the revenue in thousands of dollars, and the x-axis represents the budget in thousands of dollars.\n [Graph: Revenue vs Budget]\n Which budget should new projects have at this company to maximize revenue?","options":["New projects should have a budget of $9,000 since this returned a revenue of $19,000.","New projects should have a budget of $19,000 since this returned a revenue of $9,000.","New projects should have a budget of $20,000 since this returned a revenue of $6,000.","New projects should have a budget of $6,000 since this returned a revenue of $20,000."],"correctAnswer":0,"explanation":"Reading the scatterplot, the data point with the highest revenue (y-value) is at approximately (9, 19), meaning a budget of $9,000 returned a revenue of $19,000. This is the maximum revenue observed in the data.","category":"Graph Reading","tags":["graph-reading","maximum","scatterplot"],"difficulty":2},{"id":53,"text":"The following graph represents profit on the y-axis (in thousands of dollars) based on production levels on the x-axis (in thousands of units). Each valley represents the decrease in profit after a major production expansion.\n [Graph: Profit with Expansions]\n After which production expansion do profits increase the fastest on average?","options":["The expansion at 9,500 units","The expansion at 3,500 units","The expansion at 1,500 units","The expansion at 6,500 units"],"correctAnswer":1,"explanation":"After each expansion (valley), profits recover and increase. The expansion at 3,500 units shows the steepest upward slope in the recovery phase, meaning profits increase the fastest on average after this particular expansion compared to the others.","category":"Graph Reading","tags":["graph-reading","rate-of-change","expansion"],"difficulty":3},{"id":54,"text":"In last week's sales meeting, a supervisor at a company stressed that current sales are increasing, but the graph of the sales is concave down. She seemed to emphasize this repeatedly to encourage the sales team to change the curvature of the sales.\n What could happen to the company sales if the sales graph keeps the trend of being concave down?","options":["Sales could begin decreasing faster and faster, or sales could begin increasing faster and faster.","Sales could begin decreasing slower and slower, or sales could begin decreasing faster and faster.","Sales could continue increasing slower and slower, or sales could begin decreasing slower and slower.","Sales could continue increasing slower and slower, or sales could begin decreasing faster and faster."],"correctAnswer":3,"explanation":"A concave down graph curves downward. If sales are currently increasing and the graph is concave down, sales are increasing slower and slower (the rate of increase is declining). If this trend continues, sales will eventually peak and begin decreasing. Once decreasing on a concave down graph, sales would decrease faster and faster.","category":"Concavity & Curvature","tags":["concavity","concave-down","prediction"],"difficulty":3},{"id":55,"text":"A technology firm in Erie, Pennsylvania, receives a contract to develop a computer program controlling the angle of a solar array on a daily basis. The firm first needs to model the hours of sunlight for every day of the year.\n From December to March, the hours of daylight are increasing faster and faster, and from March to June, they are increasing slower and slower.\n Which graph would be an appropriate model for this firm to use?","options":["Graph A","Graph B","Graph C","Graph D"],"correctAnswer":0,"explanation":"The description requires: increasing faster and faster (concave up) from December to March, then increasing slower and slower (concave down) from March to June, with an inflection point around March. Graph A shows this S-shaped pattern of concave up transitioning to concave down while continuously increasing.","category":"Concavity & Curvature","tags":["concavity","inflection","model-selection"],"difficulty":3},{"id":56,"text":"The following graph represents revenue from vending machines at a large business during a typical day. The y-axis represents revenue in dollars, and the x-axis represents time.\n [Graph: Vending Machine Revenue]\n What is the difference between the maximum revenue and the minimum revenue?","options":["$15","$100","$60","$85"],"correctAnswer":3,"explanation":"Reading the graph, the maximum revenue is approximately $100 and the minimum revenue is approximately $15. The difference is $100 - $15 = $85. This represents the range of daily revenue from the vending machines.","category":"Graph Reading","tags":["graph-reading","range","revenue"],"difficulty":1},{"id":57,"text":"The U.S. housing price index from 1970 to 2010 is plotted in the graph below.\n [Graph: US Housing Price Index]\n Which conclusion about this graph is correct?","options":["The lowest housing price index occurred in 1995, and the highest housing price index occurred in 2010.","The lowest housing price index occurred in 1970, and the highest housing price index occurred in 2010.","The lowest housing price index occurred in 2000, and the highest housing price index occurred in 2005.","The lowest housing price index occurred in 1970, and the highest housing price index occurred in 2005."],"correctAnswer":3,"explanation":"Reading the graph, the housing price index starts at its lowest point in 1970 and rises over the decades, reaching its peak around 2005 before declining. The highest value is around 2005, not 2010 (which shows the post-crash decline).","category":"Graph Reading","tags":["graph-reading","extremes","housing"],"difficulty":2},{"id":58,"text":"A company is trying to develop a computer algorithm to predict whether a customer will make a purchase of $100 or more. As the company collects more customer data, it updates its algorithm. The graph shows the algorithm's error rate for various amounts of customer data.\n [Graph: Error Rate]\n Which conclusion can the company make about the error rate for this algorithm?","options":["The error rate constantly decreases toward 0% error.","The error rate stabilizes and approaches an error rate of 2.5%.","The decrease in error rate is unsustainable and will eventually increase.","The asymptote indicates that 2.5% of customers make purchases of $100 or more in the online store."],"correctAnswer":1,"explanation":"The graph shows the error rate decreasing rapidly at first, then leveling off and approaching a horizontal asymptote at approximately 2.5%. The error rate stabilizes rather than continuing to decrease to 0%, indicating there is a fundamental limit to the algorithm's accuracy.","category":"Exponential & Logistic","tags":["asymptote","error-rate","algorithm"],"difficulty":2},{"id":59,"text":"The average cost in dollars, A(x), to produce x cell phone screen covers is given by the graph below.\n [Graph: Average Cost]\n What happens to the average cost as more and more covers are produced?","options":["The average cost increases to about $15 per cover.","The average cost reduces to about $0 per cover.","The average cost increases to about $4 per cover.","The average cost reduces to about $2 per cover."],"correctAnswer":3,"explanation":"Reading the graph, as x increases, the average cost curve decreases and approaches a horizontal asymptote at approximately $2 per cover. The cost decreases due to economies of scale but never reaches $0 because there are always some per-unit costs.","category":"Exponential & Logistic","tags":["asymptote","average-cost","economies-of-scale"],"difficulty":2},{"id":60,"text":"A software developer recently launched a new social media app and is studying user retention. Group A shared 3+ pictures in the first 5 days (solid line); Group B did not (dashed line). The graph shows retention rates over time.\n [Graph: User Retention]\n Which conclusion can be made from the data in this graph?","options":["The retention rates of both Group A and Group B stabilize as time increases and will eventually level off at the same rate.","The retention rate of Group B stabilizes as time increases, but the retention rate of Group A continues to decrease.","The retention rate of Group A stabilizes as time increases, but the retention rate of Group B continues to decrease.","The retention rates of both Group A and Group B stabilize as time increases and appear to have different asymptotes."],"correctAnswer":3,"explanation":"The graph shows both curves leveling off over time, each approaching its own horizontal asymptote. Group A (active users) stabilizes at a higher retention rate than Group B. The two different asymptotes indicate that early engagement (sharing pictures) leads to a permanently higher retention rate.","category":"Exponential & Logistic","tags":["asymptote","retention","compare-groups"],"difficulty":2},{"id":61,"text":"The following graph shows the sales of two popular items a company sells for a random sample of months. The company has chosen to fit the data with a linear model, and r^2 = 0.82.\n [Graph: Sales with Linear Fit]\n Is the linear function a good regression model for the data?","options":["No, the data would fit better with an exponential function.","Yes, the data is strongly correlated, and it has a roughly constant rate of change.","No, the data would fit better with a logistic function.","Yes, the data is S-shaped and therefore is best modeled by a linear function."],"correctAnswer":1,"explanation":"An r^2 value of 0.82 indicates a strong correlation (generally r^2 > 0.7 is considered strong). The data shows a roughly linear pattern with a constant rate of change, making a linear model appropriate. The data is not S-shaped or exponential in nature.","category":"Regression & Predictions","tags":["regression","r-squared","linear-fit"],"difficulty":2},{"id":62,"text":"A business wants to model the relationship between the number of items sold for two similar products. The monthly sales data for 20 months are shown in the graph below. The company fit its data with a linear model, which has an R-squared value of r^2 = 0.18.\n [Graph: Weak Linear Fit]\n What does r^2 imply for the fit of the model?","options":["This model has a weak fit; therefore, predictions should not be made based on this function.","This model has a weak fit; therefore, predictions can be reliably made based on this function.","This model has a moderate fit; therefore, predictions should not be made based on this function.","This model has a moderate fit; therefore, predictions can be reliably made based on this function."],"correctAnswer":0,"explanation":"An r^2 value of 0.18 means only 18% of the variation in the data is explained by the model. This is a very weak fit (well below 0.5). With such a weak correlation, predictions based on this model would be unreliable and should not be made.","category":"Regression & Predictions","tags":["regression","r-squared","weak-fit"],"difficulty":1},{"id":63,"text":"A real estate agent wanted to develop a model for the number of days a rental property sits vacant based on how the rental price compares to market value. The agent fit the data with an exponential function, which has an r^2 value of 0.83.\n [Graph: Vacancy vs Price]\n Is this exponential function a good regression model for the data?","options":["Yes, the data points increase by a constant rate.","No, there is a moderate correlation, and a linear function would be a better fit for the data.","Yes, there is a strong correlation, and the data points increase approximately by a constant ratio.","No, a polynomial model would be a better fit for the data."],"correctAnswer":2,"explanation":"With r^2 = 0.83, the correlation is strong. Exponential functions are characterized by data that increases by a constant ratio (multiplicative growth) rather than a constant amount. The data pattern matches exponential behavior, confirming the model is a good fit.","category":"Regression & Predictions","tags":["regression","exponential","constant-ratio"],"difficulty":2},{"id":64,"text":"A student created the scatterplot of data on the graph below. The x-axis represents the number of items, and the y-axis represents the total cost. The student drew a line of best fit. The calculator produced r^2 = 0.9946991797.\n [Graph: Items vs Cost]\n How can the value of r^2 be interpreted?","options":["The number of items has no correlation to the total cost.","The number of items has a weak correlation to the total cost.","The number of items has a moderate correlation to the total cost.","The number of items has a strong correlation to the total cost."],"correctAnswer":3,"explanation":"An r^2 value of 0.9947 is extremely close to 1, indicating that approximately 99.5% of the variation in total cost is explained by the number of items. This is a very strong correlation, meaning the linear model fits the data almost perfectly.","category":"Regression & Predictions","tags":["regression","r-squared","interpret"],"difficulty":1},{"id":65,"text":"A company has tracked the depreciating value of a company car over a 10-year period. The company performed a regression and modeled the value of the car, V, at year x with the function V(x) = 26,878.23e^(-0.21x) with r^2 = 0.98.\n [Graph: Car Depreciation]\n Would it be appropriate to use this model to make a prediction for the value of the car when the car is 12 years old?","options":["Yes, it would be appropriate because the data has a strong correlation, and 12 is within the range for accurate extrapolation.","Yes, it would be appropriate because 12 is an interpolation value.","No, it would not be appropriate because 12 is not close enough to the known data values, so it would be an extreme extrapolation value.","No, it would not be appropriate because 12 is an interpolation value."],"correctAnswer":2,"explanation":"The data covers years 0-10. Predicting at x = 12 is extrapolation (outside the known data range). While x = 12 is not extremely far from x = 10, it is far enough outside the 10-year data window that the model may not accurately represent real depreciation. This makes it an extreme extrapolation that should not be relied upon.","category":"Regression & Predictions","tags":["regression","extrapolation","appropriate"],"difficulty":2},{"id":66,"text":"A local university collects data related to its increasing enrollment for the past 19 years. The university models this with the logistic function P(t) = 9.51/(1 + 11.96e^(-0.37t)) with r^2 = 0.96, where t is time in years, and P is enrollment in thousands.\n [Graph: University Enrollment]\n Would it be appropriate for the university to use this model to predict enrollment five years from now (when t = 24)?","options":["Yes, t = 24 is an interpolation value.","Yes, the data are strongly correlated, so this would be considered a somewhat safe extrapolation.","No, the data is moderately correlated, so this would be considered too risky of an extrapolation.","No, t = 24 is an extreme extrapolation value."],"correctAnswer":1,"explanation":"The r^2 = 0.96 indicates very strong correlation. While t = 24 is outside the 19-year data range (extrapolation), it is only 5 years beyond, which is considered a somewhat safe extrapolation. Additionally, logistic functions naturally level off, so predictions slightly beyond the data are more reliable than with other model types.","category":"Regression & Predictions","tags":["regression","extrapolation","logistic","safe"],"difficulty":2},{"id":67,"text":"A company examined cost data in an effort to model the relationship between number of items produced, x, and cost, C. The regression equation is C(x) = 0.52x + 366 with a coefficient of determination of r^2 = 0.92. The company plans to use this function to determine the cost of producing 45 items.\n [Graph: Cost vs Items]\n Is the company's plan appropriate?","options":["No, it is not appropriate because the data should be modeled with a logistic function.","Yes, it is appropriate because as the number of items produced increases, so does the cost.","No, it is not appropriate because the data should be modeled with an exponential function.","Yes, it is appropriate because the coefficient of determination is close to 1, and this is an interpolation value."],"correctAnswer":3,"explanation":"The plan is appropriate for two reasons: (1) r^2 = 0.92 is close to 1, indicating a strong fit, and (2) x = 45 falls within the range of known data values, making it an interpolation (not extrapolation). Both conditions support making a reliable prediction.","category":"Regression & Predictions","tags":["regression","interpolation","r-squared"],"difficulty":2},{"id":68,"text":"A company has tracked the relationship between the selling price of an item, x, and the revenue generated by the sales of that item, f. The company performs a polynomial regression on the data and models the data with the function f(x) = -24.34x^2 + 336.21x + 53.88 with r^2 = 0.93.\n [Graph: Revenue vs Price]\n The company uses this model to predict that if it charges $12 per item, it will earn a revenue of approximately $583.44.\n Is this conclusion valid and why?","options":["No, it is not a valid conclusion because this data would be better modeled with a logistic function.","Yes, it is a valid conclusion because the relationship between selling price and revenue is quadratic.","No, it is not a valid conclusion because f(12) = 529.56.","Yes, it is a valid conclusion because f(12) = 583.44, r^2 is close to 1, and 12 is not far outside of the known data values."],"correctAnswer":3,"explanation":"Checking: f(12) = -24.34(144) + 336.21(12) + 53.88 = -3504.96 + 4034.52 + 53.88 = 583.44. The calculation is correct, r^2 = 0.93 indicates a strong fit, and x = 12 is close to the known data range. All three conditions validate the conclusion.","category":"Regression & Predictions","tags":["regression","polynomial","validate-prediction"],"difficulty":3},{"id":69,"text":"A company has tracked the relationship between the number of units of an item that sold, x, (measured in thousands) and the total revenue earned from the item in dollars, A. The company decided to perform an exponential regression and found the function A(x) = 223.7e^(0.04x) with r^2 = 0.76.\n [Graph: Revenue vs Units]\n The company uses this model to predict that when it sells 180,000 items, its revenue will be approximately $300,000.\n Is this a valid conclusion and why?","options":["Yes, this is a valid conclusion because A(180) = 300,000, and r^2 is close to 1, so the model is a good fit for the data.","Yes, this is a valid conclusion because the data is following an exponential pattern.","No, this is not a valid conclusion because A(180) = 200,000.","No, an accurate prediction cannot be made when x = 180 because it is too far from the known data values."],"correctAnswer":3,"explanation":"Even though r^2 = 0.76 suggests a moderate fit, x = 180 (180,000 items) is far outside the range of known data values. Extrapolating exponential functions far beyond the data range produces highly unreliable predictions. The extreme extrapolation makes this prediction invalid.","category":"Regression & Predictions","tags":["regression","extrapolation","invalid"],"difficulty":2},{"id":70,"text":"A company has tracked the depreciating value of a company car over an eight-year period. The company performed a linear regression and modeled the value of the car, V, at year x with the function V(x) = -2606.54x + 24109.37 with r^2 = 0.96.\n [Graph: Car Depreciation - Linear]\n Would it be appropriate to use this model to predict the value of the car when the car is 10 years old?","options":["Yes, it would be appropriate because r^2 is close to 1, and x = 10 is close to the given data values.","No, it would not be appropriate because this situation should be modeled using a quadratic function.","Yes, it would be appropriate because car depreciation should be modeled with a decreasing linear function.","No, it would not be appropriate because past x = 9 the linear trend will not continue, and data cannot be extrapolated."],"correctAnswer":0,"explanation":"The r^2 = 0.96 indicates a very strong linear correlation. Since the data covers 8 years and x = 10 is only 2 years beyond the data range, this is a close extrapolation. The strong fit combined with the proximity to known data makes this prediction appropriate.","category":"Regression & Predictions","tags":["regression","extrapolation","close","appropriate"],"difficulty":2}]}
</script>

<!-- GAMIFICATION UI ELEMENTS -->
<!-- Combo Display -->
<div class="combo-display" id="comboDisplay">
    <span class="combo-fire">🔥</span>
    <span class="combo-count" id="comboCount">x0</span>
    <span class="combo-mult" id="comboMult">1.0x</span>
</div>

<!-- Achievement Toast -->
<div class="achievement-toast hidden" id="achievementToast">
    <div class="ach-icon" id="achIcon">🏆</div>
    <div class="ach-info">
        <div class="ach-name" id="achName">Achievement</div>
        <div class="ach-desc" id="achDesc">Description</div>
        <div class="ach-xp" id="achXp">+100 XP</div>
    </div>
</div>

<!-- Level Up Modal -->
<div class="levelup-overlay" id="levelupOverlay" onclick="if(event.target===this)Gamification.closeLevelUp()">
    <div class="levelup-modal">
        <div class="level-icon">⬆️</div>
        <h2>LEVEL UP!</h2>
        <div class="level-num" id="levelupNum">2</div>
        <div class="level-title" id="levelupTitle">Algebra Apprentice</div>
        <div class="level-rewards" id="levelupRewards"></div>
        <button onclick="Gamification.closeLevelUp()">Awesome!</button>
    </div>
</div>

<!-- Study Buddy Widget -->
<div class="study-buddy" id="studyBuddy">
    <div class="buddy-sprite" id="buddySprite">🥚</div>
    <div class="buddy-name" id="buddyName">Mathie</div>
    <div class="buddy-mood" id="buddyMood">Sleepy</div>
    <div class="buddy-progress">
        <div class="buddy-progress-fill" id="buddyProgress" style="width:0%"></div>
    </div>
</div>

<!-- Confetti Canvas -->
<canvas id="confettiCanvas"></canvas>

</body>
</html>
