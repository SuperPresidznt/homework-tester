<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Xooper's Battleground</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"></script>
    <style>
@import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@600;700&display=swap');
/* === RESET & VARIABLES === */
*{box-sizing:border-box;margin:0;padding:0}
:root{
    --navy:#1a3a5c;--navy-dark:#0d2137;--blue:#2980b9;--blue-light:#3498db;
    --green:#27ae60;--green-light:#2ecc71;--red:#c0392b;--red-light:#e74c3c;
    --orange:#f39c12;--yellow:#ffd60a;
    --bg:#e8e8e8;--white:#fff;--gray-50:#f5f5f5;--gray-100:#eee;
    --gray-200:#ddd;--gray-300:#ccc;--gray-400:#aaa;--gray-500:#999;--gray-600:#777;
    --gray-700:#555;--gray-800:#333;--gray-900:#222;
    --radius:4px;--shadow:0 2px 8px rgba(0,0,0,.12);
}
html,body{width:100%;max-width:100vw;overflow-x:hidden}
body{font-family:Arial,Helvetica,sans-serif;font-size:14px;background:var(--bg);color:var(--gray-800);min-height:100vh;-webkit-tap-highlight-color:transparent;margin:0;padding:0}
a{color:var(--blue);text-decoration:none}
a:hover{text-decoration:underline}
button{font-family:inherit;cursor:pointer;transition:transform .1s ease}
button:active:not(:disabled){transform:scale(0.97)}

/* === HEADER === */
.main-header{background:linear-gradient(to bottom,var(--navy),var(--navy-dark));color:#fff;border-bottom:3px solid var(--blue)}
.header-top{display:flex;align-items:center;justify-content:space-between;padding:8px 20px;min-height:55px}
.logo-link{background:transparent;border:none;padding:0;margin:0;cursor:pointer;color:inherit;font:inherit}
.logo-link:focus-visible{outline:2px solid #fff;outline-offset:4px;border-radius:8px}
.logo-area{display:flex;align-items:center;gap:12px}
.logo-mark{width:52px;height:52px;flex-shrink:0;filter:drop-shadow(0 6px 12px rgba(255,255,255,.25)) drop-shadow(0 12px 24px rgba(14,17,33,.35));}
.logo-text{font-family:'Space Grotesk','Segoe UI',sans-serif;font-size:20px;font-weight:700;letter-spacing:.8px;text-transform:uppercase;line-height:1}
.logo-text::after{content:'BETA';font-size:10px;font-weight:600;margin-left:8px;padding:2px 6px;background:rgba(255,255,255,.15);border-radius:99px;letter-spacing:.6px}
.header-actions{display:flex;align-items:center;gap:12px}
.header-actions button{background:none;border:1px solid rgba(255,255,255,.3);color:#fff;padding:5px 12px;border-radius:var(--radius);font-size:12px}
.header-actions button:hover{background:rgba(255,255,255,.1)}

/* === SUBHEADER === */
.subheader{background:var(--gray-50);border-bottom:1px solid var(--gray-300);display:flex;align-items:center;justify-content:space-between;padding:6px 20px;min-height:40px;flex-wrap:wrap;gap:8px}
.test-name{font-size:15px;font-weight:bold;color:var(--navy)}
.test-name span{background:#ff0;padding:1px 6px}
.section-tab{display:inline-block;background:var(--navy);color:#fff;padding:5px 16px;border-radius:3px 3px 0 0;font-size:13px;font-weight:bold}
.timer-area{display:flex;align-items:center;gap:10px;font-size:13px;color:var(--gray-700)}
.timer-display{font-family:'Courier New',monospace;font-size:16px;font-weight:bold;color:var(--red);background:#fff;border:1px solid var(--gray-300);padding:3px 10px;border-radius:3px}
.timer-display.warning{animation:flash .5s infinite alternate}
@keyframes flash{from{background:#fff}to{background:#ffeaea;color:#c0392b}}
[data-theme="dark"] .timer-display.warning{animation:flashDark .5s infinite alternate}
@keyframes flashDark{from{background:#1f2937}to{background:#450a0a;color:#fca5a5}}
.timer-toggle{color:#1a5276;cursor:pointer;font-size:12px;font-weight:bold}

/* === SCREENS === */
.screen{display:none;width:100vw;max-width:100vw;margin:0;padding:clamp(8px,2vw,20px);min-height:calc(100vh - 200px);opacity:0;transform:translateY(6px);transition:opacity .25s ease,transform .25s ease;box-sizing:border-box}
.screen.active{display:block;opacity:1;transform:translateY(0)}
.screen.active{animation:screenIn .25s ease forwards}
@keyframes screenIn{from{opacity:0;transform:translateY(6px)}to{opacity:1;transform:translateY(0)}}

/* === HOME SCREEN === */
.home-layout{display:flex;flex-direction:column;gap:16px;align-items:stretch;padding:8px 0;width:100%}
.home-main{flex:1 1 100%;min-width:0}
.home-side{flex:1 1 100%;width:100%;display:flex;flex-direction:column;gap:16px;position:static}
.home-hero{text-align:center;padding:30px 0 10px}
.home-hero h1{color:var(--navy);font-size:28px;margin-bottom:8px}
.home-hero p{color:var(--gray-600);font-size:15px}
.bank-list-header{display:flex;align-items:flex-end;justify-content:space-between;gap:20px;margin:10px 0 6px}
.bank-list-header h2{font-size:18px;color:var(--navy);margin:0}
.bank-list-header p{font-size:13px;color:var(--gray-600);margin:4px 0 0}
.bank-list-subtle{font-size:12px;color:var(--gray-500);font-weight:600;text-transform:uppercase}
.quick-actions{display:flex;flex-direction:column;gap:10px}
.quick-actions .btn-nav{width:100%}

.stats-panel{background:var(--white);border:1px solid var(--gray-200);border-radius:12px;padding:0 16px;margin:20px 0;box-shadow:0 4px 18px rgba(15,23,42,.05)}
.stats-panel summary{list-style:none;display:flex;align-items:center;justify-content:space-between;font-size:15px;font-weight:600;color:var(--navy);cursor:pointer;padding:16px 0;margin:0}
.stats-panel summary::-webkit-details-marker{display:none}
.stats-panel summary .summary-caret{font-size:18px;color:var(--gray-500);transition:transform .2s ease}
.stats-panel:not([open]) summary .summary-caret{transform:rotate(-90deg)}
.stats-panel[open] summary{border-bottom:1px solid var(--gray-100);margin-bottom:12px}
.stats-row{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:12px;max-height:240px;overflow-y:auto;padding:12px 6px 16px}
.meta-panel{background:var(--white);border:1px solid var(--gray-200);border-radius:12px;margin:12px 0 20px;padding:0 16px;box-shadow:0 10px 30px rgba(15,23,42,.05)}
.meta-panel summary{list-style:none;display:flex;align-items:center;justify-content:space-between;font-size:14px;font-weight:600;color:var(--navy);cursor:pointer;padding:14px 0;margin:0}
.meta-panel summary::-webkit-details-marker{display:none}
.meta-panel summary .summary-meta{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.meta-panel summary .summary-caret{font-size:16px;color:var(--gray-500);transition:transform .2s ease}
.meta-panel:not([open]) summary .summary-caret{transform:rotate(-90deg)}
.meta-panel[open]{padding-bottom:12px}
.meta-panel[open] summary{border-bottom:1px solid var(--gray-100);margin-bottom:12px}
.meta-glance{display:flex;flex-wrap:wrap;gap:8px;justify-content:center;margin:12px 0}
.meta-pill{background:rgba(15,23,42,.08);color:var(--navy);font-size:12px;padding:6px 12px;border-radius:999px;display:inline-flex;align-items:center;gap:6px;font-weight:600}
.meta-pill span{font-weight:500;color:var(--gray-600)}
.meta-pill .pill-source{font-size:10px;color:var(--gray-500);font-weight:500}
.stat-card{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:16px;text-align:center;transition:transform .2s ease,box-shadow .2s ease}
.stat-card:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.08)}
.stat-card .stat-val{font-size:28px;font-weight:bold;color:var(--navy)}
.stat-card .stat-lbl{font-size:12px;color:var(--gray-600);margin-top:4px}

@media(max-width:1400px){
    .home-layout{flex-direction:column}
    .home-main{order:1}
    .home-side{order:2;width:100%;position:static}
    .quick-actions{flex-direction:row;flex-wrap:wrap;justify-content:center}
    .quick-actions .btn-nav{flex:1 1 150px}
}

@media(max-width:1024px){
    #bankList{grid-template-columns:repeat(auto-fit,minmax(300px,1fr));gap:18px}
    .mode-buttons{grid-template-columns:repeat(auto-fit,minmax(150px,1fr))}
}

@media(max-width:768px){
    #bankList{grid-template-columns:1fr;gap:14px}
    .bank-card{padding:18px}
}

/* === STREAK & DAILY GOAL === */
.streak-banner{display:flex;align-items:center;justify-content:center;gap:12px;margin:16px 0;padding:16px;background:linear-gradient(135deg,#ff6b35,#f7931e);border-radius:12px;color:#fff;font-weight:bold}
.streak-banner .streak-flame{font-size:32px;line-height:1}
.streak-banner .streak-info{text-align:left}
.streak-banner .streak-count{font-size:24px}
.streak-banner .streak-label{font-size:12px;opacity:.9;font-weight:normal}
.streak-banner.no-streak{background:var(--gray-200);color:var(--gray-600)}
.streak-banner.no-streak .streak-flame{opacity:.5}

.daily-goal-card{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:16px;margin:12px 0}
.daily-goal-card h3{font-size:14px;color:var(--navy);margin-bottom:8px;display:flex;align-items:center;gap:8px}
.daily-goal-card .goal-progress{display:flex;align-items:center;gap:12px}
.daily-goal-card .goal-bar{flex:1;height:12px;background:var(--gray-200);border-radius:6px;overflow:hidden}
.daily-goal-card .goal-bar-fill{height:100%;background:linear-gradient(90deg,var(--green),var(--green-light));border-radius:6px;transition:width .3s ease}
.daily-goal-card .goal-bar-fill.complete{background:linear-gradient(90deg,var(--green),#2ecc71)}
.daily-goal-card .goal-text{font-size:14px;color:var(--gray-700);min-width:100px;text-align:right}
.daily-goal-card .goal-text.complete{color:var(--green);font-weight:bold}
.goal-celebration{text-align:center;padding:8px;margin-top:8px;background:#eafaf1;border-radius:6px;color:var(--green);font-weight:bold;animation:goalPulse .5s ease}
@keyframes goalPulse{0%,100%{transform:scale(1)}50%{transform:scale(1.02)}}

/* === DAILY CHALLENGES === */
.daily-challenges-card{background:var(--white);border:1px solid var(--gray-200);border-radius:12px;padding:16px;margin:12px 0;box-shadow:0 2px 8px rgba(0,0,0,.05)}
.daily-challenges-card h3{font-size:15px;color:var(--navy);margin-bottom:12px;display:flex;align-items:center;justify-content:space-between}
.challenges-reset{font-size:11px;color:var(--gray-500);font-weight:normal}
.challenges-list{display:flex;flex-direction:column;gap:10px}
.challenge-item{display:flex;align-items:center;gap:12px;padding:12px;background:var(--gray-50);border-radius:8px;border:1px solid var(--gray-200);transition:all .2s ease}
.challenge-item:hover{border-color:var(--blue-light);background:#f8fafc}
.challenge-item.completed{background:linear-gradient(135deg,#ecfdf5,#d1fae5);border-color:#86efac}
.challenge-icon{font-size:24px;width:36px;text-align:center}
.challenge-info{flex:1;min-width:0}
.challenge-name{font-weight:600;color:var(--navy);font-size:13px}
.challenge-desc{font-size:11px;color:var(--gray-600);margin:2px 0 6px}
.challenge-progress-bar{height:6px;background:var(--gray-200);border-radius:3px;overflow:hidden}
.challenge-progress-fill{height:100%;background:linear-gradient(90deg,var(--blue),var(--blue-light));border-radius:3px;transition:width .3s ease}
.challenge-item.completed .challenge-progress-fill{background:linear-gradient(90deg,var(--green),var(--green-light))}
.challenge-status{min-width:50px;text-align:right}
.challenge-count{font-size:12px;font-weight:600;color:var(--gray-600)}
.challenges-complete-bonus{text-align:center;padding:10px;margin-top:8px;background:linear-gradient(135deg,#fef3c7,#fde68a);border-radius:8px;color:#92400e;font-weight:600;font-size:13px}
[data-theme="dark"] .daily-challenges-card{background:#16213e;border-color:#374151}

/* === STREAK MULTIPLIER === */
.streak-mult{display:inline-block;background:linear-gradient(135deg,#fbbf24,#f59e0b);color:#fff;padding:2px 8px;border-radius:12px;font-size:11px;font-weight:700;margin-left:6px;animation:streakGlow 2s ease-in-out infinite}
.streak-next{font-size:10px;color:var(--gray-500);font-weight:normal}
@keyframes streakGlow{0%,100%{box-shadow:0 0 4px rgba(251,191,36,.4)}50%{box-shadow:0 0 12px rgba(251,191,36,.8)}}

/* === KEYBOARD SHORTCUTS HELP === */
.shortcuts-help{padding:12px;background:var(--gray-50);border-radius:8px;margin-top:12px}
.shortcuts-help h4{margin:0 0 10px;font-size:14px;color:var(--navy)}
.shortcuts-section{margin-bottom:12px}
.shortcuts-section strong{font-size:12px;color:var(--gray-600);display:block;margin-bottom:6px}
.shortcuts-section ul{list-style:none;padding:0;margin:0;display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:4px}
.shortcuts-section li{font-size:12px;color:var(--gray-700);display:flex;align-items:center;gap:6px}
.shortcuts-section kbd{display:inline-block;background:var(--white);border:1px solid var(--gray-300);border-radius:4px;padding:2px 6px;font-family:monospace;font-size:11px;color:var(--navy);box-shadow:0 1px 2px rgba(0,0,0,.1)}
[data-theme="dark"] .shortcuts-help{background:#1f2937}
[data-theme="dark"] .shortcuts-help h4{color:#93c5fd}
[data-theme="dark"] .shortcuts-section strong{color:#9ca3af}
[data-theme="dark"] .shortcuts-section li{color:#d1d5db}
[data-theme="dark"] .shortcuts-section kbd{background:#374151;border-color:#4b5563;color:#e5e7eb}

/* === STUDY ANALYTICS === */
.analytics-card{background:var(--white);border:1px solid var(--gray-200);border-radius:12px;padding:16px;margin:12px 0;box-shadow:0 2px 8px rgba(0,0,0,.05)}
.analytics-card h3{font-size:15px;color:var(--navy);margin-bottom:12px}
.analytics-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:8px;margin-bottom:12px}
.analytics-stat{text-align:center;padding:8px;background:var(--gray-50);border-radius:8px}
.analytics-val{font-size:18px;font-weight:700;color:var(--navy)}
.analytics-lbl{font-size:10px;color:var(--gray-600);margin-top:2px}
.analytics-trend{display:flex;align-items:center;gap:8px;padding:8px 12px;background:var(--gray-50);border-radius:8px;margin-bottom:12px}
.trend-icon{font-size:18px}
.trend-text{font-size:13px;font-weight:600}
.analytics-time-dist{margin-bottom:12px}
.time-dist-label{font-size:11px;color:var(--gray-600);margin-bottom:6px}
.time-dist-bars{display:flex;justify-content:space-between;align-items:flex-end;height:50px;gap:4px}
.time-dist-bar{flex:1;display:flex;flex-direction:column;align-items:center}
.time-bar-fill{width:100%;background:linear-gradient(180deg,var(--blue),var(--blue-light));border-radius:3px 3px 0 0;min-height:3px;transition:height .3s ease}
.time-bar-day{font-size:9px;color:var(--gray-500);margin-top:4px}
.analytics-goal{padding:8px;background:var(--gray-50);border-radius:8px}
.goal-label{font-size:11px;color:var(--gray-600);margin-bottom:4px}
.goal-bar-mini{height:6px;background:var(--gray-200);border-radius:3px;overflow:hidden}
.goal-bar-fill-mini{height:100%;background:linear-gradient(90deg,var(--green),var(--green-light));border-radius:3px;transition:width .3s ease}
[data-theme="dark"] .analytics-card{background:#16213e;border-color:#374151}
[data-theme="dark"] .analytics-card h3{color:#93c5fd}
[data-theme="dark"] .analytics-stat{background:#1f2937}
[data-theme="dark"] .analytics-val{color:#e5e7eb}
[data-theme="dark"] .analytics-lbl{color:#9ca3af}
[data-theme="dark"] .analytics-trend{background:#1f2937}
[data-theme="dark"] .analytics-time-dist .time-dist-label{color:#9ca3af}
[data-theme="dark"] .time-bar-day{color:#6b7280}
[data-theme="dark"] .analytics-goal{background:#1f2937}
[data-theme="dark"] .goal-label{color:#9ca3af}
[data-theme="dark"] .goal-bar-mini{background:#374151}

/* === GARDEN GRAVEYARD === */
.garden-graveyard{text-align:center;padding:12px;background:linear-gradient(135deg,#1f2937,#374151);border-radius:12px}
.graveyard-header{font-size:14px;font-weight:600;color:#9ca3af;margin-bottom:8px}
.graveyard-list{display:flex;flex-direction:column;gap:4px}
.graveyard-pet{display:flex;align-items:center;gap:8px;padding:6px 10px;background:rgba(0,0,0,0.2);border-radius:6px;cursor:pointer;transition:background 0.2s}
.graveyard-pet:hover{background:rgba(99,102,241,0.3)}
.graveyard-icon{font-size:16px}
.graveyard-name{font-size:12px;color:#d1d5db}
.graveyard-footer{font-size:11px;color:#6b7280;margin-top:8px}
.garden-no-pet{text-align:center;padding:16px}

[data-theme="dark"] .daily-challenges-card h3{color:#93c5fd}
[data-theme="dark"] .challenge-item{background:#1f2937;border-color:#374151}
[data-theme="dark"] .challenge-item:hover{background:#1e3a5f;border-color:#60a5fa}
[data-theme="dark"] .challenge-item.completed{background:linear-gradient(135deg,#064e3b,#065f46);border-color:#34d399}
[data-theme="dark"] .challenge-name{color:#e5e7eb}
[data-theme="dark"] .challenge-desc{color:#9ca3af}
[data-theme="dark"] .challenge-progress-bar{background:#374151}
[data-theme="dark"] .challenge-count{color:#9ca3af}
[data-theme="dark"] .challenges-complete-bonus{background:linear-gradient(135deg,#78350f,#92400e);color:#fde68a}

#bankList{display:grid;grid-template-columns:1fr;gap:16px;width:100%}
.bank-card{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:20px;box-shadow:var(--shadow);transition:box-shadow .2s ease;height:100%;display:flex;flex-direction:column}
.bank-card:hover{box-shadow:0 4px 16px rgba(0,0,0,.15)}
.bank-card h2{color:var(--navy);font-size:20px;margin-bottom:4px}
.bank-card .bank-desc{color:#555;font-size:13px;margin-bottom:16px}
.bank-card .bank-meta{display:flex;gap:16px;font-size:12px;color:var(--gray-600);margin-bottom:16px;flex-wrap:wrap}

.mode-buttons{display:grid;grid-template-columns:repeat(auto-fit,minmax(180px,1fr));gap:10px}
.mode-btn{padding:14px 16px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);text-align:left;transition:all .2s ease}
.mode-btn:hover{border-color:var(--blue);background:#f0f7ff;transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1)}
.mode-btn h3{font-size:14px;color:var(--navy);margin-bottom:4px}
.mode-btn p{font-size:12px;color:var(--gray-600);line-height:1.4}
.mode-btn.m-test{border-left:4px solid var(--red)}
.mode-btn.m-practice{border-left:4px solid var(--green)}
.mode-btn.m-drill{border-left:4px solid var(--orange)}
.mode-btn.m-review{border-left:4px solid var(--blue)}
.mode-btn.m-ai{border-left:4px solid #9b59b6}

/* === AI PRACTICE MODE === */
.ai-practice-container{max-width:700px;margin:0 auto}
.ai-progress{text-align:center;color:var(--gray-600);font-size:14px;margin-bottom:20px;padding:16px;background:var(--white);border:1px solid var(--gray-200);border-radius:8px}
.ai-progress .targeting{font-weight:bold;color:#9b59b6;font-size:16px;margin-bottom:8px}
.ai-progress .session-stats{display:flex;justify-content:center;gap:20px;margin-top:8px;flex-wrap:wrap}
.ai-progress .session-stat{text-align:center}
.ai-progress .session-stat .val{font-size:20px;font-weight:bold;color:var(--navy)}
.ai-progress .session-stat .lbl{font-size:11px;color:var(--gray-600)}
.ai-progress .weak-areas{margin-top:12px;font-size:12px;color:var(--gray-600)}
.ai-progress .weak-areas .weak-cat{display:inline-block;background:var(--gray-100);padding:2px 8px;border-radius:12px;margin:2px 4px;font-size:11px}
.ai-progress .weak-areas .weak-cat.current{background:#9b59b6;color:#fff}

.ai-card{background:#fff;border:1px solid var(--gray-300);border-radius:8px;padding:30px;min-height:300px;box-shadow:var(--shadow)}
.ai-card .ai-loading{text-align:center;padding:60px 20px;color:var(--gray-600)}
.ai-card .ai-loading .spinner{display:inline-block;width:40px;height:40px;border:4px solid var(--gray-200);border-top:4px solid #9b59b6;border-radius:50%;animation:aispin 1s linear infinite;margin-bottom:16px}
@keyframes aispin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.ai-card .ai-loading p{font-size:14px;margin-top:8px}
.ai-card .question-text{font-size:16px;line-height:1.7;margin-bottom:20px}
.ai-card .options-list{list-style:none}
.ai-card .option-item{display:flex;align-items:flex-start;gap:10px;padding:12px 14px;margin:8px 0;border:1px solid var(--gray-200);border-radius:var(--radius);cursor:pointer;transition:all .15s}
.ai-card .option-item:hover:not(.disabled){background:#f0f7ff;border-color:var(--blue)}
.ai-card .option-item.selected{background:#e3f0fc;border-color:var(--blue)}
.ai-card .option-item.correct-answer{border:2px solid var(--green);background:#eafaf1}
.ai-card .option-item.wrong-answer{border:2px solid var(--red);background:#fdf2f2}
.ai-card .option-item.disabled{cursor:not-allowed;opacity:0.8}
.ai-card .option-label{font-size:14px;line-height:1.6}

.ai-card .ai-explanation{margin-top:20px;padding:16px;border-radius:var(--radius);background:#f0faf4;border:1px solid #c3e6cb;font-size:14px;line-height:1.6;color:#155724}
.ai-card .ai-explanation.incorrect{background:#fdf2f2;border-color:#f5c6cb;color:#721c24}
.ai-card .ai-explanation h4{margin-bottom:8px;font-size:15px}

.ai-card .ai-buttons{display:flex;gap:10px;margin-top:20px;justify-content:center;flex-wrap:wrap}
.ai-card .ai-btn{padding:12px 24px;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold;color:#fff;min-width:140px;cursor:pointer}
.ai-card .ai-btn.btn-check{background:#9b59b6}
.ai-card .ai-btn.btn-check:hover{background:#8e44ad}
.ai-card .ai-btn.btn-check:disabled{background:var(--gray-500);cursor:not-allowed}
.ai-card .ai-btn.btn-next{background:var(--blue)}
.ai-card .ai-btn.btn-next:hover{background:var(--blue-light)}
.ai-card .ai-btn.btn-end{background:var(--gray-700)}
.ai-card .ai-btn.btn-end:hover{background:var(--gray-600)}

.ai-card .ai-difficulty{display:flex;align-items:center;gap:8px;margin-bottom:16px;font-size:12px;color:var(--gray-600)}
.ai-card .ai-difficulty .diff-indicator{display:flex;gap:3px}
.ai-card .ai-difficulty .diff-dot{width:10px;height:10px;border-radius:50%;background:var(--gray-200)}
.ai-card .ai-difficulty .diff-dot.filled{background:#9b59b6}

.ai-session-summary{text-align:center;padding:40px 20px}
.ai-session-summary h2{color:var(--navy);margin-bottom:16px}
.ai-session-summary .summary-score{font-size:48px;font-weight:bold;color:#9b59b6;margin-bottom:8px}
.ai-session-summary .summary-label{font-size:16px;color:var(--gray-600);margin-bottom:24px}
.ai-session-summary .summary-details{max-width:400px;margin:0 auto 24px;text-align:left}
.ai-session-summary .summary-details table{width:100%;border-collapse:collapse}
.ai-session-summary .summary-details td{padding:8px 12px;font-size:14px;border-bottom:1px solid var(--gray-100)}
.ai-session-summary .summary-details .label-col{color:var(--gray-600)}
.ai-session-summary .summary-details .value-col{font-weight:bold;text-align:right}
.ai-session-summary .category-improvements{margin-top:20px}
.ai-session-summary .category-improvements h3{font-size:16px;color:var(--navy);margin-bottom:12px}
.ai-session-summary .cat-improvement{display:flex;align-items:center;gap:10px;margin:6px 0;font-size:13px}
.ai-session-summary .cat-improvement .cat-name{flex:1}
.ai-session-summary .cat-improvement .cat-score{font-weight:bold}
.ai-session-summary .cat-improvement .cat-score.improved{color:var(--green)}
.ai-session-summary .cat-improvement .cat-score.declined{color:var(--red)}
.ai-session-summary .summary-actions{display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
.ai-session-summary .summary-actions button{padding:12px 28px;border:none;border-radius:var(--radius);font-size:15px;font-weight:bold;color:#fff;cursor:pointer}

.ai-error{text-align:center;padding:40px;color:var(--red)}
.ai-error h3{margin-bottom:12px}
.ai-error p{color:var(--gray-600);margin-bottom:20px}

/* Dark mode support for AI Practice */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .ai-progress { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .ai-progress .targeting { color: #a78bfa; }
    body:not([data-theme="light"]) .ai-progress .session-stat .val { color: #93c5fd; }
    body:not([data-theme="light"]) .ai-progress .weak-areas .weak-cat { background: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .ai-progress .weak-areas .weak-cat.current { background: #7c3aed; color: #fff; }
    body:not([data-theme="light"]) .ai-card { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .ai-card .option-item { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .ai-card .option-item:hover:not(.disabled) { background: #1e3a5f; border-color: var(--blue); }
    body:not([data-theme="light"]) .ai-card .option-item.selected { background: #1e3a5f; }
    body:not([data-theme="light"]) .ai-card .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
    body:not([data-theme="light"]) .ai-card .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
    body:not([data-theme="light"]) .ai-card .ai-explanation { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
    body:not([data-theme="light"]) .ai-card .ai-explanation.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
    body:not([data-theme="light"]) .ai-session-summary h2 { color: #93c5fd; }
    body:not([data-theme="light"]) .ai-session-summary .summary-score { color: #a78bfa; }
}
[data-theme="dark"] .ai-progress { background: #16213e; border-color: #374151; }
[data-theme="dark"] .ai-progress .targeting { color: #a78bfa; }
[data-theme="dark"] .ai-progress .session-stat .val { color: #93c5fd; }
[data-theme="dark"] .ai-progress .weak-areas .weak-cat { background: #374151; color: #d1d5db; }
[data-theme="dark"] .ai-progress .weak-areas .weak-cat.current { background: #7c3aed; color: #fff; }
[data-theme="dark"] .ai-card { background: #16213e; border-color: #374151; }
[data-theme="dark"] .ai-card .option-item { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .ai-card .option-item:hover:not(.disabled) { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .ai-card .option-item.selected { background: #1e3a5f; }
[data-theme="dark"] .ai-card .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
[data-theme="dark"] .ai-card .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
[data-theme="dark"] .ai-card .ai-explanation { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
[data-theme="dark"] .ai-card .ai-explanation.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
[data-theme="dark"] .ai-session-summary h2 { color: #93c5fd; }
[data-theme="dark"] .ai-session-summary .summary-score { color: #a78bfa; }

/* === QUESTION CONTAINER === */
.question-container{background:#fff;border:1px solid var(--gray-200);border-radius:var(--radius);padding:24px;margin-bottom:20px;box-shadow:var(--shadow);max-width:100%;box-sizing:border-box;overflow:hidden}
.question-header{display:flex;justify-content:space-between;align-items:flex-start;flex-wrap:wrap;gap:8px;margin-bottom:15px;padding-bottom:10px;border-bottom:1px solid var(--gray-100)}
.question-number{font-weight:bold;color:var(--navy);font-size:14px}
.question-actions{display:flex;gap:8px}
.btn-bookmark,.btn-clear{padding:4px 14px;border:1px solid var(--gray-500);border-radius:3px;background:#f0f0f0;font-size:12px;color:#333}
.btn-bookmark:hover,.btn-clear:hover{background:#e0e0e0}
.btn-bookmark.flagged{background:#fff3cd;border-color:var(--orange);color:#856404}
.question-text{font-size:15px;line-height:1.7;margin-bottom:18px;color:var(--gray-900);overflow-wrap:break-word}
.question-text strong{color:var(--navy)}
.md-table{width:100%;border-collapse:collapse;margin:12px 0;font-size:14px}
.md-table th,.md-table td{border:1px solid var(--gray-300);padding:8px 12px;text-align:left}
.md-table th{background:var(--gray-100);font-weight:600;color:var(--navy)}
.md-table tr:nth-child(even){background:var(--gray-50)}
[data-theme="dark"] .md-table th,[data-theme="dark"] .md-table td{border-color:#374151}
[data-theme="dark"] .md-table th{background:#1e293b;color:#93c5fd}
[data-theme="dark"] .md-table tr:nth-child(even){background:rgba(255,255,255,0.03)}
.question-text img,.question-text canvas{max-width:100%;height:auto}
.question-text [data-graph]{display:block;width:100%;max-width:100%}
.question-text,.option-label,.explanation-panel,.explanation-panel p{word-break:normal;overflow-wrap:break-word;white-space:normal}
.question-text p{margin-bottom:8px;word-break:normal;white-space:normal}

/* === OPTIONS === */
.options-list{list-style:none}
.option-item{display:flex;align-items:flex-start;gap:10px;padding:10px 14px;margin:6px 0;border:1px solid var(--gray-200);border-radius:var(--radius);cursor:pointer;transition:all .15s ease}
.option-item:hover{background:#f0f7ff;border-color:var(--blue)}
.option-item.selected{background:#e3f0fc;border-color:var(--blue)}
.option-item input[type="radio"]{margin-top:3px;accent-color:var(--blue)}
.option-label{font-size:14px;line-height:1.6;color:var(--gray-800);word-break:normal;overflow-wrap:break-word;white-space:normal}

/* Practice/Review feedback on options */
.option-item.correct-answer{border:2px solid var(--green);background:#eafaf1;animation:correctPop .3s ease}
.option-item.wrong-answer{border:2px solid var(--red);background:#fdf2f2;animation:wrongShake .4s ease}
@keyframes correctPop{0%{transform:scale(1)}50%{transform:scale(1.02)}100%{transform:scale(1)}}
@keyframes wrongShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-4px)}40%{transform:translateX(4px)}60%{transform:translateX(-3px)}80%{transform:translateX(2px)}}

/* === EXPLANATION PANEL === */
.explanation-panel{display:none;margin-top:15px;padding:16px;border-radius:var(--radius);background:#f0faf4;border:1px solid #c3e6cb;font-size:14px;line-height:1.6;color:#155724;word-break:normal;overflow-wrap:break-word;white-space:normal}
.explanation-panel.show{display:block}
.explanation-panel.incorrect{background:#fdf2f2;border-color:#f5c6cb;color:#721c24}
.explanation-panel h4{margin-bottom:6px}
.explanation-panel p{margin:0;word-break:normal;white-space:normal}

/* === NOTE PANEL === */
.note-panel{margin-top:12px;display:none}
.note-panel.open{display:block}
.note-textarea{width:100%;min-height:80px;padding:10px;border:1px solid var(--gray-300);border-radius:var(--radius);font-size:13px;resize:vertical;font-family:inherit}
.note-saved{font-size:11px;color:var(--green);margin-top:4px;opacity:0;transition:opacity .3s}
.note-saved.show{opacity:1}
.btn-note{padding:4px 14px;border:1px solid var(--gray-500);border-radius:3px;background:#f0f0f0;font-size:12px;color:var(--gray-700)}
.btn-note:hover{background:#e0e0e0}
.btn-note.has-note{background:#e8f4fd;border-color:var(--blue);color:var(--blue)}
.q-num.has-note::before{content:'';position:absolute;bottom:-2px;left:50%;transform:translateX(-50%);width:6px;height:6px;background:var(--blue);border-radius:50%}
.q-num{position:relative}
.review-q .rq-note{margin-top:10px;padding:10px;background:#e8f4fd;border-left:3px solid var(--blue);font-size:13px;line-height:1.5;color:var(--gray-700)}
.review-q .rq-note-label{font-weight:bold;color:var(--blue);margin-bottom:4px;font-size:12px}

/* === CHECK ANSWER BUTTON (Practice mode) === */
.btn-check{padding:10px 24px;background:var(--green);color:#fff;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold;margin-top:10px}
.btn-check:hover{background:var(--green-light)}
.btn-check:disabled{background:var(--gray-500);cursor:not-allowed}

/* === CONFIDENCE INDICATOR (Practice mode) === */
.confidence-panel{display:flex;align-items:center;gap:8px;margin-top:12px;padding:10px;background:#f8f9fa;border-radius:var(--radius);flex-wrap:wrap}
.confidence-label{font-size:13px;color:var(--gray-700);margin-right:4px}
.confidence-btn{padding:6px 14px;border:1px solid var(--gray-300);border-radius:16px;background:#fff;font-size:12px;color:var(--gray-700);cursor:pointer;transition:all .15s}
.confidence-btn:hover{border-color:var(--blue);color:var(--blue)}
.confidence-btn.selected{background:var(--blue);color:#fff;border-color:var(--blue)}
.confidence-btn.conf-maybe.selected{background:var(--orange);border-color:var(--orange)}
.confidence-btn.conf-probably.selected{background:var(--blue);border-color:var(--blue)}
.confidence-btn.conf-definitely.selected{background:var(--green);border-color:var(--green)}

/* === TOOLBAR (Calculator, Audio, Timer) === */
.toolbar{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
.tool-btn{background:var(--gray-100);border:1px solid var(--gray-300);border-radius:var(--radius);padding:6px 12px;font-size:12px;color:var(--gray-700);display:flex;align-items:center;gap:4px}
.tool-btn:hover{background:var(--gray-200)}
.tool-btn.active{background:var(--blue);color:#fff;border-color:var(--blue)}
.tool-btn svg{width:14px;height:14px}

/* === CALCULATOR === */
.calc-panel{display:none;position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#fff;border-radius:8px;box-shadow:0 8px 32px rgba(0,0,0,.3);z-index:400;width:280px}
.calc-panel.open{display:block}
.calc-header{background:var(--navy);color:#fff;padding:10px 14px;display:flex;justify-content:space-between;align-items:center;border-radius:8px 8px 0 0}
.calc-header h4{font-size:14px;margin:0}
.calc-close{background:none;border:none;color:#fff;font-size:18px;cursor:pointer}
.calc-display{background:#222;color:#0f0;font-family:monospace;font-size:24px;padding:12px;text-align:right;min-height:50px;word-break:break-all}
.calc-buttons{display:grid;grid-template-columns:repeat(4,1fr);gap:2px;padding:8px}
.calc-btn{padding:14px;font-size:16px;border:none;background:var(--gray-100);cursor:pointer}
.calc-btn:hover{background:var(--gray-200)}
.calc-btn.op{background:var(--orange);color:#fff}
.calc-btn.op:hover{background:#e67e22}
.calc-btn.eq{background:var(--green);color:#fff}
.calc-btn.clear{background:var(--red);color:#fff}

/* === POWER-UP BAR (styles in gamification section below) === */

/* === METRICS PANEL === */
.metrics-summary{background:var(--gray-50);border:1px solid var(--gray-200);border-radius:8px;padding:16px;margin-top:20px}
.metrics-summary h3{font-size:14px;color:var(--navy);margin-bottom:12px}
.metrics-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:12px}
.metric-item{text-align:center}
.metric-val{font-size:20px;font-weight:bold;color:var(--navy)}
.metric-lbl{font-size:11px;color:var(--gray-600)}
.time-per-q{margin-top:12px;font-size:12px;color:var(--gray-600)}
.time-per-q table{width:100%;margin-top:8px;font-size:11px}
.time-per-q th,.time-per-q td{padding:4px 8px;text-align:left;border-bottom:1px solid var(--gray-200)}
.time-bar{height:8px;background:var(--gray-200);border-radius:4px;overflow:hidden;margin-top:2px}
.time-bar-fill{height:100%;background:var(--blue);border-radius:4px}

/* === FOOTER NAV === */
.footer-nav{background:var(--gray-50);border-top:1px solid var(--gray-300);padding:10px 20px;position:sticky;bottom:0;z-index:50}
.nav-controls{display:flex;align-items:center;justify-content:space-between;max-width:960px;margin:0 auto;gap:10px;flex-wrap:wrap}
.nav-buttons{display:flex;gap:8px;flex-shrink:0}
.btn-nav{padding:8px 20px;border:1px solid var(--navy);border-radius:3px;background:var(--navy);color:#fff;font-size:13px;font-weight:bold}
.btn-nav:hover{background:#2c5a8a}
.btn-nav:disabled{background:var(--gray-500);border-color:var(--gray-500);cursor:not-allowed}
.btn-submit{background:var(--red);border-color:var(--red)}
.btn-submit:hover{background:var(--red-light)}
.btn-home{background:var(--gray-700);border-color:var(--gray-700)}

/* === QUESTION PALETTE === */
.palette-wrap{text-align:center;min-width:0;overflow:hidden}
.question-palette{display:flex;flex-wrap:wrap;gap:4px;justify-content:center;max-width:600px;margin:0 auto}
.q-num{width:32px;height:28px;display:flex;align-items:center;justify-content:center;border:1px solid var(--gray-500);border-radius:3px;cursor:pointer;font-size:12px;font-weight:bold;background:#fff;color:#666;transition:all .15s;flex-shrink:0}
.q-num:hover{border-color:var(--blue);color:var(--blue)}
.q-num.current{background:var(--navy);color:#fff;border-color:var(--navy)}
.q-num.answered{background:var(--green);color:#fff;border-color:var(--green)}
.q-num.visited{color:#996600}
.q-num.skipped{background:#f59e0b;color:#fff;border-color:#f59e0b}
.q-num.flagged{position:relative}
.q-num.flagged::after{content:'';position:absolute;top:-2px;right:-2px;width:8px;height:8px;background:var(--orange);border-radius:50%}
/* Practice palette colors */
.q-num.p-correct{background:var(--green);color:#fff;border-color:var(--green)}
.q-num.p-incorrect{background:var(--red);color:#fff;border-color:var(--red)}
.q-num.p-skipped{background:var(--orange);color:#fff;border-color:var(--orange)}

.palette-legend{display:flex;gap:15px;font-size:11px;color:var(--gray-600);margin-top:8px;justify-content:center;flex-wrap:wrap}
.legend-item{display:flex;align-items:center;gap:4px}
.legend-dot{width:12px;height:12px;border-radius:2px;border:1px solid var(--gray-500)}
.legend-dot.lg-current{background:var(--navy);border-color:var(--navy)}
.legend-dot.lg-answered{background:var(--green);border-color:var(--green)}
.legend-dot.lg-skipped{background:#f59e0b;border-color:#f59e0b}
.legend-dot.lg-unanswered{background:#fff;border:2px solid #666}
.legend-dot.lg-flagged{background:var(--orange);border-color:var(--orange)}

/* === PALETTE STATS BAR === */
.palette-stats{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;font-size:11px;margin-top:6px;padding:4px 8px;background:var(--gray-100);border-radius:6px}
.stat-item{display:flex;align-items:center;gap:4px;color:var(--gray-600)}
.stat-item .stat-dot{width:8px;height:8px;border-radius:2px}
.stat-answered .stat-dot{background:var(--green)}
.stat-skipped .stat-dot{background:#f59e0b}
.stat-unanswered .stat-dot{background:var(--gray-400)}
.stat-flagged .stat-dot{background:var(--orange)}
.stat-item strong{color:var(--gray-800)}

/* === MINI PALETTE (shows ~5 around current) === */
.palette-mini{display:flex;gap:4px;justify-content:center;align-items:center;margin-bottom:6px}
.palette-mini .q-num{width:36px;height:32px;font-size:13px}
.palette-mini .pm-ellipsis{color:var(--gray-500);font-size:14px;padding:0 4px}
.palette-expand-btn{background:none;border:1px solid var(--gray-400);color:var(--gray-600);padding:4px 12px;border-radius:12px;font-size:11px;margin-bottom:6px}
.palette-expand-btn:hover{background:var(--gray-100)}
.question-palette.collapsed{display:none}
.question-palette.expanded{display:flex}

/* === MODAL === */
.modal-overlay{display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:1000}
.modal-overlay.active{display:flex;align-items:center;justify-content:center}
.modal{background:#fff;border-radius:6px;padding:30px;max-width:500px;width:90%;max-height:80vh;overflow-y:auto}
.modal h2{color:var(--navy);margin-bottom:15px;font-size:18px}
.modal table{width:100%;border-collapse:collapse;margin:15px 0}
.modal th,.modal td{padding:8px 12px;border:1px solid var(--gray-200);text-align:left;font-size:13px}
.modal th{background:var(--navy);color:#fff}
.modal-actions{display:flex;gap:10px;justify-content:flex-end;margin-top:20px}
.modal .btn-nav{font-size:14px;padding:10px 24px}

/* === SCORE SCREEN === */
.score-screen{text-align:center;padding:40px 20px}
.score-big{font-size:64px;font-weight:bold;color:var(--navy);animation:scoreReveal .6s ease}
.score-big.pass{color:var(--green)}
.score-big.fail{color:var(--red)}
@keyframes scoreReveal{from{opacity:0;transform:scale(.5)}to{opacity:1;transform:scale(1)}}
.score-label{font-size:18px;color:var(--gray-600);margin:10px 0 20px}
.score-details{max-width:450px;margin:0 auto;text-align:left}
.score-details table{width:100%;border-collapse:collapse}
.score-details td{padding:6px 10px;font-size:14px;border-bottom:1px solid var(--gray-100)}
.score-details .label-col{color:var(--gray-600)}
.score-details .value-col{font-weight:bold;text-align:right}
.category-breakdown{margin-top:20px}
.category-breakdown h3{font-size:16px;color:var(--navy);margin-bottom:10px}
.cat-row{display:flex;align-items:center;gap:10px;margin:6px 0;font-size:13px}
.cat-bar{flex:1;height:20px;background:var(--gray-100);border-radius:10px;overflow:hidden}
.cat-fill{height:100%;border-radius:10px;transition:width .8s cubic-bezier(.4,0,.2,1);animation:barGrow .8s ease forwards}
.cat-fill.good{background:var(--green)}
.cat-fill.warn{background:var(--orange)}
.cat-fill.bad{background:var(--red)}
.score-actions{margin-top:30px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap}
.score-actions button{padding:12px 28px;border:none;border-radius:var(--radius);font-size:15px;font-weight:bold;color:#fff;cursor:pointer}

/* === DRILL MODE === */
.drill-container{max-width:700px;margin:0 auto}
.drill-progress{text-align:center;color:var(--gray-600);font-size:14px;margin-bottom:20px}
.drill-progress .due-count{font-weight:bold;color:var(--navy)}
.drill-card{background:#fff;border:1px solid var(--gray-300);border-radius:8px;padding:30px;min-height:300px;box-shadow:var(--shadow);animation:cardSlideIn .3s ease}
@keyframes cardSlideIn{from{opacity:0;transform:translateX(20px)}to{opacity:1;transform:translateX(0)}}
.drill-card .question-text{font-size:16px}
.speed-option{display:flex;align-items:center;gap:12px;padding:12px 16px;border:1px solid var(--gray-300);border-radius:var(--radius);background:#fff;cursor:pointer;transition:all .15s;width:100%;text-align:left;font-size:14px}
.speed-option:hover:not(:disabled){background:#f0f7ff;border-color:var(--blue)}
.speed-option:disabled{cursor:default;opacity:0.9}
.speed-option.correct{background:#d4edda;border-color:var(--green);color:#155724}
.speed-option.wrong{background:#f8d7da;border-color:var(--red);color:#721c24}
.speed-option .option-letter{display:inline-flex;align-items:center;justify-content:center;width:28px;height:28px;border-radius:50%;background:var(--gray-100);font-weight:bold;color:var(--navy);flex-shrink:0}
.speed-option .option-text{flex:1;line-height:1.4}
.drill-answer{display:none;margin-top:20px;padding-top:20px;border-top:2px solid var(--gray-200)}
.drill-answer.show{display:block}
.drill-answer .correct-label{font-weight:bold;color:var(--green);font-size:15px;margin-bottom:8px}
.drill-answer .explanation{color:var(--gray-700);font-size:14px;line-height:1.6}
.drill-buttons{display:flex;gap:10px;margin-top:20px;justify-content:center;flex-wrap:wrap}
.drill-btn{padding:12px 24px;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold;color:#fff;min-width:120px}
.drill-btn.btn-got-it{background:var(--green)}
.drill-btn.btn-struggled{background:var(--orange)}
.drill-btn.btn-missed{background:var(--red)}
.drill-btn.btn-show{background:var(--blue);min-width:200px}
.drill-session-done{text-align:center;padding:40px}
.drill-session-done h2{color:var(--navy);margin-bottom:10px}

/* === REVIEW MODE === */
.review-controls{display:flex;gap:10px;margin-bottom:20px;flex-wrap:wrap;align-items:center}
.review-controls select,.review-controls input{padding:8px 12px;border:1px solid var(--gray-300);border-radius:var(--radius);font-size:13px}
.review-controls input{flex:1;min-width:200px}
.review-category{margin-bottom:20px}
.review-category h3{color:var(--navy);font-size:16px;padding:10px 0;border-bottom:2px solid var(--navy);cursor:pointer;display:flex;justify-content:space-between;align-items:center}
.review-category h3 .toggle-arrow{transition:transform .2s}
.review-category h3 .toggle-arrow.collapsed{transform:rotate(-90deg)}
.review-q{background:#fff;border:1px solid var(--gray-200);border-radius:var(--radius);padding:16px;margin:8px 0}
.review-q .rq-text{font-size:14px;line-height:1.6;margin-bottom:12px}
.review-q .rq-options{list-style:none}
.review-q .rq-opt{padding:6px 10px;margin:3px 0;border-radius:3px;font-size:13px}
.review-q .rq-opt.rq-correct{background:#eafaf1;border:1px solid #c3e6cb;font-weight:bold}
.review-q .rq-explanation{margin-top:10px;padding:10px;background:#f8f9fa;border-left:3px solid var(--yellow);font-size:13px;line-height:1.5;color:var(--gray-700)}
.review-q .rq-meta{display:flex;gap:8px;margin-top:8px;font-size:11px}
.review-q .rq-tag{background:var(--gray-100);padding:2px 6px;border-radius:3px;color:#333}

/* === SETTINGS === */
.settings-panel{max-width:600px;margin:0 auto}
.settings-panel h2{color:var(--navy);margin-bottom:20px}
.setting-group{background:#fff;border:1px solid var(--gray-200);border-radius:8px;padding:20px;margin-bottom:16px}
.setting-group h3{font-size:14px;color:var(--navy);margin-bottom:12px}
.setting-row{margin-bottom:12px}
.setting-row label{display:block;font-size:13px;color:var(--gray-700);margin-bottom:4px}
.setting-row input,.setting-row select{width:100%;padding:8px 12px;border:1px solid var(--gray-300);border-radius:var(--radius);font-size:14px}
.setting-row input[type="password"]{font-family:monospace}
.setting-row .hint{font-size:11px;color:#555;margin-top:4px}
.setting-row button{margin-top:8px}
.btn-save-settings{padding:10px 24px;background:var(--green);color:#fff;border:none;border-radius:var(--radius);font-size:14px;font-weight:bold}

/* === AI CHAT BUBBLE === */
.chat-fab{position:fixed;bottom:80px;right:20px;width:50px;height:50px;border-radius:50%;background:var(--navy);color:#fff;border:none;font-size:22px;box-shadow:0 4px 12px rgba(0,0,0,.3);z-index:200;display:flex;align-items:center;justify-content:center;transition:transform .2s}
.chat-fab:hover{transform:scale(1.1)}
.chat-fab.has-context::after{content:'';position:absolute;top:2px;right:2px;width:10px;height:10px;background:var(--green);border-radius:50%;border:2px solid var(--navy)}

.chat-panel{display:none;position:fixed;bottom:80px;right:20px;width:360px;max-width:calc(100vw - 40px);height:460px;max-height:calc(100vh - 120px);background:#fff;border-radius:12px;box-shadow:0 8px 32px rgba(0,0,0,.25);z-index:300;flex-direction:column;overflow:hidden}
.chat-panel.open{display:flex}
.chat-header{background:var(--navy);color:#fff;padding:12px 16px;display:flex;justify-content:space-between;align-items:center;flex-shrink:0}
.chat-header h3{font-size:14px}
.chat-close{background:none;border:none;color:#fff;font-size:20px;cursor:pointer;padding:0 4px}
.chat-header-actions{display:flex;align-items:center;gap:8px}
.chat-personality-btn{background:none;border:none;color:#fff;font-size:16px;cursor:pointer;padding:4px;opacity:0.8}
.chat-personality-btn:hover{opacity:1}
.chat-personality-picker{background:var(--gray-50);border-bottom:1px solid var(--gray-200);padding:8px;display:grid;grid-template-columns:repeat(4,1fr);gap:6px;max-height:200px;overflow-y:auto}
.chat-personality-option{display:flex;flex-direction:column;align-items:center;padding:8px 4px;border:2px solid var(--gray-200);border-radius:8px;cursor:pointer;background:#fff;transition:all 0.15s}
.chat-personality-option:hover{border-color:var(--blue);background:var(--blue-50)}
.chat-personality-option.active{border-color:var(--navy);background:var(--blue-50)}
.chat-personality-option.locked{border-color:var(--gray-300);background:var(--gray-100);opacity:0.8}
.chat-personality-option.locked:hover{border-color:var(--gold);background:#fffde7}
.chat-personality-option .p-icon{font-size:20px}
.chat-personality-option .p-name{font-size:9px;font-weight:600;color:var(--gray-700);margin-top:2px;text-align:center}
.chat-messages{flex:1;overflow-y:auto;padding:12px;display:flex;flex-direction:column;gap:8px}
.chat-msg{max-width:85%;padding:10px 14px;border-radius:12px;font-size:13px;line-height:1.5;word-wrap:break-word}
.chat-msg.user{align-self:flex-end;background:var(--blue);color:#fff;border-bottom-right-radius:4px}
.chat-msg.assistant{align-self:flex-start;background:var(--gray-50);color:var(--gray-800);border:1px solid var(--gray-200);border-bottom-left-radius:4px}
.chat-msg.system{align-self:center;background:#fffde7;color:#856404;font-size:12px;text-align:center;border-radius:8px}
.chat-input-area{display:flex;gap:8px;padding:12px;border-top:1px solid var(--gray-200);flex-shrink:0}
.chat-input-area input{flex:1;padding:8px 12px;border:1px solid var(--gray-300);border-radius:20px;font-size:13px;outline:none}
.chat-input-area input:focus{border-color:var(--blue)}
.chat-input-area button{background:var(--navy);color:#fff;border:none;border-radius:50%;width:36px;height:36px;font-size:16px;flex-shrink:0}
.chat-tts-btn{position:absolute;top:4px;right:4px;background:none;border:none;cursor:pointer;font-size:14px;opacity:.4;padding:2px 4px;border-radius:4px;line-height:1}
.chat-tts-btn:hover{opacity:.8;background:rgba(0,0,0,.05)}
.chat-tts-btn.speaking{opacity:1;color:var(--blue)}

/* === QUESTION COUNT PICKER === */
#qCountModal{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.5);z-index:500;align-items:center;justify-content:center;padding:20px}
.modal-box{background:var(--white);border-radius:12px;padding:24px;max-width:400px;width:100%;box-shadow:0 8px 32px rgba(0,0,0,.3)}
.qcount-options{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.qcount-opt{padding:14px 12px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);cursor:pointer;text-align:center;transition:all .15s;font-size:14px;font-weight:bold;color:var(--gray-800)}
.qcount-opt:hover{border-color:var(--blue);background:#f0f7ff}
.qcount-opt.selected{border-color:var(--blue);background:#e3f0fc;color:var(--navy)}
.qcount-opt .qcount-label{font-size:13px;font-weight:normal;color:var(--gray-600);margin-top:2px}
[data-theme="dark"] .modal-box{background:#1a2332;color:#e0e0e0}
[data-theme="dark"] .qcount-opt{background:#16213e;border-color:#374151;color:#e0e0e0}
[data-theme="dark"] .qcount-opt:hover{background:#1e3a5f;border-color:var(--blue)}
[data-theme="dark"] .qcount-opt.selected{background:#1e3a5f;border-color:var(--blue)}
body:not([data-theme="light"]) .modal-box{background:#1a2332;color:#e0e0e0}
body:not([data-theme="light"]) .qcount-opt{background:#16213e;border-color:#374151;color:#e0e0e0}
body:not([data-theme="light"]) .qcount-opt:hover{background:#1e3a5f;border-color:var(--blue)}
body:not([data-theme="light"]) .qcount-opt.selected{background:#1e3a5f;border-color:var(--blue)}

/* === TABLET (landscape/compact) === */
@media(max-height:700px),(max-width:1024px) and (max-height:900px){
    .main-header .header-top{padding:4px 12px;min-height:40px}
    .subheader{padding:4px 12px;min-height:32px}
    .screen{padding:8px 12px}
    .question-container{padding:12px 16px;margin-bottom:8px;min-height:auto}
    .question-header{margin-bottom:8px;padding-bottom:6px}
    .question-text{margin-bottom:12px;font-size:14px;line-height:1.5}
    .option-item{padding:8px 12px;margin:4px 0}
    .option-label{font-size:13px;line-height:1.4}
    .btn-check{padding:8px 20px;margin-top:8px}
    .confidence-panel{margin-top:8px;padding:8px}
    .explanation-panel{margin-top:10px;padding:12px}
    .footer-nav{padding:6px 12px}
    .nav-buttons{gap:6px}
    .palette-mini{margin-bottom:4px}
}

/* === MOBILE === */
@media(max-width:768px){
    .header-top{padding:6px 12px}
    .logo-text{font-size:15px}
    .subheader{padding:4px 12px}
    .screen{padding:8px;max-width:100%;box-sizing:border-box}
    .question-container{padding:12px;max-width:100%;box-sizing:border-box;overflow-x:hidden;min-height:auto}
    .question-text,.option-label,.explanation-panel,.explanation-panel p{word-break:normal;overflow-wrap:break-word;white-space:normal}
    .question-text{font-size:14px;line-height:1.5;margin-bottom:12px}
    .option-item{padding:10px 12px;margin:4px 0;min-height:44px}
    .mode-buttons{grid-template-columns:1fr 1fr}
    .nav-controls{flex-direction:column;gap:6px}
    .nav-buttons{width:100%;justify-content:space-between;flex-wrap:wrap}
    .toolbar{width:100%;justify-content:center;margin-bottom:4px!important;margin-right:0!important}
    .tool-btn{flex:1;justify-content:center;padding:8px 10px;font-size:11px;min-height:40px}
    .tool-btn svg{width:14px;height:14px}
    .question-palette{max-width:100%;gap:4px}
    .calc-panel{width:calc(100vw - 24px);max-width:320px}
    .q-num{width:38px;height:38px;font-size:12px}
    .palette-mini .q-num{width:38px;height:38px}
    .btn-nav{padding:10px 14px;min-height:40px;font-size:12px}
    .drill-btn{padding:12px 18px;min-height:44px}
    .confidence-btn{min-height:40px;padding:8px 10px}
    .score-big{font-size:48px}
    .chat-panel{width:calc(100vw - 24px);right:12px;bottom:60px;height:calc(100vh - 100px)}
    .chat-fab{bottom:60px;right:12px;min-width:44px;min-height:44px}
    .stats-row{grid-template-columns:repeat(2,1fr)}
    .home-hero h1{font-size:22px}
    .home-hero{padding:15px 0 10px}
}
@media(max-width:400px){
    .mode-buttons{grid-template-columns:1fr}
    .q-num{width:40px;height:40px;font-size:11px}
}

/* === AI PRACTICE MOBILE === */
@media(max-width:768px){
    .ai-practice-container{padding:0 8px}
    .ai-card{padding:16px}
    .ai-card .question-text{font-size:15px}
    .ai-card .option-item{padding:10px 12px}
    .ai-card .option-label{font-size:13px}
    .ai-buttons{flex-direction:column;gap:8px}
    .ai-btn{width:100%;min-width:unset}
    .ai-progress .session-stats{gap:12px}
    .ai-progress .session-stat .val{font-size:18px}
    .ai-session-summary{padding:20px 12px}
    .ai-session-summary .summary-score{font-size:36px}
}
@media(max-width:400px){
    .ai-card{padding:12px}
    .ai-progress{padding:12px}
    .ai-progress .weak-areas .weak-cat{padding:2px 6px;font-size:10px;margin:2px}
    .ai-card .ai-difficulty{font-size:11px}
}

/* === ACCESSIBILITY - FOCUS STATES === */
button:focus-visible {
    outline: 2px solid var(--blue);
    outline-offset: 2px;
}
.option-item:focus-within {
    outline: 2px solid var(--blue);
}

/* === DARK MODE === */
/* System preference detection */
@media (prefers-color-scheme: dark) {
    :root:not([data-theme="light"]) {
        --bg: #1a1a2e;
        --white: #16213e;
        --gray-50: #1f2937;
        --gray-100: #374151;
        --gray-200: #4b5563;
        --gray-300: #6b7280;
        --gray-500: #9ca3af;
        --gray-600: #d1d5db;
        --gray-700: #e5e7eb;
        --gray-800: #e5e7eb;
        --gray-900: #f3f4f6;
    }
    body:not([data-theme="light"]) { color: #e5e7eb; }
}

/* Manual dark mode via data-theme attribute */
:root[data-theme="dark"] {
    --bg: #1a1a2e;
    --white: #16213e;
    --gray-50: #1f2937;
    --gray-100: #374151;
    --gray-200: #4b5563;
    --gray-300: #6b7280;
    --gray-500: #9ca3af;
    --gray-600: #d1d5db;
    --gray-700: #e5e7eb;
    --gray-800: #e5e7eb;
    --gray-900: #f3f4f6;
}
[data-theme="dark"] body, body[data-theme="dark"] { color: #e5e7eb; }

/* Dark mode component overrides */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .question-container,
    body:not([data-theme="light"]) .bank-card,
    body:not([data-theme="light"]) .modal,
    body:not([data-theme="light"]) .chat-panel,
    body:not([data-theme="light"]) .calc-panel,
    body:not([data-theme="light"]) .drill-card,
    body:not([data-theme="light"]) .review-q,
    body:not([data-theme="light"]) .setting-group,
    body:not([data-theme="light"]) .stat-card,
    body:not([data-theme="light"]) .mode-btn {
        background: #16213e;
        border-color: #374151;
    }
    body:not([data-theme="light"]) .option-item { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .option-item:hover { background: #1e3a5f; border-color: var(--blue); }
    body:not([data-theme="light"]) .option-item.selected { background: #1e3a5f; }
    body:not([data-theme="light"]) .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
    body:not([data-theme="light"]) .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
    body:not([data-theme="light"]) .speed-option { background: #1f2937; border-color: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .speed-option:hover:not(:disabled) { background: #1e3a5f; border-color: var(--blue); }
    body:not([data-theme="light"]) .speed-option.correct { background: #064e3b; border-color: var(--green); color: #a7f3d0; }
    body:not([data-theme="light"]) .speed-option.wrong { background: #7f1d1d; border-color: var(--red); color: #fecaca; }
    body:not([data-theme="light"]) .speed-option .option-letter { background: #374151; color: #93c5fd; }
    body:not([data-theme="light"]) .explanation-panel { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
    body:not([data-theme="light"]) .explanation-panel.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
    body:not([data-theme="light"]) .subheader { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .footer-nav { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .q-num { background: #1f2937; border-color: #6b7280; color: #9ca3af; }
    body:not([data-theme="light"]) .timer-display { background: #1f2937; border-color: #374151; }
    body:not([data-theme="light"]) .calc-btn { background: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .calc-btn:hover { background: #4b5563; }
    body:not([data-theme="light"]) .chat-msg.assistant { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .chat-input-area input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .review-controls select,
    body:not([data-theme="light"]) .review-controls input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .setting-row input,
    body:not([data-theme="light"]) .setting-row select { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .rq-explanation { background: #1f2937; border-color: var(--yellow); color: #d1d5db; }
    body:not([data-theme="light"]) .rq-opt.rq-correct { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
    body:not([data-theme="light"]) .confidence-btn { background: #1f2937; border-color: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .metrics-summary { background: #1f2937; border-color: #374151; }
}

/* Manual dark mode component overrides */
[data-theme="dark"] .question-container,
[data-theme="dark"] .bank-card,
[data-theme="dark"] .modal,
[data-theme="dark"] .chat-panel,
[data-theme="dark"] .calc-panel,
[data-theme="dark"] .drill-card,
[data-theme="dark"] .review-q,
[data-theme="dark"] .setting-group,
[data-theme="dark"] .stat-card,
[data-theme="dark"] .mode-btn {
    background: #16213e;
    border-color: #374151;
}
[data-theme="dark"] .option-item { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .option-item:hover { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .option-item.selected { background: #1e3a5f; }
[data-theme="dark"] .option-item.correct-answer { background: #064e3b; border-color: var(--green); }
[data-theme="dark"] .option-item.wrong-answer { background: #7f1d1d; border-color: var(--red); }
[data-theme="dark"] .speed-option { background: #1f2937; border-color: #374151; color: #d1d5db; }
[data-theme="dark"] .speed-option:hover:not(:disabled) { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .speed-option.correct { background: #064e3b; border-color: var(--green); color: #a7f3d0; }
[data-theme="dark"] .speed-option.wrong { background: #7f1d1d; border-color: var(--red); color: #fecaca; }
[data-theme="dark"] .speed-option .option-letter { background: #374151; color: #93c5fd; }
[data-theme="dark"] .explanation-panel { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
[data-theme="dark"] .explanation-panel.incorrect { background: #7f1d1d; border-color: #991b1b; color: #fecaca; }
[data-theme="dark"] .subheader { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .footer-nav { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .q-num { background: #1f2937; border-color: #6b7280; color: #9ca3af; }
[data-theme="dark"] .timer-display { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .calc-btn { background: #374151; color: #e5e7eb; }
[data-theme="dark"] .calc-btn:hover { background: #4b5563; }
[data-theme="dark"] .chat-msg.assistant { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .chat-input-area input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .review-controls select,
[data-theme="dark"] .review-controls input { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .setting-row input,
[data-theme="dark"] .setting-row select { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .rq-explanation { background: #1f2937; border-color: var(--yellow); color: #d1d5db; }
[data-theme="dark"] .rq-opt.rq-correct { background: #064e3b; border-color: #065f46; color: #a7f3d0; }
[data-theme="dark"] .confidence-btn { background: #1f2937; border-color: #374151; color: #d1d5db; }
[data-theme="dark"] .metrics-summary { background: #1f2937; border-color: #374151; }

/* Additional dark mode text and element overrides */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .test-name { color: #93c5fd; }
    body:not([data-theme="light"]) .bank-card h2,
    body:not([data-theme="light"]) .home-hero h1,
    body:not([data-theme="light"]) .settings-panel h2,
    body:not([data-theme="light"]) .setting-group h3,
    body:not([data-theme="light"]) .question-number,
    body:not([data-theme="light"]) .stat-card .stat-val,
    body:not([data-theme="light"]) .mode-btn h3,
    body:not([data-theme="light"]) .metrics-summary h3,
    body:not([data-theme="light"]) .drill-session-done h2,
    body:not([data-theme="light"]) .review-category h3,
    body:not([data-theme="light"]) .category-breakdown h3,
    body:not([data-theme="light"]) .score-screen .score-big { color: #93c5fd; }
    body:not([data-theme="light"]) .score-big.pass { color: var(--green-light); }
    body:not([data-theme="light"]) .score-big.fail { color: var(--red-light); }
    body:not([data-theme="light"]) a { color: #60a5fa; }
    body:not([data-theme="light"]) .hint { color: #d1d5db; }
    body:not([data-theme="light"]) .bank-desc,
    body:not([data-theme="light"]) .bank-meta,
    body:not([data-theme="light"]) .mode-btn p,
    body:not([data-theme="light"]) .stat-card .stat-lbl { color: #d1d5db; }
    body:not([data-theme="light"]) .palette-expand-btn { background: #1f2937; border-color: #4b5563; color: #9ca3af; }
    body:not([data-theme="light"]) .tool-btn { background: #374151; border-color: #4b5563; color: #d1d5db; }
    body:not([data-theme="light"]) .tool-btn:hover { background: #4b5563; }
    body:not([data-theme="light"]) .btn-bookmark,
    body:not([data-theme="light"]) .btn-clear { background: #374151; border-color: #4b5563; color: #d1d5db; }
    body:not([data-theme="light"]) .btn-note { background: #374151; border-color: #4b5563; color: #d1d5db; }
    body:not([data-theme="light"]) .btn-note.has-note { background: #1e3a5f; border-color: var(--blue); color: #60a5fa; }
    body:not([data-theme="light"]) .note-textarea { background: #1f2937; border-color: #374151; color: #e5e7eb; }
    body:not([data-theme="light"]) .review-q .rq-note { background: #1e3a5f; border-color: var(--blue); color: #d1d5db; }
    body:not([data-theme="light"]) .modal th { background: #1e3a5f; }
    body:not([data-theme="light"]) .daily-goal-card { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .daily-goal-card h3 { color: #93c5fd; }
    body:not([data-theme="light"]) .daily-goal-card .goal-bar { background: #374151; }
    body:not([data-theme="light"]) .daily-goal-card .goal-text { color: #d1d5db; }
    body:not([data-theme="light"]) .goal-celebration { background: #064e3b; color: #a7f3d0; }
    body:not([data-theme="light"]) .streak-banner.no-streak { background: #374151; color: #9ca3af; }
    body:not([data-theme="light"]) .rq-tag { background: #374151; color: #d1d5db; }
    body:not([data-theme="light"]) .timer-toggle { color: #60a5fa; }
    body:not([data-theme="light"]) .legend-dot.lg-unanswered { background: #374151; border-color: #9ca3af; }
}
[data-theme="dark"] .test-name { color: #93c5fd; }
[data-theme="dark"] .bank-card h2,
[data-theme="dark"] .home-hero h1,
[data-theme="dark"] .settings-panel h2,
[data-theme="dark"] .setting-group h3,
[data-theme="dark"] .question-number,
[data-theme="dark"] .stat-card .stat-val,
[data-theme="dark"] .mode-btn h3,
[data-theme="dark"] .metrics-summary h3,
[data-theme="dark"] .drill-session-done h2,
[data-theme="dark"] .review-category h3,
[data-theme="dark"] .category-breakdown h3,
[data-theme="dark"] .score-screen .score-big { color: #93c5fd; }
[data-theme="dark"] .score-big.pass { color: var(--green-light); }
[data-theme="dark"] .score-big.fail { color: var(--red-light); }
[data-theme="dark"] a { color: #60a5fa; }
[data-theme="dark"] .hint { color: #d1d5db; }
[data-theme="dark"] .bank-desc,
[data-theme="dark"] .bank-meta,
[data-theme="dark"] .mode-btn p,
[data-theme="dark"] .stat-card .stat-lbl { color: #d1d5db; }
[data-theme="dark"] .palette-expand-btn { background: #1f2937; border-color: #4b5563; color: #9ca3af; }
[data-theme="dark"] .tool-btn { background: #374151; border-color: #4b5563; color: #d1d5db; }
[data-theme="dark"] .tool-btn:hover { background: #4b5563; }
[data-theme="dark"] .btn-bookmark,
[data-theme="dark"] .btn-clear { background: #374151; border-color: #4b5563; color: #d1d5db; }
[data-theme="dark"] .btn-note { background: #374151; border-color: #4b5563; color: #d1d5db; }
[data-theme="dark"] .btn-note.has-note { background: #1e3a5f; border-color: var(--blue); color: #60a5fa; }
[data-theme="dark"] .note-textarea { background: #1f2937; border-color: #374151; color: #e5e7eb; }
[data-theme="dark"] .note-panel { background: transparent; }
[data-theme="dark"] .review-q .rq-note { background: #1e3a5f; border-color: var(--blue); color: #d1d5db; }
[data-theme="dark"] .modal th { background: #1e3a5f; }
[data-theme="dark"] .daily-goal-card { background: #16213e; border-color: #374151; }
[data-theme="dark"] .daily-goal-card h3 { color: #93c5fd; }
[data-theme="dark"] .daily-goal-card .goal-bar { background: #374151; }
[data-theme="dark"] .daily-goal-card .goal-text { color: #d1d5db; }
[data-theme="dark"] .goal-celebration { background: #064e3b; color: #a7f3d0; }
[data-theme="dark"] .streak-banner.no-streak { background: #374151; color: #9ca3af; }
[data-theme="dark"] .rq-tag { background: #374151; color: #d1d5db; }
[data-theme="dark"] .timer-toggle { color: #60a5fa; }
[data-theme="dark"] .legend-dot.lg-unanswered { background: #374151; border-color: #9ca3af; }
[data-theme="dark"] .mode-btn:hover { background: #1e3a5f; border-color: var(--blue); }
[data-theme="dark"] .test-name span { background: #854d0e; color: #fef08a; }
[data-theme="dark"] .chat-msg.system { background: #422006; color: #fbbf24; }
[data-theme="dark"] .timer-display { background: #1f2937; border-color: #374151; }
[data-theme="dark"] .btn-bookmark.flagged { background: #422006; border-color: var(--orange); color: #fbbf24; }

/* === PROGRESS DASHBOARD === */
.progress-chart{margin:16px 0}
.chart-row{display:flex;align-items:center;margin:6px 0}
.chart-label{width:140px;font-size:12px;color:var(--gray-700);flex-shrink:0}
.chart-bar-bg{flex:1;height:20px;background:var(--gray-200);border-radius:10px;overflow:hidden}
.chart-bar-fill{height:100%;border-radius:10px;transition:width .5s}
.chart-bar-fill.good{background:var(--green)}
.chart-bar-fill.warn{background:var(--orange)}
.chart-bar-fill.bad{background:var(--red)}
.chart-value{width:50px;text-align:right;font-size:12px;font-weight:bold;color:var(--gray-700);margin-left:8px}

.progress-section{background:var(--white);border:1px solid var(--gray-200);border-radius:8px;padding:16px;margin-bottom:16px}
.progress-section h3{font-size:14px;color:var(--navy);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--gray-100)}

.progress-table{width:100%;border-collapse:collapse;font-size:13px}
.progress-table th,.progress-table td{padding:8px 10px;text-align:left;border-bottom:1px solid var(--gray-100)}
.progress-table th{background:var(--gray-50);color:var(--navy);font-weight:bold}
.progress-table tr:hover{background:var(--gray-50)}

.mastery-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-top:12px}
.mastery-item{text-align:center;padding:12px;background:var(--gray-50);border-radius:8px}
.mastery-item .value{font-size:24px;font-weight:bold}
.mastery-item .label{font-size:11px;color:var(--gray-600);margin-top:4px}
.mastery-item.mastered .value{color:var(--green)}
.mastery-item.learning .value{color:var(--orange)}
.mastery-item.new .value{color:var(--blue)}

.study-bars{display:flex;align-items:flex-end;gap:4px;height:100px;margin-top:12px}
.study-day{flex:1;display:flex;flex-direction:column;align-items:center}
.study-day .bar-value{font-size:10px;font-weight:600;color:var(--blue);margin-bottom:2px}
.study-day .bar{width:100%;background:var(--blue);border-radius:4px 4px 0 0;transition:height .3s;min-height:2px}
.study-day .day-label{font-size:10px;color:var(--gray-600);margin-top:4px}

@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .progress-section { background: #16213e; border-color: #374151; }
    body:not([data-theme="light"]) .progress-table th { background: #1f2937; color: #93c5fd; }
    body:not([data-theme="light"]) .mastery-item { background: #1f2937; }
    body:not([data-theme="light"]) .progress-section h3 { color: #93c5fd; }
}
[data-theme="dark"] .progress-section { background: #16213e; border-color: #374151; }
[data-theme="dark"] .progress-table th { background: #1f2937; color: #93c5fd; }
[data-theme="dark"] .mastery-item { background: #1f2937; }
[data-theme="dark"] .progress-section h3 { color: #93c5fd; }

/* Inline chart container */
.inline-chart-wrap{margin:12px 0;border:1px solid var(--gray-200);border-radius:8px;overflow:hidden;background:#fff;max-width:100%;position:relative}
.inline-chart-wrap canvas{display:block;width:100%;height:clamp(260px,50vw,400px);max-height:400px}
.chart-legend{display:flex;flex-wrap:wrap;justify-content:center;gap:10px 20px;padding:10px 16px;background:rgba(0,0,0,0.03);border-top:1px solid var(--gray-200);font-size:13px;font-weight:500}
.chart-legend-item{display:flex;align-items:center;gap:8px}
.chart-legend-color{width:20px;height:4px;border-radius:2px}
.chart-legend-color.dashed{background:repeating-linear-gradient(90deg,currentColor 0,currentColor 4px,transparent 4px,transparent 8px)}
[data-theme="dark"] .chart-legend{background:rgba(255,255,255,0.05);border-color:#374151}
[data-theme="dark"] .inline-chart-wrap{background:#16213e;border-color:#374151}
@media(prefers-color-scheme:dark){body:not([data-theme="light"]) .inline-chart-wrap{background:#16213e;border-color:#374151}}

/* Grid layout for multiple graph panels (2x2) */
.inline-chart-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px;margin:12px 0;padding:12px;background:var(--gray-100);border-radius:8px}
.inline-chart-grid-item{background:#fff;border:1px solid var(--gray-200);border-radius:6px;overflow:hidden}
.chart-grid-label{padding:8px 12px;font-weight:600;font-size:14px;background:var(--gray-100);border-bottom:1px solid var(--gray-200);text-align:center}
.inline-chart-grid-item canvas{display:block;width:100%;height:160px}
[data-theme="dark"] .inline-chart-grid{background:#1e293b}
[data-theme="dark"] .inline-chart-grid-item{background:#16213e;border-color:#374151}
[data-theme="dark"] .chart-grid-label{background:#1e293b;border-color:#374151;color:#93c5fd}
@media(max-width:500px){.inline-chart-grid{grid-template-columns:1fr}.inline-chart-grid-item canvas{height:140px}}

/* Graph/image placeholder styling for dark mode */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .question-text em[data-graph],
    body:not([data-theme="light"]) .question-text .graph-placeholder {
        display: inline-block;
        background: #374151;
        border: 1px dashed #6b7280;
        padding: 8px 12px;
        border-radius: 4px;
        color: #9ca3af;
        font-style: italic;
    }
}
[data-theme="dark"] .question-text em[data-graph],
[data-theme="dark"] .question-text .graph-placeholder {
    display: inline-block;
    background: #374151;
    border: 1px dashed #6b7280;
    padding: 8px 12px;
    border-radius: 4px;
    color: #9ca3af;
    font-style: italic;
}

/* === PRINT STYLESHEET === */
@media print {
    /* Hide UI elements */
    .main-header, .footer-nav, .chat-fab, .chat-panel,
    .calc-panel, .modal-overlay, .toolbar,
    .btn-bookmark, .btn-clear, .btn-check,
    .palette-expand-btn, .palette-legend,
    .score-actions, #helpModal { display: none !important; }

    /* Reset backgrounds for printing */
    body { background: white !important; color: black !important; }
    .screen { display: none !important; }
    .screen.active { display: block !important; max-width: 100% !important; }
    .question-container, .bank-card, .score-screen,
    .review-q, .progress-section {
        background: white !important;
        border: 1px solid #ccc !important;
        page-break-inside: avoid;
    }

    /* Make content readable */
    .question-text, .option-label { color: black !important; }
    .option-item.correct-answer { background: #e8f5e9 !important; border: 2px solid #4caf50 !important; }

    /* Remove shadows and transitions */
    * { box-shadow: none !important; transition: none !important; }
}

/* === GAMIFICATION SYSTEM === */
/* XP Bar */
.xp-bar-container{display:flex;align-items:center;gap:12px;background:linear-gradient(135deg,#1e3a5c,#2c5a8a);padding:12px 20px;border-radius:10px;margin:12px 0;box-shadow:0 4px 12px rgba(0,0,0,.2)}
.xp-level{background:var(--yellow);color:#1a3a5c;font-weight:bold;font-size:16px;padding:6px 12px;border-radius:6px;min-width:60px;text-align:center}
.xp-bar{flex:1;height:16px;background:rgba(255,255,255,.2);border-radius:8px;overflow:hidden;position:relative}
.xp-fill{height:100%;background:linear-gradient(90deg,var(--yellow),var(--orange));border-radius:8px;transition:width .5s ease;position:relative}
.xp-fill::after{content:'';position:absolute;top:0;left:0;right:0;height:50%;background:linear-gradient(to bottom,rgba(255,255,255,.3),transparent);border-radius:8px 8px 0 0}
.xp-info{text-align:right;min-width:100px}
.xp-text{color:#fff;font-size:12px;opacity:.9}
.xp-title{color:var(--yellow);font-size:11px;font-weight:bold;margin-top:2px}
.momentum-pill-wrap{display:flex;flex-wrap:wrap;gap:6px;margin-left:auto}
.momentum-pill{display:inline-flex;align-items:center;gap:6px;background:rgba(255,255,255,.15);color:#fff;font-size:11px;padding:4px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.25);backdrop-filter:blur(4px)}
.momentum-pill.secondary{background:rgba(255,255,255,.08);border-style:dashed}
.momentum-pill.muted{color:rgba(255,255,255,.7);border-color:rgba(255,255,255,.15)}
.qcount-tier-pill,.batch-preview-pill{display:inline-flex;align-items:center;gap:6px;background:var(--navy);color:#fff;font-size:11px;padding:4px 10px;border-radius:999px;margin-top:6px}
.batch-preview{margin-top:12px;padding:10px;background:var(--gray-100);border-radius:10px;border:1px solid var(--gray-200)}
.batch-preview-pill{background:var(--blue);}
.xp-bar-container .buddy-mini{font-size:24px;margin-left:8px;cursor:pointer;transition:transform .2s}
.xp-bar-container .buddy-mini:hover{transform:scale(1.2)}

/* Combo Display */
.combo-display{position:fixed;top:100px;right:20px;background:linear-gradient(135deg,#ff6b35,#f7931e);color:#fff;padding:10px 16px;border-radius:12px;box-shadow:0 4px 16px rgba(255,107,53,.4);z-index:100;display:none;align-items:center;gap:8px;font-weight:bold;max-width:200px}
.combo-display.active{display:flex}
.combo-fire{font-size:24px;animation:firePulse .5s infinite alternate}
.combo-count{font-size:20px}
.combo-mult{font-size:14px;opacity:.9;background:rgba(0,0,0,.2);padding:2px 8px;border-radius:4px}
@keyframes firePulse{0%{transform:scale(1)}100%{transform:scale(1.15)}}

/* XP Popup */
.xp-popup{position:fixed;pointer-events:none;font-weight:bold;font-size:18px;color:var(--yellow);text-shadow:0 2px 4px rgba(0,0,0,.3);animation:xpFloat 1.5s ease-out forwards;z-index:500}
@keyframes xpFloat{0%{opacity:1;transform:translateY(0) scale(1)}50%{opacity:1;transform:translateY(-30px) scale(1.1)}100%{opacity:0;transform:translateY(-60px) scale(0.9)}}

/* Coin Display */
.coin-display{background:linear-gradient(135deg,#ffd700,#ffb700);color:#5a3e00;font-weight:bold;font-size:13px;padding:4px 10px;border-radius:12px;white-space:nowrap;cursor:default;min-width:60px;text-align:center;box-shadow:0 2px 6px rgba(255,183,0,.3)}

/* Coin Popup */
.coin-popup{position:fixed;pointer-events:none;font-weight:bold;font-size:16px;color:#ffd700;text-shadow:0 2px 4px rgba(0,0,0,.4);animation:coinFloat 1.5s ease-out forwards;z-index:500}
@keyframes coinFloat{0%{opacity:1;transform:translateY(0) scale(1)}50%{opacity:1;transform:translateY(-25px) scale(1.1)}100%{opacity:0;transform:translateY(-50px) scale(0.9)}}

/* === SHOP === */
.shop-header{display:flex;align-items:center;gap:12px;padding:12px 0;margin-bottom:12px;border-bottom:2px solid var(--gray-200)}
.shop-header h2{color:var(--navy);font-size:22px}
.shop-tabs{display:flex;gap:6px;margin-bottom:16px;overflow-x:auto;padding-bottom:4px}
.shop-tab{padding:8px 14px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:13px;font-weight:bold;color:var(--gray-700);white-space:nowrap;transition:all .2s}
.shop-tab:hover{border-color:var(--blue);color:var(--blue)}
.shop-tab.active{background:var(--navy);color:#fff;border-color:var(--navy)}
.shop-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(160px,1fr));gap:12px}
.shop-item{background:var(--white);border:2px solid var(--gray-200);border-radius:12px;padding:16px;text-align:center;transition:all .2s}
.shop-item:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1)}
.shop-item.cant-afford{opacity:.6}
.shop-item.already-owned{border-color:var(--green);background:linear-gradient(135deg,#f0fdf4,#dcfce7)}
.shop-item.already-owned .shop-item-icon{opacity:.7}
.shop-owned-badge{background:var(--green);color:white;padding:6px 12px;border-radius:8px;font-size:12px;font-weight:600;margin-top:8px}
.shop-item.locked-item{opacity:.5;position:relative}
.shop-item.locked-item .shop-item-icon{filter:grayscale(1)}
.shop-item-lock{font-size:11px;color:#ef4444;font-weight:600;margin:4px 0}
.shop-item.sold-out{opacity:.4}
.pet-roster{display:flex;flex-wrap:wrap;gap:8px;margin-bottom:12px}
.pet-roster-item{display:flex;flex-direction:column;align-items:center;padding:8px 12px;border:2px solid var(--gray-200);border-radius:10px;cursor:pointer;transition:all .2s;min-width:80px}
.pet-roster-item.active{border-color:var(--blue);background:#eff6ff}
.pet-roster-item:hover{transform:scale(1.05)}
.pet-roster-emoji{font-size:28px}
.pet-roster-name{font-size:11px;font-weight:bold;color:var(--navy)}
.pet-roster-info{font-size:10px;color:var(--gray-600)}
.pet-roster-active{font-size:9px;background:var(--blue);color:#fff;padding:1px 6px;border-radius:4px;margin-top:2px}
.pet-selector{display:flex;gap:6px;justify-content:center;margin-bottom:8px}
.pet-sel-btn{padding:6px 10px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:20px;cursor:pointer;transition:all .2s}
.pet-sel-btn.active{border-color:var(--blue);background:#eff6ff}
.pet-sel-btn:hover{transform:scale(1.1)}
.shop-item.sold-out{opacity:.5}

/* === HOUSE INTERIOR === */
.house-interior{position:relative;border-radius:16px;overflow:hidden;min-height:320px;margin-bottom:20px}
.house-interior.tent{background:linear-gradient(180deg,#4a3728 0%,#3d2d1f 100%)}
.house-interior.cabin{background:linear-gradient(180deg,#5d4037 0%,#4e342e 100%)}
.house-interior.house{background:linear-gradient(180deg,#f5f0e6 0%,#e8e0d0 100%)}
.house-interior.mansion{background:linear-gradient(180deg,#faf8f5 0%,#f0ebe0 100%)}
.house-interior.penthouse{background:linear-gradient(180deg,#1a1a2e 0%,#16213e 100%)}
.house-interior.castle{background:linear-gradient(180deg,#2d2d44 0%,#1f1f30 100%)}
.house-window{position:absolute;top:0;left:0;right:0;height:35%;overflow:hidden}
.house-window-view{width:100%;height:100%;object-fit:cover}
.house-window.penthouse{background:linear-gradient(180deg,#0f0c29 0%,#302b63 50%,#24243e 100%)}
.house-window.penthouse::before{content:'';position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:80px;opacity:0.3}
.house-skyline{position:absolute;bottom:0;left:0;right:0;height:60%;display:flex;align-items:flex-end;justify-content:center;gap:4px;padding:0 10px}
.house-building{background:linear-gradient(180deg,#1a1a2e,#0d0d1a);border-radius:4px 4px 0 0;position:relative}
.house-building::before{content:'';position:absolute;inset:4px;background:repeating-linear-gradient(0deg,transparent 0,transparent 8px,rgba(255,200,50,0.3) 8px,rgba(255,200,50,0.3) 10px),repeating-linear-gradient(90deg,transparent 0,transparent 6px,rgba(255,200,50,0.2) 6px,rgba(255,200,50,0.2) 8px)}
.house-floor{position:absolute;bottom:0;left:0;right:0;height:65%;display:flex;flex-direction:column}
.house-room-tabs{display:flex;gap:4px;padding:8px 12px;background:rgba(0,0,0,0.2);overflow-x:auto;scrollbar-width:thin}
.house-room-tab{padding:6px 12px;border-radius:8px;background:rgba(255,255,255,0.1);color:rgba(255,255,255,0.7);font-size:12px;font-weight:500;cursor:pointer;transition:all 0.2s;white-space:nowrap;border:none}
.house-room-tab:hover{background:rgba(255,255,255,0.2)}
.house-room-tab.active{background:var(--blue);color:#fff}
.house-room-content{flex:1;padding:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative}
.house-room-name{font-size:14px;font-weight:600;color:rgba(255,255,255,0.9);margin-bottom:12px;text-transform:capitalize}
.house-room-furniture{display:flex;flex-wrap:wrap;gap:12px;justify-content:center;margin-bottom:16px}
.house-furniture-item{font-size:32px;padding:8px;background:rgba(255,255,255,0.1);border-radius:10px;cursor:default;transition:transform 0.2s}
.house-furniture-item:hover{transform:scale(1.1)}
.house-pet{position:absolute;bottom:20px;left:20px;cursor:pointer;transition:transform 0.2s}
.house-pet:hover{transform:scale(1.1)}
.house-pet-sprite{font-size:48px;animation:petIdle 2s ease-in-out infinite}
.house-pet-name{font-size:11px;color:rgba(255,255,255,0.8);text-align:center;margin-top:4px}
.house-pet-mood{position:absolute;top:-20px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,0.9);padding:2px 8px;border-radius:8px;font-size:10px;white-space:nowrap}
[data-theme="light"] .house-interior.house,.house-interior.house{background:linear-gradient(180deg,#f5f0e6 0%,#e8e0d0 100%)}
[data-theme="light"] .house-interior.house .house-room-name{color:#333}
[data-theme="light"] .house-interior.house .house-room-tab{background:rgba(0,0,0,0.05);color:#555}
[data-theme="light"] .house-interior.house .house-room-tab.active{background:var(--blue);color:#fff}
[data-theme="light"] .house-interior.mansion .house-room-name{color:#333}

.shop-item-icon{font-size:36px;margin-bottom:8px}
.shop-item-name{font-weight:bold;font-size:14px;color:var(--navy);margin-bottom:4px}
.shop-item-desc{font-size:11px;color:var(--gray-600);margin-bottom:6px;line-height:1.3}
.shop-item-owned{font-size:11px;color:var(--gray-500);margin-bottom:6px}
.shop-buy-btn{background:linear-gradient(135deg,#ffd700,#ffb700);color:#5a3e00;border:none;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:bold;cursor:pointer;transition:all .2s}
.shop-buy-btn:hover:not(:disabled){transform:scale(1.05);box-shadow:0 2px 8px rgba(255,183,0,.4)}
.shop-buy-btn:disabled{background:var(--gray-300);color:var(--gray-500);cursor:not-allowed}
.shop-buy-btn.sale-btn{background:linear-gradient(135deg,#ef4444,#dc2626);color:#fff}
.shop-sale-banner{background:linear-gradient(135deg,#ef4444,#f97316);color:#fff;padding:10px 16px;border-radius:8px;font-weight:bold;text-align:center;margin-bottom:12px;animation:pulse 2s infinite}
.shop-sale-tag{position:absolute;top:-6px;right:-6px;background:#ef4444;color:#fff;font-size:10px;font-weight:bold;padding:3px 6px;border-radius:4px;z-index:1}
.shop-item.on-sale{border:2px solid #ef4444;position:relative}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.85}}

/* === GARDEN === */
.garden-header{display:flex;align-items:center;gap:8px;padding:12px 0;margin-bottom:12px;border-bottom:2px solid var(--gray-200);flex-wrap:wrap}

/* Garden Scene */
.garden-scene{position:relative;border-radius:16px;overflow:hidden;min-height:420px;background:linear-gradient(to bottom,#87CEEB 0%,#a8d8ea 28%,#7CCD7C 28%,#6ab84a 40%,#5a9e3a 100%);padding:0;display:flex;flex-direction:column}
.garden-sky{position:absolute;top:0;left:0;right:0;height:28%;pointer-events:none;z-index:1}
.garden-sky-sun{position:absolute;top:12px;right:16px;font-size:28px;filter:drop-shadow(0 0 8px rgba(255,200,0,.5));transition:opacity .3s}
.garden-sky-stars{display:none;position:absolute;top:8px;left:16px;font-size:16px;letter-spacing:12px}
.garden-fence{position:relative;z-index:2;display:flex;justify-content:center;padding:4px 12px 0;font-size:11px;letter-spacing:1px;color:#8B6914;opacity:.5;user-select:none}
.garden-ground{position:relative;z-index:2;flex:1;display:flex;flex-direction:column;padding:8px 16px 12px}
.garden-plots{display:grid;grid-template-columns:repeat(3,1fr);gap:10px;max-width:480px;margin:0 auto;width:100%}

/* Dirt plot beds */
.garden-plot{aspect-ratio:1;background:linear-gradient(145deg,#8B6C42,#6B4E2E);border:2px solid #5a3e1b;border-radius:14px;display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;transition:all .2s;position:relative;min-height:100px;box-shadow:inset 0 2px 6px rgba(0,0,0,.3),0 3px 6px rgba(0,0,0,.2)}
.garden-plot:hover{transform:scale(1.04);box-shadow:inset 0 2px 6px rgba(0,0,0,.3),0 5px 14px rgba(0,0,0,.25)}
.garden-plot.locked{background:linear-gradient(145deg,#6b6b6b,#4a4a4a);border-color:#3a3a3a;cursor:pointer;opacity:.6}
.garden-plot.locked:hover{opacity:.75}
.plot-lock{font-size:24px}
.plot-empty-icon{font-size:28px;opacity:.6;transition:opacity .2s}
.garden-plot.empty:hover .plot-empty-icon{opacity:1}
.garden-plot.empty{border-style:dashed;border-color:#7a5c30}
.plot-water-btn{margin-top:6px;padding:3px 10px;font-size:11px;border-radius:999px;border:1px solid rgba(59,130,246,.4);background:rgba(59,130,246,.15);color:#0b5394;font-weight:600;cursor:pointer;transition:all .2s}
.plot-water-btn:hover{background:rgba(59,130,246,.25);border-color:rgba(59,130,246,.6)}
.plot-water-btn:disabled{opacity:.5;cursor:not-allowed}
.plot-plant{font-size:40px;transition:all .3s;filter:drop-shadow(0 2px 2px rgba(0,0,0,.2))}
.plot-plant.glow-bounce{animation:glowBounce 1s infinite alternate;filter:drop-shadow(0 0 10px rgba(255,215,0,.7)) drop-shadow(0 0 20px rgba(255,215,0,.3))}
@keyframes glowBounce{0%{transform:scale(1)}100%{transform:scale(1.12) translateY(-5px)}}
.plot-progress-bar{width:75%;height:5px;background:rgba(0,0,0,.3);border-radius:3px;overflow:hidden;margin-top:6px}
.plot-progress-fill{height:100%;background:linear-gradient(90deg,#4ade80,#22c55e);border-radius:3px;transition:width .3s}
.plot-ready{font-size:11px;font-weight:bold;color:#fef08a;margin-top:4px;animation:pulse 1s infinite alternate;text-shadow:0 1px 2px rgba(0,0,0,.5)}
@keyframes pulse{0%{opacity:.7}100%{opacity:1}}
.plot-label{font-size:10px;color:rgba(255,255,255,.75);margin-top:2px;text-shadow:0 1px 1px rgba(0,0,0,.4)}
.plot-fertilized{position:absolute;top:4px;right:4px;font-size:14px;filter:drop-shadow(0 0 4px rgba(100,200,255,.5))}

/* Decorations in scene */
.garden-decos-row{display:flex;gap:10px;justify-content:center;padding:6px 0;z-index:2}
.garden-deco{font-size:26px;cursor:default;filter:drop-shadow(0 2px 2px rgba(0,0,0,.2))}

/* Garden Pet in scene */
.garden-pet{position:absolute;bottom:12px;left:16px;z-index:3;cursor:pointer;transition:transform .2s;text-align:center}
.garden-pet:hover{transform:scale(1.08)}
.garden-pet-sprite{position:relative;display:inline-block}
.garden-pet-emoji{font-size:44px;animation:petIdle 2s ease-in-out infinite;filter:drop-shadow(0 2px 3px rgba(0,0,0,.3))}
@keyframes petIdle{0%,100%{transform:translateY(0)}50%{transform:translateY(-5px)}}
/* Garden pet accessory positioning ON the pet */
.pet-accessory{position:absolute;font-size:14px;z-index:10;filter:drop-shadow(1px 1px 1px rgba(0,0,0,0.4))}
.pet-accessory.acc-hat{top:-6px;left:50%;transform:translateX(-50%)}
.pet-accessory.acc-crown{top:-8px;left:50%;transform:translateX(-50%)}
.pet-accessory.acc-scarf{bottom:8px;left:50%;transform:translateX(-50%)}
.pet-accessory.acc-sunglasses{top:12px;left:50%;transform:translateX(-50%)}
.pet-accessory.acc-cape{top:18px;right:-2px;font-size:16px}
.pet-accessory.acc-bowtie{bottom:14px;left:50%;transform:translateX(-50%)}
.garden-pet-name{font-weight:bold;font-size:11px;color:#fff;text-shadow:0 1px 3px rgba(0,0,0,.5)}
.garden-pet-mood-bubble{position:absolute;top:-24px;left:50%;transform:translateX(-50%);background:rgba(255,255,255,.92);border-radius:10px;padding:2px 7px;font-size:11px;white-space:nowrap;box-shadow:0 1px 4px rgba(0,0,0,.15);pointer-events:none}
.garden-pet-mood-bubble::after{content:'';position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:8px;height:4px;background:rgba(255,255,255,.92);clip-path:polygon(0 0,100% 0,50% 100%)}

/* Watering can button in scene */
.garden-water-btn{position:absolute;bottom:12px;right:16px;z-index:3;background:rgba(255,255,255,.85);border:2px solid rgba(52,152,219,.4);border-radius:12px;padding:6px 12px;cursor:pointer;font-size:14px;transition:all .2s;display:flex;align-items:center;gap:4px;box-shadow:0 2px 8px rgba(0,0,0,.1)}
.garden-water-btn:hover{background:rgba(255,255,255,.95);transform:scale(1.05);border-color:rgba(52,152,219,.7)}
.garden-water-btn .water-count{font-size:12px;font-weight:bold;color:#2563eb}
.garden-water-meter{position:absolute;bottom:110px;right:16px;z-index:3;background:rgba(255,255,255,.92);border:2px solid rgba(52,152,219,.35);border-radius:14px;padding:10px 14px;font-size:12px;box-shadow:0 2px 10px rgba(0,0,0,.12);width:160px}
.garden-water-meter .water-meter-label{font-weight:600;color:#2563eb;margin-bottom:4px;text-transform:uppercase;font-size:11px;letter-spacing:.05em}
.garden-water-meter .water-meter-bar{position:relative;height:10px;background:rgba(37,99,235,.12);border-radius:999px;overflow:hidden}
.garden-water-meter .water-meter-fill{position:absolute;top:0;left:0;height:100%;background:linear-gradient(90deg,#2563eb,#60a5fa);border-radius:999px;transition:width .3s ease}
.garden-water-meter .water-meter-text{margin-top:6px;font-weight:bold;color:#2563eb}
.garden-water-meter .water-meter-text.low{color:#f97316}
.garden-water-meter .water-meter-text.critical{color:#dc2626}
.garden-water-meter.pulse .water-meter-fill{animation:meterPulse .7s ease}
@keyframes meterPulse{0%{box-shadow:0 0 0 0 rgba(96,165,250,.6)}100%{box-shadow:0 0 0 12px rgba(96,165,250,0)}}

/* Water purchase prompt */
.garden-water-prompt{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);z-index:10000;background:#fff;border-radius:12px;padding:20px 24px;box-shadow:0 8px 32px rgba(0,0,0,.25);text-align:center;max-width:300px;animation:fadeInScale .2s ease}
@keyframes fadeInScale{from{opacity:0;transform:translate(-50%,-50%) scale(.9)}to{opacity:1;transform:translate(-50%,-50%) scale(1)}}
.garden-water-prompt p{margin:0 0 16px;font-size:14px;color:#374151}
.garden-water-prompt-actions{display:flex;gap:10px;justify-content:center}
.garden-water-prompt .prompt-primary{padding:8px 16px;background:#2563eb;color:#fff;border:none;border-radius:6px;font-weight:600;cursor:pointer;transition:background .2s}
.garden-water-prompt .prompt-primary:hover{background:#1d4ed8}
.garden-water-prompt .prompt-secondary{padding:8px 16px;background:#f3f4f6;color:#374151;border:1px solid #d1d5db;border-radius:6px;cursor:pointer;transition:all .2s}
.garden-water-prompt .prompt-secondary:hover{background:#e5e7eb}
[data-theme="dark"] .garden-water-prompt{background:#1f2937;border:1px solid #374151}
[data-theme="dark"] .garden-water-prompt p{color:#d1d5db}
[data-theme="dark"] .garden-water-prompt .prompt-secondary{background:#374151;color:#e5e7eb;border-color:#4b5563}

/* Weather effects on scene */
.garden-scene.water-low{filter:saturate(.6) brightness(.92)}
.garden-scene.water-critical{filter:saturate(.35) brightness(.82)}

/* Garden Stats Bar */
.garden-stats-bar{position:relative;z-index:3;display:flex;justify-content:center;gap:12px;padding:6px 12px;background:rgba(0,0,0,.25);backdrop-filter:blur(4px);border-radius:8px;margin:8px 12px 0;font-size:12px}
.garden-stat{display:flex;align-items:center;gap:4px;padding:4px 10px;background:rgba(255,255,255,.15);border-radius:6px;color:#fff;font-weight:600;text-shadow:0 1px 2px rgba(0,0,0,.3)}
.garden-stat.bonus-active{background:rgba(74,222,128,.3);color:#4ade80}

/* Weather animations */
.garden-weather{position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;z-index:0}
.garden-weather.rainy::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(transparent 0%,rgba(100,149,237,.15) 100%);animation:rainFall 0.5s linear infinite}
.garden-weather.stormy::before{content:'';position:absolute;top:0;left:0;right:0;bottom:0;background:linear-gradient(transparent 0%,rgba(50,50,80,.25) 100%);animation:stormFlash 3s ease-in-out infinite}
.garden-weather.sunny::after{content:'';position:absolute;top:10px;right:10px;width:60px;height:60px;background:radial-gradient(circle,rgba(255,200,0,.3) 0%,transparent 70%);border-radius:50%;animation:sunGlow 3s ease-in-out infinite}
@keyframes rainFall{0%{background-position:0 0}100%{background-position:0 20px}}
@keyframes stormFlash{0%,90%,100%{opacity:1}92%,94%{opacity:.7}}
@keyframes sunGlow{0%,100%{transform:scale(1);opacity:.8}50%{transform:scale(1.1);opacity:1}}

/* Garden Info Panel */
.garden-info-panel{display:flex;justify-content:space-around;padding:12px 16px;background:linear-gradient(135deg,rgba(34,197,94,.1),rgba(59,130,246,.1));border-radius:12px;margin:12px 0;border:1px solid rgba(74,222,128,.2)}
.garden-info-row{display:flex;flex-direction:column;align-items:center;gap:2px}
.garden-info-label{font-size:11px;color:var(--gray-500);font-weight:500}
.garden-info-value{font-size:16px;font-weight:700;color:var(--green)}

/* Companion planting glow */
.garden-plot.companion-bonus{box-shadow:inset 0 2px 6px rgba(0,0,0,.3),0 0 12px rgba(74,222,128,.4)}
.garden-plot.companion-bonus::after{content:'';position:absolute;top:-8px;right:-8px;font-size:14px;animation:pulse 2s infinite}

/* In-season glow */
.garden-plot.in-season{border-color:#fbbf24;box-shadow:inset 0 2px 6px rgba(0,0,0,.3),0 0 8px rgba(251,191,36,.5)}
.plot-season-badge{position:absolute;top:-6px;left:-6px;font-size:16px;animation:pulse 1.5s infinite}
.plot-bonus-tag{position:absolute;bottom:4px;right:4px;background:linear-gradient(135deg,#22c55e,#16a34a);color:#fff;font-size:10px;font-weight:700;padding:2px 6px;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.2)}

/* Season themes */
.garden-scene.spring{background:linear-gradient(to bottom,#87CEEB 0%,#a8d8ea 28%,#7CCD7C 28%,#6ab84a 40%,#5a9e3a 100%)}
.garden-scene.summer{background:linear-gradient(to bottom,#5BA8E8 0%,#87CEEB 28%,#8BC34A 28%,#7CB342 40%,#689F38 100%)}
.garden-scene.autumn{background:linear-gradient(to bottom,#B8860B 0%,#DAA520 28%,#CD853F 28%,#A0522D 40%,#8B4513 100%)}
.garden-scene.winter{background:linear-gradient(to bottom,#B0C4DE 0%,#E0E8F0 28%,#F5F5F5 28%,#E8E8E8 40%,#D3D3D3 100%)}

/* Seed Picker & Plot Info Modals */
.garden-modal-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.55);display:flex;align-items:center;justify-content:center;z-index:5000;animation:fadeIn .2s}
.garden-modal{background:var(--white);border-radius:16px;padding:24px;max-width:380px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,.3);position:relative;max-height:80vh;overflow-y:auto}
.garden-modal h3{margin:0 0 16px;font-size:18px;color:var(--navy);text-align:center}
.garden-modal-close{position:absolute;top:10px;right:12px;background:none;border:none;font-size:22px;color:var(--gray-400);cursor:pointer;line-height:1;padding:4px}
.garden-modal-close:hover{color:var(--gray-700)}
.seed-option{display:flex;align-items:center;gap:12px;padding:12px;border:2px solid var(--gray-200);border-radius:12px;cursor:pointer;transition:all .15s;margin-bottom:8px}
.seed-option:hover{border-color:var(--green);background:rgba(74,222,128,.08);transform:translateX(4px)}
.seed-option:active{transform:translateX(2px) scale(.98)}
.seed-option-icon{font-size:32px;flex-shrink:0}
.seed-option-info{flex:1}
.seed-option-name{font-weight:bold;font-size:14px;color:var(--navy)}
.seed-option-meta{font-size:12px;color:var(--gray-600);margin-top:2px}
.seed-option-count{font-size:12px;font-weight:bold;color:var(--green);background:rgba(74,222,128,.15);padding:2px 8px;border-radius:8px;flex-shrink:0}
.plot-info-header{text-align:center;margin-bottom:16px}
.plot-info-header .plot-info-emoji{font-size:48px}
.plot-info-header .plot-info-name{font-size:16px;font-weight:bold;color:var(--navy);margin-top:4px}
.plot-info-stats{display:flex;flex-direction:column;gap:8px;margin-bottom:16px}
.plot-info-stat{display:flex;justify-content:space-between;align-items:center;font-size:13px;color:var(--gray-700)}
.plot-info-stat span:last-child{font-weight:600}
.plot-info-progress{width:100%;height:8px;background:var(--gray-200);border-radius:4px;overflow:hidden;margin:4px 0 12px}
.plot-info-progress-fill{height:100%;background:linear-gradient(90deg,#4ade80,#22c55e);border-radius:4px;transition:width .3s}
.plot-info-actions{display:flex;flex-direction:column;gap:8px}
.plot-info-action{display:flex;align-items:center;gap:10px;padding:10px 12px;border:2px solid var(--gray-200);border-radius:10px;cursor:pointer;transition:all .15s;background:none;width:100%;text-align:left;font-size:13px;color:var(--navy)}
.plot-info-action:hover:not(:disabled){border-color:var(--blue);background:rgba(37,99,235,.06)}
.plot-info-action:disabled{opacity:.4;cursor:not-allowed}
.plot-info-action-icon{font-size:22px;flex-shrink:0}
.plot-info-action-label{font-weight:600}
.plot-info-action-desc{font-size:11px;color:var(--gray-500)}

/* === PET MODAL === */
.pet-modal-content{background:var(--white);border-radius:16px;padding:24px;max-width:400px;width:90%;margin:40px auto;position:relative;max-height:85vh;overflow-y:auto}
.pet-modal-close{position:absolute;top:12px;right:12px;background:none;border:none;font-size:24px;color:var(--gray-500);cursor:pointer}
.pet-modal-sprite{text-align:center;position:relative;display:inline-block;width:100%;min-height:80px}
.pet-modal-emoji{font-size:64px;position:relative;display:inline-block}
/* Accessory positioning - each type has specific placement ON the pet */
.pet-modal-acc{position:absolute;font-size:20px;z-index:10;filter:drop-shadow(1px 1px 1px rgba(0,0,0,0.3))}
.pet-modal-acc.acc-hat{top:-8px;left:50%;transform:translateX(-50%)}
.pet-modal-acc.acc-crown{top:-12px;left:50%;transform:translateX(-50%)}
.pet-modal-acc.acc-scarf{bottom:5px;left:50%;transform:translateX(-50%)}
.pet-modal-acc.acc-sunglasses{top:18px;left:50%;transform:translateX(-50%)}
.pet-modal-acc.acc-cape{top:25px;right:-5px;font-size:24px}
.pet-modal-acc.acc-bowtie{bottom:12px;left:50%;transform:translateX(-50%)}
.pet-modal-name{text-align:center;font-size:20px;font-weight:bold;color:var(--navy);cursor:pointer;margin:8px 0 4px}
.pet-modal-name:hover{text-decoration:underline}
.pet-modal-stage{text-align:center;font-size:13px;color:var(--gray-600);margin-bottom:12px}
.pet-meters{display:flex;flex-direction:column;gap:8px;margin-bottom:16px}
.pet-meter{display:flex;align-items:center;gap:8px;font-size:12px;color:var(--gray-700)}
.pet-meter span{min-width:70px}
.pet-meter span:last-child{min-width:35px;text-align:right}
.pet-meter-bar{flex:1;height:10px;background:var(--gray-200);border-radius:5px;overflow:hidden}
.pet-meter-fill{height:100%;border-radius:5px;transition:width .3s}
.pet-meter-fill.hunger{background:linear-gradient(90deg,#e74c3c,#e67e22)}
.pet-meter-fill.happiness{background:linear-gradient(90deg,#f39c12,#ffd60a)}
.pet-meter-fill.hydration{background:linear-gradient(90deg,#3b82f6,#06b6d4)}
.pet-meter-fill.evolution{background:linear-gradient(90deg,#9b59b6,#3498db)}
.pet-meter-fill.care{background:linear-gradient(90deg,#10b981,#06b6d4)}
.pet-sick-banner{background:#fef3c7;border:1px solid #f59e0b;color:#92400e;padding:6px 10px;border-radius:8px;font-size:12px;text-align:center;margin:6px 0;animation:buddySick 2s ease-in-out infinite}
.pet-evo-timer{font-size:11px;color:var(--blue);text-align:center;margin:4px 0;font-weight:500}
.food-growth{font-size:9px;color:var(--green);margin-left:4px;font-weight:600}
.pet-modal-content h4{font-size:13px;color:var(--navy);margin:12px 0 8px;border-bottom:1px solid var(--gray-200);padding-bottom:4px}
.pet-food-grid{display:grid;grid-template-columns:repeat(2,1fr);gap:6px}
.pet-food-btn{padding:8px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:12px;cursor:pointer;transition:all .2s;display:flex;align-items:center;gap:6px}
.pet-food-btn:hover:not(:disabled){border-color:var(--green);background:#eafaf1}
.pet-food-btn:disabled{opacity:.4;cursor:not-allowed}
.pet-food-count{margin-left:auto;background:var(--gray-100);padding:2px 6px;border-radius:4px;font-size:11px}
.pet-accessory-grid{display:flex;flex-wrap:wrap;gap:6px}
.pet-accessory-btn{width:44px;height:44px;border:2px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:20px;cursor:pointer;transition:all .2s;display:flex;align-items:center;justify-content:center}
.pet-accessory-btn:hover{border-color:var(--blue)}
.pet-accessory-btn.equipped{border-color:var(--green);background:#eafaf1}
.pet-modal-stats{display:flex;gap:16px;justify-content:center;margin-top:16px;font-size:11px;color:var(--gray-500)}

/* Achievement Toast */
.achievement-toast{position:fixed;bottom:100px;right:20px;background:#fff;border:2px solid var(--yellow);border-radius:12px;padding:16px 20px;box-shadow:0 8px 24px rgba(0,0,0,.2);z-index:600;display:flex;align-items:center;gap:14px;animation:achievementSlide .5s ease-out;max-width:320px}
.achievement-toast.hidden{display:none}
.ach-icon{font-size:40px;flex-shrink:0}
.ach-info{flex:1}
.ach-name{font-weight:bold;font-size:16px;color:var(--navy);margin-bottom:2px}
.ach-desc{font-size:13px;color:var(--gray-600)}
.ach-xp{font-size:12px;color:var(--green);font-weight:bold;margin-top:4px}
@keyframes achievementSlide{0%{opacity:0;transform:translateX(100px)}100%{opacity:1;transform:translateX(0)}}

/* Level Up Modal */
.levelup-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);z-index:1000;display:none;align-items:center;justify-content:center}
.levelup-overlay.active{display:flex}
.levelup-modal{background:linear-gradient(135deg,#1e3a5c,#2c5a8a);color:#fff;padding:40px 50px;border-radius:20px;text-align:center;animation:levelUpBounce .6s ease-out;box-shadow:0 20px 60px rgba(0,0,0,.4)}
.levelup-modal .level-icon{font-size:60px;margin-bottom:12px}
.levelup-modal h2{font-size:32px;margin-bottom:8px;color:var(--yellow)}
.levelup-modal .level-num{font-size:64px;font-weight:bold;color:#fff;margin:12px 0}
.levelup-modal .level-title{font-size:20px;color:var(--yellow);margin-bottom:16px}
.levelup-modal .level-rewards{font-size:14px;opacity:.9;margin-bottom:20px}
.levelup-modal button{background:var(--yellow);color:#1a3a5c;border:none;padding:12px 32px;border-radius:8px;font-size:16px;font-weight:bold;cursor:pointer}
.levelup-modal button:hover{background:#fff}
@keyframes levelUpBounce{0%{opacity:0;transform:scale(.5)}60%{transform:scale(1.1)}100%{opacity:1;transform:scale(1)}}

/* Study Buddy Widget */
.study-buddy{position:fixed;background:#fff;border:2px solid var(--gray-200);border-radius:16px;padding:12px 16px;box-shadow:0 4px 12px rgba(0,0,0,.1);z-index:100;display:none;text-align:center;cursor:grab;transition:transform .2s,box-shadow .2s;touch-action:none;user-select:none;transform-origin:center}
.study-buddy.hidden{display:none!important}
.study-buddy.active{display:block}
@media (hover:hover) {
    .study-buddy:hover:not(.dragging){transform:scale(1.05)}
}
.study-buddy.dragging{cursor:grabbing;box-shadow:0 6px 18px rgba(0,0,0,.25)}
.buddy-sprite{font-size:36px;margin-bottom:4px;position:relative;display:inline-block}
/* Buddy widget accessory positioning ON the pet */
.buddy-acc{position:absolute;font-size:12px;z-index:10;filter:drop-shadow(1px 1px 1px rgba(0,0,0,0.3))}
.buddy-acc.acc-hat{top:-4px;left:50%;transform:translateX(-50%)}
.buddy-acc.acc-crown{top:-6px;left:50%;transform:translateX(-50%)}
.buddy-acc.acc-scarf{bottom:2px;left:50%;transform:translateX(-50%)}
.buddy-acc.acc-sunglasses{top:10px;left:50%;transform:translateX(-50%)}
.buddy-acc.acc-cape{top:14px;right:-2px;font-size:14px}
.buddy-acc.acc-bowtie{bottom:6px;left:50%;transform:translateX(-50%)}
.buddy-name{font-size:12px;font-weight:bold;color:var(--navy)}
.buddy-mood{font-size:10px;color:var(--gray-600)}
.study-buddy.urgent{animation:buddyPulse 1.5s ease-in-out infinite;border-color:#ef4444}
.study-buddy.sick{animation:buddySick 1s ease-in-out infinite;border-color:#f59e0b;background:#fffbeb}
@keyframes buddyPulse{0%,100%{transform:scale(1);box-shadow:0 4px 12px rgba(0,0,0,.1)}50%{transform:scale(1.08);box-shadow:0 4px 16px rgba(239,68,68,.3)}}
@keyframes buddySick{0%,100%{transform:rotate(0deg)}25%{transform:rotate(-3deg)}75%{transform:rotate(3deg)}}
@keyframes speedFeedback{0%{opacity:1;transform:translate(-50%,-50%) scale(1)}100%{opacity:0;transform:translate(-50%,-80%) scale(1.5)}}
.buddy-progress{width:60px;height:4px;background:var(--gray-200);border-radius:2px;margin:6px auto 0;overflow:hidden}
.buddy-progress-fill{height:100%;background:var(--green);border-radius:2px}

/* Power-Up Button */
.powerup-btn{background:linear-gradient(135deg,#9b59b6,#8e44ad);color:#fff;border:none;padding:8px 16px;border-radius:8px;font-size:13px;font-weight:bold;cursor:pointer;display:inline-flex;align-items:center;gap:6px;margin:4px;transition:all .2s}
.powerup-btn:hover{transform:scale(1.05);box-shadow:0 4px 12px rgba(155,89,182,.4)}
.powerup-btn:disabled{background:var(--gray-400);cursor:not-allowed;transform:none}
.powerup-btn .pu-icon{font-size:16px}
.powerup-btn .pu-count{background:rgba(255,255,255,.3);padding:2px 6px;border-radius:4px;font-size:11px}

/* Power-Up Bar */
.powerup-bar{display:flex;flex-wrap:wrap;gap:6px;margin:8px 0;justify-content:center}

/* Category Mastery Badges */
.mastery-badge{display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:12px;font-size:11px;font-weight:bold}
.mastery-badge.bronze{background:#cd7f32;color:#fff}
.mastery-badge.silver{background:#c0c0c0;color:#333}
.mastery-badge.gold{background:linear-gradient(135deg,#ffd700,#ffb700);color:#333}
.mastery-badge.platinum{background:linear-gradient(135deg,#e5e4e2,#a0d2db);color:#333}

/* === BATTLE SYSTEM === */
.battle-header{display:flex;align-items:center;gap:8px;padding:12px 0;margin-bottom:12px;border-bottom:2px solid var(--gray-200);flex-wrap:wrap}
.battle-header h2{flex:1;text-align:center;margin:0;font-size:18px;color:var(--navy)}
.battle-header .battle-stars{color:var(--yellow);font-size:14px;letter-spacing:2px}
.battle-arena{display:flex;flex-direction:column;align-items:center;gap:8px;padding:16px 0}
.battle-combatant{display:flex;flex-direction:column;align-items:center;gap:6px;padding:12px 20px;background:var(--white);border:2px solid var(--gray-200);border-radius:12px;min-width:220px;position:relative;transition:transform .15s}
.battle-combatant.enemy-side{border-color:var(--red)}
.battle-combatant.pet-side{border-color:var(--blue)}
.battle-combatant .combatant-sprite{font-size:48px;line-height:1}
.battle-combatant .combatant-name{font-size:14px;font-weight:bold;color:var(--gray-800)}
.battle-combatant .combatant-level{font-size:11px;color:var(--gray-600)}
.battle-hp{width:100%;display:flex;align-items:center;gap:6px;font-size:11px}
.battle-hp-bar{flex:1;height:12px;background:var(--gray-200);border-radius:6px;overflow:hidden}
.battle-hp-fill{height:100%;border-radius:6px;transition:width .4s ease}
.battle-hp-fill.hp-high{background:linear-gradient(90deg,#27ae60,#2ecc71)}
.battle-hp-fill.hp-mid{background:linear-gradient(90deg,#f39c12,#f1c40f)}
.battle-hp-fill.hp-low{background:linear-gradient(90deg,#c0392b,#e74c3c)}
.battle-vs{font-size:28px;font-weight:bold;color:var(--gray-400);margin:4px 0}
.battle-stats-row{display:flex;gap:16px;font-size:11px;color:var(--gray-600)}
.battle-stats-row span{display:flex;align-items:center;gap:3px}
.battle-question{margin-top:12px;padding:16px;background:var(--white);border:1px solid var(--gray-200);border-radius:8px}
.battle-question .bq-text{font-size:14px;color:var(--gray-800);margin-bottom:12px;line-height:1.5}
.battle-question .bq-options{display:grid;gap:8px}
.battle-question .bq-opt{padding:12px 14px;border:2px solid var(--gray-200);border-radius:var(--radius);background:var(--white);text-align:left;font-size:13px;cursor:pointer;transition:all .15s}
.battle-question .bq-opt:hover:not(.disabled){background:#f0f7ff;border-color:var(--blue)}
.battle-question .bq-opt.correct{border-color:var(--green);background:#eafaf1}
.battle-question .bq-opt.wrong{border-color:var(--red);background:#fdf2f2}
.battle-question .bq-opt.disabled{cursor:not-allowed;opacity:.7}
.battle-items-bar{display:flex;gap:8px;justify-content:center;margin-top:12px;flex-wrap:wrap}
.battle-item-btn{padding:8px 14px;border:1px solid var(--gray-200);border-radius:8px;background:var(--white);font-size:12px;display:flex;align-items:center;gap:4px;cursor:pointer;transition:all .15s}
.battle-item-btn:hover:not(:disabled){border-color:var(--blue);background:#f0f7ff}
.battle-item-btn:disabled{opacity:.4;cursor:not-allowed}
.battle-item-btn .item-count{background:var(--blue);color:#fff;border-radius:50%;width:18px;height:18px;display:inline-flex;align-items:center;justify-content:center;font-size:10px;font-weight:bold}
.battle-log{margin-top:8px;padding:8px 12px;background:var(--gray-50);border-radius:6px;font-size:12px;color:var(--gray-600);text-align:center;min-height:24px}

/* Chapter Select */
.chapter-select{display:grid;grid-template-columns:1fr;gap:12px;max-width:500px;margin:0 auto}
.chapter-card{display:flex;align-items:center;gap:14px;padding:16px;border:2px solid var(--gray-200);border-radius:12px;background:var(--white);cursor:pointer;transition:all .2s}
.chapter-card:hover:not(.locked){border-color:var(--blue);transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.1)}
.chapter-card.locked{opacity:.5;cursor:not-allowed;filter:grayscale(.6)}
.chapter-card.current{border-color:var(--green);background:#eafaf1}
.chapter-card .ch-icon{font-size:36px;line-height:1}
.chapter-card .ch-info{flex:1}
.chapter-card .ch-name{font-size:15px;font-weight:bold;color:var(--navy)}
.chapter-card .ch-progress{font-size:11px;color:var(--gray-600);margin-top:2px}
.chapter-card .ch-stars{color:var(--yellow);font-size:13px;letter-spacing:1px}
.chapter-card .ch-lock{font-size:20px;color:var(--gray-400)}
.chapter-card .ch-req{font-size:11px;color:var(--gray-500)}

/* Battle result overlay */
.battle-result-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,.6);display:flex;align-items:center;justify-content:center;z-index:5000;animation:fadeIn .3s}
.battle-result-modal{background:var(--white);border-radius:16px;padding:32px;text-align:center;max-width:360px;width:90%;box-shadow:0 8px 32px rgba(0,0,0,.3)}
.battle-result-modal h2{font-size:24px;margin-bottom:8px}
.battle-result-modal .result-icon{font-size:56px;margin-bottom:12px}
.battle-result-modal .result-rewards{margin:16px 0;font-size:14px;color:var(--gray-700)}
.battle-result-modal .result-rewards div{margin:4px 0}
.battle-result-modal button{margin:6px;padding:10px 24px;border:none;border-radius:8px;font-size:14px;font-weight:bold;cursor:pointer}
.battle-result-modal .btn-primary{background:var(--blue);color:#fff}
.battle-result-modal .btn-secondary{background:var(--gray-200);color:var(--gray-700)}
@keyframes fadeIn{from{opacity:0}to{opacity:1}}

/* Battle animations */
@keyframes battleShake{0%,100%{transform:translateX(0)}20%{transform:translateX(-8px)}40%{transform:translateX(8px)}60%{transform:translateX(-5px)}80%{transform:translateX(5px)}}
@keyframes battleFlash{0%{opacity:1}25%{opacity:.3}50%{opacity:1}75%{opacity:.3}100%{opacity:1}}
.battle-shake{animation:battleShake .4s ease}
.battle-flash{animation:battleFlash .5s ease}
.battle-dmg-popup{position:absolute;top:-10px;right:0;font-size:18px;font-weight:bold;color:var(--red);animation:dmgFloat .8s ease forwards;pointer-events:none}
.battle-dmg-popup.heal{color:var(--green)}
@keyframes dmgFloat{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-30px)}}

/* Battle dark mode */
[data-theme="dark"] .battle-header{border-color:#374151}
[data-theme="dark"] .battle-combatant{background:#16213e;border-color:#374151}
[data-theme="dark"] .battle-combatant.enemy-side{border-color:#7f1d1d}
[data-theme="dark"] .battle-combatant.pet-side{border-color:#1e3a5f}
[data-theme="dark"] .battle-combatant .combatant-name{color:#e5e7eb}
[data-theme="dark"] .battle-hp-bar{background:#374151}
[data-theme="dark"] .battle-question{background:#16213e;border-color:#374151}
[data-theme="dark"] .battle-question .bq-text{color:#e5e7eb}
[data-theme="dark"] .battle-question .bq-opt{background:#1f2937;border-color:#374151;color:#e5e7eb}
[data-theme="dark"] .battle-question .bq-opt:hover:not(.disabled){background:#1e3a5f;border-color:var(--blue)}
[data-theme="dark"] .battle-question .bq-opt.correct{background:#064e3b;border-color:var(--green)}
[data-theme="dark"] .battle-question .bq-opt.wrong{background:#7f1d1d;border-color:var(--red)}
[data-theme="dark"] .battle-item-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .battle-log{background:#1f2937;color:#9ca3af}
[data-theme="dark"] .chapter-card{background:#16213e;border-color:#374151;color:#e5e7eb}
[data-theme="dark"] .chapter-card:hover:not(.locked){border-color:var(--blue);background:#1e3a5f}
[data-theme="dark"] .chapter-card.current{border-color:var(--green);background:#064e3b}
[data-theme="dark"] .chapter-card .ch-name{color:#93c5fd}
[data-theme="dark"] .battle-result-modal{background:#16213e;color:#e5e7eb}
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .battle-header{border-color:#374151}
    body:not([data-theme="light"]) .battle-combatant{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .battle-combatant.enemy-side{border-color:#7f1d1d}
    body:not([data-theme="light"]) .battle-combatant.pet-side{border-color:#1e3a5f}
    body:not([data-theme="light"]) .battle-hp-bar{background:#374151}
    body:not([data-theme="light"]) .battle-question{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .battle-question .bq-opt{background:#1f2937;border-color:#374151;color:#e5e7eb}
    body:not([data-theme="light"]) .battle-question .bq-opt:hover:not(.disabled){background:#1e3a5f;border-color:var(--blue)}
    body:not([data-theme="light"]) .battle-question .bq-opt.correct{background:#064e3b;border-color:var(--green)}
    body:not([data-theme="light"]) .battle-question .bq-opt.wrong{background:#7f1d1d;border-color:var(--red)}
    body:not([data-theme="light"]) .battle-item-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
    body:not([data-theme="light"]) .battle-log{background:#1f2937;color:#9ca3af}
    body:not([data-theme="light"]) .chapter-card{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .chapter-card:hover:not(.locked){border-color:var(--blue);background:#1e3a5f}
    body:not([data-theme="light"]) .chapter-card .ch-name{color:#93c5fd}
    body:not([data-theme="light"]) .battle-result-modal{background:#16213e;color:#e5e7eb}
}

/* Confetti Canvas */
#confettiCanvas{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999}

/* Gamification Settings */
.gamify-settings{margin-top:12px}
.gamify-settings label{display:flex;align-items:center;gap:8px;margin:8px 0;font-size:13px;color:var(--gray-700);cursor:pointer}
.gamify-settings input[type="checkbox"]{width:18px;height:18px;accent-color:var(--blue)}
.gamify-settings .volume-row{display:flex;align-items:center;gap:12px;margin:12px 0}
.gamify-settings .volume-row label{margin:0;flex-shrink:0}
.gamify-settings input[type="range"]{flex:1;height:6px;accent-color:var(--blue)}
.gamify-settings .gamify-reset{margin-top:12px}

/* Dark Mode Gamification */
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .xp-bar-container{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
    body:not([data-theme="light"]) .achievement-toast{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .achievement-toast .ach-name{color:#93c5fd}
    body:not([data-theme="light"]) .achievement-toast .ach-desc{color:#d1d5db}
    body:not([data-theme="light"]) .study-buddy{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .study-buddy .buddy-name{color:#93c5fd}
    body:not([data-theme="light"]) .study-buddy .buddy-mood{color:#9ca3af}
    body:not([data-theme="light"]) .levelup-modal{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
}
[data-theme="dark"] .xp-bar-container{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
[data-theme="dark"] .achievement-toast{background:#16213e;border-color:#374151}
[data-theme="dark"] .achievement-toast .ach-name{color:#93c5fd}
[data-theme="dark"] .achievement-toast .ach-desc{color:#d1d5db}
[data-theme="dark"] .study-buddy{background:#16213e;border-color:#374151}
[data-theme="dark"] .study-buddy .buddy-name{color:#93c5fd}
[data-theme="dark"] .study-buddy .buddy-mood{color:#9ca3af}
[data-theme="dark"] .levelup-modal{background:linear-gradient(135deg,#0d1b2a,#1b2838)}
[data-theme="dark"] .shop-item,[data-theme="dark"] .pet-modal-content{background:#16213e;border-color:#374151}
[data-theme="dark"] .shop-item-name,[data-theme="dark"] .pet-modal-name{color:#93c5fd}
[data-theme="dark"] .shop-tab{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .shop-tab.active{background:#2563eb;border-color:#2563eb}
[data-theme="dark"] .garden-scene{background:linear-gradient(to bottom,#0d1b3e 0%,#162350 28%,#1a3a1a 28%,#122e12 40%,#0a1f0a 100%)}
[data-theme="dark"] .garden-sky-stars{display:block}
[data-theme="dark"] .garden-sky-sun{display:none}
[data-theme="dark"] .garden-plot{background:linear-gradient(145deg,#4a3728,#3a2718);border-color:#2a1a0a}
[data-theme="dark"] .garden-plot.locked{background:linear-gradient(145deg,#2a2a2a,#1a1a1a);border-color:#111}
[data-theme="dark"] .garden-plot.empty{border-color:#5a4530}
[data-theme="dark"] .garden-header{border-color:#374151}
[data-theme="dark"] .garden-modal{background:#16213e}
[data-theme="dark"] .garden-modal h3,.garden-modal .plot-info-name{color:#93c5fd}
[data-theme="dark"] .seed-option{border-color:#374151}
[data-theme="dark"] .seed-option:hover{border-color:#4ade80;background:rgba(74,222,128,.1)}
[data-theme="dark"] .seed-option-name{color:#e2e8f0}
[data-theme="dark"] .seed-option-meta{color:#9ca3af}
[data-theme="dark"] .plot-info-stat{color:#d1d5db}
[data-theme="dark"] .plot-info-action{border-color:#374151;color:#e2e8f0}
[data-theme="dark"] .plot-info-action:hover:not(:disabled){border-color:#60a5fa;background:rgba(96,165,250,.1)}
[data-theme="dark"] .garden-water-btn{background:rgba(30,40,60,.85);border-color:rgba(96,165,250,.4);color:#e2e8f0}
[data-theme="dark"] .garden-water-meter{background:rgba(15,23,42,.92);border-color:rgba(96,165,250,.3)}
[data-theme="dark"] .garden-water-meter .water-meter-bar{background:rgba(59,130,246,.2)}
[data-theme="dark"] .garden-water-meter .water-meter-fill{background:linear-gradient(90deg,#3b82f6,#60a5fa)}
[data-theme="dark"] .garden-pet-mood-bubble{background:rgba(30,40,60,.92);color:#e2e8f0}
[data-theme="dark"] .garden-pet-mood-bubble::after{background:rgba(30,40,60,.92)}
[data-theme="dark"] .shop-header{border-color:#374151}
[data-theme="dark"] .pet-food-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .pet-accessory-btn{background:#1f2937;border-color:#374151}
[data-theme="dark"] .pet-meter-bar{background:#374151}
[data-theme="dark"] .pet-sick-banner{background:#451a03;border-color:#92400e;color:#fbbf24}
[data-theme="dark"] .study-buddy.sick{background:#1c1917;border-color:#92400e}
[data-theme="dark"] .pet-sel-btn{background:#1f2937;border-color:#374151}
[data-theme="dark"] .pet-sel-btn.active{background:#1e3a5f;border-color:#2563eb}
[data-theme="dark"] .pet-roster-item{background:#1f2937;border-color:#374151;color:#d1d5db}
[data-theme="dark"] .pet-roster-item.active{background:#1e3a5f;border-color:#2563eb}
@media (prefers-color-scheme: dark) {
    body:not([data-theme="light"]) .shop-item,body:not([data-theme="light"]) .pet-modal-content{background:#16213e;border-color:#374151}
    body:not([data-theme="light"]) .shop-item-name,body:not([data-theme="light"]) .pet-modal-name{color:#93c5fd}
    body:not([data-theme="light"]) .shop-tab{background:#1f2937;border-color:#374151;color:#d1d5db}
    body:not([data-theme="light"]) .shop-tab.active{background:#2563eb;border-color:#2563eb}
    body:not([data-theme="light"]) .garden-scene{background:linear-gradient(to bottom,#0d1b3e 0%,#162350 28%,#1a3a1a 28%,#122e12 40%,#0a1f0a 100%)}
    body:not([data-theme="light"]) .garden-sky-stars{display:block}
    body:not([data-theme="light"]) .garden-sky-sun{display:none}
    body:not([data-theme="light"]) .garden-plot{background:linear-gradient(145deg,#4a3728,#3a2718);border-color:#2a1a0a}
    body:not([data-theme="light"]) .garden-plot.locked{background:linear-gradient(145deg,#2a2a2a,#1a1a1a);border-color:#111}
    body:not([data-theme="light"]) .garden-plot.empty{border-color:#5a4530}
    body:not([data-theme="light"]) .garden-header,body:not([data-theme="light"]) .shop-header{border-color:#374151}
    body:not([data-theme="light"]) .garden-modal{background:#16213e}
    body:not([data-theme="light"]) .garden-water-btn{background:rgba(30,40,60,.85);border-color:rgba(96,165,250,.4);color:#e2e8f0}
    body:not([data-theme="light"]) .garden-pet-mood-bubble{background:rgba(30,40,60,.92);color:#e2e8f0}
    body:not([data-theme="light"]) .pet-food-btn{background:#1f2937;border-color:#374151;color:#d1d5db}
    body:not([data-theme="light"]) .pet-accessory-btn{background:#1f2937;border-color:#374151}
    body:not([data-theme="light"]) .pet-meter-bar{background:#374151}
    body:not([data-theme="light"]) .pet-sick-banner{background:#451a03;border-color:#92400e;color:#fbbf24}
    body:not([data-theme="light"]) .study-buddy.sick{background:#1c1917;border-color:#92400e}
}

/* === CENGAGE LIGHT THEME === */
[data-theme="cengage-light"] {
    --navy: #1a4480; --navy-dark: #0d2a5a; --blue: #0066cc; --blue-light: #1a8cff;
    --bg: #f0f2f5; --white: #ffffff; --gray-50: #f8f9fa; --gray-100: #e9ecef;
    --gray-200: #dee2e6; --gray-300: #ced4da; --gray-400: #adb5bd; --gray-500: #6c757d;
    --gray-600: #495057; --gray-700: #343a40; --gray-800: #212529; --gray-900: #111;
    --green: #198754; --green-light: #20c997; --red: #dc3545; --red-light: #f77;
    --orange: #fd7e14; --yellow: #ffc107;
}
[data-theme="cengage-light"] .main-header {
    background: linear-gradient(to bottom, #1a4480, #0d2a5a);
    border-bottom: 3px solid #ffc107;
}
[data-theme="cengage-light"] .option-item { border-radius: 2px; }
[data-theme="cengage-light"] .bank-card,
[data-theme="cengage-light"] .question-container,
[data-theme="cengage-light"] .modal { border-radius: 2px; border: 1px solid #dee2e6; }
[data-theme="cengage-light"] .btn-nav { border-radius: 2px; }

/* === CENGAGE DARK THEME === */
[data-theme="cengage-dark"] {
    --navy: #1a4480; --navy-dark: #0d1b33; --blue: #4d9fff; --blue-light: #6db3ff;
    --bg: #1e1e2e; --white: #2a2a3a; --gray-50: #2f2f42; --gray-100: #3a3a50;
    --gray-200: #4a4a60; --gray-300: #6a6a80; --gray-400: #8a8a9a; --gray-500: #a0a0b0;
    --gray-600: #c0c0d0; --gray-700: #d8d8e8; --gray-800: #e8e8f0; --gray-900: #f0f0f8;
    --green: #20c997; --green-light: #3ddca8; --red: #ff6b6b; --red-light: #ff8a8a;
    --orange: #ffa94d; --yellow: #ffd43b;
}
[data-theme="cengage-dark"] body, body[data-theme="cengage-dark"] { color: #e8e8f0; }
[data-theme="cengage-dark"] .main-header {
    background: linear-gradient(to bottom, #0d1b33, #060e1f);
    border-bottom: 3px solid #ffd43b;
}
[data-theme="cengage-dark"] .question-container,
[data-theme="cengage-dark"] .bank-card,
[data-theme="cengage-dark"] .modal,
[data-theme="cengage-dark"] .score-container { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .option-item { background: #2f2f42; border-color: #3a3a50; border-radius: 2px; }
[data-theme="cengage-dark"] .option-item:hover:not(.disabled):not(.correct-answer):not(.wrong-answer) { background: #35355a; border-color: #4d9fff; }
[data-theme="cengage-dark"] .option-item.selected { background: #1a3366; border-color: #4d9fff; }
[data-theme="cengage-dark"] .option-item.correct-answer { background: #0d3b2e; border-color: #20c997; }
[data-theme="cengage-dark"] .option-item.wrong-answer { background: #4a1a1a; border-color: #ff6b6b; }
[data-theme="cengage-dark"] .speed-option { background: #2f2f42; border-color: #3a3a50; color: #e5e7eb; border-radius: 2px; }
[data-theme="cengage-dark"] .speed-option:hover:not(:disabled) { background: #35355a; border-color: #4d9fff; }
[data-theme="cengage-dark"] .speed-option.correct { background: #0d3b2e; border-color: #20c997; color: #a7f3d0; }
[data-theme="cengage-dark"] .speed-option.wrong { background: #4a1a1a; border-color: #ff6b6b; color: #fecaca; }
[data-theme="cengage-dark"] .speed-option .option-letter { background: #3a3a50; color: #6db3ff; }
[data-theme="cengage-dark"] .btn-nav { border-radius: 2px; }
[data-theme="cengage-dark"] .explanation-panel { background: #0d3b2e; border-color: #20c997; color: #a7f3d0; }
[data-theme="cengage-dark"] .explanation-panel.incorrect { background: #4a1a1a; border-color: #ff6b6b; color: #fecaca; }
[data-theme="cengage-dark"] .xp-bar-container { background: linear-gradient(135deg, #0d1b33, #1a2844); }
[data-theme="cengage-dark"] .achievement-toast { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .study-buddy { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .levelup-modal { background: linear-gradient(135deg, #0d1b33, #1a2844); }
[data-theme="cengage-dark"] .ai-card { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .ai-card .option-item { background: #2f2f42; border-color: #3a3a50; }
[data-theme="cengage-dark"] .progress-section { background: #2a2a3a; border-color: #3a3a50; }
[data-theme="cengage-dark"] .progress-table th { background: #1a2844; color: #6db3ff; }

/* === SYNTHWAVE THEME (fun) === */
[data-theme="synthwave"] {
    --navy: #2b1055; --navy-dark: #1a0a33; --blue: #00d4ff; --blue-light: #00eaff;
    --bg: #0f0e17; --white: #1a1a2e; --gray-50: #1f1f35; --gray-100: #2a2a44;
    --gray-200: #3a3a55; --gray-300: #5a5a75; --gray-400: #8080a0; --gray-500: #a0a0c0;
    --gray-600: #c0c0e0; --gray-700: #d8d8f0; --gray-800: #e8e8ff; --gray-900: #f0f0ff;
    --green: #00ff88; --green-light: #33ffaa; --red: #ff2a6d; --red-light: #ff5588;
    --orange: #ff6e27; --yellow: #ffdd00;
    --radius: 8px;
}
[data-theme="synthwave"] body, body[data-theme="synthwave"] { color: #e8e8ff; }
[data-theme="synthwave"] .main-header {
    background: linear-gradient(135deg, #2b1055 0%, #d53369 50%, #2b1055 100%);
    border-bottom: 3px solid #00d4ff;
}
[data-theme="synthwave"] .main-header .logo-text { text-shadow: 0 0 10px #00d4ff; }
[data-theme="synthwave"] .home-hero h1 { background: linear-gradient(90deg, #00d4ff, #ff2a6d, #ffdd00); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
[data-theme="synthwave"] .question-container,
[data-theme="synthwave"] .bank-card,
[data-theme="synthwave"] .modal,
[data-theme="synthwave"] .score-container { background: #1a1a2e; border: 1px solid #3a3a55; box-shadow: 0 0 15px rgba(0,212,255,0.08); }
[data-theme="synthwave"] .option-item { background: #1f1f35; border-color: #3a3a55; }
[data-theme="synthwave"] .option-item:hover:not(.disabled):not(.correct-answer):not(.wrong-answer) { background: #2a2050; border-color: #00d4ff; box-shadow: 0 0 8px rgba(0,212,255,0.2); }
[data-theme="synthwave"] .option-item.selected { background: #2a1060; border-color: #d53369; box-shadow: 0 0 10px rgba(213,51,105,0.3); }
[data-theme="synthwave"] .option-item.correct-answer { background: #0a3020; border-color: #00ff88; box-shadow: 0 0 10px rgba(0,255,136,0.2); }
[data-theme="synthwave"] .option-item.wrong-answer { background: #3a0a20; border-color: #ff2a6d; box-shadow: 0 0 10px rgba(255,42,109,0.2); }
[data-theme="synthwave"] .speed-option { background: #1f1f35; border-color: #3a3a55; color: #e8e8ff; }
[data-theme="synthwave"] .speed-option:hover:not(:disabled) { background: #2a2050; border-color: #00d4ff; box-shadow: 0 0 8px rgba(0,212,255,0.2); }
[data-theme="synthwave"] .speed-option.correct { background: #0a3020; border-color: #00ff88; color: #aaffcc; box-shadow: 0 0 10px rgba(0,255,136,0.2); }
[data-theme="synthwave"] .speed-option.wrong { background: #3a0a20; border-color: #ff2a6d; color: #ffaacc; box-shadow: 0 0 10px rgba(255,42,109,0.2); }
[data-theme="synthwave"] .speed-option .option-letter { background: #3a3a55; color: #00d4ff; }
[data-theme="synthwave"] .btn-nav { border-radius: 8px; }
[data-theme="synthwave"] .btn-nav:hover { box-shadow: 0 0 8px rgba(0,212,255,0.3); }
[data-theme="synthwave"] .explanation-panel { background: #0a3020; border-color: #00ff88; color: #aaffcc; }
[data-theme="synthwave"] .explanation-panel.incorrect { background: #3a0a20; border-color: #ff2a6d; color: #ffaacc; }
[data-theme="synthwave"] .xp-bar-container { background: linear-gradient(135deg, #1a0a33, #2b1055); }
[data-theme="synthwave"] .xp-bar .xp-fill { background: linear-gradient(90deg, #d53369, #00d4ff); }
[data-theme="synthwave"] .achievement-toast { background: #1a1a2e; border-color: #d53369; box-shadow: 0 0 15px rgba(213,51,105,0.2); }
[data-theme="synthwave"] .study-buddy { background: #1a1a2e; border-color: #3a3a55; }
[data-theme="synthwave"] .levelup-modal { background: linear-gradient(135deg, #1a0a33, #2b1055); }
[data-theme="synthwave"] .combo-display.active { background: linear-gradient(135deg, #d53369, #2b1055); border-color: #00d4ff; }
[data-theme="synthwave"] .ai-card { background: #1a1a2e; border-color: #3a3a55; }
[data-theme="synthwave"] .ai-card .option-item { background: #1f1f35; border-color: #3a3a55; }
[data-theme="synthwave"] .progress-section { background: #1a1a2e; border-color: #3a3a55; }
[data-theme="synthwave"] .progress-table th { background: #2b1055; color: #00d4ff; }
[data-theme="synthwave"] .bank-card h2 { color: #00d4ff; }
[data-theme="synthwave"] .mode-btn:hover { box-shadow: 0 0 12px rgba(0,212,255,0.15); }
[data-theme="synthwave"] .stat-card { background: #1f1f35; border: 1px solid #3a3a55; }
[data-theme="synthwave"] .stat-card .stat-val { color: #00d4ff; }
[data-theme="synthwave"] .timer-display.warning { animation: flashSynth .5s infinite alternate; }
@keyframes flashSynth { from { background: #1a1a2e; } to { background: #3a0a20; color: #ff5588; } }

/* Mobile Gamification */
@media(max-width:768px){
    .xp-bar-container{flex-wrap:wrap;padding:10px 14px;gap:8px}
    .xp-bar{order:3;flex-basis:100%}
    .xp-info{order:2;min-width:auto}
    .combo-display{top:70px;right:10px;padding:8px 12px;font-size:14px}
    .combo-fire{font-size:20px}
    .achievement-toast{bottom:80px;right:10px;left:10px;max-width:none}
    .study-buddy{bottom:80px;left:10px}
    .levelup-modal{padding:30px;margin:20px}
    .levelup-modal .level-num{font-size:48px}
    /* Shop responsive */
    .shop-grid{grid-template-columns:repeat(auto-fill,minmax(130px,1fr));gap:8px}
    .shop-item{padding:12px}
    .shop-item-icon{font-size:28px}
    .shop-tabs{gap:4px}
    .shop-tab{padding:6px 10px;font-size:12px}
    /* Garden responsive */
    .garden-scene{min-height:360px}
    .garden-plots{gap:6px}
    .garden-plot{min-height:75px}
    .plot-plant{font-size:30px}
    .plot-empty-icon{font-size:22px}
    .garden-header{gap:6px;font-size:12px}
    .garden-pet-emoji{font-size:36px}
    .garden-pet{bottom:8px;left:8px}
    .garden-water-btn{bottom:8px;right:8px;padding:5px 8px;font-size:12px}
    .garden-water-meter{right:8px;bottom:72px;width:140px}
    .garden-ground{padding:6px 8px 10px}
    .garden-modal{padding:16px;max-width:320px}
    /* Pet modal responsive */
    .pet-modal-content{padding:16px;margin:20px auto}
    .pet-modal-emoji{font-size:48px}
    .pet-food-grid{grid-template-columns:1fr}
}

/* ========== SCENE BACKGROUNDS ========== */
#sceneCanvas{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:0;display:none}
#deskTrinkets{position:fixed;bottom:0;left:0;right:0;height:100px;pointer-events:none;z-index:1}
.desk-trinket{position:absolute;font-size:28px;transform:translateX(-50%);filter:drop-shadow(0 2px 4px rgba(0,0,0,.2));animation:trinketBob 3s ease-in-out infinite}
@keyframes trinketBob{0%,100%{transform:translateX(-50%) translateY(0)}50%{transform:translateX(-50%) translateY(-4px)}}

.scene-default{background:var(--bg)}
.scene-cozy-desk{background:linear-gradient(135deg,#2d1f1a 0%,#3d2a1f 50%,#4a3728 100%)}
.scene-cozy-desk::before{content:'';position:fixed;top:0;left:0;right:0;bottom:0;background:radial-gradient(ellipse at 30% 20%,rgba(255,200,100,.08) 0%,transparent 50%);pointer-events:none;z-index:0}
.scene-night-sky{background:linear-gradient(180deg,#0a0a1a 0%,#1a1a3a 50%,#0f0f2f 100%)}
.scene-night-sky.scene-animated::before{content:'';position:fixed;top:0;left:0;right:0;bottom:0;background-image:radial-gradient(2px 2px at 20% 30%,white,transparent),radial-gradient(2px 2px at 40% 70%,white,transparent),radial-gradient(1px 1px at 50% 20%,white,transparent),radial-gradient(2px 2px at 60% 50%,white,transparent),radial-gradient(1px 1px at 70% 80%,white,transparent),radial-gradient(2px 2px at 80% 10%,white,transparent),radial-gradient(1px 1px at 90% 40%,white,transparent);animation:twinkle 4s ease-in-out infinite alternate;pointer-events:none;z-index:0}
@keyframes twinkle{0%{opacity:.6}100%{opacity:1}}
.scene-rain-window{background:linear-gradient(180deg,#2a3a4a 0%,#1a2a3a 100%)}
.scene-forest-glade{background:linear-gradient(180deg,#1a3a2a 0%,#2a4a3a 50%,#1a3020 100%)}
.scene-forest-glade.scene-animated::before{content:'';position:fixed;top:0;left:0;right:0;bottom:0;background:radial-gradient(ellipse at 60% 30%,rgba(255,255,200,.15) 0%,transparent 40%);animation:sunbeam 6s ease-in-out infinite alternate;pointer-events:none;z-index:0}
@keyframes sunbeam{0%{opacity:.8;transform:scale(1)}100%{opacity:1;transform:scale(1.1)}}
.scene-synthwave{background:linear-gradient(180deg,#1a0a2e 0%,#2d1b4e 40%,#1a0a2e 100%)}
.scene-synthwave::before{content:'';position:fixed;bottom:0;left:0;right:0;height:50%;background:linear-gradient(90deg,transparent 49%,rgba(255,0,255,.1) 50%,transparent 51%),linear-gradient(0deg,transparent 49%,rgba(0,255,255,.1) 50%,transparent 51%);background-size:60px 60px;transform:perspective(500px) rotateX(60deg);transform-origin:bottom;pointer-events:none;z-index:0}
.scene-synthwave.scene-animated::before{animation:gridScroll 2s linear infinite}
@keyframes gridScroll{0%{background-position:0 0}100%{background-position:0 60px}}
.scene-lava-lamp{background:linear-gradient(180deg,#1a0a2e 0%,#0d0520 100%)}
@media(prefers-reduced-motion:reduce){.scene-animated::before,.scene-animated::after{animation:none!important}}

/* ========== BACKPACK & TRINKETS ========== */
.modal-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.6);display:none;align-items:center;justify-content:center;z-index:1000;backdrop-filter:blur(4px)}
.modal-overlay.active{display:flex}
.backpack-modal{background:var(--white);border-radius:16px;max-width:600px;width:90vw;max-height:80vh;overflow-y:auto;padding:24px;position:relative}
.backpack-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:20px}
.backpack-header h2{margin:0;font-size:1.5rem}
.backpack-close{background:none;border:none;font-size:24px;cursor:pointer;color:var(--gray-500);padding:4px 8px;border-radius:4px}
.backpack-close:hover{background:var(--gray-100);color:var(--gray-800)}
.backpack-desk{background:var(--gray-100);border-radius:12px;padding:16px;margin-bottom:20px}
.backpack-desk h3{margin:0 0 12px;font-size:1rem;color:var(--gray-600)}
.desk-slots{position:relative;height:120px;background:linear-gradient(180deg,var(--gray-100) 0%,var(--gray-200) 100%);border-radius:8px;border:2px dashed var(--gray-300)}
.desk-slot{position:absolute;width:48px;height:48px;transform:translate(-50%,-50%);background:var(--white);border:2px dashed var(--gray-300);border-radius:8px;display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all .2s ease}
.desk-slot:hover{border-color:var(--blue);transform:translate(-50%,-50%) scale(1.1)}
.desk-slot .trinket-icon{font-size:24px}
.desk-slot .slot-empty{font-size:20px;color:var(--gray-400)}
.backpack-inventory h3{margin:0 0 12px;font-size:1rem;color:var(--gray-600)}
.trinket-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:12px}
.trinket-card{background:var(--gray-50);border:2px solid var(--gray-200);border-radius:12px;padding:12px;text-align:center;cursor:pointer;transition:all .2s ease;position:relative}
.trinket-card:hover{transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,0,0,.15)}
.trinket-card.equipped{background:rgba(41,128,185,.1)}
.trinket-card.locked{opacity:.5;cursor:not-allowed}
.trinket-card .trinket-icon{font-size:32px;display:block;margin-bottom:8px}
.trinket-card .trinket-name{font-size:12px;font-weight:600;display:block;margin-bottom:4px}
.trinket-card .trinket-rarity{font-size:10px;text-transform:uppercase;letter-spacing:.5px}
.trinket-card .new-badge{position:absolute;top:-6px;right:-6px;background:var(--red);color:#fff;font-size:9px;font-weight:700;padding:2px 6px;border-radius:10px}
.empty-inventory{color:var(--gray-500);text-align:center;padding:24px;font-style:italic}
.trinket-toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%) translateY(100px);background:var(--white);border-radius:12px;padding:16px 24px;display:flex;align-items:center;gap:12px;box-shadow:0 8px 32px rgba(0,0,0,.3);z-index:1001;opacity:0;transition:all .4s cubic-bezier(.34,1.56,.64,1)}
.trinket-toast.show{transform:translateX(-50%) translateY(0);opacity:1}
.trinket-toast .toast-icon{font-size:36px}
.trinket-toast .toast-content{text-align:left}
.trinket-toast .toast-title{font-weight:700;font-size:14px}
.trinket-toast .toast-subtitle{font-size:12px;color:var(--gray-500)}
</style>
</head>
<body>

<!-- HEADER -->
<div class="main-header">
    <div class="header-top">
        <button class="logo-link" onclick="SessionState.clear();showScreen('home');Home.render()" aria-label="Go to home">
        <div class="logo-area">
            <svg class="logo-mark" viewBox="0 0 56 56" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Xooper logo">
                <defs>
                    <linearGradient id="shieldGrad" x1="0" y1="0" x2="0" y2="1">
                        <stop offset="0%" stop-color="#c084fc"/>
                        <stop offset="100%" stop-color="#7c3aed"/>
                    </linearGradient>
                    <linearGradient id="xGrad" x1="0" y1="0" x2="1" y2="1">
                        <stop offset="0%" stop-color="#fde047"/>
                        <stop offset="100%" stop-color="#f97316"/>
                    </linearGradient>
                </defs>
                <path d="M28 4L50 16V34C50 44 40 52 28 56C16 52 6 44 6 34V16L28 4Z" fill="url(#shieldGrad)" stroke="#e9d5ff" stroke-width="2"/>
                <path d="M18 18L38 38M38 18L18 38" stroke="url(#xGrad)" stroke-width="6" stroke-linecap="round"/>
            </svg>
            <div class="logo-text">Xooper's Battleground</div>
        </div>
        </button>
        <div class="header-actions">
            <span id="headerGems" class="coin-display" style="background:linear-gradient(135deg,#a855f7,#7c3aed);color:#fff;padding:4px 10px;border-radius:12px;font-size:13px;font-weight:bold;cursor:pointer" onclick="Shop.show()" title="Premium Currency"> 0</span>
            <span id="headerCoins" class="coin-display" style="background:linear-gradient(135deg,#f59e0b,#d97706);color:#fff;padding:4px 10px;border-radius:12px;font-size:13px;font-weight:bold;cursor:pointer" onclick="Shop.show()" title="Open Shop"> 0</span>
            <button onclick="if(document.getElementById('screen-exam').classList.contains('active') && !App.submitted){App.exitToHome()}else{SessionState.clear();showScreen('home');Home.render()}">Home</button>
            <button onclick="if(App.timerInterval && !App.timerPaused){App.toggleTimer()}showScreen('settings')">Settings</button>
            <button onclick="document.getElementById('helpModal').classList.add('active')" title="Keyboard shortcuts (?)" aria-label="Help" style="font-size:14px;padding:5px 10px">?</button>
        </div>
    </div>
</div>

<!-- SUBHEADER (test/practice modes) -->
<div class="subheader" id="subheader" style="display:none">
    <div style="display:flex;align-items:center;gap:20px;flex-wrap:wrap">
        <div class="test-name" id="testNameBar">Test</div>
        <div class="section-tab" id="modeTab">Test Mode</div>
    </div>
    <div class="timer-area">
        <span class="timer-toggle" id="timerToggle" onclick="App.toggleTimer()">Pause Timer</span>
        <span class="timer-display" id="timerDisplay" aria-live="polite">01:30:00</span>
    </div>
</div>

<!-- Canvas for animated backgrounds -->
<canvas id="sceneCanvas"></canvas>
<!-- Desk trinkets container -->
<div id="deskTrinkets"></div>

<!-- ========== HOME SCREEN ========== -->
<div class="screen active" id="screen-home">
    <div class="home-hero">
        <svg width="80" height="88" viewBox="0 0 80 88" fill="none" style="display:block;margin:0 auto 8px"><defs><linearGradient id="herosg" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#8b5cf6"/><stop offset="100%" stop-color="#ec4899"/></linearGradient><linearGradient id="herosw" x1="0" y1="0" x2="0" y2="1"><stop offset="0%" stop-color="#fbbf24"/><stop offset="100%" stop-color="#f59e0b"/></linearGradient><filter id="heroglow"><feGaussianBlur stdDeviation="2" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs><line x1="12" y1="6" x2="68" y2="82" stroke="url(#herosw)" stroke-width="3" stroke-linecap="round"/><line x1="68" y1="6" x2="12" y2="82" stroke="url(#herosw)" stroke-width="3" stroke-linecap="round"/><rect x="4" y="2" width="16" height="3" rx="1.5" fill="#fbbf24" transform="rotate(40 12 6)"/><rect x="60" y="2" width="16" height="3" rx="1.5" fill="#fbbf24" transform="rotate(-40 68 6)"/><circle cx="12" cy="6" r="3" fill="#fbbf24" opacity=".6"/><circle cx="68" cy="6" r="3" fill="#fbbf24" opacity=".6"/><path d="M40 12L64 22V44C64 58 53 68 40 76 27 68 16 58 16 44V22Z" fill="url(#herosg)" filter="url(#heroglow)"/><path d="M30 31L50 55M50 31L30 55" stroke="#fff" stroke-width="6" stroke-linecap="round"/></svg>
        <h1>Xooper's Battleground</h1>
        <p>Choose a question bank and study mode</p>
    </div>

    <div class="home-layout">
        <div class="home-main">
            <div class="bank-list-header">
                <div>
                    <div class="bank-list-subtle">Pick a path</div>
                    <h2>Question Banks</h2>
                </div>
                <p>Start with a full test, practice set, drill, review, or AI run.</p>
            </div>
            <div id="bankList"></div>
        </div>
        <div class="home-side">
            <div class="meta-panel" id="homeMetaPanel">
                <summary>
                    <div class="summary-meta">
                        <span id="metaSummaryTitle">Daily Momentum</span>
                        <small id="metaSummaryBody" style="color:var(--gray-500);font-weight:400">Loading</small>
                        <div class="meta-glance" id="metaBuffGlance" aria-label="Active buffs" role="list"></div>
                    </div>
                    <span class="summary-caret"></span>
                </summary>
                <div id="streakBanner"></div>
                <div id="dailyGoalCard"></div>
                <div id="dailyChallengesCard"></div>
                <div id="analyticsCard"></div>
                <div id="xpBarContainer"></div>
            </div>

            <div class="quick-actions">
                <button class="btn-nav" style="background:var(--blue);border-color:var(--blue)" onclick="Progress.show()">View Progress</button>
                <button class="btn-nav" style="background:var(--green);border-color:var(--green)" id="btnGarden" onclick="Garden.show()">&#127793; Garden</button>
                <button class="btn-nav" style="background:var(--orange);border-color:var(--orange)" id="btnShop" onclick="Shop.show()">&#128176; Shop</button>
                <button class="btn-nav" style="background:#0ea5e9;border-color:#0ea5e9" id="btnHouse" onclick="House.show()">&#127968; My House</button>
                <button class="btn-nav" style="background:#059669;border-color:#059669" id="btnBusiness" onclick="Business.show()">&#128188; Business</button>
                <button class="btn-nav" style="background:var(--red);border-color:var(--red)" id="btnBattle" onclick="Battle.show()">&#9876;&#65039; Battle</button>
                <button class="btn-nav" style="background:#a855f7;border-color:#a855f7" id="btnBackpack" onclick="Backpack.openModal()">&#127890; Backpack</button>
                <button class="btn-nav" style="background:#6366f1;border-color:#6366f1" id="btnScenes" onclick="SceneManager.openModal()">&#127912; Backgrounds</button>
                <button class="btn-nav" style="background:#14b8a6;border-color:#14b8a6" id="btnLearn" onclick="LearnMode.show()">&#128218; Learn</button>
            </div>

            <details class="stats-panel" id="homeStatsPanel">
                <summary>
                    <span>Performance Snapshot</span>
                    <span class="summary-caret"></span>
                </summary>
                <div class="stats-row" id="homeStats"></div>
            </details>
            
            <!-- AI Tutor Card -->
            <div class="ai-tutor-card" id="aiTutorCard" style="background:linear-gradient(135deg,#6366f1,#8b5cf6);border-radius:12px;padding:16px;margin-top:16px;color:#fff;cursor:pointer" onclick="AITutor.openModal()">
                <div style="display:flex;align-items:center;gap:12px;margin-bottom:12px">
                    <span style="font-size:32px"></span>
                    <div>
                        <div style="font-weight:bold;font-size:16px">AI Study Coach</div>
                        <div style="font-size:12px;opacity:0.8">Tap for personalized advice</div>
                    </div>
                </div>
                <div id="aiTutorQuickTip" style="font-size:13px;background:rgba(0,0,0,0.2);padding:10px;border-radius:8px">
                    Loading recommendations...
                </div>
            </div>
        </div>
    </div>
</div>

<!-- ========== AI TUTOR MODAL ========== -->
<div class="modal-overlay" id="aiTutorModal" onclick="if(event.target===this)AITutor.closeModal()">
    <div class="modal-content" style="max-width:700px;max-height:90vh;overflow:hidden;display:flex;flex-direction:column">
        <div style="display:flex;justify-content:space-between;align-items:center;padding-bottom:12px;border-bottom:1px solid var(--gray-200)">
            <h2 style="margin:0;display:flex;align-items:center;gap:10px"><span style="font-size:28px"></span> AI Study Coach</h2>
            <div style="display:flex;gap:8px;align-items:center">
                <button onclick="AITutor.switchTab('chat')" id="aiTabChat" class="ai-tab active" style="padding:6px 12px;border-radius:6px;border:1px solid var(--gray-300);background:var(--blue);color:#fff;cursor:pointer;font-size:13px"> Chat</button>
                <button onclick="AITutor.switchTab('stats')" id="aiTabStats" class="ai-tab" style="padding:6px 12px;border-radius:6px;border:1px solid var(--gray-300);background:#fff;color:var(--gray-700);cursor:pointer;font-size:13px"> Stats</button>
                <button onclick="AITutor.closeModal()" style="background:none;border:none;font-size:24px;cursor:pointer;color:var(--gray-500);margin-left:8px"></button>
            </div>
        </div>
        
        <!-- Chat Tab -->
        <div id="aiTutorChatTab" style="flex:1;display:flex;flex-direction:column;overflow:hidden">
            <div id="aiTutorChatMessages" style="flex:1;overflow-y:auto;padding:16px;display:flex;flex-direction:column;gap:12px;min-height:300px;max-height:50vh"></div>
            <div style="padding:12px;border-top:1px solid var(--gray-200);background:var(--gray-50)">
                <div style="display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap" id="aiQuickQuestions">
                    <button onclick="AITutor.askQuestion('What should I study next?')" class="ai-quick-btn" style="padding:6px 10px;border-radius:16px;border:1px solid var(--blue);background:#fff;color:var(--blue);font-size:12px;cursor:pointer">What should I study next?</button>
                    <button onclick="AITutor.askQuestion('How am I doing overall?')" class="ai-quick-btn" style="padding:6px 10px;border-radius:16px;border:1px solid var(--blue);background:#fff;color:var(--blue);font-size:12px;cursor:pointer">How am I doing?</button>
                    <button onclick="AITutor.askQuestion('What are my weak areas?')" class="ai-quick-btn" style="padding:6px 10px;border-radius:16px;border:1px solid var(--blue);background:#fff;color:var(--blue);font-size:12px;cursor:pointer">My weak areas?</button>
                    <button onclick="AITutor.askQuestion('Am I ready for the exam?')" class="ai-quick-btn" style="padding:6px 10px;border-radius:16px;border:1px solid var(--blue);background:#fff;color:var(--blue);font-size:12px;cursor:pointer">Am I exam ready?</button>
                </div>
                <div style="display:flex;gap:8px">
                    <input type="text" id="aiTutorInput" placeholder="Ask your study coach anything..." style="flex:1;padding:12px;border:1px solid var(--gray-300);border-radius:8px;font-size:14px" onkeydown="if(event.key==='Enter')AITutor.sendMessage()">
                    <button onclick="AITutor.sendMessage()" style="background:var(--blue);color:#fff;border:none;padding:12px 20px;border-radius:8px;cursor:pointer;font-weight:bold">Send</button>
                </div>
            </div>
        </div>
        
        <!-- Stats Tab (hidden by default) -->
        <div id="aiTutorStatsTab" style="flex:1;overflow-y:auto;padding:16px;display:none">
            <div id="aiTutorContent"></div>
        </div>
    </div>
</div>

<!-- ========== SHOP SCREEN ========== -->
<div class="screen" id="screen-shop">
    <div class="shop-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:auto">Home</button>
        <h2 style="flex:1;text-align:center;margin:0">Shop</h2>
        <span class="coin-display shop-coins" id="shopCoins">&#x1FA99; 0</span>
    </div>
    <div class="shop-tabs" id="shopTabs"></div>
    <div class="shop-items" id="shopItems"></div>
</div>

<!-- ========== MY HOUSE SCREEN ========== -->
<div class="screen" id="screen-house">
    <div class="shop-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:auto">Home</button>
        <h2 style="flex:1;text-align:center;margin:0"> My House</h2>
        <span class="coin-display" id="houseCoins">&#x1FA99; 0</span>
    </div>
    <div id="houseContent"></div>
</div>

<!-- ========== BUSINESS SCREEN ========== -->
<div class="screen" id="screen-business">
    <div class="shop-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:auto">Home</button>
        <h2 style="flex:1;text-align:center;margin:0"> My Businesses</h2>
        <span class="coin-display" id="businessCoins">&#x1FA99; 0</span>
    </div>
    <div id="businessContent" style="padding:16px"></div>
</div>

<!-- ========== LEARN MODE SCREEN ========== -->
<div class="screen" id="screen-learn">
    <div class="shop-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:auto">Home</button>
        <h2 style="flex:1;text-align:center;margin:0"> Learning Mode</h2>
        <span class="coin-display" id="learnCoins">&#x1FA99; 0</span>
    </div>
    <div id="learnContent" style="padding:16px"></div>
</div>

<!-- ========== GARDEN SCREEN ========== -->
<div class="screen" id="screen-garden">
    <div class="garden-header">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-right:8px">Home</button>
        <span class="coin-display" id="gardenCoins" style="margin-left:auto">&#x1FA99; 0</span>
        <button class="btn-nav" style="background:var(--orange);border-color:var(--orange);margin-left:8px" onclick="Shop.show()">Shop</button>
    </div>
    <div class="garden-scene" id="gardenScene">
        <div class="garden-sky">
            <span class="garden-sky-sun" id="gardenSun">&#9728;&#65039;</span>
            <span class="garden-sky-stars">&#10024; &#11088; &#10024;</span>
            <span class="garden-weather" id="gardenWeather"></span>
        </div>
        <div class="garden-stats-bar" id="gardenStatsBar">
            <span class="garden-stat" id="gardenSeason" title="Current Season"> Spring</span>
            <span class="garden-stat" id="gardenWeatherStat" title="Weather Effect"> Sunny</span>
            <span class="garden-stat" id="gardenBonus" title="Growth Bonus">+0%</span>
        </div>
        <div class="garden-fence">&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;&#9596;</div>
        <div class="garden-ground">
            <div class="garden-plots" id="gardenGrid"></div>
            <div class="garden-decos-row" id="gardenDecos"></div>
        </div>
        <div class="garden-pet" id="gardenPet" onclick="PetModal.show()"></div>
        <div class="garden-water-meter" id="gardenWaterMeter">
            <div class="water-meter-label">Water Level</div>
            <div class="water-meter-bar"><div class="water-meter-fill" style="width:100%"></div></div>
            <div class="water-meter-text">100% - Hydrated</div>
        </div>
        <div class="garden-water-btn" id="gardenWaterBtn" onclick="Garden.useWater()" title="Use Watering Can">
            <span>&#x1FAA3;</span>
            <span class="water-count" id="gardenWaterCount">0</span>
        </div>
    </div>
    <div class="garden-info-panel" id="gardenInfoPanel">
        <div class="garden-info-row">
            <span class="garden-info-label"> Total Harvests:</span>
            <span class="garden-info-value" id="gardenTotalHarvests">0</span>
        </div>
        <div class="garden-info-row">
            <span class="garden-info-label"> Coin Bonus:</span>
            <span class="garden-info-value" id="gardenCoinBonusDisplay">+0%</span>
        </div>
        <div class="garden-info-row">
            <span class="garden-info-label"> Companion Bonus:</span>
            <span class="garden-info-value" id="gardenCompanionBonus">+0%</span>
        </div>
    </div>
</div>

<!-- ========== BATTLE SCREEN ========== -->
<div class="screen" id="screen-battle">
    <div class="battle-header">
        <button class="btn-nav btn-home" onclick="Battle.goHome()">Home</button>
        <h2 id="battleTitle">Battle</h2>
        <span class="battle-stars" id="battleStars"></span>
    </div>
    <div id="battleContent"></div>
</div>

<!-- ========== TEST / PRACTICE SCREEN ========== -->
<div class="screen" id="screen-exam">
    <div class="question-container" id="questionContainer">
        <div class="question-header">
            <span class="question-number" id="questionNumber">Question 1 of 70</span>
            <div class="question-actions">
                <button class="btn-bookmark" id="btnBookmark" onclick="App.toggleBookmark()" aria-label="Bookmark this question">Bookmark</button>
                <button class="btn-note" id="btnNote" onclick="Notes.toggle()" aria-label="Add note to this question">Notes</button>
                <button class="btn-clear" onclick="App.clearAnswer()">Clear</button>
            </div>
        </div>
        <div class="powerup-bar" id="powerupBar" style="display:none"></div>
        <div class="question-text" id="questionText"></div>
        <ul class="options-list" id="optionsList"></ul>
        <button class="btn-check" id="btnCheck" style="display:none" onclick="App.checkAnswer()">Check Answer</button>
        <div class="confidence-panel" id="confidencePanel" style="display:none">
            <span class="confidence-label">How confident?</span>
            <button class="confidence-btn conf-maybe" onclick="App.setConfidence(1)">Maybe</button>
            <button class="confidence-btn conf-probably" onclick="App.setConfidence(2)">Probably</button>
            <button class="confidence-btn conf-definitely" onclick="App.setConfidence(3)">Definitely</button>
        </div>
        <div class="explanation-panel" id="explanationPanel"></div>
        <div class="note-panel" id="notePanel">
            <textarea class="note-textarea" id="noteTextarea" placeholder="Add your notes here..." oninput="Notes.onInput()" onblur="Notes.save()"></textarea>
            <div class="note-saved" id="noteSaved">Note saved</div>
        </div>
    </div>
</div>

<!-- ========== SCORE SCREEN ========== -->
<div class="screen" id="screen-score">
    <div class="score-screen">
        <div class="score-big" id="scoreBig" aria-live="polite">0%</div>
        <div class="score-label" id="scoreLabel">Score</div>
        <div class="score-details">
            <table>
                <tr><td class="label-col">Correct</td><td class="value-col" id="scoreCorrect">0</td></tr>
                <tr><td class="label-col">Incorrect</td><td class="value-col" id="scoreIncorrect">0</td></tr>
                <tr><td class="label-col">Unanswered</td><td class="value-col" id="scoreUnanswered">0</td></tr>
                <tr><td class="label-col">Total</td><td class="value-col" id="scoreTotal">70</td></tr>
                <tr><td class="label-col">Time</td><td class="value-col" id="scoreTime">00:00:00</td></tr>
            </table>
        </div>
        <div class="category-breakdown" id="categoryBreakdown"></div>
        <div class="score-actions">
            <button style="background:var(--red-light)" onclick="App.reviewWrongOnly()">Review Wrong Only</button>
            <button style="background:var(--blue)" onclick="App.startReview()">Review All</button>
            <button style="background:var(--orange)" onclick="App.drillWrongOnly()">Drill Missed Questions</button>
            <button style="background:var(--red)" onclick="App.retakeTest()">Retake</button>
            <button style="background:var(--gray-700)" onclick="showScreen('home');Home.render()">Home</button>
            <button style="background:var(--gray-600)" onclick="window.print()">Print Results</button>
        </div>
    </div>
</div>

<!-- ========== DRILL SCREEN ========== -->
<div class="screen" id="screen-drill">
    <div class="drill-container">
        <div class="drill-progress" id="drillProgress"></div>
        <div class="drill-card" id="drillCard"></div>
    </div>
</div>

<!-- ========== SPEED MODE SCREEN ========== -->
<div class="screen" id="screen-speed">
    <div class="speed-container" style="max-width:700px;margin:0 auto;padding:20px">
        <div class="speed-header" style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px">
            <div>
                <span id="speedScore" style="font-size:24px;font-weight:bold;color:var(--navy)">0</span>
                <span style="font-size:14px;color:var(--gray-600)">pts</span>
                <span id="speedCoins" style="margin-left:12px;font-size:18px;color:var(--orange)"> 0</span>
            </div>
            <div id="speedTimer" style="font-size:32px;font-weight:bold;color:var(--red);font-family:monospace">30</div>
            <div>
                <span id="speedStreak" style="font-size:18px"> 0</span>
                <span id="speedMultiplier" style="margin-left:8px;font-size:14px;background:var(--green);color:#fff;padding:2px 8px;border-radius:12px">1x</span>
            </div>
        </div>
        <div class="speed-progress-bar" style="height:6px;background:var(--gray-200);border-radius:3px;margin-bottom:20px;overflow:hidden">
            <div id="speedTimerBar" style="height:100%;background:linear-gradient(90deg,var(--green),var(--orange),var(--red));width:100%;transition:width 0.1s linear"></div>
        </div>
        <div id="speedCard" class="drill-card"></div>
        <div style="text-align:center;margin-top:16px">
            <button class="btn-nav" onclick="SpeedMode.end()" style="background:var(--gray-400)">End Session</button>
        </div>
    </div>
</div>

<!-- ========== AI PRACTICE SCREEN ========== -->
<div class="screen" id="screen-ai-practice">
    <div class="ai-practice-container">
        <div class="ai-progress" id="aiProgress"></div>
        <div class="ai-card" id="aiCard"></div>
    </div>
</div>

<!-- ========== REVIEW SCREEN ========== -->
<div class="screen" id="screen-review">
    <h2 style="color:var(--navy);margin-bottom:16px">Review All Questions</h2>
    <div class="review-controls">
        <select id="reviewCatFilter" onchange="Review.render()"><option value="">All Categories</option></select>
        <select id="reviewDiffFilter" onchange="Review.render()"><option value="">All Difficulty</option><option value="1">Easy</option><option value="2">Medium</option><option value="3">Hard</option></select>
        <input type="text" id="reviewSearch" placeholder="Search questions..." oninput="Review.render()">
        <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Home</button>
    </div>
    <div id="reviewContent"></div>
</div>

<!-- ========== PROGRESS SCREEN ========== -->
<div class="screen" id="screen-progress">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:16px;flex-wrap:wrap;gap:8px">
        <h2 style="color:var(--navy);margin:0"> Metrics Dashboard</h2>
        <div id="overallTrend" style="font-size:14px;font-weight:600"></div>
    </div>
    <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()" style="margin-bottom:16px">Back to Home</button>
    <div id="progressContent"></div>
</div>

<!-- ========== SETTINGS SCREEN ========== -->
<div class="screen" id="screen-settings">
    <div class="settings-panel">
        <h2>Settings</h2>
        <div class="setting-group">
            <h3>Appearance</h3>
            <div class="setting-row">
                <label>Theme</label>
                <select id="settingTheme" onchange="Theme.apply(this.value)">
                    <option value="system">System (Auto)</option>
                    <option value="light">Light</option>
                    <option value="dark">Dark</option>
                    <option value="cengage-light">Cengage Light</option>
                    <option value="cengage-dark">Cengage Dark</option>
                    <option value="synthwave">Synthwave</option>
                </select>
                <div class="hint">Choose your preferred color scheme. "System" follows your device settings.</div>
            </div>
        </div>
        <div class="setting-group">
            <h3>Daily Goal</h3>
            <div class="setting-row">
                <label>Questions per day</label>
                <select id="settingDailyGoal" onchange="DailyGoal.setGoal(parseInt(this.value))">
                    <option value="5">5 questions</option>
                    <option value="10" selected>10 questions</option>
                    <option value="15">15 questions</option>
                    <option value="20">20 questions</option>
                    <option value="30">30 questions</option>
                </select>
                <div class="hint">Set a daily study goal. Build a streak by reaching your goal each day!</div>
            </div>
        </div>
        <div class="setting-group">
            <h3>AI Chat - Anthropic (Claude)</h3>
            <div class="setting-row">
                <label>Anthropic API Key</label>
                <input type="password" id="settingAnthropicKey" placeholder="sk-ant-api03-...">
                <div class="hint">Get yours at console.anthropic.com. Stored locally only.</div>
            </div>
            <div class="setting-row">
                <label>Claude Model</label>
                <select id="settingAnthropicModel">
                    <option value="claude-sonnet-4-5-20250929">Claude Sonnet 4.5 (Fast)</option>
                    <option value="claude-haiku-4-5-20251001">Claude Haiku 4.5 (Fastest)</option>
                    <option value="claude-opus-4-5-20251101">Claude Opus 4.5 (Best)</option>
                </select>
            </div>
        </div>
        <div class="setting-group">
            <h3>AI Chat - OpenAI (GPT)</h3>
            <div class="setting-row">
                <label>OpenAI API Key</label>
                <input type="password" id="settingOpenaiKey" placeholder="sk-proj-...">
                <div class="hint">Get yours at platform.openai.com. Stored locally only.</div>
            </div>
            <div class="setting-row">
                <label>OpenAI Model</label>
                <select id="settingOpenaiModel">
                    <option value="gpt-4o-mini">GPT-4o Mini (Fast)</option>
                    <option value="gpt-4o">GPT-4o (Best)</option>
                    <option value="gpt-4.1-mini">GPT-4.1 Mini</option>
                    <option value="gpt-4.1">GPT-4.1</option>
                </select>
            </div>
        </div>
        <div class="setting-group">
            <h3>Active Provider</h3>
            <div class="setting-row">
                <select id="settingProvider">
                    <option value="anthropic">Anthropic (Claude)</option>
                    <option value="openai">OpenAI (GPT)</option>
                </select>
                <div class="hint">Switch between providers anytime. Both keys are saved independently.</div>
            </div>
            <button class="btn-save-settings" onclick="Settings.save()">Save Settings</button>
        </div>
        <div class="setting-group">
            <h3>Keyboard Shortcuts</h3>
            <div class="setting-row">
                <table style="width:100%;border-collapse:collapse;font-size:13px">
                    <thead>
                        <tr style="background:var(--navy);color:#fff">
                            <th style="padding:8px 12px;text-align:left">Key</th>
                            <th style="padding:8px 12px;text-align:left">Action</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">?</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Show keyboard shortcuts help</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&larr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">P</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Previous question</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&rarr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">N</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Next question</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">1</kbd> - <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">4</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Select answer option</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">B</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Bookmark question</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">T</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle notes panel</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">C</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle calculator</td></tr>
                        <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Enter</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Check answer (Practice mode)</td></tr>
                        <tr><td style="padding:6px 12px"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Esc</kbd></td><td style="padding:6px 12px">Close modals/calculator</td></tr>
                    </tbody>
                </table>
                <div class="hint" style="margin-top:8px">Press <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">?</kbd> anytime to see a quick reference overlay.</div>
            </div>
        </div>
        <div class="setting-group">
            <h3> Gamification</h3>
            <div class="gamify-settings">
                <label><input type="checkbox" id="gamifyEnabled" checked onchange="Gamification.updateSettings()"> Enable Gamification</label>
                <label><input type="checkbox" id="gamifySounds" checked onchange="Gamification.updateSettings()"> Sound Effects</label>
                <label><input type="checkbox" id="gamifyConfetti" checked onchange="Gamification.updateSettings()"> Visual Effects (Confetti)</label>
                <label><input type="checkbox" id="gamifyXpPopups" checked onchange="Gamification.updateSettings()"> XP Popups</label>
                <label><input type="checkbox" id="gamifyPet" checked onchange="Gamification.updateSettings()"> Study Buddy</label>
                <label><input type="checkbox" id="gamifyGarden" checked onchange="Gamification.updateSettings()"> Garden System</label>
                <label><input type="checkbox" id="gamifyPetBuffs" checked onchange="Gamification.updateSettings()"> Pet/Garden Buffs</label>
                <label><input type="checkbox" id="gamifyCoinPopups" checked onchange="Gamification.updateSettings()"> Coin Popups</label>
                <label><input type="checkbox" id="gamifyPixelArt" onchange="Gamification.updateSettings()"> Pixel Art Mode</label>
                <div class="volume-row">
                    <label>Volume:</label>
                    <input type="range" id="gamifyVolume" min="0" max="100" value="50" onchange="Gamification.updateSettings()">
                    <span id="gamifyVolumeLabel">50%</span>
                </div>
                <div class="gamify-reset">
                    <button class="btn-nav" style="background:var(--red);border-color:var(--red)" onclick="Gamification.resetProgress()">Reset Gamification Data</button>
                    <div class="hint">Clears XP, level, achievements, and power-ups.</div>
                </div>
            </div>
        </div>
        <div class="setting-group">
            <h3>Data</h3>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--blue);border-color:var(--blue)" onclick="Notes.exportAll()">Export Notes</button>
                <div class="hint">Download all your notes as a JSON file.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--green);border-color:var(--green)" onclick="Settings.exportAll()">Export All Data</button>
                <div class="hint">Download all progress, history, stats, notes, and settings as a backup file.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--blue);border-color:var(--blue)" onclick="document.getElementById('importFile').click()">Import Data Backup</button>
                <input type="file" id="importFile" accept=".json" style="display:none" onchange="Settings.importAll(this)">
                <div class="hint">Restore from a previously exported backup file. Merges with existing data.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--orange);border-color:var(--orange)" onclick="Settings.clearProgress()">Clear All Progress</button>
                <div class="hint">Removes all test history, drill progress, and stats.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--gray-600);border-color:var(--gray-600)" onclick="Settings.clearTimeData()">Clear Study Time</button>
                <div class="hint">Clears daily study time totals only.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:#7c3aed;border-color:#7c3aed" onclick="Settings.resetTimeStats()">Reset All Time Stats</button>
                <div class="hint">Clears ALL time data: study time, session history, and per-question time tracking. Keeps your correct/incorrect counts. Use this if time stats seem inflated.</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav" style="background:var(--red);border-color:var(--red)" onclick="Settings.resetAllMetrics()">Reset All Metrics</button>
                <div class="hint">Resets XP, level, coins, streaks, achievements, pet, garden, and all gamification data to defaults. Cannot be undone!</div>
            </div>
            <div class="setting-row">
                <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Back to Home</button>
            </div>
        </div>
    </div>
</div>

<!-- KEYBOARD SHORTCUTS HELP MODAL -->
<div class="modal-overlay" id="helpModal" onclick="if(event.target===this)document.getElementById('helpModal').classList.remove('active')">
    <div class="modal" style="max-width:400px" role="dialog" aria-modal="true" aria-labelledby="helpModalTitle">
        <h2 id="helpModalTitle">Keyboard Shortcuts</h2>
        <table style="width:100%;border-collapse:collapse;font-size:13px">
            <thead>
                <tr><th style="padding:8px 12px;text-align:left;background:var(--navy);color:#fff">Key</th><th style="padding:8px 12px;text-align:left;background:var(--navy);color:#fff">Action</th></tr>
            </thead>
            <tbody>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&larr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">P</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Previous question</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">&rarr;</kbd> / <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">N</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Next question</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">1</kbd> - <kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">4</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Select answer option</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">B</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Bookmark question</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">T</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle notes panel</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">C</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Toggle calculator</td></tr>
                <tr><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Enter</kbd></td><td style="padding:6px 12px;border-bottom:1px solid var(--gray-200)">Check answer (Practice)</td></tr>
                <tr><td style="padding:6px 12px"><kbd style="background:var(--gray-100);padding:2px 6px;border-radius:3px;font-family:monospace">Esc</kbd></td><td style="padding:6px 12px">Close modals</td></tr>
            </tbody>
        </table>
        <div class="modal-actions" style="margin-top:16px">
            <button class="btn-nav" onclick="document.getElementById('helpModal').classList.remove('active')">Close</button>
        </div>
    </div>
</div>

<!-- CALCULATOR PANEL -->
<div class="calc-panel" id="calcPanel" role="dialog" aria-modal="true" aria-labelledby="calcPanelTitle">
    <div class="calc-header">
        <h4 id="calcPanelTitle">Calculator</h4>
        <button class="calc-close" onclick="Calc.toggle()">&times;</button>
    </div>
    <div class="calc-display" id="calcDisplay">0</div>
    <div class="calc-buttons">
        <button class="calc-btn clear" onclick="Calc.clear()">C</button>
        <button class="calc-btn" onclick="Calc.input('(')">(</button>
        <button class="calc-btn" onclick="Calc.input(')')">)</button>
        <button class="calc-btn op" onclick="Calc.input('/')">&divide;</button>
        <button class="calc-btn" onclick="Calc.input('7')">7</button>
        <button class="calc-btn" onclick="Calc.input('8')">8</button>
        <button class="calc-btn" onclick="Calc.input('9')">9</button>
        <button class="calc-btn op" onclick="Calc.input('*')">&times;</button>
        <button class="calc-btn" onclick="Calc.input('4')">4</button>
        <button class="calc-btn" onclick="Calc.input('5')">5</button>
        <button class="calc-btn" onclick="Calc.input('6')">6</button>
        <button class="calc-btn op" onclick="Calc.input('-')">-</button>
        <button class="calc-btn" onclick="Calc.input('1')">1</button>
        <button class="calc-btn" onclick="Calc.input('2')">2</button>
        <button class="calc-btn" onclick="Calc.input('3')">3</button>
        <button class="calc-btn op" onclick="Calc.input('+')">+</button>
        <button class="calc-btn" onclick="Calc.input('0')">0</button>
        <button class="calc-btn" onclick="Calc.input('.')">.</button>
        <button class="calc-btn" onclick="Calc.backspace()">&larr;</button>
        <button class="calc-btn eq" onclick="Calc.equals()">=</button>
    </div>
</div>

<!-- TIMER ADJUST MODAL -->
<div class="modal-overlay" id="timerModal" onclick="if(event.target===this)App.hideTimerModal()">
    <div class="modal" style="max-width:350px" role="dialog" aria-modal="true" aria-labelledby="timerModalTitle">
        <h2 id="timerModalTitle">Adjust Timer</h2>
        <div class="setting-row">
            <label>Test Duration (minutes)</label>
            <input type="number" id="timerMinutes" min="1" max="300" value="90">
            <div class="hint">Default: 90 minutes (1.5 hours)</div>
        </div>
        <div class="modal-actions">
            <button class="btn-nav" style="background:var(--gray-500);border-color:var(--gray-500)" onclick="App.hideTimerModal()">Cancel</button>
            <button class="btn-nav" style="background:var(--green);border-color:var(--green)" onclick="App.applyTimerChange()">Apply</button>
        </div>
    </div>
</div>

<!-- FOOTER NAV (exam/practice/review-after-test) -->
<div class="footer-nav" id="footerNav" style="display:none">
    <div class="nav-controls">
        <div class="nav-buttons">
            <div class="toolbar" style="margin-right:8px">
                <button class="tool-btn" id="btnCalc" onclick="Calc.toggle()" title="Calculator" aria-label="Open Calculator">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V9h2v4zm4 4h-2v-6h2v6zm0-8h-2V7h2v2zm-8 8H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2z"/></svg>
                    Calc
                </button>
                <button class="tool-btn" id="btnAudio" onclick="Audio.speak()" title="Read question aloud" aria-label="Read question aloud">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/></svg>
                    Audio
                </button>
                <button class="tool-btn" onclick="Audio.showSettingsModal()" title="Voice Settings" aria-label="Voice Settings" style="padding:6px 8px;min-width:auto">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true" style="width:16px;height:16px"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
                </button>
                <button class="tool-btn" id="btnTimerAdj" onclick="App.showTimerModal()" title="Adjust timer" aria-label="Adjust timer">
                    <svg viewBox="0 0 24 24" fill="currentColor" aria-hidden="true"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"/></svg>
                    Timer
                </button>
            </div>
            <button class="btn-nav btn-home" onclick="App.exitToHome()">Exit</button>
            <button class="btn-nav" id="btnPrev" onclick="App.prev()" disabled>&laquo; Prev</button>
            <button class="btn-nav" id="btnSkip" onclick="App.skipQuestion()" style="background:#f59e0b;border-color:#f59e0b" title="Skip this question (lowers mastery weight)">Skip</button>
            <button class="btn-nav" id="btnNext" onclick="App.next()">Next &raquo;</button>
            <button class="btn-nav btn-submit" id="btnSubmit" onclick="App.showSubmitModal()">Submit</button>
        </div>
        <div class="palette-wrap">
            <div class="palette-mini" id="paletteMini"></div>
            <button class="palette-expand-btn" id="paletteExpandBtn" onclick="App.togglePalette()">Show All</button>
            <div class="question-palette collapsed" id="questionPalette"></div>
            <div class="palette-stats" id="paletteStats">
                <span class="stat-item stat-answered"><span class="stat-dot"></span>Answered: <strong id="statAnswered">0</strong></span>
                <span class="stat-item stat-skipped"><span class="stat-dot"></span>Skipped: <strong id="statSkipped">0</strong></span>
                <span class="stat-item stat-unanswered"><span class="stat-dot"></span>Unanswered: <strong id="statUnanswered">0</strong></span>
                <span class="stat-item stat-flagged"><span class="stat-dot"></span>Flagged: <strong id="statFlagged">0</strong></span>
            </div>
            <div class="palette-legend" id="paletteLegend" style="display:none">
                <div class="legend-item"><div class="legend-dot lg-current"></div>Current</div>
                <div class="legend-item"><div class="legend-dot lg-answered"></div>Answered</div>
                <div class="legend-item"><div class="legend-dot lg-skipped"></div>Skipped</div>
                <div class="legend-item"><div class="legend-dot lg-unanswered"></div>Not Visited</div>
                <div class="legend-item"><div class="legend-dot lg-flagged"></div>Flagged</div>
            </div>
        </div>
    </div>
</div>

<!-- SUBMIT MODAL -->
<div class="modal-overlay" id="submitModal" onclick="if(event.target===this)App.hideSubmitModal()">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="submitModalTitle">
        <h2 id="submitModalTitle">Submit Test</h2>
        <p>Are you sure you want to submit?</p>
        <table>
            <thead><tr><th>Status</th><th>Count</th></tr></thead>
            <tbody>
                <tr><td>Answered</td><td id="modalAnswered">0</td></tr>
                <tr><td>Unanswered</td><td id="modalUnanswered">0</td></tr>
                <tr><td>Bookmarked</td><td id="modalBookmarked">0</td></tr>
            </tbody>
        </table>
        <div class="modal-actions">
            <button class="btn-nav" style="background:var(--gray-500);border-color:var(--gray-500)" onclick="App.hideSubmitModal()">Cancel</button>
            <button class="btn-nav btn-submit" onclick="App.submitTest()">Submit</button>
        </div>
    </div>
</div>

<!-- QUESTION COUNT PICKER MODAL -->
<div id="qCountModal" style="display:none" onclick="if(event.target===this)App.closeCountPicker()">
    <div class="modal-box">
        <h3 style="color:var(--navy);margin-bottom:4px" id="qCountTitle">How many questions?</h3>
        <p style="color:var(--gray-600);font-size:13px;margin-bottom:16px" id="qCountSubtitle"></p>
        <div class="qcount-options" id="qCountOptions"></div>
        <div class="batch-preview" id="batchRewardPreview" aria-live="polite"></div>
        <div style="display:flex;gap:10px;margin-top:16px;justify-content:flex-end">
            <button class="btn-nav" onclick="App.closeCountPicker()" style="background:var(--gray-300);color:var(--gray-800)">Cancel</button>
            <button class="btn-nav" id="qCountStart" onclick="App.confirmStart()" style="background:var(--blue);color:#fff">Start</button>
        </div>
    </div>
</div>

<!-- AI CHAT -->
<button class="chat-fab" id="chatFab" onclick="Chat.toggle()" title="Ask AI about this question" aria-label="Open AI tutor chat" style="display:none">?</button>
<div class="chat-panel" id="chatPanel" role="dialog" aria-modal="true" aria-labelledby="chatPanelTitle">
    <div class="chat-header">
        <h3 id="chatPanelTitle"><span id="chatPersonalityIcon"></span> AI Tutor</h3>
        <div class="chat-header-actions">
            <button class="chat-personality-btn" onclick="Chat.showPersonalityPicker()" title="Change AI personality"></button>
            <button class="chat-close" onclick="Chat.toggle()">&times;</button>
        </div>
    </div>
    <div class="chat-personality-picker" id="chatPersonalityPicker" style="display:none"></div>
    <div class="chat-messages" id="chatMessages" aria-live="polite"></div>
    <div class="chat-input-area">
        <input type="text" id="chatInput" placeholder="Ask about this question..." onkeydown="if(event.key==='Enter')Chat.send()">
        <button onclick="Chat.send()">&#9654;</button>
    </div>
</div>

<script>
// =====================================================================
// EMBEDDED FALLBACK BANK DATA (for file:// protocol)
// =====================================================================
let BANK_DATA = null; // Will be set after we try fetch

// =====================================================================
// STORAGE HELPERS
// =====================================================================
const Store = {
    get(k, def) { try { const v = localStorage.getItem('wgu_' + k); return v ? JSON.parse(v) : def; } catch { return def; } },
    set(k, v) { try { localStorage.setItem('wgu_' + k, JSON.stringify(v)); } catch(e) { if (e.name === 'QuotaExceededError') { console.warn('Storage full  data not saved for:', k); if (!this._quotaWarned) { this._quotaWarned = true; alert('Storage is full. Some data may not be saved. Export your data from Settings to avoid losing progress.'); } } } },
    remove(k) { try { localStorage.removeItem('wgu_' + k); } catch {} }
};

// =====================================================================
// HTML ESCAPING (XSS protection for AI-generated content)
// =====================================================================
function escapeHtml(str) {
    if (typeof str !== 'string') return '';
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// Format question text with markdown table support and bold
function formatQuestionText(str) {
    if (typeof str !== 'string') return '';
    
    // Check if text contains a markdown table
    const lines = str.split('\n');
    const result = [];
    let inTable = false;
    let tableRows = [];
    
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i].trim();
        
        // Detect table row (starts and ends with |, or is separator row)
        const isTableRow = /^\|.*\|$/.test(line);
        const isSeparator = /^\|[-:\s|]+\|$/.test(line);
        
        if (isTableRow || isSeparator) {
            if (!inTable) {
                inTable = true;
                tableRows = [];
            }
            if (!isSeparator) {
                // Parse cells
                const cells = line.split('|').filter((c, idx, arr) => idx > 0 && idx < arr.length - 1).map(c => c.trim());
                tableRows.push(cells);
            }
        } else {
            // End of table
            if (inTable && tableRows.length > 0) {
                result.push(renderMarkdownTable(tableRows));
                tableRows = [];
                inTable = false;
            }
            // Regular line - escape and handle bold
            let escaped = escapeHtml(line);
            // Convert **text** to <strong>text</strong>
            escaped = escaped.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
            result.push(escaped);
        }
    }
    
    // Handle table at end of text
    if (inTable && tableRows.length > 0) {
        result.push(renderMarkdownTable(tableRows));
    }
    
    return result.join('<br>');
}

function renderMarkdownTable(rows) {
    if (!rows || rows.length === 0) return '';
    const header = rows[0];
    const body = rows.slice(1);
    
    let html = '<table class="md-table"><thead><tr>';
    header.forEach(cell => {
        html += `<th>${escapeHtml(cell)}</th>`;
    });
    html += '</tr></thead><tbody>';
    body.forEach(row => {
        html += '<tr>';
        row.forEach(cell => {
            html += `<td>${escapeHtml(cell)}</td>`;
        });
        html += '</tr>';
    });
    html += '</tbody></table>';
    return html;
}

// =====================================================================
// GAMIFICATION SYSTEM
// =====================================================================
/**
 * @namespace Gamification
 * @description Core gamification engine managing XP, coins, levels, achievements,
 * combo streaks, momentum buffs, pet/garden systems, and reward calculations.
 * 
 * State persisted to localStorage key: `wgu_gamification`
 * 
 * Key methods:
 * - awardXp(action, options) - Grant XP for actions with multipliers
 * - awardCoins(action, options) - Grant coins with buff scaling
 * - getActiveBuffs() - Returns array of active pet/garden buffs
 * - applyBuffScalars(baseAmount) - Applies buff multipliers to rewards
 * - activateBatchMomentum(batchSize) - Activates batch-tier momentum
 * - handleMomentumBreak(reason) - Revokes momentum on combo break/exit
 */
const Gamification = {
    // XP Values for different actions
    XP_VALUES: {
        correctAnswer: 25,
        firstTryCorrect: 50,
        drillGotIt: 40,
        drillStruggled: 15,
        testComplete: 100,
        perfectTest: 500,
        comboBonus: 10,
        dailyGoalReached: 100,
        weeklyGoalReached: 300,
        loginBonus: 25
    },

    getDefaultMomentumState() {
        return {
            active: false,
            tierId: null,
            label: 'Standard Pace',
            xpMultiplier: 1,
            coinMultiplier: 1,
            batchSize: null,
            questionGoal: 0,
            questionsCompleted: 0,
            pillIcon: '',
            description: '',
            source: null,
            startedAt: null,
            clearedAt: null,
            lastUpdated: null,
            lastClearedReason: null
        };
    },

    getBatchTier(count) {
        if (!count) return null;
        const tiers = [...this.BATCH_TIERS].sort((a, b) => b.minQuestions - a.minQuestions);
        return tiers.find(t => count >= t.minQuestions) || null;
    },

    activateBatchMomentum(batchSize, options = {}) {
        const state = this.getState();
        const tier = this.getBatchTier(batchSize);
        if (!tier) {
            state.momentum = { ...this.getDefaultMomentumState(), batchSize: batchSize || null, questionGoal: batchSize || 0 };
            this.saveState(state);
            this.renderXpBar();
            return { ...state.momentum };
        }

        state.momentum = {
            active: true,
            tierId: tier.id,
            label: tier.label,
            xpMultiplier: tier.xpMultiplier,
            coinMultiplier: tier.coinMultiplier,
            batchSize: batchSize || tier.minQuestions,
            questionGoal: options.questionGoal || batchSize || tier.minQuestions,
            questionsCompleted: 0,
            pillIcon: tier.pillIcon,
            description: tier.description,
            source: 'batch',
            startedAt: Date.now(),
            clearedAt: null,
            lastUpdated: Date.now(),
            lastClearedReason: null
        };
        this.saveState(state);
        this.renderXpBar();
        return { ...state.momentum };
    },

    syncMomentum(meta) {
        const state = this.getState();
        if (!meta || !meta.active) {
            state.momentum = { ...this.getDefaultMomentumState(), batchSize: meta?.batchSize || null };
            this.saveState(state);
            return { ...state.momentum };
        }

        state.momentum = {
            ...this.getDefaultMomentumState(),
            ...meta,
            active: true,
            startedAt: meta.startedAt || Date.now(),
            lastUpdated: Date.now(),
            source: meta.source || 'batch'
        };
        this.saveState(state);
        this.renderXpBar();
        return { ...state.momentum };
    },

    clearMomentum(reason = 'manual') {
        const state = this.getState();
        state.momentum = {
            ...this.getDefaultMomentumState(),
            clearedAt: Date.now(),
            lastClearedReason: reason
        };
        this.saveState(state);
        this.renderXpBar();
        return { ...state.momentum };
    },

    getMomentumState() {
        const state = this.getState();
        return { ...state.momentum };
    },

    getActiveMomentum(state) {
        const src = state || this.getState();
        return src.momentum && src.momentum.active ? src.momentum : null;
    },

    // Daily streak multiplier: rewards consecutive days of studying
    // 3 days = 1.1x, 7 days = 1.25x, 14 days = 1.5x, 30 days = 2x
    getStreakMultiplier() {
        const stats = DailyGoal ? DailyGoal.getStats() : { streak: 0 };
        const streak = stats.streak || 0;
        if (streak >= 30) return 2.0;
        if (streak >= 14) return 1.5;
        if (streak >= 7) return 1.25;
        if (streak >= 3) return 1.1;
        return 1.0;
    },

    getStreakBonusInfo() {
        const stats = DailyGoal ? DailyGoal.getStats() : { streak: 0 };
        const streak = stats.streak || 0;
        const mult = this.getStreakMultiplier();
        let nextMilestone = null, daysToNext = 0;
        if (streak < 3) { nextMilestone = 3; daysToNext = 3 - streak; }
        else if (streak < 7) { nextMilestone = 7; daysToNext = 7 - streak; }
        else if (streak < 14) { nextMilestone = 14; daysToNext = 14 - streak; }
        else if (streak < 30) { nextMilestone = 30; daysToNext = 30 - streak; }
        return { streak, multiplier: mult, nextMilestone, daysToNext };
    },

    showMomentumToast(message, icon = '') {
        const toast = document.getElementById('momentumToast');
        if (!toast) return;
        const iconEl = document.getElementById('momentumToastIcon');
        const textEl = document.getElementById('momentumToastText');
        iconEl.textContent = icon;
        textEl.textContent = message;
        toast.classList.add('show');
        clearTimeout(this._momentumToastTimer);
        this._momentumToastTimer = setTimeout(() => toast.classList.remove('show'), 2500);
    },

    incrementMomentumProgress(delta = 1) {
        const state = this.getState();
        if (!state.momentum || !state.momentum.active) return { ...state.momentum };
        state.momentum.questionsCompleted = Math.max(0, (state.momentum.questionsCompleted || 0) + (delta || 0));
        state.momentum.lastUpdated = Date.now();
        this.saveState(state);
        this.renderXpBar();
        return { ...state.momentum };
    },

    handleMomentumBreak(reason) {
        const state = this.getState();
        if (!state.momentum || !state.momentum.active) return;
        const label = state.momentum?.label || 'Momentum';
        this.clearMomentum(reason);
        const reasonText = {
            incorrect: 'Momentum lost on a miss.',
            exit: 'Momentum dropped when you left the run.',
            combo: 'Combo broke, so boosts reset.',
            session_end: 'Session ended, boosts cleared.',
            manual: 'Momentum cleared.'
        }[reason] || 'Momentum expired.';
        this.showMomentumToast(`${label} ended  ${reasonText}`);
    },

    getMomentumPillMarkup(meta) {
        const tier = meta && meta.active ? meta : this.getMomentumState();
        if (tier && tier.active) {
            const pct = Math.round(((tier.xpMultiplier || 1) - 1) * 100);
            const goal = tier.questionGoal || tier.batchSize || null;
            const progress = goal ? Math.min(goal, tier.questionsCompleted || 0) : (tier.questionsCompleted || 0);
            const tooltipParts = [];
            if (tier.description) tooltipParts.push(tier.description);
            if (goal) tooltipParts.push(`Progress ${progress}/${goal} questions`);
            tooltipParts.push('Miss a question or exit to lose this boost.');
            const tooltip = tooltipParts.join('  ');
            const pills = [];
            pills.push(`<span class="momentum-pill" title="${escapeHtml(tooltip)}">${tier.pillIcon || ''} Momentum x${(tier.xpMultiplier || 1).toFixed(2)}  +${pct}%</span>`);
            if (tier.batchSize) {
                pills.push(`<span class="momentum-pill secondary" title="Batch goal ${tier.batchSize} questions"> Batch ${tier.batchSize}</span>`);
            }
            return pills.join('');
        }
        return '<span class="momentum-pill muted"> No active boosts</span>';
    },

    renderMomentumPillsInto(el, meta) {
        if (!el) return;
        el.innerHTML = this.getMomentumPillMarkup(meta);
    },

    // Level titles
    TITLES: {
        1: 'Curious Beginner',
        5: 'Eager Learner',
        10: 'Knowledge Seeker',
        15: 'Pattern Finder',
        20: 'Skilled Scholar',
        25: 'Expert Explorer',
        30: 'Grand Master'
    },

    // Achievements list
    ACHIEVEMENTS: [
        { id: 'first_correct', name: 'First Steps', desc: 'Get your first correct answer', icon: '', xp: 50 },
        { id: 'ten_streak', name: 'On Fire', desc: '10 correct answers in a row', icon: '', xp: 100 },
        { id: 'twenty_streak', name: 'Unstoppable', desc: '20 correct answers in a row', icon: '', xp: 200 },
        { id: 'fifty_streak', name: 'Legendary', desc: '50 correct answers in a row', icon: '', xp: 500 },
        { id: 'perfect_test', name: 'Perfectionist', desc: 'Score 100% on a test', icon: '', xp: 500 },
        { id: 'category_master', name: 'Category Master', desc: 'Master a category (30+ correct, 90%+)', icon: '', xp: 200 },
        { id: 'multi_master', name: 'Multi-Master', desc: 'Master 5 different categories', icon: '', xp: 400 },
        { id: 'week_streak', name: 'Weekly Warrior', desc: '7-day study streak', icon: '', xp: 300 },
        { id: 'month_streak', name: 'Dedicated Learner', desc: '30-day study streak', icon: '', xp: 1000 },
        { id: 'early_bird', name: 'Early Bird', desc: 'Study before 7am', icon: '', xp: 50 },
        { id: 'night_owl', name: 'Night Owl', desc: 'Study after 11pm', icon: '', xp: 50 },
        { id: 'speed_demon', name: 'Speed Demon', desc: 'Answer correctly in under 10 seconds', icon: '', xp: 75 },
        { id: 'lightning_fast', name: 'Lightning Fast', desc: 'Answer correctly in under 5 seconds', icon: '', xp: 150 },
        { id: 'century', name: 'Century', desc: 'Answer 100 questions', icon: '', xp: 200 },
        { id: 'five_hundred', name: 'Halfway There', desc: 'Answer 500 questions', icon: '', xp: 400 },
        { id: 'thousand', name: 'Grind Master', desc: 'Answer 1000 questions', icon: '', xp: 1000 },
        { id: 'five_thousand', name: 'Unstoppable Force', desc: 'Answer 5000 questions', icon: '', xp: 2500 },
        { id: 'comeback', name: 'Comeback Kid', desc: 'Return after 3+ days away', icon: '', xp: 100 },
        { id: 'level_5', name: 'Rising Star', desc: 'Reach level 5', icon: '', xp: 100 },
        { id: 'level_10', name: 'Dedicated Student', desc: 'Reach level 10', icon: '', xp: 200 },
        { id: 'level_20', name: 'True Expert', desc: 'Reach level 20', icon: '', xp: 500 },
        { id: 'level_30', name: 'Grand Master', desc: 'Reach level 30', icon: '', xp: 1000 },
        // Daily mastery achievements
        { id: 'daily_10', name: 'Daily Dozen', desc: 'Answer 10 questions correctly in one day', icon: '', xp: 50, daily: true },
        { id: 'daily_25', name: 'Quarter Century', desc: 'Answer 25 questions correctly in one day', icon: '', xp: 100, daily: true },
        { id: 'daily_50', name: 'Half Century', desc: 'Answer 50 questions correctly in one day', icon: '', xp: 200, daily: true },
        { id: 'daily_100', name: 'Century Day', desc: 'Answer 100 questions correctly in one day', icon: '', xp: 500, daily: true },
        { id: 'daily_perfect_10', name: 'Perfect Ten', desc: 'Get 10 correct in a row today', icon: '', xp: 75, daily: true },
        { id: 'daily_speed_5', name: 'Quick Study', desc: 'Answer 5 questions under 15 seconds today', icon: '', xp: 60, daily: true },
        { id: 'daily_all_modes', name: 'Well Rounded', desc: 'Use Test, Practice, Drill, and Speed mode today', icon: '', xp: 100, daily: true },
        { id: 'daily_3_banks', name: 'Explorer', desc: 'Study from 3 different banks today', icon: '', xp: 75, daily: true },
        // Garden & Pet achievements
        { id: 'green_thumb', name: 'Green Thumb', desc: 'Harvest your first plant', icon: '', xp: 75 },
        { id: 'master_gardener', name: 'Master Gardener', desc: 'Harvest 10 plants', icon: '', xp: 200 },
        { id: 'legendary_gardener', name: 'Legendary Gardener', desc: 'Harvest 50 plants', icon: '', xp: 500 },
        { id: 'garden_paradise', name: 'Garden Paradise', desc: 'Fill all 9 garden plots', icon: '', xp: 300 },
        { id: 'best_friends', name: 'Best Friends', desc: 'Reach max pet evolution', icon: '', xp: 250 },
        { id: 'happy_tummy', name: 'Happy Tummy', desc: 'Feed your pet 50 meals', icon: '', xp: 150 },
        { id: 'pet_collector', name: 'Pet Collector', desc: 'Own 3 different pets', icon: '', xp: 300 },
        { id: 'window_shopper', name: 'Window Shopper', desc: 'Make your first purchase', icon: '', xp: 50 },
        { id: 'big_spender', name: 'Big Spender', desc: 'Earn 1000 total coins', icon: '', xp: 200 },
        { id: 'coin_hoarder', name: 'Coin Hoarder', desc: 'Earn 10000 total coins', icon: '', xp: 500 },
        { id: 'rainbow_bloom', name: 'Rainbow Bloom', desc: 'Grow a Rainbow Rose', icon: '', xp: 500 },
        { id: 'rare_collector', name: 'Rare Collector', desc: 'Grow all premium seed types', icon: '', xp: 750 },
        // Battle achievements
        { id: 'first_victory', name: 'First Blood', desc: 'Win your first battle', icon: '', xp: 75 },
        { id: 'chapter_clear', name: 'Chapter Master', desc: 'Complete a full chapter', icon: '', xp: 200 },
        { id: 'boss_slayer', name: 'Boss Slayer', desc: 'Defeat all 5 bosses', icon: '', xp: 500 },
        { id: 'flawless', name: 'Flawless Victory', desc: 'Win a battle taking no damage', icon: '', xp: 150 },
        // Business achievements
        { id: 'entrepreneur', name: 'Entrepreneur', desc: 'Start your first business', icon: '', xp: 100 },
        { id: 'business_mogul', name: 'Business Mogul', desc: 'Own 3 different businesses', icon: '', xp: 300 },
        { id: 'millionaire', name: 'Millionaire', desc: 'Earn 1,000,000 from businesses', icon: '', xp: 1000 },
        // Housing achievements
        { id: 'homeowner', name: 'Homeowner', desc: 'Buy your first house', icon: '', xp: 150 },
        { id: 'interior_designer', name: 'Interior Designer', desc: 'Own 10 pieces of furniture', icon: '', xp: 200 },
        { id: 'real_estate', name: 'Real Estate Mogul', desc: 'Own 3 different houses', icon: '', xp: 500 }
    ],

    // Power-ups
    POWERUPS: {
        fiftyFifty: { name: '50/50', desc: 'Eliminate 2 wrong answers', cost: 100, icon: '' },
        skipQuestion: { name: 'Skip', desc: 'Skip without penalty', cost: 75, icon: '' },
        extraTime: { name: '+2 Min', desc: 'Add 2 minutes to timer', cost: 50, icon: '' },
        doubleXp: { name: '2x XP', desc: 'Double XP for next 5 questions', cost: 80, icon: '' },
        showHint: { name: 'Hint', desc: 'Show explanation hint', cost: 80, icon: '' }
    },

    // Level unlock requirements for shop items
    LEVEL_REQS: {
        food:        { kibble: 1, treat: 3, feast: 7, goldfish: 12 },
        seeds:       { sunflower: 1, cactus: 3, bonsai: 7, crystal: 12, rainbow: 18, moneyTree: 20, starfruit: 15, dragonFruit: 18, moonflower: 12, goldenApple: 22, ancientOak: 25 },
        gardenItems: { water: 1, fertilizer: 5, magicDust: 10, evoStone: 5, healthPotion: 1, shieldCharm: 5, powerBerry: 3 },
        decorations: { fountain: 5, gnome: 1, lantern: 3, bench: 1, statue: 10, windmill: 8, pond: 12, clover: 10, weatherVane: 6, scarecrow: 4 },
        cosmetics:   { hat: 3, crown: 10, scarf: 1, sunglasses: 3, cape: 7 }
    },

    // Garden plot auto-unlocks at these levels (additive, on top of starting 3)
    PLOT_UNLOCK_LEVELS: [5, 10, 15, 20],

    // Check if item is unlocked at current level
    isItemUnlocked(tab, itemId) {
        const state = this.getState();
        const reqs = this.LEVEL_REQS[tab];
        if (!reqs || !reqs[itemId]) return true;
        return state.level >= reqs[itemId];
    },

    // Evolution thresholds (same for all species)
    BUDDY_STAGES: [
        { stage: 1, xpNeeded: 0, careNeeded: 0 },
        { stage: 2, xpNeeded: 500, careNeeded: 30 },
        { stage: 3, xpNeeded: 2000, careNeeded: 120 },
        { stage: 4, xpNeeded: 5000, careNeeded: 360 },
        { stage: 5, xpNeeded: 15000, careNeeded: 720 }
    ],

    // Pet species  each has unique evolution line + difficulty
    PET_SPECIES: {
        bird:    { name: 'Bird',    difficulty: 1.0, unlockLevel: 1,  price: 0,
                   emojis: ['','','','',''], stages: ['Egg','Hatchling','Chick','Bird','Eagle'] },
        cat:     { name: 'Cat',     difficulty: 1.2, unlockLevel: 3,  price: 200,
                   emojis: ['','','','',''], stages: ['Egg','Kitten','Cat','Happy Cat','Lion'] },
        dragon:  { name: 'Dragon',  difficulty: 1.5, unlockLevel: 5,  price: 400,
                   emojis: ['','','','',''], stages: ['Dragon Egg','Hatchling','Drake','Dragon','Elder Dragon'] },
        fox:     { name: 'Fox',     difficulty: 1.3, unlockLevel: 7,  price: 500,
                   emojis: ['','','','',''], stages: ['Egg','Pup','Fox Cub','Fox','Spirit Fox'] },
        slime:   { name: 'Slime',   difficulty: 0.7, unlockLevel: 1,  price: 100,
                   emojis: ['','','','',''], stages: ['Bubble','Tiny Slime','Slime','Big Slime','King Slime'] },
        phoenix: { name: 'Phoenix', difficulty: 2.0, unlockLevel: 15, price: 1000,
                   emojis: ['','','','',''], stages: ['Ember Egg','Spark','Firebird','Phoenix','Eternal Phoenix'] }
    },

    // Helpers to get species emoji/name for a pet
    getSpeciesEmoji(species, stage) {
        const sp = this.PET_SPECIES[species || 'bird'];
        return sp ? (sp.emojis[stage - 1] || '') : '';
    },
    getSpeciesStageName(species, stage) {
        const sp = this.PET_SPECIES[species || 'bird'];
        return sp ? (sp.stages[stage - 1] || 'Unknown') : 'Unknown';
    },
    getSpeciesDifficulty(species) {
        const sp = this.PET_SPECIES[species || 'bird'];
        return sp ? sp.difficulty : 1.0;
    },

    applyBuffScalars(type, baseAmount) {
        const state = this.getState();
        if (!state.settings?.petBuffs) {
            return { amount: baseAmount, amountDelta: 0, breakdown: '' };
        }
        let amount = baseAmount;
        const buffs = this.getActiveBuffs();
        const parts = [];
        buffs.forEach(buff => {
            const pct = /([0-9]{1,3})%/.exec(buff.value || '');
            if (!pct) return;
            const delta = Math.floor((amount * parseInt(pct[1], 10)) / 100);
            if (delta <= 0) return;
            const appliesXp = type === 'xp' && /xp/i.test(buff.value || buff.description || '');
            const appliesCoin = type === 'coin' && /coin|yield|water/i.test(buff.value || buff.description || '');
            if ((appliesXp && type === 'xp') || (appliesCoin && type === 'coin')) {
                amount += delta;
                parts.push(`${buff.label} +${pct[1]}%`);
            }
        });
        return {
            amount,
            amountDelta: amount - baseAmount,
            breakdown: parts.length ? `(${parts.join(', ')})` : ''
        };
    },

    getActiveBuffs() {
        const state = this.getState();
        const buffs = [];
        if (!state.settings?.petBuffs) return buffs;

        const buddy = state.studyBuddy;
        if (state.settings.pet && buddy) {
            const happy = buddy.happiness ?? 0;
            const hunger = buddy.hunger ?? 0;
            const moodBonus = Math.max(0, Math.floor(((happy + hunger) / 200) * 10));
            if (moodBonus >= 2) {
                buffs.push({
                    icon: '',
                    label: 'Buddy Boost',
                    value: `+${moodBonus}% XP`,
                    description: 'Happy, well-fed pets share their energy for extra XP.',
                    source: buddy.species === 'dragon' ? 'Dragon' : 'Buddy'
                });
            }
            const speciesMeta = this.PET_SPECIES[buddy.species] || this.PET_SPECIES.bird;
            if (speciesMeta && speciesMeta.difficulty >= 1.5) {
                buffs.push({
                    icon: '',
                    label: `${speciesMeta.name} Focus`,
                    value: '+5% combo cap',
                    description: 'Challenging pets raise your focus window before combos drop.',
                    source: speciesMeta.name
                });
            }
        }

        const plots = state.garden?.plots || [];
        const sprouting = plots.filter(p => p && p.seedType).length;
        if (state.settings.garden && sprouting >= 3) {
            const pct = sprouting * 2;
            buffs.push({
                icon: '',
                label: 'Garden Groove',
                value: `+${pct}% coin yield`,
                description: 'Multiple thriving crops improve coin harvests.',
                source: 'Garden'
            });
        }

        if ((state.garden?.decorations || []).includes('fountain')) {
            buffs.push({
                icon: '',
                label: 'Fountain Flow',
                value: '+5 water/question',
                description: 'Fountain keeps crops hydrated automatically.',
                source: 'Decoration'
            });
        }

        return buffs.slice(0, 4);
    },

    // Get default state
    // Coin values for different actions
    COIN_VALUES: {
        correctAnswer: 5,
        firstTryCorrect: 10,
        drillGotIt: 8,
        testComplete: 20,
        perfectTest: 100,
        dailyGoalReached: 25,
        loginBonus: 10,
        harvest: 0 // varies per plant
    },

    // Batch tiers for momentum rewards
    BATCH_TIERS: [
        { id: 'batch5', minQuestions: 5, label: 'Batch 5', xpMultiplier: 1.05, coinMultiplier: 1.05, pillIcon: '', description: '+5% rewards for 5-question runs.' },
        { id: 'batch10', minQuestions: 10, label: 'Batch 10', xpMultiplier: 1.12, coinMultiplier: 1.12, pillIcon: '', description: '+12% rewards for double-digit focus.' },
        { id: 'batch15', minQuestions: 15, label: 'Batch 15', xpMultiplier: 1.2, coinMultiplier: 1.2, pillIcon: '', description: '+20% rewards once you clear 15.' },
        { id: 'batch20', minQuestions: 20, label: 'Batch 20+', xpMultiplier: 1.35, coinMultiplier: 1.35, pillIcon: '', description: '+35% rewards for marathon batches.' }
    ],

    // Shop catalog
    SHOP: {
        food: {
            kibble:  { name: 'Kibble',    price: 10,  icon: '', hunger: 10, happiness: 4,  careBonus: 4, healthy: true, decayMod: 0.8 },
            treat:   { name: 'Treat',     price: 25,  icon: '', hunger: 20, happiness: 10, careBonus: 8, healthy: false, decayMod: 1.3 },
            feast:   { name: 'Feast',     price: 60,  icon: '', hunger: 40, happiness: 22, careBonus: 15, healthy: false, decayMod: 1.4 },
            goldfish:{ name: 'Gold Fish', price: 100, icon: '', hunger: 35, happiness: 35, careBonus: 12, healthy: true, decayMod: 0.7 },
            premiumSteak: { name: 'Premium Steak', price: 200, icon: '', hunger: 60, happiness: 50, careBonus: 25, healthy: false, decayMod: 1.5 },
            magicBerry:   { name: 'Magic Berry',   price: 150, icon: '', hunger: 30, happiness: 60, careBonus: 20, healthy: true, decayMod: 0.6 }
        },
        seeds: {
            // Growth times at 1.4 GP/hour: sunflower ~24h, cactus ~36h, bonsai ~2d, etc.
            sunflower: { name: 'Sunflower',     price: 15,  icon: '', gpNeeded: 35, stages: 4, coinReward: 15, xpReward: 35,
                         emojis: ['','','',''], growthHours: 24 },
            cactus:    { name: 'Cactus',        price: 20,  icon: '', gpNeeded: 50, stages: 4, coinReward: 25, xpReward: 50,
                         emojis: ['','','',''], growthHours: 36 },
            bonsai:    { name: 'Bonsai',        price: 40,  icon: '', gpNeeded: 70, stages: 5, coinReward: 45, xpReward: 100,
                         emojis: ['','','','',''], growthHours: 48 },
            crystal:   { name: 'Crystal Bloom', price: 75,  icon: '', gpNeeded: 100, stages: 5, coinReward: 75, xpReward: 175,
                         emojis: ['','','','',''], growthHours: 72 },
            rainbow:   { name: 'Rainbow Rose',  price: 120, icon: '', gpNeeded: 140, stages: 6, coinReward: 150, xpReward: 350,
                         emojis: ['','','','','',''], growthHours: 96 },
            moneyTree: { name: 'Money Tree',    price: 300, icon: '', gpNeeded: 200, stages: 7, coinReward: 400, xpReward: 750,
                         emojis: ['','','','','','',''], growthHours: 144 },
            // Premium/rare seeds - take even longer but better rewards
            starfruit:  { name: 'Starfruit',     price: 200, icon: '', gpNeeded: 170, stages: 6, coinReward: 250, xpReward: 500, gemReward: 1,
                         emojis: ['','','','','',''], desc: 'Rare! Yields gems on harvest', growthHours: 120 },
            dragonFruit:{ name: 'Dragon Fruit',  price: 250, icon: '', gpNeeded: 190, stages: 6, coinReward: 300, xpReward: 600, petBonus: true,
                         emojis: ['','','','','',''], desc: '+10 pet happiness on harvest', growthHours: 132 },
            moonflower: { name: 'Moonflower',    price: 180, icon: '', gpNeeded: 150, stages: 5, coinReward: 200, xpReward: 450, nightBonus: true,
                         emojis: ['','','','',''], desc: '2x rewards if harvested at night', growthHours: 108 },
            goldenApple:{ name: 'Golden Apple',  price: 400, icon: '', gpNeeded: 250, stages: 7, coinReward: 500, xpReward: 900, healPet: true,
                         emojis: ['','','','','','',''], desc: 'Fully heals pet on harvest', growthHours: 180 },
            ancientOak: { name: 'Ancient Oak',   price: 500, icon: '', gpNeeded: 350, stages: 8, coinReward: 700, xpReward: 1200, permBonus: 0.05,
                         emojis: ['','','','','','','',''], desc: 'Permanent +5% coin bonus after harvest', growthHours: 240 }
        },
        gardenItems: {
            water:      { name: 'Watering Can', price: 5,   icon: '', desc: '+25 water level' },
            fertilizer: { name: 'Fertilizer',   price: 20,  icon: '', desc: '2x growth for 1 plant (10 questions)' },
            magicDust:  { name: 'Magic Dust',   price: 50,  icon: '', desc: 'Advance 1 plant by 1 stage' },
            evoStone:   { name: 'Evolution Stone', price: 150, icon: '', desc: '+60 care minutes for pet evolution' },
            healthPotion: { name: 'Health Potion', price: 30, icon: '', desc: 'Heal pet 40 HP mid-battle' },
            shieldCharm:  { name: 'Shield Charm',  price: 50, icon: '', desc: 'Block next enemy attack 100%' },
            powerBerry:   { name: 'Power Berry',   price: 40, icon: '', desc: '+50% ATK for 3 questions' },
            resStone:     { name: 'Resurrection Stone', price: 50, icon: '', desc: 'Revive a pet from the graveyard' },
            superFertilizer: { name: 'Super Fertilizer', price: 75, icon: '', desc: '3x growth for 1 plant' },
            rainCloud:    { name: 'Rain Cloud',   price: 100, icon: '', desc: 'Auto-water all plants for 1 hour' }
        },
        petHousing: {
            basicBed:    { name: 'Pet Bed',       price: 50,   icon: '', desc: 'Slows happiness decay 10%', comfortBonus: 0.10 },
            cozyBed:     { name: 'Cozy Bed',      price: 150,  icon: '', desc: 'Slows happiness decay 20%', comfortBonus: 0.20 },
            luxuryBed:   { name: 'Luxury Bed',    price: 400,  icon: '', desc: 'Slows happiness decay 35%', comfortBonus: 0.35 },
            foodBowl:    { name: 'Food Bowl',     price: 75,   icon: '', desc: 'Auto-feed when away (holds 5 meals)', capacity: 5, type: 'food' },
            waterBowl:   { name: 'Water Bowl',    price: 60,   icon: '', desc: 'Auto-hydrate when away (holds 10 drinks)', capacity: 10, type: 'water' },
            largeFoodBowl:  { name: 'Large Food Bowl',  price: 200, icon: '', desc: 'Auto-feed (holds 12 meals)', capacity: 12, type: 'food' },
            largeWaterBowl: { name: 'Large Water Bowl', price: 150, icon: '', desc: 'Auto-hydrate (holds 25 drinks)', capacity: 25, type: 'water' },
            petHouse:    { name: 'Pet House',     price: 300,  icon: '', desc: 'Slows all decay 25%, +comfort', comfortBonus: 0.25, allDecay: true },
            deluxePetHouse: { name: 'Deluxe Pet House', price: 800, icon: '', desc: 'Slows all decay 40%, max comfort', comfortBonus: 0.40, allDecay: true },
            toyBox:      { name: 'Toy Box',       price: 100,  icon: '', desc: '+5 happiness per study session', happinessBonus: 5 },
            scratchPost: { name: 'Scratch Post',  price: 80,   icon: '', desc: '+3 happiness per question', happinessPerQ: 3 }
        },
        decorations: {
            fountain: { name: 'Fountain',     price: 80,  icon: '', desc: '+5 water per question (passive)', effect: 'autoWater' },
            gnome:    { name: 'Garden Gnome',  price: 25,  icon: '', desc: 'Decorative' },
            lantern:  { name: 'Lantern',       price: 35,  icon: '', desc: 'Decorative' },
            bench:    { name: 'Garden Bench',  price: 40,  icon: '', desc: 'Decorative' },
            statue:   { name: 'Scholar Statue', price: 200, icon: '', desc: '+2% XP bonus', xpBonus: 0.02 },
            windmill: { name: 'Windmill',      price: 150, icon: '', desc: 'Decorative, animated' },
            pond:     { name: 'Koi Pond',      price: 250, icon: '', desc: '+1 coin per correct answer', coinBonus: 1 },
            clover:   { name: 'Lucky Clover',  price: 175, icon: '', desc: '+25% rare seed drop chance', effect: 'luckyDrop' },
            weatherVane: { name: 'Weather Vane', price: 120, icon: '', desc: 'Shows weather forecast', effect: 'weatherInfo' },
            scarecrow: { name: 'Scarecrow',   price: 90,  icon: '', desc: 'Protects crops from disasters', effect: 'protection' }
        },
        cosmetics: {
            hat:        { name: 'Hat',        price: 50,  icon: '' },
            crown:      { name: 'Crown',      price: 100, icon: '' },
            scarf:      { name: 'Scarf',      price: 30,  icon: '' },
            sunglasses: { name: 'Sunglasses', price: 40,  icon: '' },
            cape:       { name: 'Cape',       price: 75,  icon: '' },
            bowtie:     { name: 'Bow Tie',    price: 35,  icon: '' },
            glasses:    { name: 'Glasses',    price: 45,  icon: '' },
            headphones: { name: 'Headphones', price: 60,  icon: '' },
            wings:      { name: 'Wings',      price: 200, icon: '' },
            halo:       { name: 'Halo',       price: 150, icon: '' }
        },
        housing: {
            tent:       { name: 'Tent',         price: 100,   icon: '', desc: 'Basic shelter', tier: 1, decayRate: 0.5, repairCost: 10, rooms: ['sleeping'] },
            cabin:      { name: 'Cabin',        price: 500,   icon: '', desc: 'Cozy wooden cabin', tier: 2, decayRate: 0.4, repairCost: 25, rooms: ['living', 'sleeping'] },
            house:      { name: 'House',        price: 1500,  icon: '', desc: 'Comfortable home', tier: 3, decayRate: 0.3, repairCost: 75, rooms: ['living', 'kitchen', 'bedroom', 'bathroom'] },
            mansion:    { name: 'Mansion',      price: 5000,  icon: '', desc: 'Luxurious estate', tier: 4, decayRate: 0.25, repairCost: 200, rooms: ['foyer', 'living', 'kitchen', 'dining', 'bedroom', 'bathroom', 'study'] },
            penthouse:  { name: 'Penthouse',    price: 25000, icon: '', desc: 'Luxury city living with skyline views', tier: 5, decayRate: 0.15, repairCost: 800, rooms: ['foyer', 'living', 'kitchen', 'dining', 'master', 'guest', 'bathroom', 'office', 'terrace'] },
            castle:     { name: 'Castle',       price: 50000, icon: '', desc: 'Royal residence', tier: 6, decayRate: 0.1, repairCost: 1500, rooms: ['throne', 'great_hall', 'kitchen', 'dining', 'master', 'guest', 'tower', 'library', 'courtyard'] }
        },
        services: {
            laborer:    { name: 'Laborer (1 day)', price: 50,  icon: '', desc: 'Repairs 10% condition/day', duration: 1 },
            handyman:   { name: 'Handyman (3 days)', price: 120, icon: '', desc: 'Repairs 15% condition/day', duration: 3, repairRate: 15 },
            contractor: { name: 'Contractor (7 days)', price: 250, icon: '', desc: 'Repairs 20% condition/day', duration: 7, repairRate: 20 },
            repair:     { name: 'Quick Repair', price: 25, icon: '', desc: 'Instantly repair 25% condition', instant: true, repairAmount: 25 },
            fullRepair: { name: 'Full Renovation', price: 100, icon: '', desc: 'Restore to 100% condition', instant: true, repairAmount: 100 }
        },
        furniture: {
            desk:       { name: 'Study Desk',   price: 100,  icon: '', desc: '+1% XP bonus', xpBonus: 0.01 },
            bookshelf:  { name: 'Bookshelf',    price: 150,  icon: '', desc: '+2% XP bonus', xpBonus: 0.02 },
            lamp:       { name: 'Desk Lamp',    price: 50,   icon: '', desc: 'Decorative' },
            plant:      { name: 'House Plant',  price: 40,   icon: '', desc: 'Decorative' },
            rug:        { name: 'Cozy Rug',     price: 75,   icon: '', desc: 'Decorative' },
            painting:   { name: 'Painting',     price: 120,  icon: '', desc: 'Decorative' },
            tv:         { name: 'Television',   price: 300,  icon: '', desc: 'Entertainment' },
            computer:   { name: 'Computer',     price: 500,  icon: '', desc: '+3% XP bonus', xpBonus: 0.03 },
            aquarium:   { name: 'Aquarium',     price: 250,  icon: '', desc: 'Relaxing' },
            fireplace:  { name: 'Fireplace',    price: 400,  icon: '', desc: 'Cozy warmth' },
            bed:        { name: 'Bed',          price: 200,  icon: '', desc: 'Rest well' },
            couch:      { name: 'Couch',        price: 175,  icon: '', desc: 'Comfortable seating' }
        },
        vehicles: {
            bicycle:    { name: 'Bicycle',      price: 200,   icon: '', desc: 'Eco-friendly transport', tier: 1 },
            scooter:    { name: 'Scooter',      price: 500,   icon: '', desc: 'Quick around town', tier: 2 },
            car:        { name: 'Car',          price: 2000,  icon: '', desc: 'Reliable sedan', tier: 3 },
            sportsCar:  { name: 'Sports Car',   price: 5000,  icon: '', desc: 'Fast and stylish', tier: 4 },
            helicopter: { name: 'Helicopter',   price: 15000, icon: '', desc: 'Sky travel', tier: 5 },
            yacht:      { name: 'Yacht',        price: 25000, icon: '', desc: 'Luxury water vessel', tier: 6 },
            spaceship:  { name: 'Spaceship',    price: 50000, icon: '', desc: 'To infinity!', tier: 7 }
        },
        businesses: {
            // SIMPLIFIED BUSINESS SYSTEM v2
            // - Single "supplies" resource per business (cost per cycle)
            // - Level = income multiplier, Machines = speed, Manager = automation
            // - Prestige system for permanent bonuses
            // - Study boost: answering questions adds progress
            lemonade: { 
                name: 'Lemonade Stand', price: 100, icon: '', desc: 'A humble beginning',
                baseIncome: 2, cycleTime: 60, managerCost: 500, supplyCost: 1,
                theme: { bg: '#92400e', accent: '#f59e0b', dark: '#451a03' },
                flavorText: 'When life gives you lemons...',
                milestones: [100, 500, 2000, 10000] // Total profit milestones
            },
            newspaper: { 
                name: 'Paper Route', price: 250, icon: '', desc: 'Deliver the news',
                baseIncome: 4, cycleTime: 90, managerCost: 1000, supplyCost: 2,
                theme: { bg: '#374151', accent: '#9ca3af', dark: '#1f2937' },
                flavorText: 'Extra! Extra! Read all about it!',
                milestones: [200, 1000, 5000, 25000]
            },
            carwash: { 
                name: 'Car Wash', price: 600, icon: '', desc: 'Sparkle and shine',
                baseIncome: 8, cycleTime: 120, managerCost: 3000, supplyCost: 4,
                theme: { bg: '#1e40af', accent: '#60a5fa', dark: '#1e3a8a' },
                flavorText: 'Making cars sparkle since day one!',
                milestones: [500, 2500, 12000, 60000]
            },
            bakery: { 
                name: 'Bakery', price: 2000, icon: '', desc: 'Fresh baked goods',
                baseIncome: 15, cycleTime: 180, managerCost: 10000, supplyCost: 8,
                theme: { bg: '#9a3412', accent: '#fb923c', dark: '#431407' },
                flavorText: 'The smell of fresh bread fills the air...',
                milestones: [1500, 8000, 40000, 200000]
            },
            pizzeria: { 
                name: 'Pizzeria', price: 5000, icon: '', desc: 'Slice of heaven',
                baseIncome: 30, cycleTime: 240, managerCost: 25000, supplyCost: 15,
                theme: { bg: '#7f1d1d', accent: '#f87171', dark: '#450a0a' },
                flavorText: 'Authentic Italian flavors!',
                milestones: [4000, 20000, 100000, 500000]
            },
            arcade: { 
                name: 'Arcade', price: 12000, icon: '', desc: 'Fun and games',
                baseIncome: 60, cycleTime: 300, managerCost: 60000, supplyCost: 30,
                theme: { bg: '#581c87', accent: '#c084fc', dark: '#3b0764' },
                flavorText: 'Insert coin to continue...',
                milestones: [10000, 50000, 250000, 1000000]
            },
            gym: { 
                name: 'Gym', price: 30000, icon: '', desc: 'Fitness empire',
                baseIncome: 120, cycleTime: 360, managerCost: 150000, supplyCost: 60,
                theme: { bg: '#065f46', accent: '#34d399', dark: '#022c22' },
                flavorText: 'No pain, no gain!',
                milestones: [25000, 125000, 600000, 3000000]
            },
            hotel: { 
                name: 'Hotel', price: 80000, icon: '', desc: '5-star service',
                baseIncome: 250, cycleTime: 480, managerCost: 400000, supplyCost: 125,
                theme: { bg: '#854d0e', accent: '#fbbf24', dark: '#422006' },
                flavorText: 'Where luxury meets comfort.',
                milestones: [70000, 350000, 1500000, 8000000]
            },
            techStartup: { 
                name: 'Tech Startup', price: 200000, icon: '', desc: 'Disrupt the market',
                baseIncome: 500, cycleTime: 600, managerCost: 1000000, supplyCost: 250,
                theme: { bg: '#166534', accent: '#4ade80', dark: '#052e16' },
                flavorText: 'Move fast and ship things!',
                milestones: [180000, 900000, 4500000, 20000000]
            },
            spacePort: { 
                name: 'Space Port', price: 1000000, icon: '', desc: 'To the stars!',
                baseIncome: 2000, cycleTime: 900, managerCost: 5000000, supplyCost: 1000,
                theme: { bg: '#0f172a', accent: '#6366f1', dark: '#1e1b4b' },
                flavorText: 'The final frontier awaits...',
                milestones: [900000, 4500000, 20000000, 100000000]
            }
        },
        plotExpansion: { name: 'Garden Plot', price: 100, icon: '', desc: 'Unlock 1 additional garden plot' }
    },

    // Multiplier to make pet decay more visible during short sessions (1 = real time)
    // Lowered from 3 to 1 for more realistic survival times
    PET_DECAY_TIMESCALE: 1,

    getDefaultState() {
        return {
            xp: 0,
            level: 1,
            coins: 0,
            gems: 0,
            totalCoinsEarned: 0,
            totalGemsEarned: 0,
            combo: { current: 0, best: 0, multiplier: 1.0, lastCorrectTime: null },
            achievements: {},
            powerUpInventory: { fiftyFifty: 1, skipQuestion: 1, extraTime: 2, doubleXp: 0, showHint: 1 },
            categoryMastery: {},
            studyBuddy: {
                name: 'Buddy', species: 'bird', stage: 1, totalXpFed: 0, mood: 'sleepy', lastFed: null,
                hunger: 100, happiness: 100, hydration: 100, lastDecayCheck: null,
                careMinutes: 0, lastCareCheck: null, studyMinutes: 0,
                sick: false, lastInteraction: null,
                accessories: [], totalMealsEaten: 0,
                // Per-pet housing/care items
                petCare: {
                    foodBowl: { level: 0, capacity: 0 },
                    waterBowl: { level: 0, capacity: 0 },
                    comfortBonus: 0,
                    allDecayReduction: 0,
                    housing: {} // owned housing items for this pet
                }
            },
            pets: [],
            activePetIdx: 0,
            garden: {
                plots: [],
                decorations: [],
                unlockedPlots: 3,
                waterLevel: 100,
                lastWaterDecay: null,
                lastGrowthTick: null,
                totalHarvests: 0
            },
            inventory: {
                petFood: { kibble: 3, treat: 1, feast: 0, goldfish: 0 },
                seeds: { sunflower: 2, cactus: 0, bonsai: 0, crystal: 0, rainbow: 0, moneyTree: 0, starfruit: 0, dragonFruit: 0, moonflower: 0, goldenApple: 0, ancientOak: 0 },
                gardenItems: { water: 5, fertilizer: 0, magicDust: 0, evoStone: 0 },
                battleItems: { healthPotion: 0, shieldCharm: 0, powerBerry: 0, resStone: 5 },
                decorations: [],
                petAccessories: [],
                petHousing: {},
                furniture: {},
                vehicles: {}
            },
            housing: { current: null, owned: [], conditions: {}, lastDecayCheck: null, laborers: 0 },
            businesses: {
                owned: {},          // { businessId: { level: 1, hasManager: false, progress: 0, inventory: {}, adActive: false, adExpires: null, machines: 0, balance: 0 } }
                totalEarned: 0,
                lastTick: null,
                studyMultiplier: 1.0,  // Bonus from answering questions
                studyBoostExpires: null
            },
            graveyard: [],
            retiredNames: [],
            battle: {
                currentChapter: 1,
                currentEnemy: 0,
                chaptersCompleted: [],
                totalWins: 0,
                totalLosses: 0,
                bestChapter: 0
            },
            currentTitle: 'Curious Beginner',
            settings: {
                enabled: true,
                sounds: true,
                confetti: true,
                xpPopups: true,
                pet: true,
                garden: true,
                petBuffs: true,
                coinPopups: true,
                pixelArt: false,
                volume: 50,
                buddyPosition: null
            },
            stats: {
                totalXpEarned: 0,
                questionsAnswered: 0,
                testsCompleted: 0,
                perfectTests: 0,
                longestStreak: 0,
                powerUpsUsed: 0,
                lastActiveDate: null,
                lastActiveTimestamp: null
            },
            doubleXpRemaining: 0,
            questionStartTime: null,
            momentum: this.getDefaultMomentumState()
        };
    },

    // In-memory state cache  prevents read-modify-write race conditions
    // when chained calls (checkAchievements  unlockAchievement  awardXp  feedBuddy)
    // each read stale copies from localStorage
    _state: null,
    _saveTimeout: null,
    _rewardToastTimer: null,
    _momentumToastTimer: null,

    // Get current state (reads localStorage only on first call, then returns cached)
    getState() {
        if (!this._state) {
            const defaults = this.getDefaultState();
            const saved = Store.get('gamification', {});
            try {
                const m = (d, s) => ({ ...d, ...(s && typeof s === 'object' ? s : {}) });
                const mDeep = (d, s) => {
                    const result = { ...d };
                    if (s && typeof s === 'object') {
                        for (const k of Object.keys(s)) {
                            if (typeof d[k] === 'object' && d[k] !== null && !Array.isArray(d[k]) && typeof s[k] === 'object' && s[k] !== null && !Array.isArray(s[k])) {
                                result[k] = { ...d[k], ...s[k] };
                            } else {
                                result[k] = s[k];
                            }
                        }
                    }
                    return result;
                };
                this._state = { ...defaults, ...saved,
                    combo: m(defaults.combo, saved.combo),
                    settings: m(defaults.settings, saved.settings),
                    stats: m(defaults.stats, saved.stats),
                    studyBuddy: m(defaults.studyBuddy, saved.studyBuddy),
                    powerUpInventory: m(defaults.powerUpInventory, saved.powerUpInventory),
                    garden: m(defaults.garden, saved.garden),
                    inventory: mDeep(defaults.inventory, saved.inventory),
                    battle: m(defaults.battle, saved.battle),
                    momentum: m(defaults.momentum, saved.momentum)
                };
                // Multi-pet sync: migrate and sync active pet
                const st = this._state;
                if (!st.studyBuddy.species) st.studyBuddy.species = 'bird';
                
                // Clean up graveyard - remove default "Buddy" pets that were never really used
                if (st.graveyard && st.graveyard.length > 0) {
                    const graveSeen = new Set();
                    st.graveyard = st.graveyard.filter(g => {
                        if (!g || !g.name) return false;
                        // Filter out default "Buddy" pets with minimal interaction
                        if (g.name === 'Buddy' && g.species === 'bird' && (g.totalXpFed || 0) < 100) {
                            return false; // Remove unused default pet from graveyard
                        }
                        const key = g.name.toLowerCase();
                        if (graveSeen.has(key)) return false;
                        graveSeen.add(key);
                        return true;
                    });
                }
                
                if (!st.pets || st.pets.length === 0) {
                    // Don't auto-create default pet if user has graveyard (had real pets before)
                    if (st.graveyard && st.graveyard.length > 0) {
                        st.pets = [];
                        st.studyBuddy.dead = true;
                    } else {
                        st.pets = [st.studyBuddy];
                    }
                    st.activePetIdx = 0;
                } else {
                    // Clean up duplicate pets by name AND remove unused default Buddy pets
                    const seenNames = new Set();
                    const hasRealPet = st.pets.some(p => p && p.name !== 'Buddy');
                    st.pets = st.pets.filter(p => {
                        if (!p || !p.name) return false;
                        // Remove default Buddy if user has other real pets and Buddy is unused
                        if (hasRealPet && p.name === 'Buddy' && p.species === 'bird' && (p.totalXpFed || 0) < 100) {
                            return false;
                        }
                        const key = p.name.toLowerCase();
                        if (seenNames.has(key)) return false;
                        seenNames.add(key);
                        return true;
                    });
                    // Ensure activePetIdx is valid
                    if (st.activePetIdx >= st.pets.length) st.activePetIdx = 0;
                    // Load active pet into studyBuddy
                    const idx = st.activePetIdx || 0;
                    if (st.pets[idx]) st.studyBuddy = st.pets[idx];
                }
            } catch (e) {
                console.error('Corrupt gamification data, resetting to defaults:', e);
                this._state = defaults;
            }
        }
        return this._state;
    },

    // Save state  updates in-memory cache immediately, debounces localStorage write
    saveState(state) {
        // Sync active pet back to pets array
        if (state.pets && state.pets.length > 0) {
            state.pets[state.activePetIdx || 0] = state.studyBuddy;
        }
        if (state.stats) {
            state.stats.lastActiveTimestamp = Date.now();
        }
        this._state = state;
        if (this._saveTimeout) clearTimeout(this._saveTimeout);
        this._saveTimeout = setTimeout(() => Store.set('gamification', state), 100);
    },

    // Flush to localStorage immediately (for beforeunload, export, etc.)
    saveStateImmediate(state) {
        if (state) this._state = state;
        if (this._state && this._state.stats) {
            this._state.stats.lastActiveTimestamp = Date.now();
        }
        if (this._saveTimeout) clearTimeout(this._saveTimeout);
        if (this._state) Store.set('gamification', this._state);
    },

    // Check if enabled
    isEnabled() {
        return this.getState().settings.enabled;
    },

    // Get level threshold (exponential curve)
    getLevelThreshold(level) {
        return Math.floor(100 * Math.pow(1.5, level - 1));
    },

    // Get total XP needed for level
    getTotalXpForLevel(level) {
        let total = 0;
        for (let i = 1; i < level; i++) {
            total += this.getLevelThreshold(i);
        }
        return total;
    },

    // Get title for level
    getTitleForLevel(level) {
        let title = 'Curious Beginner';
        for (const [lvl, t] of Object.entries(this.TITLES)) {
            if (level >= parseInt(lvl)) title = t;
        }
        return title;
    },

    // Award XP
    awardXp(action, options = {}) {
        if (!this.isEnabled()) return 0;

        const state = this.getState();
        let xpAmount = this.XP_VALUES[action] || 0;
        const momentum = this.getActiveMomentum(state);

        // Apply multipliers
        if (options.multiplier) xpAmount = Math.floor(xpAmount * options.multiplier);
        let appliedMomentum = null;
        if (momentum && momentum.xpMultiplier && momentum.xpMultiplier !== 1) {
            xpAmount = Math.floor(xpAmount * momentum.xpMultiplier);
            appliedMomentum = momentum;
        }
        if (state.combo.multiplier > 1) xpAmount = Math.floor(xpAmount * state.combo.multiplier);
        
        // Apply daily streak multiplier bonus
        const streakMultiplier = this.getStreakMultiplier();
        if (streakMultiplier > 1) xpAmount = Math.floor(xpAmount * streakMultiplier);
        if (state.doubleXpRemaining > 0) {
            xpAmount *= 2;
            state.doubleXpRemaining--;
        }

        const buffInfo = this.applyBuffScalars('xp', xpAmount);
        xpAmount = buffInfo.amount;

        // Add combo bonus
        if (options.withCombo && state.combo.current > 0) {
            xpAmount += this.XP_VALUES.comboBonus * state.combo.current;
        }

        const oldLevel = state.level;
        state.xp += xpAmount;
        state.stats.totalXpEarned += xpAmount;

        // Check for level up (award intermediate milestone rewards)
        const levelRewards = [];
        while (state.xp >= this.getLevelThreshold(state.level)) {
            state.xp -= this.getLevelThreshold(state.level);
            state.level++;
            state.currentTitle = this.getTitleForLevel(state.level);
            const lvlRewards = [];
            if (state.level % 5 === 0) {
                state.powerUpInventory.fiftyFifty = (state.powerUpInventory.fiftyFifty || 0) + 1;
                state.powerUpInventory.doubleXp = (state.powerUpInventory.doubleXp || 0) + 1;
                lvlRewards.push('+1 50/50, +1 2x XP');
            }
            // Auto-unlock garden plots at milestone levels
            if (this.PLOT_UNLOCK_LEVELS.includes(state.level)) {
                const maxPlots = 9;
                if ((state.garden.unlockedPlots || 3) < maxPlots) {
                    state.garden.unlockedPlots = Math.min(maxPlots, (state.garden.unlockedPlots || 3) + 1);
                    lvlRewards.push('+1 Garden Plot');
                }
            }
            // Evolution stones at levels 10, 15, 20
            if (state.level === 10 || state.level === 15 || state.level === 20) {
                state.inventory.gardenItems.evoStone = (state.inventory.gardenItems.evoStone || 0) + 1;
                lvlRewards.push('+1 Evolution Stone');
            }
            if (lvlRewards.length > 0) {
                levelRewards.push('Lv' + state.level + ': ' + lvlRewards.join(', '));
            }
        }

        this.saveState(state);

        // Show XP popup
        if (state.settings.xpPopups && xpAmount > 0) {
            this.showXpPopup(xpAmount);
        }

        // Show level up
        if (state.level > oldLevel) {
            this.showLevelUp(state.level, state.currentTitle, levelRewards.join(' | '));
            this.checkLevelAchievements(state.level);
        }

        // Update buddy
        this.feedBuddy(xpAmount);

        // Award coins alongside XP
        const coinAction = this.COIN_VALUES[action];
        if (coinAction !== undefined && coinAction > 0) {
            this.awardCoins(coinAction, action, appliedMomentum, buffInfo);
        }

        // Update home XP bar if visible
        this.renderXpBar();

        return xpAmount;
    },

    // Award coins
    awardCoins(amount, reason, momentum, xpBuffInfo) {
        if (!this.isEnabled() || amount <= 0) return 0;

        const state = this.getState();
        let coinsToAdd = amount;
        
        // Apply garden permanent coin bonus (from Ancient Oak harvests)
        if (state.gardenCoinBonus && state.gardenCoinBonus > 0) {
            coinsToAdd = Math.floor(coinsToAdd * (1 + state.gardenCoinBonus));
        }
        
        if (momentum && momentum.coinMultiplier && momentum.coinMultiplier !== 1) {
            coinsToAdd = Math.floor(coinsToAdd * momentum.coinMultiplier);
        }
        const coinBuff = this.applyBuffScalars('coin', coinsToAdd);
        coinsToAdd = coinBuff.amount;
        state.coins = (state.coins || 0) + coinsToAdd;
        state.totalCoinsEarned = (state.totalCoinsEarned || 0) + coinsToAdd;
        this.saveState(state);
        if (state.totalCoinsEarned >= 1000) this.unlockAchievement('big_spender');
        if (state.settings.coinPopups) {
            this.showCoinPopup(coinsToAdd);
        }
        this.renderXpBar();
        const xpBuffGain = xpBuffInfo && xpBuffInfo.amountDelta > 0;
        const coinBuffGain = coinBuff.amountDelta > 0;
        if (reason === 'correctAnswer' && (xpBuffGain || coinBuffGain)) {
            this.showAnswerReward({
                icon: '',
                title: 'Buff stacking!',
                xp: xpBuffGain ? xpBuffInfo.amountDelta : null,
                xpBreakdown: xpBuffInfo?.breakdown,
                coins: coinBuffGain ? coinBuff.amountDelta : null,
                coinBreakdown: coinBuff.breakdown,
                note: 'Pet & garden boosts applied.'
            });
        }
        return coinsToAdd;
    },

    // Spend coins (returns true if successful)
    spendCoins(amount) {
        const state = this.getState();
        if ((state.coins || 0) < amount) return false;
        state.coins -= amount;
        this.saveState(state);
        this.renderXpBar();
        return true;
    },

    // Award gems (premium currency - harder to earn)
    awardGems(amount, reason) {
        if (!this.isEnabled() || amount <= 0) return 0;
        const state = this.getState();
        state.gems = (state.gems || 0) + amount;
        state.totalGemsEarned = (state.totalGemsEarned || 0) + amount;
        this.saveState(state);
        this.showGemPopup(amount);
        this.renderXpBar();
        return amount;
    },

    // Spend gems (returns true if successful)
    spendGems(amount) {
        const state = this.getState();
        if ((state.gems || 0) < amount) return false;
        state.gems -= amount;
        this.saveState(state);
        this.renderXpBar();
        return true;
    },

    // Show gem popup
    showGemPopup(amount) {
        const popup = document.createElement('div');
        popup.className = 'xp-popup';
        popup.style.background = 'linear-gradient(135deg, #a855f7, #7c3aed)';
        popup.textContent = '+' + amount + ' ';
        popup.style.left = (Math.random() * 60 + 20) + '%';
        popup.style.top = (window.scrollY + window.innerHeight * 0.35) + 'px';
        document.body.appendChild(popup);
        setTimeout(() => popup.remove(), 1500);
    },

    // Show coin popup
    showCoinPopup(amount) {
        const popup = document.createElement('div');
        popup.className = 'coin-popup';
        popup.textContent = '+' + amount + ' coins';
        popup.style.left = (Math.random() * 40 + 50) + '%';
        popup.style.top = (window.scrollY + window.innerHeight * 0.35) + 'px';
        document.body.appendChild(popup);
        setTimeout(() => popup.remove(), 1500);
    },

    // Increment combo
    incrementCombo() {
        if (!this.isEnabled()) return;
        
        // Trigger business study boost on correct answer
        Business.onCorrectAnswer();

        const state = this.getState();
        state.combo.current++;
        state.combo.lastCorrectTime = Date.now();

        // Update multiplier (max 3x at 20 streak)
        state.combo.multiplier = Math.min(3.0, 1.0 + (state.combo.current * 0.1));

        // Update best streak
        if (state.combo.current > state.combo.best) {
            state.combo.best = state.combo.current;
        }
        if (state.combo.current > state.stats.longestStreak) {
            state.stats.longestStreak = state.combo.current;
        }

        this.saveState(state);
        this.updateComboDisplay();
        if (state.momentum && state.momentum.active) {
            this.incrementMomentumProgress(1);
        }

        // Check streak achievements
        if (state.combo.current === 10) this.unlockAchievement('ten_streak');
        if (state.combo.current === 20) this.unlockAchievement('twenty_streak');

        // Play combo sound
        if (state.settings.sounds && state.combo.current > 1) {
            SoundFX.play('combo');
        }
    },

    // Reset combo
    resetCombo() {
        if (!this.isEnabled()) return;

        const state = this.getState();
        state.combo.current = 0;
        state.combo.multiplier = 1.0;
        this.saveState(state);
        this.updateComboDisplay();
        this.handleMomentumBreak('combo');
    },

    // Update combo display
    updateComboDisplay() {
        const state = this.getState();
        const el = document.getElementById('comboDisplay');
        if (!el) return;

        if (state.combo.current >= 2) {
            el.classList.add('active');
            document.getElementById('comboCount').textContent = 'x' + state.combo.current;
            document.getElementById('comboMult').textContent = state.combo.multiplier.toFixed(1) + 'x';
        } else {
            el.classList.remove('active');
        }
    },

    // Show XP popup
    showXpPopup(amount) {
        const popup = document.createElement('div');
        popup.className = 'xp-popup';
        popup.textContent = '+' + amount + ' XP';
        popup.style.left = (Math.random() * 60 + 20) + '%';
        popup.style.top = (window.scrollY + window.innerHeight * 0.4) + 'px';
        document.body.appendChild(popup);

        setTimeout(() => popup.remove(), 1500);
    },

    // Show level up modal
    showLevelUp(level, title, rewardsText) {
        document.getElementById('levelupNum').textContent = level;
        document.getElementById('levelupTitle').textContent = title;
        document.getElementById('levelupRewards').textContent = rewardsText ? 'Rewards: ' + rewardsText : '';

        document.getElementById('levelupOverlay').classList.add('active');

        // Play sound and confetti
        const state = this.getState();
        if (state.settings.sounds) SoundFX.play('levelUp');
        if (state.settings.confetti) this.triggerConfetti();

        // Award gems on level up (2 gems per level, bonus 5 every 5 levels)
        const gemReward = level % 5 === 0 ? 7 : 2;
        this.awardGems(gemReward, 'levelUp');

        // Award trinket on level up (guaranteed every 5 levels, 20% chance otherwise)
        if (state.settings.trinketsEnabled !== false) {
            const guaranteedTrinket = level % 5 === 0;
            if (guaranteedTrinket || Math.random() < 0.2) {
                const trinket = Backpack.awardRandomTrinket();
                if (trinket) {
                    setTimeout(() => Backpack.showTrinketToast(trinket), 2500);
                }
            }
        }
    },

    // Close level up modal
    closeLevelUp() {
        document.getElementById('levelupOverlay').classList.remove('active');
    },

    // Unlock achievement
    unlockAchievement(id) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        if (state.achievements[id]) return; // Already unlocked

        const achievement = this.ACHIEVEMENTS.find(a => a.id === id);
        if (!achievement) return;

        state.achievements[id] = Date.now();
        state.xp += achievement.xp;
        state.stats.totalXpEarned += achievement.xp;

        // Check for level up from achievement XP
        const oldLevel = state.level;
        const levelRewards = [];
        while (state.xp >= this.getLevelThreshold(state.level)) {
            state.xp -= this.getLevelThreshold(state.level);
            state.level++;
            state.currentTitle = this.getTitleForLevel(state.level);
            const lvlR = [];
            if (state.level % 5 === 0) {
                state.powerUpInventory.fiftyFifty = (state.powerUpInventory.fiftyFifty || 0) + 1;
                state.powerUpInventory.doubleXp = (state.powerUpInventory.doubleXp || 0) + 1;
                lvlR.push('+1 50/50, +1 2x XP');
            }
            if (this.PLOT_UNLOCK_LEVELS.includes(state.level)) {
                if ((state.garden.unlockedPlots || 3) < 9) {
                    state.garden.unlockedPlots = Math.min(9, (state.garden.unlockedPlots || 3) + 1);
                    lvlR.push('+1 Garden Plot');
                }
            }
            if (state.level === 10 || state.level === 15 || state.level === 20) {
                state.inventory.gardenItems.evoStone = (state.inventory.gardenItems.evoStone || 0) + 1;
                lvlR.push('+1 Evolution Stone');
            }
            if (lvlR.length > 0) levelRewards.push('Lv' + state.level + ': ' + lvlR.join(', '));
        }
        this.saveState(state);

        // Show toast
        this.showAchievementToast(achievement);

        // Show level up if triggered by achievement XP
        if (state.level > oldLevel) {
            this.showLevelUp(state.level, state.currentTitle, levelRewards.join(' | '));
            this.checkLevelAchievements(state.level);
        }

        // Play sound
        if (state.settings.sounds) SoundFX.play('achievement');
        if (state.settings.confetti) this.triggerConfetti();

        // Award 1 gem for each achievement unlock (premium currency)
        this.awardGems(1, 'achievement');

        // Award random trinket on achievement unlock (30% chance)
        if (state.settings.trinketsEnabled !== false && Math.random() < 0.3) {
            const trinket = Backpack.awardRandomTrinket();
            if (trinket && trinket.isNew) {
                setTimeout(() => Backpack.showTrinketToast(trinket), 2000);
            }
        }
    },

    // Show achievement toast
    showAchievementToast(achievement) {
        const toast = document.getElementById('achievementToast');
        if (!toast) return;

        document.getElementById('achIcon').textContent = achievement.icon;
        document.getElementById('achName').textContent = achievement.name;
        document.getElementById('achDesc').textContent = achievement.desc;
        document.getElementById('achXp').textContent = '+' + achievement.xp + ' XP';

        toast.classList.remove('hidden');

        setTimeout(() => toast.classList.add('hidden'), 4000);
    },

    // Check achievements after answering
    checkAchievements(isCorrect, timeSpent) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        state.stats.questionsAnswered++;
        this.saveState(state);

        // First correct
        if (isCorrect && !state.achievements['first_correct']) {
            this.unlockAchievement('first_correct');
        }

        // Speed demon
        if (isCorrect && timeSpent && timeSpent < 10000) {
            this.unlockAchievement('speed_demon');
        }

        // Century and thousand
        if (state.stats.questionsAnswered >= 100) this.unlockAchievement('century');
        if (state.stats.questionsAnswered >= 1000) this.unlockAchievement('thousand');

        // Time-based achievements
        const hour = new Date().getHours();
        if (hour < 7) this.unlockAchievement('early_bird');
        if (hour >= 23) this.unlockAchievement('night_owl');
    },

    // Check level achievements
    checkLevelAchievements(level) {
        if (level >= 5) this.unlockAchievement('level_5');
        if (level >= 10) this.unlockAchievement('level_10');
        if (level >= 20) this.unlockAchievement('level_20');
    },

    // Update category mastery
    updateCategoryMastery(category, isCorrect) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        if (!state.categoryMastery[category]) {
            state.categoryMastery[category] = { correct: 0, total: 0, level: null, totalTimeMs: 0 };
        }

        state.categoryMastery[category].total++;
        if (isCorrect) state.categoryMastery[category].correct++;
        
        // Track time spent per category (cap at 5 min to filter outliers)
        const rawTime = this.getQuestionTime() || 0;
        const timeSpent = Math.min(rawTime, 5 * 60 * 1000);
        state.categoryMastery[category].totalTimeMs = (state.categoryMastery[category].totalTimeMs || 0) + timeSpent;

        const cm = state.categoryMastery[category];
        const accuracy = cm.total > 0 ? (cm.correct / cm.total) * 100 : 0;

        // Update mastery level
        if (cm.total >= 50 && accuracy >= 95) cm.level = 'platinum';
        else if (cm.total >= 30 && accuracy >= 90) cm.level = 'gold';
        else if (cm.total >= 20 && accuracy >= 80) cm.level = 'silver';
        else if (cm.total >= 10 && accuracy >= 70) cm.level = 'bronze';

        // Check for category master achievement (gold or platinum)
        if ((cm.level === 'gold' || cm.level === 'platinum') && !state.achievements['category_master']) {
            this.unlockAchievement('category_master');
        }

        this.saveState(state);
    },

    // Feed buddy XP
    feedBuddy(xp) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        const buddy = state.studyBuddy;
        buddy.totalXpFed += xp;
        buddy.lastFed = Date.now();
        buddy.lastInteraction = Date.now();

        // Studying gives a small happiness boost
        buddy.happiness = Math.min(100, (buddy.happiness ?? 100) + 1);

        // Accumulate study minutes (~1 min per question)
        buddy.studyMinutes = (buddy.studyMinutes || 0) + 1;
        // Study time counts 3x toward care (active study > passive time)
        buddy.careMinutes = (buddy.careMinutes || 0) + 3;

        // Studying heals sickness
        if (buddy.sick && buddy.hunger > 30 && buddy.happiness > 30) {
            buddy.sick = false;
        }

        // Check for evolution  needs BOTH enough XP AND enough care time
        for (let i = this.BUDDY_STAGES.length - 1; i >= 0; i--) {
            const req = this.BUDDY_STAGES[i];
            if (buddy.totalXpFed >= req.xpNeeded && (buddy.careMinutes || 0) >= req.careNeeded) {
                if (buddy.stage < req.stage) {
                    buddy.stage = req.stage;
                    this.showAchievementToast({
                        icon: this.getSpeciesEmoji(buddy.species, req.stage),
                        name: buddy.name + ' evolved!',
                        desc: 'Now a ' + this.getSpeciesStageName(buddy.species, req.stage),
                        xp: 0
                    });
                }
                break;
            }
        }

        this.saveState(state);
        this.updateBuddyWidget();
    },

    // Update buddy mood
    updateBuddyMood() {
        const state = this.getState();
        const buddy = state.studyBuddy;
        const h = buddy.hunger ?? 100;
        const hp = buddy.happiness ?? 100;

        if (buddy.sick) buddy.mood = 'sick';
        else if (h > 75 && hp > 75) buddy.mood = 'happy';
        else if (h > 50 && hp > 50) buddy.mood = 'content';
        else if (h < 25 || hp < 25) buddy.mood = 'miserable';
        else if (h < 50) buddy.mood = 'hungry';
        else buddy.mood = 'sad';

        this.saveState(state);
        this.updateBuddyWidget();
    },

    // Update buddy widget
    updateBuddyWidget() {
        const state = this.getState();
        const el = document.getElementById('studyBuddy');
        if (!el) return;

        // Hide if pet setting disabled, pet is dead, or no pets exist
        if (!state.settings.pet || state.studyBuddy.dead || (state.pets || []).length === 0) {
            el.classList.remove('active');
            return;
        }

        const buddy = state.studyBuddy;
        const stage = this.BUDDY_STAGES.find(s => s.stage === buddy.stage) || this.BUDDY_STAGES[0];
        const nextStage = this.BUDDY_STAGES.find(s => s.stage === buddy.stage + 1);

        el.classList.add('active');
        el.classList.remove('urgent', 'sick');
        const hunger = buddy.hunger ?? 100;
        const happiness = buddy.happiness ?? 100;
        if (buddy.sick) el.classList.add('sick');
        else if (hunger < 30 || happiness < 30) el.classList.add('urgent');

        this._applyBuddyPosition(el, state.settings.buddyPosition);
        this._ensureBuddyDraggable(el);

        const accessories = buddy.accessories || [];
        const accHtml = accessories.map(a => {
            const item = this.SHOP?.cosmetics?.[a];
            return item ? `<span class="buddy-acc acc-${a}">${item.icon}</span>` : '';
        }).join('');
        document.getElementById('buddySprite').innerHTML = Sprites.petSprite(buddy.stage, this.getSpeciesEmoji(buddy.species, buddy.stage), 36) + accHtml;
        document.getElementById('buddyName').textContent = buddy.name;
        const moodStr = buddy.mood || 'content';
        const moodDisplay = buddy.sick ? 'Sick \ud83e\udd12' : moodStr.charAt(0).toUpperCase() + moodStr.slice(1);
        document.getElementById('buddyMood').textContent = moodDisplay;

        const buffWrap = document.getElementById('buddyBuffs');
        if (buffWrap) {
            const buffs = this.getActiveBuffs();
            buffWrap.innerHTML = buffs.length ? buffs.map(buff => `<div class="buddy-buff" title="${escapeHtml(buff.description)}">${buff.icon} ${buff.label} <span>${buff.value}</span></div>`).join('') : '<div class="buddy-buff muted">No active buffs</div>';
        }

        // Progress to next stage
        if (nextStage) {
            const currentXp = buddy.totalXpFed - stage.xpNeeded;
            const neededXp = nextStage.xpNeeded - stage.xpNeeded;
            const pct = Math.min(100, Math.floor((currentXp / neededXp) * 100));
            document.getElementById('buddyProgress').style.width = pct + '%';
        } else {
            document.getElementById('buddyProgress').style.width = '100%';
        }
    },

    _applyBuddyPosition(el, pos) {
        if (!el) return;
        if (pos && typeof pos.left === 'number' && typeof pos.top === 'number') {
            el.style.left = pos.left + 'px';
            el.style.top = pos.top + 'px';
            el.style.bottom = 'auto';
        } else {
            el.style.left = '20px';
            el.style.bottom = '100px';
            el.style.top = 'auto';
        }
    },

    _ensureBuddyDraggable(el) {
        if (!el || el.dataset.dragInit === '1') return;
        el.dataset.dragInit = '1';
        el.setAttribute('role', 'button');
        el.setAttribute('tabindex', '0');
        const self = this;
        let pointerId = null;
        let offsetX = 0;
        let offsetY = 0;
        let startX = 0;
        let startY = 0;
        let moved = false;
        let pointerDownAt = 0;

        const clamp = (val, min, max) => Math.min(Math.max(val, min), max);

        const endDrag = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            el.releasePointerCapture(pointerId);
            pointerId = null;
            document.removeEventListener('pointermove', onPointerMove);
            document.removeEventListener('pointerup', endDrag);
            document.removeEventListener('pointercancel', endDrag);
            el.classList.remove('dragging');
            const wasDrag = moved;
            moved = false;
            const pressDuration = Date.now() - pointerDownAt;
            pointerDownAt = 0;
            if (!wasDrag && pressDuration < 350) {
                self.showBuddyInfo();
            }
        };

        const onPointerMove = (e) => {
            if (pointerId === null || e.pointerId !== pointerId) return;
            e.preventDefault();
            const left = clamp(e.clientX - offsetX, 5, window.innerWidth - el.offsetWidth - 5);
            const top = clamp(e.clientY - offsetY, 50, window.innerHeight - el.offsetHeight - 5);
            el.style.left = left + 'px';
            el.style.top = top + 'px';
            el.style.bottom = 'auto';
            if (!moved && (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5)) {
                moved = true;
                el.classList.add('dragging');
            }
            const state = self.getState();
            state.settings.buddyPosition = { left, top };
            self.saveState(state);
        };

        el.addEventListener('pointerdown', (e) => {
            if (e.button !== 0 || pointerId !== null) return;
            pointerId = e.pointerId;
            const rect = el.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            startX = e.clientX;
            startY = e.clientY;
            pointerDownAt = Date.now();
            moved = false;
            el.setPointerCapture(pointerId);
            document.addEventListener('pointermove', onPointerMove, { passive: false });
            document.addEventListener('pointerup', endDrag);
            document.addEventListener('pointercancel', endDrag);
        });

        el.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                self.showBuddyInfo();
            }
        });
    },

    showAnswerReward(reward) {
        if (!reward) return;
        const toast = document.getElementById('rewardToast');
        if (!toast) return;
        const iconEl = document.getElementById('rewardToastIcon');
        const titleEl = document.getElementById('rewardToastTitle');
        const breakdownEl = document.getElementById('rewardToastBreakdown');
        iconEl.textContent = reward.icon || (reward.isCorrect ? '' : '');
        titleEl.textContent = reward.title || (reward.isCorrect ? 'Great strike!' : 'Keep going!');
        const parts = [];
        if (reward.xp) {
            const xpText = reward.xpBreakdown ? `${reward.xp} XP ${reward.xpBreakdown}` : `${reward.xp} XP`;
            parts.push(`<span> ${xpText}</span>`);
        }
        if (reward.coins) {
            const coinText = reward.coinBreakdown ? `${reward.coins} coins ${reward.coinBreakdown}` : `${reward.coins} coins`;
            parts.push(`<span> ${coinText}</span>`);
        }
        if (reward.combo) parts.push(`<span> x${reward.combo.toFixed(1)} combo</span>`);
        if (reward.note) parts.push(`<span>${escapeHtml(reward.note)}</span>`);
        breakdownEl.innerHTML = parts.join('');
        toast.classList.add('show');
        clearTimeout(this._rewardToastTimer);
        this._rewardToastTimer = setTimeout(() => toast.classList.remove('show'), 2000);
    },

    // Show buddy info  opens garden screen with pet modal
    showBuddyInfo() {
        if (typeof Garden !== 'undefined' && this.getState().settings.garden) {
            Garden.show();
            setTimeout(() => PetModal.show(), 100);
        } else {
            PetModal.show();
        }
    },

    // Check login bonus
    checkLoginBonus() {
        if (!this.isEnabled()) return;

        const state = this.getState();
        const _d = new Date();
        const today = _d.getFullYear() + '-' + String(_d.getMonth() + 1).padStart(2, '0') + '-' + String(_d.getDate()).padStart(2, '0');

        if (state.stats.lastActiveDate !== today) {
            // Check for comeback bonus (3+ days away)
            if (state.stats.lastActiveDate) {
                const lastDate = new Date(state.stats.lastActiveDate);
                const daysDiff = Math.floor((Date.now() - lastDate.getTime()) / (1000 * 60 * 60 * 24));
                if (daysDiff >= 3) {
                    this.unlockAchievement('comeback');
                }
            }

            // Award login bonus
            this.awardXp('loginBonus');

            // awardXp already mutated the cached state, so just update lastActiveDate
            state.stats.lastActiveDate = today;
            this.saveState(state);
        }

        // Update buddy mood
        this.updateBuddyMood();
    },

    // Render XP bar on home screen
    renderXpBar() {
        const el = document.getElementById('xpBarContainer');
        if (!el) return;

        if (!this.isEnabled()) {
            el.innerHTML = '';
            return;
        }

        const state = this.getState();
        const threshold = this.getLevelThreshold(state.level);
        const pct = Math.floor((state.xp / threshold) * 100);
        const stage = this.BUDDY_STAGES.find(s => s.stage === state.studyBuddy.stage) || this.BUDDY_STAGES[0];

        const coins = state.coins || 0;
        el.innerHTML = `
            <div class="xp-bar-container">
                <div class="xp-level">
                    <div>Lv ${state.level}</div>
                    <div class="xp-title">${escapeHtml(state.currentTitle || this.getTitleForLevel(state.level))}</div>
                </div>
                <div class="xp-bar">
                    <div class="xp-fill" style="width:${Math.min(100, pct)}%"></div>
                </div>
                <div class="xp-info">
                    <div class="xp-text">${state.xp} / ${threshold} XP</div>
                    <div class="xp-title">${stage ? stage.stageName || 'Companion' : 'Companion'}</div>
                </div>
                <div class="coin-display"> ${coins}</div>
                <div class="momentum-pill-wrap" id="momentumPills"></div>
                <div class="buddy-mini" onclick="Gamification.showBuddyInfo()" title="Buddy mood">
                    ${this.getSpeciesEmoji(state.studyBuddy.species, state.studyBuddy.stage)}
                </div>
                `;
        this.renderMomentumPillsInto(document.getElementById('momentumPills'));
        // Update header coins
        this.updateHeaderCoins();
    },

    updateHeaderCoins() {
        const state = this.getState();
        const coins = state.coins || 0;
        const gems = state.gems || 0;
        const headerCoins = document.getElementById('headerCoins');
        const headerGems = document.getElementById('headerGems');
        if (headerCoins) headerCoins.textContent = ' ' + coins.toLocaleString();
        if (headerGems) headerGems.textContent = ' ' + gems.toLocaleString();
    },

    // Trigger confetti effect
    _confettiAnimId: null,
    triggerConfetti() {
        const state = this.getState();
        if (!state.settings.confetti) return;

        const canvas = document.getElementById('confettiCanvas');
        if (!canvas) return;

        // Cancel any existing confetti animation
        if (this._confettiAnimId) cancelAnimationFrame(this._confettiAnimId);

        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const colors = ['#ff6b35', '#f7931e', '#ffd60a', '#27ae60', '#2980b9', '#9b59b6'];

        for (let i = 0; i < 100; i++) {
            particles.push({
                x: Math.random() * canvas.width,
                y: -20,
                size: Math.random() * 8 + 4,
                color: colors[Math.floor(Math.random() * colors.length)],
                speedY: Math.random() * 3 + 2,
                speedX: Math.random() * 4 - 2,
                rotation: Math.random() * 360
            });
        }

        let frame = 0;
        const maxFrames = 120;
        const self = this;

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            particles.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.rotation * Math.PI / 180);
                ctx.fillStyle = p.color;
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
                ctx.restore();

                p.y += p.speedY;
                p.x += p.speedX;
                p.rotation += 5;
                p.speedY += 0.1; // gravity
            });

            frame++;
            if (frame < maxFrames) {
                self._confettiAnimId = requestAnimationFrame(animate);
            } else {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                self._confettiAnimId = null;
            }
        }

        animate();
    },

    // Use power-up
    usePowerUp(type) {
        if (!this.isEnabled()) return false;

        const state = this.getState();
        if (!state.powerUpInventory[type] || state.powerUpInventory[type] <= 0) return false;

        state.powerUpInventory[type]--;
        state.stats.powerUpsUsed++;
        this.saveState(state);

        if (state.settings.sounds) SoundFX.play('powerUp');

        return true;
    },

    // Apply 50/50 power-up (eliminate 2 wrong options)
    applyFiftyFifty(correctIndex, totalOptions) {
        if (!this.usePowerUp('fiftyFifty')) return [];

        const wrongIndices = [];
        for (let i = 0; i < totalOptions; i++) {
            if (i !== correctIndex) wrongIndices.push(i);
        }

        // Fisher-Yates shuffle and take 2
        for (let i = wrongIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [wrongIndices[i], wrongIndices[j]] = [wrongIndices[j], wrongIndices[i]];
        }
        return wrongIndices.slice(0, Math.min(2, wrongIndices.length));
    },

    // Apply double XP
    applyDoubleXp() {
        if (!this.usePowerUp('doubleXp')) return false;

        const state = this.getState();
        state.doubleXpRemaining = 5;
        this.saveState(state);
        return true;
    },

    // Update settings
    updateSettings() {
        const state = this.getState();

        state.settings.enabled = document.getElementById('gamifyEnabled')?.checked ?? true;
        state.settings.sounds = document.getElementById('gamifySounds')?.checked ?? true;
        state.settings.confetti = document.getElementById('gamifyConfetti')?.checked ?? true;
        state.settings.xpPopups = document.getElementById('gamifyXpPopups')?.checked ?? true;
        state.settings.pet = document.getElementById('gamifyPet')?.checked ?? true;
        state.settings.garden = document.getElementById('gamifyGarden')?.checked ?? true;
        state.settings.coinPopups = document.getElementById('gamifyCoinPopups')?.checked ?? true;
        state.settings.pixelArt = document.getElementById('gamifyPixelArt')?.checked ?? false;
        state.settings.volume = parseInt(document.getElementById('gamifyVolume')?.value ?? 50);

        const volumeLabel = document.getElementById('gamifyVolumeLabel');
        if (volumeLabel) volumeLabel.textContent = state.settings.volume + '%';

        this.saveState(state);

        // Update UI
        this.renderXpBar();
        this.updateBuddyWidget();
        this.updateComboDisplay();

        // Toggle garden/shop/battle buttons
        const btnGarden = document.getElementById('btnGarden');
        const btnShop = document.getElementById('btnShop');
        const btnBattle = document.getElementById('btnBattle');
        if (btnGarden) btnGarden.style.display = state.settings.garden ? '' : 'none';
        if (btnShop) btnShop.style.display = state.settings.garden ? '' : 'none';
        if (btnBattle) btnBattle.style.display = state.settings.garden ? '' : 'none';

        // Clear sprite cache when pixel art toggled
        Sprites._cache = {};

    },

    // Load settings into UI
    loadSettings() {
        const state = this.getState();

        const el1 = document.getElementById('gamifyEnabled');
        if (el1) el1.checked = state.settings.enabled;

        const el2 = document.getElementById('gamifySounds');
        if (el2) el2.checked = state.settings.sounds;

        const el3 = document.getElementById('gamifyConfetti');
        if (el3) el3.checked = state.settings.confetti;

        const el4 = document.getElementById('gamifyXpPopups');
        if (el4) el4.checked = state.settings.xpPopups;

        const el5 = document.getElementById('gamifyPet');
        if (el5) el5.checked = state.settings.pet;

        const el5b = document.getElementById('gamifyGarden');
        if (el5b) el5b.checked = state.settings.garden !== false;

        const el5c = document.getElementById('gamifyCoinPopups');
        if (el5c) el5c.checked = state.settings.coinPopups !== false;

        const el5d = document.getElementById('gamifyPixelArt');
        if (el5d) el5d.checked = !!state.settings.pixelArt;

        const el6 = document.getElementById('gamifyVolume');
        if (el6) el6.value = state.settings.volume;

        const volumeLabel = document.getElementById('gamifyVolumeLabel');
        if (volumeLabel) volumeLabel.textContent = state.settings.volume + '%';
    },

    // Reset progress
    resetProgress() {
        if (!confirm('Are you sure? This will reset all XP, levels, achievements, and power-ups.')) return;

        this._state = null; // Clear cache so getState re-reads defaults
        Store.remove('gamification');
        this.loadSettings();
        this.renderXpBar();
        this.updateBuddyWidget();
        this.updateComboDisplay();
        alert('Gamification data reset!');
    },

    // Start tracking question time
    startQuestionTimer() {
        const state = this.getState();
        state.questionStartTime = Date.now();
        this.saveState(state);
    },

    // Get time spent on question
    getQuestionTime() {
        const state = this.getState();
        if (!state.questionStartTime) return null;
        return Date.now() - state.questionStartTime;
    },

    // Record test completion
    recordTestComplete(score, isPerfect) {
        if (!this.isEnabled()) return;

        const state = this.getState();
        state.stats.testsCompleted++;
        if (isPerfect) state.stats.perfectTests++;
        this.saveState(state);

        // Award XP based on score
        this.awardXp('testComplete', { multiplier: score / 100 });

        if (isPerfect) {
            this.awardXp('perfectTest');
            this.unlockAchievement('perfect_test');
            // Award gems for perfect test (premium currency)
            this.awardGems(5, 'perfectTest');
            // Guaranteed trinket for perfect test
            if (state.settings.trinketsEnabled !== false) {
                const trinket = Backpack.awardRandomTrinket();
                if (trinket) {
                    setTimeout(() => Backpack.showTrinketToast(trinket), 1500);
                }
            }
        }
    },

    // Check daily streak achievements
    checkStreakAchievements(streakDays) {
        if (streakDays >= 7) this.unlockAchievement('week_streak');
        if (streakDays >= 30) this.unlockAchievement('month_streak');
    },

    // Initialize on app start
    init() {
        this.checkLoginBonus();
        this.loadSettings();
        this.renderXpBar();
        this.updateBuddyWidget();
        this.updateComboDisplay();
    }
};

// =====================================================================
// SPRITE SYSTEM  Inline SVG pixel art for pet + plants
// =====================================================================
const Sprites = {
    _cache: {},

    // Returns pixel art if enabled, otherwise emoji
    petSprite(stageNum, emoji, size) {
        if (Gamification.getState().settings.pixelArt) return this.get('pet', stageNum, size || 48);
        return `<span style="font-size:${size ? size+'px' : 'inherit'}">${emoji}</span>`;
    },

    plantSprite(seedType, stageIdx, emoji, size) {
        if (Gamification.getState().settings.pixelArt) return this.get('plant', seedType + '_' + stageIdx, size || 48);
        return `<span style="font-size:${size ? size+'px' : 'inherit'}">${emoji}</span>`;
    },

    // Returns an <svg> HTML string at the requested size
    get(type, id, size) {
        const key = type + '_' + id + '_' + size;
        if (this._cache[key]) return this._cache[key];
        const svg = this._build(type, id, size);
        this._cache[key] = svg;
        return svg;
    },

    // Helper: render a pixel grid into an SVG. grid = 2D array of hex colors (null = transparent)
    _gridToSvg(grid, size) {
        const rows = grid.length;
        const cols = grid[0].length;
        const px = Math.floor(size / Math.max(rows, cols));
        const w = cols * px;
        const h = rows * px;
        let rects = '';
        for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
                const c = grid[y][x];
                if (c) rects += `<rect x="${x*px}" y="${y*px}" width="${px}" height="${px}" fill="${c}"/>`;
            }
        }
        return `<svg xmlns="http://www.w3.org/2000/svg" width="${w}" height="${h}" viewBox="0 0 ${w} ${h}" style="image-rendering:pixelated">${rects}</svg>`;
    },

    _build(type, id, size) {
        if (type === 'pet') return this._pet(id, size);
        if (type === 'plant') return this._plant(id, size);
        return '';
    },

    // Pet sprites  12x12 pixel grids
    _pet(stageNum, size) {
        const _ = null;
        const W = '#fff', K = '#222', B = '#3b82f6', Y = '#fbbf24', O = '#f97316', Br = '#92400e', G = '#6b7280', Gy = '#9ca3af';
        const grids = {
            1: [ // Egg
                [_,_,_,_,W,W,W,W,_,_,_,_],
                [_,_,_,W,W,W,W,W,W,_,_,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,Y,Y,W,W,W,W,Y,Y,W,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,W,W,Y,Y,Y,Y,W,W,W,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,_,_,W,W,W,W,W,W,_,_,_],
                [_,_,_,_,W,W,W,W,_,_,_,_]
            ],
            2: [ // Hatchling  cracked egg with eyes
                [_,_,_,_,_,Y,Y,_,_,_,_,_],
                [_,_,_,_,Y,Y,Y,Y,_,_,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,Y,Y,K,Y,Y,K,Y,Y,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,Y,Y,Y,O,O,Y,Y,Y,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,W,W,Gy,Gy,Gy,Gy,W,W,_,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,W,W,W,W,W,W,W,W,W,W,_],
                [_,_,W,W,W,W,W,W,W,W,_,_],
                [_,_,_,_,W,W,W,W,_,_,_,_]
            ],
            3: [ // Chick  round yellow bird
                [_,_,_,_,Y,Y,Y,Y,_,_,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,Y,Y,K,Y,Y,Y,K,Y,Y,Y,_],
                [_,Y,Y,Y,Y,Y,Y,Y,Y,Y,Y,_],
                [_,Y,Y,Y,Y,O,O,Y,Y,Y,Y,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,_,Y,Y,Y,Y,Y,Y,_,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,Y,Y,Y,Y,Y,Y,Y,Y,_,_],
                [_,_,_,_,O,_,_,O,_,_,_,_],
                [_,_,_,O,O,_,_,O,O,_,_,_]
            ],
            4: [ // Bird  sleeker, has wings
                [_,_,_,_,B,B,B,_,_,_,_,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,_,B,B,W,B,W,B,B,_,_,_],
                [_,_,B,B,K,B,K,B,B,_,_,_],
                [_,_,B,B,B,O,B,B,B,_,_,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,B,B,B,B,B,B,B,B,B,_,_],
                [B,B,B,B,B,B,B,B,B,B,B,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,_,_,B,B,B,B,B,_,_,_,_],
                [_,_,_,_,O,_,O,_,_,_,_,_],
                [_,_,_,O,O,_,O,O,_,_,_,_]
            ],
            5: [ // Eagle  majestic, spread wings
                [_,_,_,_,_,Br,Br,_,_,_,_,_],
                [_,_,_,_,Br,Br,Br,Br,_,_,_,_],
                [_,_,_,Br,W,Br,W,Br,Br,_,_,_],
                [_,_,_,Br,K,Br,K,Br,Br,_,_,_],
                [_,_,_,Br,Br,Y,Br,Br,Br,_,_,_],
                [Br,Br,Br,Br,Br,Br,Br,Br,Br,Br,Br,_],
                [_,Br,Br,Br,Br,Br,Br,Br,Br,Br,_,Br],
                [_,_,Br,Br,Br,Br,Br,Br,Br,_,_,_],
                [_,_,_,Br,Br,Br,Br,Br,_,_,_,_],
                [_,_,_,Br,Br,Br,Br,Br,_,_,_,_],
                [_,_,_,_,Y,_,_,Y,_,_,_,_],
                [_,_,_,Y,Y,_,_,Y,Y,_,_,_]
            ]
        };
        const grid = grids[stageNum] || grids[1];
        return this._gridToSvg(grid, size || 48);
    },

    // Plant sprites  10x12 pixel grids per stage
    _plant(key, size) {
        // key = "seedType_stageIdx" e.g. "sunflower_0"
        const [seedType, stageStr] = key.split('_');
        const stageIdx = parseInt(stageStr) || 0;
        const _ = null;
        const G = '#22c55e', DG = '#15803d', Br = '#92400e', Y = '#fbbf24', O = '#f97316';
        const LG = '#86efac', P = '#a855f7', LP = '#c084fc', Pk = '#ec4899', R = '#ef4444';
        const Cy = '#06b6d4', LB = '#7dd3fc', W = '#fff', Gy = '#6b7280';

        const plants = {
            sunflower: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,Br,Br,_,_,_,_],
                    [_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,G,G,G,G,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // stem with leaves
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,G,G,G,G,_,_,_],
                    [_,_,G,G,G,G,G,G,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,G,G,_],
                    [_,_,_,_,G,G,G,G,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // bloom
                    [_,_,_,Y,Y,Y,Y,_,_,_],
                    [_,_,Y,Y,Y,Y,Y,Y,_,_],
                    [_,Y,Y,Y,Br,Br,Y,Y,Y,_],
                    [_,Y,Y,Br,Br,Br,Br,Y,Y,_],
                    [_,_,Y,Y,Br,Br,Y,Y,_,_],
                    [_,_,_,Y,Y,Y,Y,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],
                    [_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],
                    [_,_,_,_,G,G,_,G,G,_],
                    [_,_,_,_,G,G,G,G,_,_],
                    [_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            cactus: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],
                    [_,_,_,DG,DG,DG,DG,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // small cactus
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],
                    [_,_,_,_,DG,DG,_,_,_,_],[_,DG,DG,_,DG,DG,_,_,_,_],[_,_,DG,DG,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,DG,DG,_],
                    [_,_,_,_,DG,DG,DG,DG,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // full cactus with flower
                    [_,_,_,_,Pk,Pk,_,_,_,_],[_,_,_,Pk,Y,Pk,Pk,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],
                    [_,_,_,_,DG,DG,_,_,_,_],[_,DG,DG,_,DG,DG,_,_,_,_],[_,_,DG,DG,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,DG,DG,_],
                    [_,_,_,_,DG,DG,DG,DG,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,_,_,DG,DG,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            bonsai: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,G,G,G,G,_,_,_],
                    [_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // small tree
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,G,G,G,G,G,_,_],[_,_,G,G,G,G,G,G,G,_],
                    [_,_,_,G,G,G,G,G,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,_,Br,Br,_,Br,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // medium tree
                    [_,_,_,G,G,G,G,_,_,_],[_,_,G,G,DG,G,DG,G,_,_],[_,G,G,DG,G,G,G,DG,G,_],[_,_,G,G,G,G,G,G,G,_],
                    [_,_,_,G,G,G,G,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,_,Br,Br,_,Br,_,_],[_,Br,_,_,Br,Br,_,_,Br,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // full bonsai
                    [_,G,G,G,G,G,G,G,G,_],[G,G,DG,G,DG,G,DG,G,DG,G],[G,DG,G,G,G,G,G,G,DG,G],[_,G,G,G,G,G,G,G,G,_],
                    [_,_,G,G,G,G,G,G,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],
                    [_,_,Br,_,Br,Br,_,Br,_,_],[_,Br,_,_,Br,Br,_,_,Br,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            crystal: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Gy,Gy,_,_,_,_],[_,_,_,Gy,Gy,Gy,Gy,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,Cy,LB,Cy,Cy,_,_,_],
                    [_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // growing crystal
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Cy,_,_,_,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],
                    [_,_,_,Cy,LB,Cy,_,_,_,_],[_,_,Cy,LB,W,LB,Cy,_,_,_],[_,_,_,Cy,LB,Cy,_,Cy,_,_],[_,_,_,_,Cy,_,Cy,LB,Cy,_],
                    [_,_,_,_,Cy,_,_,Cy,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // large crystal
                    [_,_,_,_,Cy,_,_,_,_,_],[_,_,_,Cy,LB,Cy,_,_,Cy,_],[_,_,Cy,LB,W,LB,Cy,Cy,LB,_],[_,_,Cy,W,W,W,LB,LB,Cy,_],
                    [_,_,_,Cy,W,LB,Cy,Cy,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],[_,_,Cy,LB,W,LB,Cy,_,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],
                    [_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // crystal bloom (glowing)
                    [_,_,W,_,Cy,W,_,_,W,_],[_,_,_,Cy,W,Cy,_,Cy,LB,_],[_,Cy,Cy,W,W,W,Cy,LB,W,Cy],[_,Cy,W,W,W,W,W,W,Cy,_],
                    [_,_,Cy,W,W,W,Cy,Cy,_,_],[_,_,_,Cy,W,Cy,_,_,_,_],[_,_,Cy,W,W,W,Cy,_,_,_],[_,_,_,Cy,LB,Cy,_,_,_,_],
                    [_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,_,_,Cy,Cy,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ],
            rainbow: [
                [ // seed
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,Br,Br,_,_,_,_],[_,_,_,Br,Br,Br,Br,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // sprout
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,G,LG,G,G,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // stem
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],
                    [_,_,_,G,LG,G,G,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // bud
                    [_,_,_,_,_,_,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,G,Pk,G,G,_,_,_],[_,_,_,G,Pk,Pk,G,_,_,_],
                    [_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // rose
                    [_,_,_,R,R,R,R,_,_,_],[_,_,R,Pk,R,R,Pk,R,_,_],[_,R,Pk,R,R,R,R,Pk,R,_],[_,R,R,R,Pk,Pk,R,R,R,_],
                    [_,_,R,R,R,R,R,R,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ],
                [ // rainbow bloom
                    [_,_,R,O,Y,G,B,P,_,_],[_,R,O,Y,G,B,P,Pk,R,_],[R,O,Y,G,W,W,B,P,Pk,R],[R,O,Y,W,W,W,W,P,Pk,R],
                    [_,R,O,Y,G,B,P,Pk,_,_],[_,_,_,_,G,G,_,_,_,_],[_,_,_,_,G,G,_,_,_,_],[_,G,G,_,G,G,_,_,_,_],
                    [_,_,G,G,G,G,_,_,_,_],[_,_,_,_,G,G,_,G,G,_],[_,_,_,_,G,G,G,G,_,_],[_,_,Br,Br,Br,Br,Br,Br,_,_]
                ]
            ]
        };

        const stages = plants[seedType];
        if (!stages) return '';
        const grid = stages[Math.min(stageIdx, stages.length - 1)];
        if (!grid) return '';
        return this._gridToSvg(grid, size || 48);
    }
};

// =====================================================================
// SOUND EFFECTS (Web Audio API)
// =====================================================================
const SoundFX = {
    audioContext: null,

    // Initialize audio context
    init() {
        try {
            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch (e) {
            // Web Audio API not supported
        }
    },

    // Play a sound
    play(type) {
        if (!this.audioContext) this.init();
        if (!this.audioContext) return;
        if (this.audioContext.state === 'suspended') this.audioContext.resume();

        const state = Gamification.getState();
        if (!state.settings.sounds) return;

        const volume = state.settings.volume / 100;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        gainNode.gain.value = volume * 0.3;

        switch (type) {
            case 'correct':
                oscillator.frequency.value = 523.25; // C5
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.2);
                break;

            case 'incorrect':
                oscillator.frequency.value = 220; // A3
                oscillator.type = 'sawtooth';
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.3);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.3);
                break;

            case 'combo':
                oscillator.frequency.value = 659.25; // E5
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.15);
                break;

            case 'levelUp':
                // Play arpeggio
                [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime + i * 0.1);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.1 + 0.3);
                    osc.start(this.audioContext.currentTime + i * 0.1);
                    osc.stop(this.audioContext.currentTime + i * 0.1 + 0.3);
                });
                break;

            case 'achievement':
                // Fanfare
                [392, 523.25, 659.25].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'triangle';
                    gain.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime + i * 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.15 + 0.4);
                    osc.start(this.audioContext.currentTime + i * 0.15);
                    osc.stop(this.audioContext.currentTime + i * 0.15 + 0.4);
                });
                break;

            case 'powerUp':
                oscillator.frequency.value = 440;
                oscillator.type = 'square';
                oscillator.frequency.exponentialRampToValueAtTime(880, this.audioContext.currentTime + 0.2);
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.25);
                oscillator.start();
                oscillator.stop(this.audioContext.currentTime + 0.25);
                break;

            case 'purchase':
                // Quick ascending cha-ching
                [523.25, 659.25, 783.99].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = 'sine';
                    gain.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime + i * 0.06);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.06 + 0.15);
                    osc.start(this.audioContext.currentTime + i * 0.06);
                    osc.stop(this.audioContext.currentTime + i * 0.06 + 0.15);
                });
                break;

            case 'petFeed':
                // Gentle chirp
                oscillator.frequency.value = 600;
                oscillator.type = 'sine';
                oscillator.frequency.exponentialRampToValueAtTime(900, this.audioContext.currentTime + 0.1);
                oscillator.frequency.exponentialRampToValueAtTime(700, this.audioContext.currentTime + 0.2);
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.25);
                oscillator.start(); oscillator.stop(this.audioContext.currentTime + 0.25);
                break;

            case 'harvest':
                // Satisfying pluck + sparkle
                [392, 523.25, 783.99, 1046.5].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = i < 2 ? 'triangle' : 'sine';
                    gain.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime + i * 0.08);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.08 + 0.3);
                    osc.start(this.audioContext.currentTime + i * 0.08);
                    osc.stop(this.audioContext.currentTime + i * 0.08 + 0.3);
                });
                break;

            case 'plant':
                // Soft pop
                oscillator.frequency.value = 300;
                oscillator.type = 'sine';
                oscillator.frequency.exponentialRampToValueAtTime(500, this.audioContext.currentTime + 0.05);
                oscillator.frequency.exponentialRampToValueAtTime(350, this.audioContext.currentTime + 0.15);
                gainNode.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.2);
                oscillator.start(); oscillator.stop(this.audioContext.currentTime + 0.2);
                break;

            case 'battleHit':
                // Sharp saw wave attack
                oscillator.frequency.value = 200;
                oscillator.type = 'sawtooth';
                oscillator.frequency.exponentialRampToValueAtTime(600, this.audioContext.currentTime + 0.05);
                oscillator.frequency.exponentialRampToValueAtTime(150, this.audioContext.currentTime + 0.15);
                gainNode.gain.setValueAtTime(volume * 0.25, this.audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.15);
                oscillator.start(); oscillator.stop(this.audioContext.currentTime + 0.15);
                break;

            case 'battleWin':
                // Ascending 4-note victory fanfare
                [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = 'triangle';
                    gain.gain.setValueAtTime(volume * 0.3, this.audioContext.currentTime + i * 0.12);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.12 + 0.4);
                    osc.start(this.audioContext.currentTime + i * 0.12);
                    osc.stop(this.audioContext.currentTime + i * 0.12 + 0.4);
                });
                break;

            case 'battleLose':
                // Descending 2-note sad horn
                [392, 293.66].forEach((freq, i) => {
                    const osc = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    osc.connect(gain); gain.connect(this.audioContext.destination);
                    osc.frequency.value = freq; osc.type = 'sawtooth';
                    gain.gain.setValueAtTime(volume * 0.2, this.audioContext.currentTime + i * 0.25);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + i * 0.25 + 0.4);
                    osc.start(this.audioContext.currentTime + i * 0.25);
                    osc.stop(this.audioContext.currentTime + i * 0.25 + 0.4);
                });
                break;
        }
    }
};

// =====================================================================
// SCENE MANAGER (Animated Backgrounds)
// =====================================================================
/**
 * @namespace SceneManager
 * @description Manages animated backgrounds with CSS/Canvas layers.
 */
const SceneManager = {
    STORAGE_KEY: 'wgu_scene',
    currentBackground: 'default',
    animationEnabled: true,
    canvasCtx: null,
    animationFrame: null,

    BACKGROUNDS: [
        { id: 'default', name: 'Classic', description: 'Clean, minimal background', unlocked: true, css: 'scene-default', animated: false },
        { id: 'cozy-desk', name: 'Cozy Desk', description: 'Warm study nook with soft lighting', unlocked: false, unlockCondition: { type: 'level', value: 2 }, css: 'scene-cozy-desk', animated: false },
        { id: 'night-sky', name: 'Night Sky', description: 'Twinkling stars and gentle aurora', unlocked: false, unlockCondition: { type: 'level', value: 5 }, css: 'scene-night-sky', animated: true, animationType: 'css' },
        { id: 'rain-window', name: 'Rainy Window', description: 'Peaceful rain on glass', unlocked: false, unlockCondition: { type: 'streak', value: 7 }, css: 'scene-rain-window', animated: true, animationType: 'canvas' },
        { id: 'forest-glade', name: 'Forest Glade', description: 'Sunlit clearing with floating particles', unlocked: false, unlockCondition: { type: 'level', value: 10 }, css: 'scene-forest-glade', animated: true, animationType: 'css' },
        { id: 'synthwave', name: 'Synthwave', description: 'Retro neon grid with pulsing colors', unlocked: false, unlockCondition: { type: 'achievement', value: 'night_owl' }, css: 'scene-synthwave', animated: true, animationType: 'css' },
        { id: 'lava-lamp', name: 'Lava Lamp', description: 'Mesmerizing floating blobs', unlocked: false, unlockCondition: { type: 'gems', value: 25 }, css: 'scene-lava-lamp', animated: true, animationType: 'canvas', premium: true },
        // New animated live wallpapers
        { id: 'aquarium', name: 'Aquarium', description: 'Swimming fish in a peaceful tank', unlocked: false, unlockCondition: { type: 'level', value: 3 }, css: 'scene-aquarium', animated: true, animationType: 'canvas' },
        { id: 'fireflies', name: 'Fireflies', description: 'Glowing fireflies in a summer night', unlocked: false, unlockCondition: { type: 'level', value: 7 }, css: 'scene-fireflies', animated: true, animationType: 'canvas' },
        { id: 'snowfall', name: 'Snowfall', description: 'Gentle snow drifting down', unlocked: false, unlockCondition: { type: 'streak', value: 3 }, css: 'scene-snowfall', animated: true, animationType: 'canvas' },
        { id: 'aurora', name: 'Aurora Borealis', description: 'Dancing northern lights', unlocked: false, unlockCondition: { type: 'level', value: 15 }, css: 'scene-aurora', animated: true, animationType: 'canvas' },
        { id: 'bubbles', name: 'Bubbles', description: 'Floating soap bubbles', unlocked: false, unlockCondition: { type: 'level', value: 4 }, css: 'scene-bubbles', animated: true, animationType: 'canvas' },
        { id: 'matrix', name: 'Matrix', description: 'Digital rain code', unlocked: false, unlockCondition: { type: 'level', value: 12 }, css: 'scene-matrix', animated: true, animationType: 'canvas' },
        { id: 'jellyfish', name: 'Jellyfish', description: 'Graceful jellyfish floating', unlocked: false, unlockCondition: { type: 'gems', value: 15 }, css: 'scene-jellyfish', animated: true, animationType: 'canvas', premium: true },
        { id: 'campfire', name: 'Campfire', description: 'Cozy crackling fire with sparks', unlocked: false, unlockCondition: { type: 'streak', value: 14 }, css: 'scene-campfire', animated: true, animationType: 'canvas' },
        { id: 'ocean-waves', name: 'Ocean Waves', description: 'Calming ocean waves', unlocked: false, unlockCondition: { type: 'level', value: 8 }, css: 'scene-ocean', animated: true, animationType: 'canvas' },
        { id: 'cherry-blossom', name: 'Cherry Blossom', description: 'Falling sakura petals', unlocked: false, unlockCondition: { type: 'gems', value: 20 }, css: 'scene-sakura', animated: true, animationType: 'canvas', premium: true },
        { id: 'galaxy', name: 'Galaxy', description: 'Swirling cosmic nebula', unlocked: false, unlockCondition: { type: 'level', value: 20 }, css: 'scene-galaxy', animated: true, animationType: 'canvas' },
        { id: 'koi-pond', name: 'Koi Pond', description: 'Colorful koi swimming peacefully', unlocked: false, unlockCondition: { type: 'gems', value: 30 }, css: 'scene-koi', animated: true, animationType: 'canvas', premium: true }
    ],

    init() {
        const saved = Store.get(this.STORAGE_KEY, {});
        this.currentBackground = saved.background || 'default';
        this.animationEnabled = saved.animationEnabled !== false;
        this.applyBackground(this.currentBackground);
        window.addEventListener('resize', () => this.handleResize());
    },

    getState() {
        return { background: this.currentBackground, animationEnabled: this.animationEnabled };
    },

    saveState() {
        Store.set(this.STORAGE_KEY, this.getState());
    },

    getBackgrounds(gamificationState = {}) {
        const purchased = Store.get('wgu_purchased_scenes', []);
        return this.BACKGROUNDS.map(bg => {
            let unlocked = bg.unlocked;
            if (!unlocked && bg.unlockCondition) {
                const cond = bg.unlockCondition;
                if (cond.type === 'level' && gamificationState.level >= cond.value) unlocked = true;
                else if (cond.type === 'streak' && gamificationState.streak >= cond.value) unlocked = true;
                else if (cond.type === 'achievement' && gamificationState.achievements?.includes(cond.value)) unlocked = true;
                else if (cond.type === 'gems' && purchased.includes(bg.id)) unlocked = true;
            }
            return { ...bg, unlocked };
        });
    },

    purchaseScene(sceneId) {
        const bg = this.BACKGROUNDS.find(b => b.id === sceneId);
        if (!bg || !bg.unlockCondition || bg.unlockCondition.type !== 'gems') return false;
        const cost = bg.unlockCondition.value;
        if (!Gamification.spendGems(cost)) return false;
        const purchased = Store.get('wgu_purchased_scenes', []);
        if (!purchased.includes(sceneId)) {
            purchased.push(sceneId);
            Store.set('wgu_purchased_scenes', purchased);
        }
        return true;
    },

    applyBackground(backgroundId) {
        const bg = this.BACKGROUNDS.find(b => b.id === backgroundId);
        if (!bg) return;
        const body = document.body;
        this.BACKGROUNDS.forEach(b => body.classList.remove(b.css));
        this.stopCanvasAnimation();
        body.classList.add(bg.css);
        this.currentBackground = backgroundId;
        if (this.animationEnabled && bg.animated) {
            if (bg.animationType === 'canvas') this.startCanvasAnimation(bg.id);
            body.classList.add('scene-animated');
        } else {
            body.classList.remove('scene-animated');
        }
        this.saveState();
    },

    toggleAnimation() {
        this.animationEnabled = !this.animationEnabled;
        this.applyBackground(this.currentBackground);
        return this.animationEnabled;
    },

    startCanvasAnimation(backgroundId) {
        const canvas = document.getElementById('sceneCanvas');
        if (!canvas) return;
        canvas.style.display = 'block';
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        this.canvasCtx = canvas.getContext('2d');
        const animations = {
            'rain-window': () => this.runRainAnimation(),
            'lava-lamp': () => this.runLavaLampAnimation(),
            'aquarium': () => this.runAquariumAnimation(),
            'fireflies': () => this.runFirefliesAnimation(),
            'snowfall': () => this.runSnowfallAnimation(),
            'aurora': () => this.runAuroraAnimation(),
            'bubbles': () => this.runBubblesAnimation(),
            'matrix': () => this.runMatrixAnimation(),
            'jellyfish': () => this.runJellyfishAnimation(),
            'campfire': () => this.runCampfireAnimation(),
            'ocean-waves': () => this.runOceanAnimation(),
            'cherry-blossom': () => this.runSakuraAnimation(),
            'galaxy': () => this.runGalaxyAnimation(),
            'koi-pond': () => this.runKoiAnimation()
        };
        if (animations[backgroundId]) animations[backgroundId]();
    },

    stopCanvasAnimation() {
        if (this.animationFrame) {
            cancelAnimationFrame(this.animationFrame);
            this.animationFrame = null;
        }
        const canvas = document.getElementById('sceneCanvas');
        if (canvas) canvas.style.display = 'none';
    },

    runRainAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const drops = [];
        for (let i = 0; i < 100; i++) {
            drops.push({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, length: Math.random() * 20 + 10, speed: Math.random() * 5 + 5, opacity: Math.random() * 0.3 + 0.1 });
        }
        const animate = () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.strokeStyle = 'rgba(174, 194, 224, 0.5)';
            ctx.lineWidth = 1;
            drops.forEach(drop => {
                ctx.globalAlpha = drop.opacity;
                ctx.beginPath();
                ctx.moveTo(drop.x, drop.y);
                ctx.lineTo(drop.x, drop.y + drop.length);
                ctx.stroke();
                drop.y += drop.speed;
                if (drop.y > canvas.height) { drop.y = -drop.length; drop.x = Math.random() * canvas.width; }
            });
            ctx.globalAlpha = 1;
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    runLavaLampAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const blobs = [];
        const colors = ['#ff6b6b', '#feca57', '#48dbfb', '#ff9ff3', '#54a0ff', '#5f27cd'];
        
        // Create floating blobs
        for (let i = 0; i < 8; i++) {
            blobs.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                radius: Math.random() * 80 + 40,
                vx: (Math.random() - 0.5) * 0.5,
                vy: (Math.random() - 0.5) * 0.3 - 0.2,
                color: colors[i % colors.length],
                phase: Math.random() * Math.PI * 2,
                wobbleSpeed: Math.random() * 0.02 + 0.01
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(26, 10, 46, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            blobs.forEach(blob => {
                blob.phase += blob.wobbleSpeed;
                const wobble = Math.sin(blob.phase) * 15;
                
                // Draw blob with gradient
                const gradient = ctx.createRadialGradient(
                    blob.x, blob.y, 0,
                    blob.x, blob.y, blob.radius + wobble
                );
                gradient.addColorStop(0, blob.color);
                gradient.addColorStop(0.7, blob.color + '88');
                gradient.addColorStop(1, 'transparent');

                ctx.beginPath();
                ctx.arc(blob.x, blob.y, blob.radius + wobble, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();

                // Move blob
                blob.x += blob.vx;
                blob.y += blob.vy;

                // Bounce off edges
                if (blob.x < -blob.radius) blob.x = canvas.width + blob.radius;
                if (blob.x > canvas.width + blob.radius) blob.x = -blob.radius;
                if (blob.y < -blob.radius) blob.y = canvas.height + blob.radius;
                if (blob.y > canvas.height + blob.radius) blob.y = -blob.radius;

                // Slight random drift
                blob.vx += (Math.random() - 0.5) * 0.02;
                blob.vy += (Math.random() - 0.5) * 0.02;
                blob.vx = Math.max(-1, Math.min(1, blob.vx));
                blob.vy = Math.max(-0.8, Math.min(0.8, blob.vy));
            });

            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== AQUARIUM - Swimming Fish =====
    runAquariumAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const fish = [];
        const fishColors = ['#ff6b6b', '#ffa502', '#2ed573', '#1e90ff', '#ff6348', '#7bed9f', '#70a1ff', '#eccc68'];
        const fishEmojis = ['', '', '', '', '', '', '', ''];
        
        for (let i = 0; i < 15; i++) {
            fish.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 30 + 20,
                speed: Math.random() * 2 + 0.5,
                direction: Math.random() > 0.5 ? 1 : -1,
                wobble: Math.random() * Math.PI * 2,
                wobbleSpeed: Math.random() * 0.05 + 0.02,
                color: fishColors[i % fishColors.length],
                emoji: fishEmojis[Math.floor(Math.random() * fishEmojis.length)]
            });
        }
        
        // Bubbles
        const bubbles = [];
        for (let i = 0; i < 20; i++) {
            bubbles.push({
                x: Math.random() * canvas.width,
                y: canvas.height + Math.random() * 100,
                size: Math.random() * 8 + 2,
                speed: Math.random() * 1 + 0.5
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(0, 50, 80, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw bubbles
            bubbles.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.fill();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.stroke();
                b.y -= b.speed;
                b.x += Math.sin(b.y * 0.02) * 0.5;
                if (b.y < -10) { b.y = canvas.height + 10; b.x = Math.random() * canvas.width; }
            });
            
            // Draw fish
            fish.forEach(f => {
                f.wobble += f.wobbleSpeed;
                const yOffset = Math.sin(f.wobble) * 10;
                ctx.font = `${f.size}px Arial`;
                ctx.save();
                ctx.translate(f.x, f.y + yOffset);
                if (f.direction < 0) ctx.scale(-1, 1);
                ctx.fillText(f.emoji, 0, 0);
                ctx.restore();
                f.x += f.speed * f.direction;
                if (f.x > canvas.width + 50) { f.x = -50; f.y = Math.random() * canvas.height; }
                if (f.x < -50) { f.x = canvas.width + 50; f.y = Math.random() * canvas.height; }
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== FIREFLIES =====
    runFirefliesAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const fireflies = [];
        
        for (let i = 0; i < 50; i++) {
            fireflies.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 4 + 2,
                vx: (Math.random() - 0.5) * 1,
                vy: (Math.random() - 0.5) * 1,
                glow: Math.random() * Math.PI * 2,
                glowSpeed: Math.random() * 0.05 + 0.02
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(10, 20, 30, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            fireflies.forEach(f => {
                f.glow += f.glowSpeed;
                const brightness = (Math.sin(f.glow) + 1) / 2;
                const alpha = 0.3 + brightness * 0.7;
                
                const gradient = ctx.createRadialGradient(f.x, f.y, 0, f.x, f.y, f.size * 3);
                gradient.addColorStop(0, `rgba(255, 255, 100, ${alpha})`);
                gradient.addColorStop(0.5, `rgba(255, 200, 50, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(f.x, f.y, f.size * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                f.x += f.vx;
                f.y += f.vy;
                f.vx += (Math.random() - 0.5) * 0.1;
                f.vy += (Math.random() - 0.5) * 0.1;
                f.vx = Math.max(-1.5, Math.min(1.5, f.vx));
                f.vy = Math.max(-1.5, Math.min(1.5, f.vy));
                
                if (f.x < 0) f.x = canvas.width;
                if (f.x > canvas.width) f.x = 0;
                if (f.y < 0) f.y = canvas.height;
                if (f.y > canvas.height) f.y = 0;
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== SNOWFALL =====
    runSnowfallAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const snowflakes = [];
        
        for (let i = 0; i < 150; i++) {
            snowflakes.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 4 + 1,
                speed: Math.random() * 2 + 0.5,
                wobble: Math.random() * Math.PI * 2,
                wobbleSpeed: Math.random() * 0.02 + 0.01
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(20, 30, 50, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            snowflakes.forEach(s => {
                s.wobble += s.wobbleSpeed;
                ctx.beginPath();
                ctx.arc(s.x + Math.sin(s.wobble) * 20, s.y, s.size, 0, Math.PI * 2);
                ctx.fill();
                s.y += s.speed;
                if (s.y > canvas.height + 10) { s.y = -10; s.x = Math.random() * canvas.width; }
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== AURORA BOREALIS =====
    runAuroraAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        let time = 0;
        const colors = ['#00ff87', '#60efff', '#0061ff', '#ff00ff', '#00ff87'];

        const animate = () => {
            ctx.fillStyle = 'rgba(5, 10, 30, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let i = 0; i < 5; i++) {
                ctx.beginPath();
                ctx.moveTo(0, canvas.height * 0.3);
                for (let x = 0; x <= canvas.width; x += 20) {
                    const y = canvas.height * 0.3 + 
                        Math.sin(x * 0.005 + time + i * 0.5) * 50 +
                        Math.sin(x * 0.01 + time * 1.5 + i) * 30;
                    ctx.lineTo(x, y);
                }
                ctx.lineTo(canvas.width, 0);
                ctx.lineTo(0, 0);
                ctx.closePath();
                
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height * 0.5);
                gradient.addColorStop(0, 'transparent');
                gradient.addColorStop(0.5, colors[i] + '40');
                gradient.addColorStop(1, 'transparent');
                ctx.fillStyle = gradient;
                ctx.fill();
            }
            
            time += 0.02;
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== BUBBLES =====
    runBubblesAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const bubbles = [];
        
        for (let i = 0; i < 30; i++) {
            bubbles.push({
                x: Math.random() * canvas.width,
                y: canvas.height + Math.random() * 200,
                size: Math.random() * 40 + 10,
                speed: Math.random() * 1.5 + 0.5,
                wobble: Math.random() * Math.PI * 2,
                hue: Math.random() * 360
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(240, 248, 255, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            bubbles.forEach(b => {
                b.wobble += 0.02;
                const x = b.x + Math.sin(b.wobble) * 30;
                
                const gradient = ctx.createRadialGradient(x - b.size * 0.3, b.y - b.size * 0.3, 0, x, b.y, b.size);
                gradient.addColorStop(0, `hsla(${b.hue}, 70%, 90%, 0.8)`);
                gradient.addColorStop(0.5, `hsla(${b.hue}, 60%, 80%, 0.3)`);
                gradient.addColorStop(1, `hsla(${b.hue}, 50%, 70%, 0.1)`);
                
                ctx.beginPath();
                ctx.arc(x, b.y, b.size, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                ctx.strokeStyle = `hsla(${b.hue}, 70%, 90%, 0.5)`;
                ctx.stroke();
                
                b.y -= b.speed;
                b.hue += 0.1;
                if (b.y < -b.size * 2) { b.y = canvas.height + b.size; b.x = Math.random() * canvas.width; }
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== MATRIX =====
    runMatrixAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const fontSize = 14;
        const columns = Math.floor(canvas.width / fontSize);
        const drops = Array(columns).fill(1);
        const chars = '0123456789';

        const animate = () => {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#0f0';
            ctx.font = `${fontSize}px monospace`;
            
            for (let i = 0; i < drops.length; i++) {
                const char = chars[Math.floor(Math.random() * chars.length)];
                ctx.fillStyle = `hsl(120, 100%, ${50 + Math.random() * 30}%)`;
                ctx.fillText(char, i * fontSize, drops[i] * fontSize);
                
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== JELLYFISH =====
    runJellyfishAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const jellyfish = [];
        const colors = ['#ff6b9d', '#c44dff', '#4dc3ff', '#ff9f43', '#26de81'];
        
        for (let i = 0; i < 8; i++) {
            jellyfish.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 40 + 30,
                speed: Math.random() * 0.5 + 0.2,
                wobble: Math.random() * Math.PI * 2,
                tentaclePhase: Math.random() * Math.PI * 2,
                color: colors[i % colors.length]
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(10, 20, 40, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            jellyfish.forEach(j => {
                j.wobble += 0.03;
                j.tentaclePhase += 0.05;
                const x = j.x + Math.sin(j.wobble) * 20;
                
                // Body
                const gradient = ctx.createRadialGradient(x, j.y, 0, x, j.y, j.size);
                gradient.addColorStop(0, j.color + 'cc');
                gradient.addColorStop(0.7, j.color + '66');
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.ellipse(x, j.y, j.size, j.size * 0.6, 0, Math.PI, 0);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                // Tentacles
                for (let t = 0; t < 5; t++) {
                    ctx.beginPath();
                    ctx.moveTo(x - j.size * 0.6 + t * j.size * 0.3, j.y);
                    for (let ty = 0; ty < j.size * 1.5; ty += 5) {
                        const tx = x - j.size * 0.6 + t * j.size * 0.3 + Math.sin(j.tentaclePhase + ty * 0.1 + t) * 10;
                        ctx.lineTo(tx, j.y + ty);
                    }
                    ctx.strokeStyle = j.color + '88';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                
                j.y -= j.speed;
                if (j.y < -j.size * 2) { j.y = canvas.height + j.size; j.x = Math.random() * canvas.width; }
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== CAMPFIRE =====
    runCampfireAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const particles = [];
        const sparks = [];
        
        const animate = () => {
            ctx.fillStyle = 'rgba(20, 10, 5, 0.2)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add new fire particles
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 60,
                    y: canvas.height * 0.7,
                    size: Math.random() * 30 + 20,
                    speed: Math.random() * 3 + 2,
                    life: 1,
                    hue: Math.random() * 40 + 10
                });
            }
            
            // Add sparks
            if (Math.random() > 0.9) {
                sparks.push({
                    x: canvas.width / 2 + (Math.random() - 0.5) * 40,
                    y: canvas.height * 0.65,
                    vx: (Math.random() - 0.5) * 3,
                    vy: -Math.random() * 4 - 2,
                    size: Math.random() * 3 + 1,
                    life: 1
                });
            }
            
            // Draw fire
            particles.forEach((p, i) => {
                const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
                gradient.addColorStop(0, `hsla(${p.hue}, 100%, 60%, ${p.life})`);
                gradient.addColorStop(0.5, `hsla(${p.hue - 10}, 100%, 50%, ${p.life * 0.5})`);
                gradient.addColorStop(1, 'transparent');
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
                
                p.y -= p.speed;
                p.x += (Math.random() - 0.5) * 2;
                p.life -= 0.02;
                p.size *= 0.98;
                
                if (p.life <= 0) particles.splice(i, 1);
            });
            
            // Draw sparks
            sparks.forEach((s, i) => {
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 200, 50, ${s.life})`;
                ctx.fill();
                
                s.x += s.vx;
                s.y += s.vy;
                s.vy += 0.05;
                s.life -= 0.015;
                
                if (s.life <= 0) sparks.splice(i, 1);
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== OCEAN WAVES =====
    runOceanAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        let time = 0;

        const animate = () => {
            ctx.fillStyle = 'rgba(10, 30, 60, 0.3)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let layer = 0; layer < 4; layer++) {
                const yBase = canvas.height * (0.5 + layer * 0.12);
                const alpha = 0.3 + layer * 0.15;
                const hue = 200 + layer * 10;
                
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                
                for (let x = 0; x <= canvas.width; x += 10) {
                    const y = yBase + 
                        Math.sin(x * 0.01 + time + layer) * 20 +
                        Math.sin(x * 0.02 + time * 1.5 + layer * 2) * 10;
                    ctx.lineTo(x, y);
                }
                
                ctx.lineTo(canvas.width, canvas.height);
                ctx.closePath();
                ctx.fillStyle = `hsla(${hue}, 60%, ${30 + layer * 10}%, ${alpha})`;
                ctx.fill();
            }
            
            time += 0.03;
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== CHERRY BLOSSOM / SAKURA =====
    runSakuraAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const petals = [];
        
        for (let i = 0; i < 60; i++) {
            petals.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height - canvas.height,
                size: Math.random() * 12 + 6,
                speed: Math.random() * 1.5 + 0.5,
                rotation: Math.random() * Math.PI * 2,
                rotSpeed: (Math.random() - 0.5) * 0.05,
                wobble: Math.random() * Math.PI * 2,
                wobbleSpeed: Math.random() * 0.03 + 0.01
            });
        }

        const drawPetal = (x, y, size, rotation) => {
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotation);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.bezierCurveTo(size, -size, size * 2, 0, 0, size);
            ctx.bezierCurveTo(-size * 2, 0, -size, -size, 0, 0);
            ctx.fillStyle = `rgba(255, ${180 + Math.random() * 40}, ${200 + Math.random() * 30}, 0.8)`;
            ctx.fill();
            ctx.restore();
        };

        const animate = () => {
            ctx.fillStyle = 'rgba(255, 240, 245, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            petals.forEach(p => {
                p.wobble += p.wobbleSpeed;
                p.rotation += p.rotSpeed;
                drawPetal(p.x + Math.sin(p.wobble) * 30, p.y, p.size, p.rotation);
                p.y += p.speed;
                p.x += Math.sin(p.wobble) * 0.5;
                if (p.y > canvas.height + 20) { p.y = -20; p.x = Math.random() * canvas.width; }
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== GALAXY =====
    runGalaxyAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const stars = [];
        const nebulae = [];
        let time = 0;
        
        for (let i = 0; i < 200; i++) {
            stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                twinkle: Math.random() * Math.PI * 2,
                twinkleSpeed: Math.random() * 0.05 + 0.01
            });
        }
        
        for (let i = 0; i < 5; i++) {
            nebulae.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 200 + 100,
                hue: Math.random() * 60 + 240,
                phase: Math.random() * Math.PI * 2
            });
        }

        const animate = () => {
            ctx.fillStyle = 'rgba(5, 5, 20, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Nebulae
            nebulae.forEach(n => {
                n.phase += 0.005;
                const gradient = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.size);
                const alpha = 0.1 + Math.sin(n.phase) * 0.05;
                gradient.addColorStop(0, `hsla(${n.hue}, 80%, 50%, ${alpha})`);
                gradient.addColorStop(0.5, `hsla(${n.hue + 30}, 70%, 40%, ${alpha * 0.5})`);
                gradient.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(n.x, n.y, n.size, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            });
            
            // Stars
            stars.forEach(s => {
                s.twinkle += s.twinkleSpeed;
                const brightness = (Math.sin(s.twinkle) + 1) / 2;
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size * (0.5 + brightness * 0.5), 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + brightness * 0.7})`;
                ctx.fill();
            });
            
            time += 0.01;
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    // ===== KOI POND =====
    runKoiAnimation() {
        const ctx = this.canvasCtx;
        const canvas = ctx.canvas;
        const koi = [];
        const koiColors = [
            { body: '#ff6b35', spots: '#ffffff' },
            { body: '#ffffff', spots: '#ff6b35' },
            { body: '#ffd700', spots: '#ffffff' },
            { body: '#ff4757', spots: '#ffffff' },
            { body: '#ffffff', spots: '#2f3542' }
        ];
        
        for (let i = 0; i < 6; i++) {
            const color = koiColors[i % koiColors.length];
            koi.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 30 + 40,
                angle: Math.random() * Math.PI * 2,
                speed: Math.random() * 1 + 0.5,
                turnSpeed: 0,
                tailPhase: Math.random() * Math.PI * 2,
                bodyColor: color.body,
                spotColor: color.spots
            });
        }
        
        // Lily pads
        const lilies = [];
        for (let i = 0; i < 5; i++) {
            lilies.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 40 + 30
            });
        }

        const drawKoi = (k) => {
            k.tailPhase += 0.15;
            ctx.save();
            ctx.translate(k.x, k.y);
            ctx.rotate(k.angle);
            
            // Tail
            const tailWave = Math.sin(k.tailPhase) * 15;
            ctx.beginPath();
            ctx.moveTo(-k.size * 0.8, 0);
            ctx.quadraticCurveTo(-k.size * 1.2, tailWave, -k.size * 1.4, tailWave * 0.5);
            ctx.quadraticCurveTo(-k.size * 1.2, -tailWave * 0.5, -k.size * 0.8, 0);
            ctx.fillStyle = k.bodyColor;
            ctx.fill();
            
            // Body
            ctx.beginPath();
            ctx.ellipse(0, 0, k.size * 0.8, k.size * 0.3, 0, 0, Math.PI * 2);
            ctx.fillStyle = k.bodyColor;
            ctx.fill();
            
            // Spots
            ctx.beginPath();
            ctx.arc(k.size * 0.2, k.size * 0.1, k.size * 0.15, 0, Math.PI * 2);
            ctx.arc(-k.size * 0.3, -k.size * 0.05, k.size * 0.1, 0, Math.PI * 2);
            ctx.fillStyle = k.spotColor;
            ctx.fill();
            
            // Eye
            ctx.beginPath();
            ctx.arc(k.size * 0.5, 0, k.size * 0.05, 0, Math.PI * 2);
            ctx.fillStyle = '#000';
            ctx.fill();
            
            ctx.restore();
        };

        const animate = () => {
            ctx.fillStyle = 'rgba(30, 80, 60, 0.15)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Lily pads
            lilies.forEach(l => {
                ctx.beginPath();
                ctx.arc(l.x, l.y, l.size, 0, Math.PI * 1.8);
                ctx.lineTo(l.x, l.y);
                ctx.fillStyle = 'rgba(50, 120, 50, 0.6)';
                ctx.fill();
            });
            
            // Koi
            koi.forEach(k => {
                drawKoi(k);
                
                // Movement
                k.x += Math.cos(k.angle) * k.speed;
                k.y += Math.sin(k.angle) * k.speed;
                k.turnSpeed += (Math.random() - 0.5) * 0.01;
                k.turnSpeed = Math.max(-0.03, Math.min(0.03, k.turnSpeed));
                k.angle += k.turnSpeed;
                
                // Wrap around
                if (k.x < -k.size) k.x = canvas.width + k.size;
                if (k.x > canvas.width + k.size) k.x = -k.size;
                if (k.y < -k.size) k.y = canvas.height + k.size;
                if (k.y > canvas.height + k.size) k.y = -k.size;
            });
            
            this.animationFrame = requestAnimationFrame(animate);
        };
        animate();
    },

    handleResize() {
        const canvas = document.getElementById('sceneCanvas');
        if (canvas && canvas.style.display !== 'none') {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
    },

    openModal() {
        let modal = document.getElementById('sceneModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'sceneModal';
            modal.className = 'modal-overlay';
            modal.onclick = function(e) { if (e.target === modal) SceneManager.closeModal(); };
            document.body.appendChild(modal);
        }
        const state = Gamification.getState();
        const backgrounds = this.getBackgrounds(state);
        let html = `<div class="backpack-modal"><div class="backpack-header"><h2> Backgrounds</h2><button class="backpack-close" onclick="SceneManager.closeModal()">&times;</button></div>`;
        html += `<div style="margin-bottom:16px"><label><input type="checkbox" ${this.animationEnabled ? 'checked' : ''} onchange="SceneManager.toggleAnimation()"> Enable animations</label></div>`;
        html += `<div class="trinket-grid">`;
        backgrounds.forEach(bg => {
            const selected = bg.id === this.currentBackground;
            const isPremium = bg.unlockCondition?.type === 'gems';
            const canPurchase = isPremium && !bg.unlocked && (state.gems || 0) >= bg.unlockCondition.value;
            let onclick = '';
            let isClickable = false;
            if (bg.unlocked) {
                onclick = `SceneManager.applyBackground('${bg.id}');SceneManager.openModal()`;
                isClickable = true;
            } else if (canPurchase) {
                onclick = `SceneManager.purchaseScene('${bg.id}');SceneManager.openModal()`;
                isClickable = true;
            } else {
                // Show info about how to unlock
                onclick = `SceneManager.showUnlockInfo('${bg.id}')`;
                isClickable = true;
            }
            html += `<div class="trinket-card ${selected ? 'equipped' : ''} ${!bg.unlocked ? 'locked' : ''} ${isPremium ? 'premium' : ''}" onclick="${onclick}" style="border-color:${selected ? 'var(--accent)' : isPremium ? '#a855f7' : 'var(--border)'};cursor:pointer">
                <span class="trinket-icon">${bg.animated ? '' : ''}${isPremium ? '' : ''}</span>
                <span class="trinket-name">${bg.name}</span>
                <span class="trinket-rarity" style="color:${bg.unlocked ? 'var(--green)' : isPremium ? '#a855f7' : 'var(--gray-500)'}">${bg.unlocked ? (selected ? 'Active' : 'Unlocked') : this.getUnlockText(bg.unlockCondition, canPurchase)}</span>
            </div>`;
        });
        html += `</div></div>`;
        modal.innerHTML = html;
        modal.classList.add('active');
    },

    getUnlockText(cond, canPurchase) {
        if (!cond) return 'Locked';
        if (cond.type === 'level') return `Level ${cond.value}`;
        if (cond.type === 'streak') return `${cond.value}-day streak`;
        if (cond.type === 'achievement') return `Achievement`;
        if (cond.type === 'gems') return canPurchase ? `Buy ${cond.value} ` : `${cond.value} `;
        return 'Locked';
    },

    showUnlockInfo(bgId) {
        const bg = this.BACKGROUNDS.find(b => b.id === bgId);
        if (!bg) return;
        const state = Gamification.getState();
        const cond = bg.unlockCondition;
        let msg = ` ${bg.name}\n\n${bg.description}\n\n`;
        
        if (!cond) {
            msg += ' This background is locked.';
        } else if (cond.type === 'level') {
            const currentLevel = state.level || 1;
            msg += ` Unlock at Level ${cond.value}\n\nYour level: ${currentLevel}`;
        } else if (cond.type === 'streak') {
            const currentStreak = DailyGoal.getStats().streak || 0;
            msg += ` Unlock with a ${cond.value}-day study streak\n\nYour streak: ${currentStreak} days`;
        } else if (cond.type === 'achievement') {
            msg += ` Unlock by earning the "${cond.value}" achievement`;
        } else if (cond.type === 'gems') {
            const gems = state.gems || 0;
            msg += ` Purchase for ${cond.value} gems\n\nYour gems: ${gems}`;
        }
        
        alert(msg);
    },

    closeModal() {
        const modal = document.getElementById('sceneModal');
        if (modal) modal.classList.remove('active');
    }
};

// =====================================================================
// BACKPACK (Trinket Inventory)
// =====================================================================
/**
 * @namespace Backpack
 * @description Trinket inventory and desk placement system.
 */
const Backpack = {
    STORAGE_KEY: 'wgu_trinkets',
    RARITY: {
        common: { label: 'Common', color: '#9ca3af', weight: 60 },
        uncommon: { label: 'Uncommon', color: '#22c55e', weight: 25 },
        rare: { label: 'Rare', color: '#3b82f6', weight: 10 },
        epic: { label: 'Epic', color: '#a855f7', weight: 4 },
        legendary: { label: 'Legendary', color: '#f59e0b', weight: 1 }
    },
    TRINKETS: [
        { id: 'pencil', name: 'Pencil', icon: '', rarity: 'common', description: 'A trusty #2 pencil.' },
        { id: 'eraser', name: 'Eraser', icon: '', rarity: 'common', description: 'For those inevitable mistakes.' },
        { id: 'paperclip', name: 'Paperclip', icon: '', rarity: 'common', description: 'Keeps things together.' },
        { id: 'sticky-note', name: 'Sticky Note', icon: '', rarity: 'common', description: 'Don\'t forget!' },
        { id: 'coffee-cup', name: 'Coffee Cup', icon: '', rarity: 'common', description: 'Fuel for late nights.' },
        { id: 'calculator', name: 'Calculator', icon: '', rarity: 'uncommon', description: 'Crunch those numbers.' },
        { id: 'globe', name: 'Mini Globe', icon: '', rarity: 'uncommon', description: 'The world at your fingertips.' },
        { id: 'plant', name: 'Desk Plant', icon: '', rarity: 'uncommon', description: 'A touch of green.' },
        { id: 'lamp', name: 'Desk Lamp', icon: '', rarity: 'uncommon', description: 'Light up your studies.' },
        { id: 'trophy', name: 'Mini Trophy', icon: '', rarity: 'rare', description: 'You earned this!' },
        { id: 'snow-globe', name: 'Snow Globe', icon: '', rarity: 'rare', description: 'Shake it up.' },
        { id: 'hourglass', name: 'Hourglass', icon: '', rarity: 'rare', description: 'Time is precious.' },
        { id: 'crystal', name: 'Study Crystal', icon: '', rarity: 'epic', description: 'Radiates focus energy.' },
        { id: 'owl-statue', name: 'Owl Statue', icon: '', rarity: 'epic', description: 'Wisdom incarnate.' },
        { id: 'golden-pen', name: 'Golden Pen', icon: '', rarity: 'legendary', description: 'Writes destiny itself.' },
        { id: 'phoenix-feather', name: 'Phoenix Feather', icon: '', rarity: 'legendary', description: 'Rise from any failure.' }
    ],
    DESK_SLOTS: [
        { id: 'slot-1', label: 'Left', x: 10, y: 80 },
        { id: 'slot-2', label: 'Center-Left', x: 30, y: 85 },
        { id: 'slot-3', label: 'Center', x: 50, y: 80 },
        { id: 'slot-4', label: 'Center-Right', x: 70, y: 85 },
        { id: 'slot-5', label: 'Right', x: 90, y: 80 }
    ],

    getState() {
        return Store.get(this.STORAGE_KEY, { inventory: [], equipped: {}, seen: [] });
    },

    saveState(state) {
        Store.set(this.STORAGE_KEY, state);
    },

    getInventory() {
        const state = this.getState();
        return state.inventory.map(id => {
            const trinket = this.TRINKETS.find(t => t.id === id);
            if (!trinket) return null;
            return { ...trinket, rarityData: this.RARITY[trinket.rarity], isNew: !state.seen.includes(id), isEquipped: Object.values(state.equipped).includes(id) };
        }).filter(Boolean);
    },

    addTrinket(trinketId) {
        const state = this.getState();
        if (!state.inventory.includes(trinketId)) {
            state.inventory.push(trinketId);
            this.saveState(state);
        }
    },

    markSeen(trinketId) {
        const state = this.getState();
        if (!state.seen.includes(trinketId)) {
            state.seen.push(trinketId);
            this.saveState(state);
        }
    },

    equip(trinketId, slotId) {
        const state = this.getState();
        Object.keys(state.equipped).forEach(slot => { if (state.equipped[slot] === trinketId) delete state.equipped[slot]; });
        state.equipped[slotId] = trinketId;
        this.saveState(state);
        this.renderDeskTrinkets();
    },

    unequip(trinketId) {
        const state = this.getState();
        Object.keys(state.equipped).forEach(slot => { if (state.equipped[slot] === trinketId) delete state.equipped[slot]; });
        this.saveState(state);
        this.renderDeskTrinkets();
    },

    getEquipped() {
        const state = this.getState();
        const equipped = [];
        this.DESK_SLOTS.forEach(slot => {
            const trinketId = state.equipped[slot.id];
            if (trinketId) {
                const trinket = this.TRINKETS.find(t => t.id === trinketId);
                if (trinket) equipped.push({ ...trinket, slot, rarityData: this.RARITY[trinket.rarity] });
            }
        });
        return equipped;
    },

    rollTrinket() {
        const totalWeight = Object.values(this.RARITY).reduce((sum, r) => sum + r.weight, 0);
        let roll = Math.random() * totalWeight;
        let selectedRarity = 'common';
        for (const [rarity, data] of Object.entries(this.RARITY)) {
            roll -= data.weight;
            if (roll <= 0) { selectedRarity = rarity; break; }
        }
        const pool = this.TRINKETS.filter(t => t.rarity === selectedRarity);
        return pool[Math.floor(Math.random() * pool.length)];
    },

    awardRandomTrinket() {
        const trinket = this.rollTrinket();
        const state = this.getState();
        const isNew = !state.inventory.includes(trinket.id);
        this.addTrinket(trinket.id);
        return { ...trinket, rarityData: this.RARITY[trinket.rarity], isNew };
    },

    openModal() {
        let modal = document.getElementById('backpackModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'backpackModal';
            modal.className = 'modal-overlay';
            document.body.appendChild(modal);
        }
        const inventory = this.getInventory();
        const equipped = this.getEquipped();
        let html = `<div class="backpack-modal"><div class="backpack-header"><h2> Backpack</h2><button class="backpack-close" onclick="Backpack.closeModal()">&times;</button></div>`;
        html += `<div class="backpack-desk"><h3>Your Desk</h3><div class="desk-slots">`;
        this.DESK_SLOTS.forEach(slot => {
            const trinket = equipped.find(t => t.slot.id === slot.id);
            html += `<div class="desk-slot" data-slot="${slot.id}" style="left:${slot.x}%;top:${slot.y}%" onclick="Backpack.handleSlotClick('${slot.id}')">
                ${trinket ? `<span class="trinket-icon" style="color:${trinket.rarityData.color}" title="${trinket.name}">${trinket.icon}</span>` : `<span class="slot-empty">+</span>`}
            </div>`;
        });
        html += `</div></div><div class="backpack-inventory"><h3>Inventory (${inventory.length})</h3><div class="trinket-grid">`;
        if (inventory.length === 0) {
            html += `<p class="empty-inventory">No trinkets yet! Complete achievements to earn some.</p>`;
        } else {
            inventory.forEach(trinket => {
                html += `<div class="trinket-card ${trinket.isEquipped ? 'equipped' : ''}" data-trinket="${trinket.id}" style="border-color:${trinket.rarityData.color}" onclick="Backpack.handleTrinketClick('${trinket.id}')">
                    ${trinket.isNew ? '<span class="new-badge">NEW</span>' : ''}
                    <span class="trinket-icon">${trinket.icon}</span>
                    <span class="trinket-name">${trinket.name}</span>
                    <span class="trinket-rarity" style="color:${trinket.rarityData.color}">${trinket.rarityData.label}</span>
                </div>`;
            });
        }
        html += `</div></div></div>`;
        modal.innerHTML = html;
        modal.classList.add('active');
        inventory.forEach(t => this.markSeen(t.id));
    },

    selectedTrinket: null,

    handleTrinketClick(trinketId) {
        this.selectedTrinket = trinketId;
        const state = this.getState();
        const isEquipped = Object.values(state.equipped).includes(trinketId);
        if (isEquipped) {
            this.unequip(trinketId);
            this.openModal();
        }
    },

    handleSlotClick(slotId) {
        if (this.selectedTrinket) {
            this.equip(this.selectedTrinket, slotId);
            this.selectedTrinket = null;
            this.openModal();
        }
    },

    closeModal() {
        const modal = document.getElementById('backpackModal');
        if (modal) modal.classList.remove('active');
        this.selectedTrinket = null;
    },

    renderDeskTrinkets() {
        const container = document.getElementById('deskTrinkets');
        if (!container) return;
        const equipped = this.getEquipped();
        container.innerHTML = equipped.map(trinket => `
            <div class="desk-trinket" style="left:${trinket.slot.x}%;bottom:${100 - trinket.slot.y}%" title="${trinket.name}: ${trinket.description}">
                <span style="color:${trinket.rarityData.color}">${trinket.icon}</span>
            </div>
        `).join('');
    },

    showTrinketToast(trinket) {
        let toast = document.getElementById('trinketToast');
        if (!toast) {
            toast = document.createElement('div');
            toast.id = 'trinketToast';
            toast.className = 'trinket-toast';
            document.body.appendChild(toast);
        }
        toast.innerHTML = `<span class="toast-icon" style="color:${trinket.rarityData.color}">${trinket.icon}</span><div class="toast-content"><div class="toast-title">New Trinket!</div><div class="toast-subtitle" style="color:${trinket.rarityData.color}">${trinket.rarityData.label} - ${trinket.name}</div></div>`;
        toast.classList.add('show');
        setTimeout(() => toast.classList.remove('show'), 3000);
    }
};

// =====================================================================
// SHOP SYSTEM
// =====================================================================
const Shop = {
    currentTab: 'food',
    TABS: ['food','seeds','gardenItems','petHousing','decorations','cosmetics','housing','furniture','vehicles','adoptPet'],
    TAB_LABELS: { food:'Food', seeds:'Seeds', gardenItems:'Garden', petHousing:'Pet Home', decorations:'Decor', cosmetics:'Cosmetics', housing:'Houses', furniture:'Furniture', vehicles:'Vehicles', adoptPet:'Pets' },
    TAB_ICONS: { food:'', seeds:'', gardenItems:'', petHousing:'', decorations:'', cosmetics:'', housing:'', furniture:'', vehicles:'', adoptPet:'' },

    // Random sales system
    SALE_KEY: 'wgu_shopSales',
    SALE_DURATION: 4 * 60 * 60 * 1000, // 4 hours
    SALE_DISCOUNTS: [0.15, 0.20, 0.25, 0.30, 0.40, 0.50], // 15-50% off

    getSales() {
        const saved = Store.get(this.SALE_KEY, null);
        const now = Date.now();
        // Check if sales expired or don't exist
        if (!saved || now > saved.expiresAt) {
            return this.generateNewSales();
        }
        return saved;
    },

    generateNewSales() {
        const now = Date.now();
        const sales = { items: [], expiresAt: now + this.SALE_DURATION };
        const allTabs = ['food', 'seeds', 'gardenItems', 'petHousing', 'decorations', 'cosmetics', 'furniture'];
        // Pick 3-6 random items to put on sale
        const numSales = 3 + Math.floor(Math.random() * 4);
        const usedItems = new Set();
        for (let i = 0; i < numSales; i++) {
            const tab = allTabs[Math.floor(Math.random() * allTabs.length)];
            const catalog = Gamification.SHOP[tab];
            if (!catalog) continue;
            const itemIds = Object.keys(catalog);
            const itemId = itemIds[Math.floor(Math.random() * itemIds.length)];
            const key = `${tab}:${itemId}`;
            if (usedItems.has(key)) continue;
            usedItems.add(key);
            const discount = this.SALE_DISCOUNTS[Math.floor(Math.random() * this.SALE_DISCOUNTS.length)];
            sales.items.push({ tab, itemId, discount });
        }
        Store.set(this.SALE_KEY, sales);
        return sales;
    },

    getSaleDiscount(tab, itemId) {
        const sales = this.getSales();
        const sale = sales.items.find(s => s.tab === tab && s.itemId === itemId);
        return sale ? sale.discount : 0;
    },

    getSalePrice(originalPrice, tab, itemId) {
        const discount = this.getSaleDiscount(tab, itemId);
        if (discount > 0) {
            return Math.floor(originalPrice * (1 - discount));
        }
        return originalPrice;
    },

    getTimeUntilSaleEnds() {
        const sales = this.getSales();
        const remaining = sales.expiresAt - Date.now();
        if (remaining <= 0) return 'Expired';
        const hours = Math.floor(remaining / (60 * 60 * 1000));
        const mins = Math.floor((remaining % (60 * 60 * 1000)) / (60 * 1000));
        return `${hours}h ${mins}m`;
    },

    show() {
        this.render();
        showScreen('shop');
    },

    switchTab(tab) {
        if (this.TABS.includes(tab)) {
            this.currentTab = tab;
            this.render();
        }
    },

    render() {
        const state = Gamification.getState();
        document.getElementById('shopCoins').innerHTML = '&#x1FA99; ' + (state.coins || 0).toLocaleString();
        this.renderTabs();
        this.renderItems();
    },

    renderTabs() {
        const el = document.getElementById('shopTabs');
        el.innerHTML = this.TABS.map(t =>
            `<button class="shop-tab${this.currentTab === t ? ' active' : ''}" onclick="Shop.switchTab('${t}')">${this.TAB_ICONS[t]} ${this.TAB_LABELS[t]}</button>`
        ).join('') + `<button class="shop-tab${this.currentTab === 'plots' ? ' active' : ''}" onclick="Shop.switchTab('plots')"> Plots</button>`;
    },

    switchTab(tab) {
        this.currentTab = tab;
        this.renderTabs();
        this.renderItems();
    },

    renderItems() {
        const el = document.getElementById('shopItems');
        const state = Gamification.getState();
        const coins = state.coins || 0;

        if (this.currentTab === 'plots') {
            const unlocked = state.garden.unlockedPlots || 3;
            const maxPlots = 9;
            const canBuy = unlocked < maxPlots;
            const price = Gamification.SHOP.plotExpansion.price;
            el.innerHTML = `
                <div class="shop-section">
                    <h3>Garden Plots (${unlocked}/${maxPlots})</h3>
                    <div class="shop-grid">
                        <div class="shop-item${!canBuy ? ' sold-out' : ''}${coins < price ? ' cant-afford' : ''}">
                            <div class="shop-item-icon"></div>
                            <div class="shop-item-name">${canBuy ? 'Unlock Plot' : 'All Unlocked!'}</div>
                            <div class="shop-item-desc">${canBuy ? 'Expand your garden' : 'You have all 9 plots'}</div>
                            ${canBuy ? `<button class="shop-buy-btn" onclick="Shop.buyPlot()" ${coins < price ? 'disabled' : ''}>&#x1FA99; ${price}</button>` : ''}
                        </div>
                    </div>
                </div>`;
            return;
        }

        if (this.currentTab === 'adoptPet') {
            this.renderAdoptTab(el, state, coins);
            return;
        }

        const catalog = Gamification.SHOP[this.currentTab];
        if (!catalog) { el.innerHTML = ''; return; }

        // Show sale banner if any items on sale
        const sales = this.getSales();
        const currentTabSales = sales.items.filter(s => s.tab === this.currentTab);
        let html = '';
        if (currentTabSales.length > 0) {
            html += `<div class="shop-sale-banner"> SALE! ${currentTabSales.length} item(s) on sale  Ends in ${this.getTimeUntilSaleEnds()}</div>`;
        }

        html += '<div class="shop-grid">';
        for (const [id, item] of Object.entries(catalog)) {
            const originalPrice = item.price;
            const discount = this.getSaleDiscount(this.currentTab, id);
            const salePrice = discount > 0 ? this.getSalePrice(originalPrice, this.currentTab, id) : originalPrice;
            const owned = this.getOwned(this.currentTab, id, state);
            const canAfford = coins >= salePrice;
            const unlocked = Gamification.isItemUnlocked(this.currentTab, id);
            const reqLevel = (Gamification.LEVEL_REQS[this.currentTab] || {})[id] || 1;
            const onSale = discount > 0;
            // Unique items (housing, cosmetics) can only be bought once
            const isUniqueItem = this.currentTab === 'housing' || this.currentTab === 'cosmetics';
            const alreadyOwned = isUniqueItem && owned === 'Yes';
            html += `
                <div class="shop-item${!unlocked ? ' locked-item' : ''}${!canAfford && unlocked && !alreadyOwned ? ' cant-afford' : ''}${onSale ? ' on-sale' : ''}${alreadyOwned ? ' already-owned' : ''}">
                    ${onSale && !alreadyOwned ? `<div class="shop-sale-tag">-${Math.round(discount * 100)}%</div>` : ''}
                    <div class="shop-item-icon">${this.currentTab === 'seeds' ? Sprites.plantSprite(id, (item.stages || 4) - 1, item.icon, 36) : item.icon}</div>
                    <div class="shop-item-name">${item.name}</div>
                    ${item.desc ? `<div class="shop-item-desc">${item.desc}</div>` : ''}
                    ${!unlocked ? `<div class="shop-item-lock">Unlocks at Lv. ${reqLevel}</div>` : ''}
                    ${owned !== null && unlocked ? `<div class="shop-item-owned">${alreadyOwned ? ' Owned' : 'Owned: ' + owned}</div>` : ''}
                    ${unlocked && !alreadyOwned ? `<button class="shop-buy-btn${onSale ? ' sale-btn' : ''}" onclick="Shop.buy('${this.currentTab}','${id}')" ${!canAfford ? 'disabled' : ''}>${onSale ? `<s style="opacity:0.5;font-size:10px">&#x1FA99;${originalPrice}</s> ` : ''}&#x1FA99; ${salePrice}</button>` : ''}
                    ${alreadyOwned ? `<div class="shop-owned-badge"> Purchased</div>` : ''}
                </div>`;
        }
        html += '</div>';
        el.innerHTML = html;
    },

    getOwned(tab, id, state) {
        if (tab === 'food') return state.inventory.petFood[id] || 0;
        if (tab === 'seeds') return state.inventory.seeds[id] || 0;
        if (tab === 'gardenItems') return state.inventory.gardenItems[id] || 0;
        if (tab === 'decorations') return state.inventory.decorations.filter(d => d === id).length;
        if (tab === 'cosmetics') return state.inventory.petAccessories.includes(id) ? 'Yes' : null;
        if (tab === 'petHousing') return (state.inventory.petHousing || {})[id] || 0;
        if (tab === 'furniture') return (state.inventory.furniture || {})[id] || 0;
        if (tab === 'vehicles') return (state.inventory.vehicles || {})[id] || 0;
        if (tab === 'housing') return (state.housing?.owned || []).includes(id) ? 'Yes' : null;
        return null;
    },

    buy(tab, id) {
        const catalog = Gamification.SHOP[tab];
        const item = catalog[id];
        if (!item) return;

        // Use sale price if on sale
        const salePrice = this.getSalePrice(item.price, tab, id);
        if (!Gamification.spendCoins(salePrice)) {
            return;
        }

        const state = Gamification.getState();

        if (tab === 'food') {
            state.inventory.petFood[id] = (state.inventory.petFood[id] || 0) + 1;
        } else if (tab === 'seeds') {
            state.inventory.seeds[id] = (state.inventory.seeds[id] || 0) + 1;
        } else if (tab === 'gardenItems') {
            if (id === 'healthPotion' || id === 'shieldCharm' || id === 'powerBerry') {
                state.inventory.battleItems[id] = (state.inventory.battleItems[id] || 0) + 1;
            } else if (id === 'evoStone') {
                // Evolution stone: add to inventory (not auto-used)
                state.inventory.gardenItems.evoStone = (state.inventory.gardenItems.evoStone || 0) + 1;
            } else if (id === 'rainCloud') {
                // Rain Cloud: activate auto-water for 1 hour
                state.garden = state.garden || {};
                state.garden.rainCloudUntil = Date.now() + 60 * 60 * 1000; // 1 hour
                Gamification.showAchievementToast({ icon: '', name: 'Rain Cloud Active!', desc: 'Auto-watering all plants for 1 hour', xp: 0 });
            } else if (id === 'superFertilizer') {
                // Super Fertilizer: add to inventory
                state.inventory.gardenItems.superFertilizer = (state.inventory.gardenItems.superFertilizer || 0) + 1;
            } else {
                state.inventory.gardenItems[id] = (state.inventory.gardenItems[id] || 0) + 1;
            }
        } else if (tab === 'decorations') {
            state.inventory.decorations.push(id);
        } else if (tab === 'cosmetics') {
            if (!state.inventory.petAccessories.includes(id)) {
                state.inventory.petAccessories.push(id);
            }
        } else if (tab === 'petHousing') {
            state.inventory.petHousing = state.inventory.petHousing || {};
            state.inventory.petHousing[id] = (state.inventory.petHousing[id] || 0) + 1;
            // Apply pet housing effects
            this.applyPetHousingEffects(state, id, item);
        } else if (tab === 'furniture') {
            state.inventory.furniture = state.inventory.furniture || {};
            state.inventory.furniture[id] = (state.inventory.furniture[id] || 0) + 1;
        } else if (tab === 'vehicles') {
            state.inventory.vehicles = state.inventory.vehicles || {};
            state.inventory.vehicles[id] = (state.inventory.vehicles[id] || 0) + 1;
        } else if (tab === 'housing') {
            state.housing = state.housing || { current: null, owned: [] };
            if (!state.housing.owned.includes(id)) {
                state.housing.owned.push(id);
                if (!state.housing.current) state.housing.current = id;
            }
        }

        Gamification.saveState(state);
        SoundFX.play('purchase');
        Gamification.unlockAchievement('window_shopper');
        this.render();
    },

    buyPlot() {
        const state = Gamification.getState();
        if (state.garden.unlockedPlots >= 9) return;
        if (!Gamification.spendCoins(Gamification.SHOP.plotExpansion.price)) return;
        state.garden.unlockedPlots++;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.render();
    },

    applyPetHousingEffects(state, id, item) {
        // Apply to active pet's petCare, not global
        const pet = state.studyBuddy;
        if (!pet) return;
        
        pet.petCare = pet.petCare || { foodBowl: { level: 0, capacity: 0 }, waterBowl: { level: 0, capacity: 0 }, comfortBonus: 0, allDecayReduction: 0, housing: {} };
        pet.petCare.housing = pet.petCare.housing || {};
        pet.petCare.housing[id] = (pet.petCare.housing[id] || 0) + 1;
        
        // Food/water bowls
        if (item.type === 'food') {
            pet.petCare.foodBowl.capacity = Math.max(pet.petCare.foodBowl.capacity, item.capacity);
        } else if (item.type === 'water') {
            pet.petCare.waterBowl.capacity = Math.max(pet.petCare.waterBowl.capacity, item.capacity);
        }
        
        // Comfort bonus (beds, houses)
        if (item.comfortBonus) {
            pet.petCare.comfortBonus = Math.min(0.5, pet.petCare.comfortBonus + item.comfortBonus);
        }
        
        // All decay reduction (pet houses)
        if (item.allDecay && item.comfortBonus) {
            pet.petCare.allDecayReduction = Math.min(0.5, pet.petCare.allDecayReduction + item.comfortBonus);
        }
    },

    fillFoodBowl() {
        const state = Gamification.getState();
        const pet = state.studyBuddy;
        if (!pet?.petCare?.foodBowl?.capacity) return;
        const capacity = pet.petCare.foodBowl.capacity;
        const current = pet.petCare.foodBowl.level || 0;
        const needed = capacity - current;
        if (needed <= 0) return;
        
        // Use kibble from inventory
        const available = state.inventory.petFood.kibble || 0;
        const toUse = Math.min(available, needed);
        if (toUse > 0) {
            state.inventory.petFood.kibble -= toUse;
            pet.petCare.foodBowl.level = current + toUse;
            Gamification.saveState(state);
            this.render();
        }
    },

    fillWaterBowl() {
        const state = Gamification.getState();
        const pet = state.studyBuddy;
        if (!pet?.petCare?.waterBowl?.capacity) return;
        const capacity = pet.petCare.waterBowl.capacity;
        const current = pet.petCare.waterBowl.level || 0;
        const needed = capacity - current;
        if (needed <= 0) return;
        
        // Water is free to fill
        pet.petCare.waterBowl.level = capacity;
        Gamification.saveState(state);
        this.render();
    },

    resurrectPet(graveIdx) {
        const state = Gamification.getState();
        let graveyard = state.graveyard || [];
        const resStones = state.inventory?.battleItems?.resStone || 0;
        const pets = state.pets || [];
        const maxPets = 6;
        
        // Clean up duplicate graveyard entries first
        const seenNames = new Set();
        graveyard = graveyard.filter(g => {
            if (seenNames.has(g.name)) return false;
            seenNames.add(g.name);
            return true;
        });
        state.graveyard = graveyard;
        
        if (graveIdx < 0 || graveIdx >= graveyard.length) {
            alert('Pet not found in graveyard.');
            return;
        }
        if (resStones <= 0) {
            alert('You need a Resurrection Stone! Buy one from the shop.');
            return;
        }
        if (pets.length >= maxPets) {
            alert('Pet roster is full! Release a pet first.');
            return;
        }
        
        const grave = graveyard[graveIdx];
        const sp = Gamification.PET_SPECIES[grave.species] || Gamification.PET_SPECIES.bird;
        
        // Confirm resurrection
        if (!confirm(`Resurrect ${grave.name} the ${sp.name}? This will use 1 Resurrection Stone.`)) return;
        
        // Use resurrection stone
        state.inventory.battleItems.resStone--;
        
        // Remove from graveyard
        graveyard.splice(graveIdx, 1);
        state.graveyard = graveyard;
        
        // Remove name from retired names so it can be used again
        const retiredIdx = (state.retiredNames || []).indexOf(grave.name);
        if (retiredIdx >= 0) state.retiredNames.splice(retiredIdx, 1);
        
        // Create resurrected pet - keep at least stage 2 (baby, not egg)
        const now = Date.now();
        const revivedStage = Math.max(2, (grave.stage || 2)); // At least baby stage, keep original if higher
        const newPet = {
            name: grave.name,
            species: grave.species,
            stage: revivedStage,
            totalXpFed: Math.floor((grave.totalXpFed || 0) * 0.75), // Keep 75% XP
            mood: 'content',
            lastFed: now,
            hunger: 80,
            happiness: 80,
            lastDecayCheck: now,
            careMinutes: Math.floor((grave.careMinutes || 0) * 0.75), // Keep 75% care time
            studyMinutes: 0,
            sick: false,
            lastInteraction: now,
            accessories: grave.accessories || [],
            totalMealsEaten: 0,
            birthDate: now, // Fresh lifespan
            lifespan: 30 + Math.floor(Math.random() * 15), // 30-45 days
            resurrected: true,
            timesResurrected: (grave.timesResurrected || 0) + 1
        };
        
        // Add to pets array
        pets.push(newPet);
        state.pets = pets;
        
        // Make it the active pet and clear dead flag
        state.activePetIdx = pets.length - 1;
        state.studyBuddy = newPet;
        state.studyBuddy.dead = false;
        
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        
        Gamification.showAchievementToast({
            icon: '',
            name: `${grave.name} has returned!`,
            desc: 'Your pet has been resurrected',
            xp: 0
        });
        
        SoundFX.play('levelUp');
        Garden.render();
        this.render();
    },

    renderAdoptTab(el, state, coins) {
        const pets = state.pets || [];
        const ownedSpecies = pets.map(p => p.species);
        const maxPets = 4;
        let html = `<div class="shop-section"><h3>Your Pets (${pets.length}/${maxPets})</h3>`;

        // Show owned pets
        if (pets.length > 0) {
            html += '<div class="pet-roster">';
            pets.forEach((pet, idx) => {
                const sp = Gamification.PET_SPECIES[pet.species] || Gamification.PET_SPECIES.bird;
                const isActive = idx === (state.activePetIdx || 0);
                html += `<div class="pet-roster-item${isActive ? ' active' : ''}" onclick="Shop.switchPet(${idx})">
                    <span class="pet-roster-emoji">${Gamification.getSpeciesEmoji(pet.species, pet.stage)}</span>
                    <span class="pet-roster-name">${pet.name}</span>
                    <span class="pet-roster-info">${sp.name} Lv${pet.stage}</span>
                    ${isActive ? '<span class="pet-roster-active">Active</span>' : ''}
                </div>`;
            });
            html += '</div>';
        }

        // Show adoptable species (allow buying same species multiple times)
        html += '<h3>Adopt New Pet</h3><div class="shop-grid">';
        const speciesDeathCount = state.speciesDeathCount || {};
        for (const [id, sp] of Object.entries(Gamification.PET_SPECIES)) {
            const levelOk = state.level >= sp.unlockLevel;
            // Price increases by 25% for each death of same species
            const deathPenalty = speciesDeathCount[id] || 0;
            const adjustedPrice = Math.round(sp.price * Math.pow(1.25, deathPenalty));
            const canAfford = coins >= adjustedPrice;
            const full = pets.length >= maxPets;
            const disabled = !levelOk || !canAfford || full;
            const priceLabel = adjustedPrice > 0 ? '&#x1FA99; ' + adjustedPrice : 'Free!';
            const deathPenaltyLabel = deathPenalty > 0 ? `<div class="shop-item-desc" style="color:#f87171">+${Math.round((Math.pow(1.25, deathPenalty) - 1) * 100)}% (${deathPenalty} lost)</div>` : '';
            html += `<div class="shop-item${!levelOk ? ' locked-item' : ''}${!canAfford && levelOk ? ' cant-afford' : ''}">
                <div class="shop-item-icon">${sp.emojis[sp.emojis.length - 1]}</div>
                <div class="shop-item-name">${sp.name}</div>
                <div class="shop-item-desc">Difficulty: ${''.repeat(Math.ceil(sp.difficulty * 2))}${''.repeat(4 - Math.ceil(sp.difficulty * 2))}</div>
                <div class="shop-item-desc">${sp.stages.join('  ')}</div>
                ${deathPenaltyLabel}
                ${!levelOk ? `<div class="shop-item-lock">Unlocks at Lv. ${sp.unlockLevel}</div>` : ''}
                ${full ? `<div class="shop-item-lock">Pet roster full (${maxPets})</div>` : ''}
                ${!disabled ? `<button class="shop-buy-btn" onclick="Shop.adoptPet('${id}')">${priceLabel}</button>` : ''}
            </div>`;
        }
        html += '</div>';
        
        // Show graveyard if any pets have died
        const graveyard = state.graveyard || [];
        const resStones = state.inventory?.battleItems?.resStone || 0;
        const maxPetsForRes = 6;
        const petsForRes = (state.pets || []).length;
        const canResurrect = resStones > 0 && petsForRes < maxPetsForRes;
        
        if (graveyard.length > 0) {
            html += `<h3> Pet Graveyard <span style="font-size:12px;color:var(--gray-500)">( ${resStones} Resurrection Stones)</span></h3><div class="shop-grid">`;
            graveyard.forEach((grave, idx) => {
                const sp = Gamification.PET_SPECIES[grave.species] || Gamification.PET_SPECIES.bird;
                const diedDate = new Date(grave.diedAt).toLocaleDateString();
                const ageLabel = grave.ageAtDeath ? `Age: ${grave.ageAtDeath} days` : '';
                const causeLabel = grave.diedOfAge ? ' Natural causes' : ' Neglect';
                html += `<div class="shop-item" style="background:linear-gradient(135deg,#2d2d3a,#1a1a2e)">
                    <div class="shop-item-icon" style="filter:grayscale(0.5)">${Gamification.getSpeciesEmoji(grave.species, grave.stage)}</div>
                    <div class="shop-item-name">${grave.name}</div>
                    <div class="shop-item-desc">${sp.name} Stage ${grave.stage}</div>
                    ${ageLabel ? `<div class="shop-item-desc" style="color:#9ca3af">${ageLabel}</div>` : ''}
                    <div class="shop-item-desc" style="color:#888">${causeLabel}  ${diedDate}</div>
                    <div class="shop-item-desc" style="color:#666">XP Fed: ${grave.totalXpFed || 0}</div>
                    ${canResurrect ? `<button class="shop-buy-btn" style="background:linear-gradient(135deg,#8b5cf6,#6366f1)" onclick="Shop.resurrectPet(${idx})"> Resurrect</button>` : ''}
                    ${!canResurrect && resStones <= 0 ? `<div class="shop-item-desc" style="color:#f59e0b">Need Resurrection Stone</div>` : ''}
                    ${!canResurrect && petsForRes >= maxPetsForRes ? `<div class="shop-item-desc" style="color:#ef4444">Pet roster full</div>` : ''}
                </div>`;
            });
            html += '</div>';
        }
        
        // Show pet care status for active pet
        const activePet = state.studyBuddy;
        const petCare = activePet?.petCare || {};
        if (petCare.foodBowl?.capacity > 0 || petCare.waterBowl?.capacity > 0) {
            html += `<h3> ${activePet.name}'s Care Station</h3><div class="shop-grid">`;
            if (petCare.foodBowl?.capacity > 0) {
                const foodLevel = petCare.foodBowl.level || 0;
                const foodCap = petCare.foodBowl.capacity;
                html += `<div class="shop-item">
                    <div class="shop-item-icon"></div>
                    <div class="shop-item-name">Food Bowl</div>
                    <div class="shop-item-desc">${foodLevel}/${foodCap} meals</div>
                    <button class="shop-buy-btn" onclick="Shop.fillFoodBowl()" ${foodLevel >= foodCap ? 'disabled' : ''}>Fill (uses kibble)</button>
                </div>`;
            }
            if (petCare.waterBowl?.capacity > 0) {
                const waterLevel = Math.round(petCare.waterBowl.level || 0);
                const waterCap = petCare.waterBowl.capacity;
                html += `<div class="shop-item">
                    <div class="shop-item-icon"></div>
                    <div class="shop-item-name">Water Bowl</div>
                    <div class="shop-item-desc">${waterLevel}/${waterCap} drinks</div>
                    <button class="shop-buy-btn" onclick="Shop.fillWaterBowl()" ${waterLevel >= waterCap ? 'disabled' : ''}>Fill (free)</button>
                </div>`;
            }
            html += '</div>';
        }
        
        html += '</div>';
        el.innerHTML = html;
    },

    adoptPet(speciesId) {
        const sp = Gamification.PET_SPECIES[speciesId];
        if (!sp) return;
        const state = Gamification.getState();
        let pets = state.pets || [];
        
        // Remove default "Buddy" pet if it exists and has minimal interaction
        // This prevents the default pet from cluttering the pet list
        pets = pets.filter(p => {
            if (p.name === 'Buddy' && p.species === 'bird' && (p.totalXpFed || 0) < 100) {
                return false; // Remove unused default pet
            }
            return true;
        });
        state.pets = pets;
        
        if (pets.length >= 4) return;
        // Allow buying same species again (removed species restriction)
        if (state.level < sp.unlockLevel) return;
        // Price increases by 25% for each death of same species
        const speciesDeathCount = state.speciesDeathCount || {};
        const deathPenalty = speciesDeathCount[speciesId] || 0;
        const adjustedPrice = Math.round(sp.price * Math.pow(1.25, deathPenalty));
        if (adjustedPrice > 0 && !Gamification.spendCoins(adjustedPrice)) return;

        // Check for retired names AND current pet names
        const retiredNames = state.retiredNames || [];
        const currentPetNames = pets.map(p => p.name.toLowerCase());
        const isNameTaken = (n) => retiredNames.map(r => r.toLowerCase()).includes(n.toLowerCase()) || currentPetNames.includes(n.toLowerCase());
        let name = prompt('Name your new ' + sp.name + ':') || sp.name;
        while (isNameTaken(name)) {
            const reason = currentPetNames.includes(name.toLowerCase()) ? 'already in use by another pet' : 'retired (belonged to a deceased pet)';
            name = prompt(`That name is ${reason}. Choose another name:`) || sp.name;
            if (!isNameTaken(name)) break;
        }
        const newPet = {
            name: name.slice(0, 20), species: speciesId, stage: 1, totalXpFed: 0,
            mood: 'sleepy', lastFed: null, hunger: 100, happiness: 100,
            lastDecayCheck: Date.now(), careMinutes: 0, lastCareCheck: null,
            studyMinutes: 0, sick: false, lastInteraction: Date.now(),
            accessories: [], totalMealsEaten: 0,
            birthDate: Date.now(), // Pet age tracking
            lifespan: 30 + Math.floor(Math.random() * 15) // 30-45 days lifespan
        };
        state.pets.push(newPet);
        state.activePetIdx = state.pets.length - 1; // Make new pet active
        state.studyBuddy = newPet;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.render();
    },

    switchPet(idx) {
        const state = Gamification.getState();
        if (idx < 0 || idx >= (state.pets || []).length) return;
        // Save current active pet back
        state.pets[state.activePetIdx || 0] = state.studyBuddy;
        // Switch
        state.activePetIdx = idx;
        state.studyBuddy = state.pets[idx];
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        Gamification.renderXpBar();
        this.render();
    }
};

// =====================================================================
// HOUSE SYSTEM
// =====================================================================
const House = {
    show() {
        this.render();
        showScreen('house');
    },

    currentRoom: 0,

    render() {
        const state = Gamification.getState();
        const housing = state.housing || { current: null, owned: [] };
        const furniture = state.inventory?.furniture || {};
        const vehicles = state.inventory?.vehicles || {};
        const coins = state.coins || 0;
        
        document.getElementById('houseCoins').innerHTML = '&#x1FA99; ' + coins.toLocaleString();
        
        let html = '';
        
        // Current house display with interior view
        const conditions = housing.conditions || {};
        if (housing.current) {
            const houseData = Gamification.SHOP.housing[housing.current];
            const condition = conditions[housing.current] ?? 100;
            const condColor = this.getConditionColor(condition);
            const condLabel = this.getConditionLabel(condition);
            const rooms = houseData?.rooms || ['living'];
            const currentRoom = Math.min(this.currentRoom, rooms.length - 1);
            
            // Interior view
            html += this.renderInterior(housing.current, houseData, rooms, currentRoom, state);
            
            // Condition bar below interior
            html += `<div style="display:flex;align-items:center;gap:12px;padding:12px;background:var(--gray-100);border-radius:10px;margin-bottom:16px">
                <span style="font-size:24px">${houseData?.icon || ''}</span>
                <div style="flex:1">
                    <div style="font-weight:600;color:var(--navy)">${houseData?.name || 'My Home'}</div>
                    <div style="font-size:11px;color:var(--gray-500)">${houseData?.desc || ''}</div>
                </div>
                <div style="text-align:right">
                    <div style="background:var(--gray-200);border-radius:6px;height:12px;width:100px;overflow:hidden">
                        <div style="background:${condColor};height:100%;width:${condition}%"></div>
                    </div>
                    <div style="font-size:11px;color:${condColor};margin-top:2px">${condLabel} (${Math.round(condition)}%)</div>
                </div>
            </div>`;
        } else {
            html += `<div class="house-display" style="text-align:center;padding:20px;background:var(--gray-100);border-radius:16px;margin-bottom:20px">
                <div style="font-size:48px;opacity:0.5"></div>
                <h3 style="color:var(--gray-500)">No Home Yet</h3>
                <p style="color:var(--gray-400)">Buy a house from the Shop!</p>
                <button class="btn-primary" onclick="Shop.show();Shop.switchTab('housing')">Browse Houses</button>
            </div>`;
        }
        
        // Active services
        const activeServices = housing.activeServices || [];
        if (activeServices.length > 0) {
            html += '<h3> Active Workers</h3><div class="shop-grid">';
            activeServices.forEach((svc, idx) => {
                const svcData = Gamification.SHOP.services[svc.type];
                const timeLeft = Math.max(0, svc.expiresAt - Date.now());
                const hoursLeft = Math.floor(timeLeft / (1000 * 60 * 60));
                const minsLeft = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
                html += `<div class="shop-item">
                    <div class="shop-item-icon">${svcData?.icon || ''}</div>
                    <div class="shop-item-name">${svcData?.name || svc.type}</div>
                    <div class="shop-item-desc">Working on: ${svc.houseId}</div>
                    <div class="shop-item-owned" style="color:var(--green)">${hoursLeft}h ${minsLeft}m left</div>
                </div>`;
            });
            html += '</div>';
        }
        
        // Repair services
        if (housing.current && (conditions[housing.current] ?? 100) < 100) {
            html += '<h3> Repair Services</h3><div class="shop-grid">';
            for (const [id, svc] of Object.entries(Gamification.SHOP.services)) {
                const canAfford = coins >= svc.price;
                html += `<div class="shop-item${!canAfford ? ' cant-afford' : ''}">
                    <div class="shop-item-icon">${svc.icon}</div>
                    <div class="shop-item-name">${svc.name}</div>
                    <div class="shop-item-desc">${svc.desc}</div>
                    <button class="shop-buy-btn" onclick="House.hireService('${id}')" ${!canAfford ? 'disabled' : ''}>&#x1FA99; ${svc.price}</button>
                </div>`;
            }
            html += '</div>';
        }
        
        // Owned houses
        if (housing.owned.length > 0) {
            html += '<h3> Your Properties</h3><div class="shop-grid">';
            housing.owned.forEach(houseId => {
                const h = Gamification.SHOP.housing[houseId];
                const isCurrent = housing.current === houseId;
                const cond = conditions[houseId] ?? 100;
                const condColor = this.getConditionColor(cond);
                html += `<div class="shop-item${isCurrent ? ' active' : ''}" style="${isCurrent ? 'border:2px solid var(--green)' : ''}">
                    <div class="shop-item-icon">${h?.icon || ''}</div>
                    <div class="shop-item-name">${h?.name || houseId}</div>
                    <div style="background:rgba(0,0,0,0.1);border-radius:4px;height:8px;margin:4px 0">
                        <div style="background:${condColor};height:100%;width:${cond}%;border-radius:4px"></div>
                    </div>
                    <div class="shop-item-desc" style="color:${condColor}">${Math.round(cond)}% condition</div>
                    ${isCurrent ? '<div class="shop-item-owned" style="color:var(--green)">Current Home</div>' : 
                        `<button class="shop-buy-btn" onclick="House.setCurrentHouse('${houseId}')">Move In</button>`}
                </div>`;
            });
            html += '</div>';
        }
        
        // Furniture inventory
        const furnitureItems = Object.entries(furniture).filter(([k, v]) => v > 0);
        if (furnitureItems.length > 0) {
            html += '<h3> Furniture</h3><div class="shop-grid">';
            furnitureItems.forEach(([id, count]) => {
                const f = Gamification.SHOP.furniture[id];
                html += `<div class="shop-item">
                    <div class="shop-item-icon">${f?.icon || ''}</div>
                    <div class="shop-item-name">${f?.name || id}</div>
                    <div class="shop-item-desc">${f?.desc || ''}</div>
                    <div class="shop-item-owned">Owned: ${count}</div>
                </div>`;
            });
            html += '</div>';
        }
        
        // Vehicles inventory
        const vehicleItems = Object.entries(vehicles).filter(([k, v]) => v > 0);
        if (vehicleItems.length > 0) {
            html += '<h3> Garage</h3><div class="shop-grid">';
            vehicleItems.forEach(([id, count]) => {
                const v = Gamification.SHOP.vehicles[id];
                html += `<div class="shop-item">
                    <div class="shop-item-icon">${v?.icon || ''}</div>
                    <div class="shop-item-name">${v?.name || id}</div>
                    <div class="shop-item-desc">${v?.desc || ''}</div>
                    <div class="shop-item-owned">Owned: ${count}</div>
                </div>`;
            });
            html += '</div>';
        }
        
        // XP bonuses from furniture
        const xpBonus = this.calculateXpBonus(state);
        if (xpBonus > 0) {
            html += `<div style="text-align:center;padding:12px;background:var(--green-light);border-radius:8px;margin-top:16px">
                <strong> Study Bonus:</strong> +${(xpBonus * 100).toFixed(0)}% XP from furniture
            </div>`;
        }
        
        // Shop link
        html += `<div style="text-align:center;margin-top:20px">
            <button class="btn-primary" onclick="Shop.show();Shop.switchTab('furniture')"> Shop Furniture</button>
            <button class="btn-primary" onclick="Shop.show();Shop.switchTab('vehicles')" style="margin-left:8px"> Shop Vehicles</button>
        </div>`;
        
        document.getElementById('houseContent').innerHTML = html;
    },

    setCurrentHouse(houseId) {
        const state = Gamification.getState();
        state.housing = state.housing || { current: null, owned: [] };
        if (state.housing.owned.includes(houseId)) {
            state.housing.current = houseId;
            Gamification.saveState(state);
            this.currentRoom = 0;
            this.render();
        }
    },

    switchRoom(roomIdx) {
        this.currentRoom = roomIdx;
        this.render();
    },

    renderInterior(houseId, houseData, rooms, currentRoomIdx, state) {
        const roomName = rooms[currentRoomIdx] || 'living';
        const furniture = state.inventory?.furniture || {};
        const pet = state.studyBuddy || {};
        
        // Room display names
        const roomNames = {
            sleeping: ' Sleeping Area', living: ' Living Room', kitchen: ' Kitchen',
            bedroom: ' Bedroom', bathroom: ' Bathroom', foyer: ' Foyer',
            dining: ' Dining Room', study: ' Study', master: ' Master Suite',
            guest: ' Guest Room', office: ' Home Office', terrace: ' Terrace',
            throne: ' Throne Room', great_hall: ' Great Hall', tower: ' Tower',
            library: ' Library', courtyard: ' Courtyard'
        };
        
        // Room-specific furniture mapping (which furniture fits best in each room)
        const roomFurniture = {
            sleeping: ['bed', 'lamp', 'rug'], living: ['couch', 'tv', 'rug', 'plant', 'painting', 'lamp'], kitchen: ['lamp', 'plant'],
            bedroom: ['bed', 'lamp', 'rug', 'painting'], bathroom: ['plant'], foyer: ['plant', 'painting', 'rug'],
            dining: ['lamp', 'rug', 'painting'], study: ['desk', 'bookshelf', 'lamp', 'computer', 'rug'],
            master: ['bed', 'lamp', 'rug', 'painting', 'tv'], guest: ['bed', 'lamp', 'rug'],
            office: ['desk', 'computer', 'bookshelf', 'lamp'], terrace: ['plant', 'lamp'],
            throne: ['rug', 'painting', 'fireplace'], great_hall: ['fireplace', 'rug', 'painting', 'couch'],
            tower: ['bookshelf', 'lamp', 'desk'], library: ['bookshelf', 'desk', 'lamp', 'rug'],
            courtyard: ['plant', 'aquarium']
        };
        
        // Get furniture for current room - show all owned furniture that fits this room
        const roomFurn = roomFurniture[roomName] || Object.keys(Gamification.SHOP.furniture || {});
        const displayFurniture = roomFurn.filter(f => furniture[f] > 0);
        
        // Also show any other owned furniture not in the room mapping (fallback)
        const otherFurniture = Object.keys(furniture).filter(f => furniture[f] > 0 && !roomFurn.includes(f));
        const allDisplayFurniture = [...displayFurniture, ...otherFurniture];
        
        // Build interior HTML
        let html = `<div class="house-interior ${houseId}">`;
        
        // Window/view area based on house type
        if (houseId === 'penthouse') {
            html += `<div class="house-window penthouse">
                <div class="house-skyline">
                    ${this._renderSkyline()}
                </div>
            </div>`;
        } else if (houseId === 'castle') {
            html += `<div class="house-window" style="background:linear-gradient(180deg,#1a1a3e 0%,#2d2d5a 100%)">
                <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-size:60px;opacity:0.2"></div>
            </div>`;
        } else if (houseId === 'mansion') {
            html += `<div class="house-window" style="background:linear-gradient(180deg,#87CEEB 0%,#98d4e8 100%)">
                <div style="position:absolute;bottom:0;left:0;right:0;height:40%;background:linear-gradient(180deg,#228B22,#2d8f2d)"></div>
            </div>`;
        } else if (houseId === 'tent' || houseId === 'cabin') {
            html += `<div class="house-window" style="background:linear-gradient(180deg,#2d4a3e 0%,#1a2f26 100%)">
                <div style="position:absolute;top:20px;right:30px;font-size:24px"></div>
                <div style="position:absolute;top:15px;left:20px;font-size:12px;letter-spacing:8px"></div>
            </div>`;
        } else {
            html += `<div class="house-window" style="background:linear-gradient(180deg,#87CEEB 0%,#b8e0f0 100%)">
                <div style="position:absolute;top:20px;right:30px;font-size:28px"></div>
            </div>`;
        }
        
        // Floor area with room tabs and content
        html += `<div class="house-floor">
            <div class="house-room-tabs">
                ${rooms.map((r, i) => `<button class="house-room-tab${i === currentRoomIdx ? ' active' : ''}" onclick="House.switchRoom(${i})">${roomNames[r] || r}</button>`).join('')}
            </div>
            <div class="house-room-content">
                <div class="house-room-name">${roomNames[roomName] || roomName}</div>
                <div class="house-room-furniture">
                    ${allDisplayFurniture.length > 0 ? allDisplayFurniture.map(f => {
                        const fData = Gamification.SHOP.furniture[f];
                        return `<div class="house-furniture-item" title="${fData?.name || f}">${fData?.icon || ''}</div>`;
                    }).join('') : '<div style="color:rgba(255,255,255,0.5);font-size:12px">No furniture placed</div>'}
                </div>
                ${this._renderPetInRoom(pet, state)}
            </div>
        </div>`;
        
        html += '</div>';
        return html;
    },

    _renderSkyline() {
        const buildings = [];
        for (let i = 0; i < 12; i++) {
            const h = 40 + Math.random() * 50;
            const w = 15 + Math.random() * 20;
            buildings.push(`<div class="house-building" style="width:${w}px;height:${h}%"></div>`);
        }
        return buildings.join('');
    },

    _renderPetInRoom(pet, state) {
        if (!pet.type) return '';
        const petData = Gamification.SHOP.pets?.[pet.type] || {};
        const emoji = petData.stages?.[pet.stage || 0] || petData.icon || '';
        const accessory = pet.accessory ? (Gamification.SHOP.petAccessories?.[pet.accessory]?.icon || '') : '';
        const mood = this._getPetMood(pet);
        
        return `<div class="house-pet" onclick="PetModal.show()">
            <div class="house-pet-mood">${mood}</div>
            <div class="house-pet-sprite">${emoji}${accessory ? `<span style="position:absolute;top:-8px;right:-8px;font-size:16px">${accessory}</span>` : ''}</div>
            <div class="house-pet-name">${pet.name || 'Pet'}</div>
        </div>`;
    },

    _getPetMood(pet) {
        const hunger = pet.hunger ?? 100;
        const happiness = pet.happiness ?? 100;
        if (pet.sick) return ' Sick';
        if (hunger < 30) return ' Starving';
        if (happiness < 30) return ' Sad';
        if (hunger < 60) return ' Hungry';
        if (happiness < 60) return ' Bored';
        if (happiness > 80 && hunger > 80) return ' Happy';
        return ' Content';
    },

    calculateXpBonus(state) {
        const furniture = state.inventory?.furniture || {};
        let bonus = 0;
        for (const [id, count] of Object.entries(furniture)) {
            const f = Gamification.SHOP.furniture[id];
            if (f?.xpBonus && count > 0) {
                bonus += f.xpBonus; // Only count once per type
            }
        }
        return bonus;
    },

    decayHouses() {
        const state = Gamification.getState();
        const housing = state.housing || { current: null, owned: [], conditions: {}, lastDecayCheck: null, laborers: 0 };
        const now = Date.now();
        
        if (!housing.owned || housing.owned.length === 0) return;
        
        // Initialize conditions for owned houses
        housing.conditions = housing.conditions || {};
        housing.owned.forEach(houseId => {
            if (housing.conditions[houseId] === undefined) {
                housing.conditions[houseId] = 100; // Start at 100%
            }
        });
        
        const lastCheck = housing.lastDecayCheck || now;
        const hoursPassed = (now - lastCheck) / (1000 * 60 * 60);
        
        if (hoursPassed < 0.5) return; // Check every 30 min minimum
        
        // Process active laborers
        housing.activeServices = housing.activeServices || [];
        const expiredServices = [];
        housing.activeServices.forEach((service, idx) => {
            if (now >= service.expiresAt) {
                expiredServices.push(idx);
            } else {
                // Apply repair per day (scaled to hours passed)
                const repairPerHour = (service.repairRate || 10) / 24;
                const repairAmount = repairPerHour * hoursPassed;
                if (service.houseId && housing.conditions[service.houseId] !== undefined) {
                    housing.conditions[service.houseId] = Math.min(100, housing.conditions[service.houseId] + repairAmount);
                }
            }
        });
        // Remove expired services
        expiredServices.reverse().forEach(idx => housing.activeServices.splice(idx, 1));
        
        // Decay all owned houses
        housing.owned.forEach(houseId => {
            const houseData = Gamification.SHOP.housing[houseId];
            if (!houseData) return;
            
            const decayRate = houseData.decayRate || 0.3; // % per day
            const decayPerHour = decayRate / 24;
            const decay = decayPerHour * hoursPassed;
            
            housing.conditions[houseId] = Math.max(0, (housing.conditions[houseId] || 100) - decay);
        });
        
        housing.lastDecayCheck = now;
        state.housing = housing;
        Gamification.saveState(state);
    },

    getConditionColor(condition) {
        if (condition >= 75) return 'var(--green)';
        if (condition >= 50) return 'var(--orange)';
        if (condition >= 25) return '#f59e0b';
        return 'var(--red)';
    },

    getConditionLabel(condition) {
        if (condition >= 90) return 'Excellent';
        if (condition >= 75) return 'Good';
        if (condition >= 50) return 'Fair';
        if (condition >= 25) return 'Poor';
        if (condition > 0) return 'Dilapidated';
        return 'Condemned';
    },

    hireService(serviceId, houseId) {
        const service = Gamification.SHOP.services[serviceId];
        if (!service) return;
        
        const state = Gamification.getState();
        if (!Gamification.spendCoins(service.price)) return;
        
        const housing = state.housing || { current: null, owned: [], conditions: {}, activeServices: [] };
        housing.conditions = housing.conditions || {};
        housing.activeServices = housing.activeServices || [];
        
        if (service.instant) {
            // Instant repair
            const targetHouse = houseId || housing.current;
            if (targetHouse && housing.conditions[targetHouse] !== undefined) {
                if (service.repairAmount === 100) {
                    housing.conditions[targetHouse] = 100;
                } else {
                    housing.conditions[targetHouse] = Math.min(100, housing.conditions[targetHouse] + service.repairAmount);
                }
            }
        } else {
            // Hire laborer for duration
            const expiresAt = Date.now() + (service.duration * 24 * 60 * 60 * 1000);
            housing.activeServices.push({
                type: serviceId,
                houseId: houseId || housing.current,
                repairRate: service.repairRate || 10,
                expiresAt: expiresAt
            });
        }
        
        state.housing = housing;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.render();
    }
};

// =====================================================================
// IDLE BUSINESS SYSTEM v2 - Simplified with Prestige & Study Integration
// =====================================================================
const Business = {
    _tickInterval: null,
    _currentBusiness: null,
    
    init() {
        if (!this._tickInterval) {
            this._tickInterval = setInterval(() => this.tick(), 1000);
        }
    },
    
    show() {
        this.tick();
        this.render();
        showScreen('business');
    },
    
    // Called when user answers a question correctly - adds progress to all businesses
    onCorrectAnswer() {
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        
        // Each correct answer adds 5% progress to all owned businesses
        for (const [id, data] of Object.entries(biz.owned || {})) {
            if (data.level > 0) {
                data.progress = Math.min(100, (data.progress || 0) + 5);
            }
        }
        
        state.businesses = biz;
        Gamification.saveState(state);
    },

    tick() {
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {}, totalEarned: 0, lastTick: null };
        const now = Date.now();
        
        if (!biz.lastTick) biz.lastTick = now;
        const elapsed = (now - biz.lastTick) / 1000;
        if (elapsed < 0.5) return;
        
        for (const [id, data] of Object.entries(biz.owned || {})) {
            const bizData = Gamification.SHOP.businesses[id];
            if (!bizData || !data.level) continue;
            
            // Calculate speed multiplier from machines
            const speedMult = 1 + (data.machines || 0) * 0.25;
            const cycleTime = bizData.cycleTime / speedMult;
            
            // Calculate income with learning curve (uses getProfit for consistency)
            const profit = this.getProfit(data, bizData);
            
            // Manager = automatic progress
            if (data.hasManager) {
                const progressGain = (elapsed / cycleTime) * 100;
                data.progress = (data.progress || 0) + progressGain;
                
                // Complete cycles and earn money
                while (data.progress >= 100) {
                    data.progress -= 100;
                    const earned = Math.max(1, Math.floor(profit));
                    state.coins = (state.coins || 0) + earned;
                    data.totalProfit = (data.totalProfit || 0) + earned;
                    biz.totalEarned = (biz.totalEarned || 0) + earned;
                    this.checkMilestones(id, data, bizData);
                }
            }
        }
        
        biz.lastTick = now;
        state.businesses = biz;
        Gamification.saveState(state);
    },
    
    // Check and award milestone rewards
    checkMilestones(bizId, data, bizData) {
        if (!bizData.milestones) return;
        const reached = data.milestonesReached || 0;
        const totalProfit = data.totalProfit || 0;
        
        for (let i = reached; i < bizData.milestones.length; i++) {
            if (totalProfit >= bizData.milestones[i]) {
                data.milestonesReached = i + 1;
                // Milestone rewards: coins + XP
                const reward = Math.floor(bizData.milestones[i] * 0.1);
                const state = Gamification.getState();
                state.coins = (state.coins || 0) + reward;
                Gamification.addXP(reward, `${bizData.name} milestone!`);
            }
        }
    },
    
    // Get profit per cycle for a business
    // Realistic business economics: higher costs early (learning curve, mistakes, waste)
    // As level increases, efficiency improves and costs decrease
    getProfit(data, bizData) {
        const level = data.level || 1;
        const prestigeBonus = 1 + (data.prestige || 0) * 0.5;
        
        // Learning curve: costs are 2x at level 1, decreasing to 1x at level 10+
        // Represents: mistakes, waste, inefficiency, training costs, supplier negotiations
        const efficiencyFactor = Math.max(1, 2 - (level - 1) * 0.11); // 2.0  1.0 over 10 levels
        const adjustedCost = bizData.supplyCost * efficiencyFactor;
        
        // Gross income scales with level and prestige
        const grossIncome = bizData.baseIncome * level * prestigeBonus;
        
        // Net profit = income - adjusted costs
        return Math.max(1, Math.floor(grossIncome - adjustedCost));
    },
    
    // Get the current efficiency percentage (for UI display)
    getEfficiency(data) {
        const level = data.level || 1;
        const efficiencyFactor = Math.max(1, 2 - (level - 1) * 0.11);
        return Math.round((1 / efficiencyFactor) * 100); // 50% at level 1, 100% at level 10+
    },
    
    // Get cycle time with machine bonus
    getCycleTime(data, bizData) {
        const speedMult = 1 + (data.machines || 0) * 0.25;
        return bizData.cycleTime / speedMult;
    },
    
    getIncomePerSecond(state) {
        const biz = state.businesses || { owned: {} };
        let total = 0;
        
        for (const [id, data] of Object.entries(biz.owned || {})) {
            const bizData = Gamification.SHOP.businesses[id];
            if (!bizData || !data.hasManager || !data.level) continue;
            
            const profit = this.getProfit(data, bizData);
            const cycleTime = this.getCycleTime(data, bizData);
            total += profit / cycleTime;
        }
        return total;
    },
    
    // Manual work - instant 10% progress
    work(businessId) {
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        const data = biz.owned[businessId];
        if (!data) return;
        
        data.progress = Math.min(100, (data.progress || 0) + 10);
        state.businesses = biz;
        Gamification.saveState(state);
        SoundFX.play('click');
        
        if (this._currentBusiness === businessId) {
            this.renderBusinessDetail(businessId);
        }
    },
    
    // Collect completed cycle
    collect(businessId) {
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        const data = biz.owned[businessId];
        const bizData = Gamification.SHOP.businesses[businessId];
        if (!data || !bizData || data.progress < 100) return;
        
        data.progress = 0;
        const profit = this.getProfit(data, bizData);
        state.coins = (state.coins || 0) + profit;
        data.totalProfit = (data.totalProfit || 0) + profit;
        biz.totalEarned = (biz.totalEarned || 0) + profit;
        
        this.checkMilestones(businessId, data, bizData);
        
        state.businesses = biz;
        Gamification.saveState(state);
        SoundFX.play('coin');
        
        if (this._currentBusiness === businessId) {
            this.renderBusinessDetail(businessId);
        }
    },

    buy(businessId) {
        const bizData = Gamification.SHOP.businesses[businessId];
        if (!bizData) return;
        
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {}, totalEarned: 0 };
        
        const currentLevel = biz.owned[businessId]?.level || 0;
        const price = Math.floor(bizData.price * Math.pow(1.15, currentLevel));
        
        if (!Gamification.spendCoins(price)) return;
        
        if (!biz.owned[businessId]) {
            biz.owned[businessId] = { 
                level: 1, hasManager: false, progress: 0,
                machines: 0, prestige: 0, totalProfit: 0, milestonesReached: 0
            };
        } else {
            biz.owned[businessId].level++;
        }
        
        state.businesses = biz;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.render();
    },

    hireManager(businessId) {
        const bizData = Gamification.SHOP.businesses[businessId];
        if (!bizData) return;
        
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        const data = biz.owned[businessId];
        if (!data || data.hasManager) return;
        
        if (!Gamification.spendCoins(bizData.managerCost)) return;
        
        data.hasManager = true;
        state.businesses = biz;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        
        if (this._currentBusiness === businessId) {
            this.renderBusinessDetail(businessId);
        } else {
            this.render();
        }
    },
    
    buyMachine(businessId) {
        const bizData = Gamification.SHOP.businesses[businessId];
        if (!bizData) return;
        
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        const data = biz.owned[businessId];
        if (!data) return;
        
        const machineCount = data.machines || 0;
        if (machineCount >= 5) return; // Max 5 machines
        
        const price = Math.floor(bizData.price * 0.5 * Math.pow(2, machineCount));
        
        if (!Gamification.spendCoins(price)) return;
        
        data.machines = machineCount + 1;
        state.businesses = biz;
        Gamification.saveState(state);
        SoundFX.play('purchase');
        this.renderBusinessDetail(businessId);
    },
    
    // PRESTIGE: Reset business for permanent +50% income bonus
    prestige(businessId) {
        const bizData = Gamification.SHOP.businesses[businessId];
        if (!bizData) return;
        
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        const data = biz.owned[businessId];
        if (!data) return;
        
        // Require level 10+ and 10x purchase price in total profit
        const minProfit = bizData.price * 10;
        if (data.level < 10 || (data.totalProfit || 0) < minProfit) {
            return;
        }
        
        // Reset but keep prestige bonus
        const newPrestige = (data.prestige || 0) + 1;
        biz.owned[businessId] = {
            level: 1, hasManager: false, progress: 0,
            machines: 0, prestige: newPrestige, totalProfit: 0, 
            milestonesReached: data.milestonesReached || 0
        };
        
        // Prestige reward: coins based on prestige level
        const reward = bizData.price * newPrestige * 2;
        state.coins = (state.coins || 0) + reward;
        
        state.businesses = biz;
        Gamification.saveState(state);
        SoundFX.play('levelup');
        this.renderBusinessDetail(businessId);
    },
    
    openBusiness(businessId) {
        this._currentBusiness = businessId;
        this.renderBusinessDetail(businessId);
    },
    
    closeBusiness() {
        this._currentBusiness = null;
        this.render();
    },
    
    renderBusinessDetail(businessId) {
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {} };
        const data = biz.owned[businessId];
        const bizData = Gamification.SHOP.businesses[businessId];
        const coins = state.coins || 0;
        
        if (!data || !bizData) {
            this.render();
            return;
        }
        
        const theme = bizData.theme;
        const progress = data.progress || 0;
        const profit = this.getProfit(data, bizData);
        const cycleTime = this.getCycleTime(data, bizData);
        const prestigeBonus = (data.prestige || 0) * 50;
        
        // Milestone progress
        const milestones = bizData.milestones || [];
        const reached = data.milestonesReached || 0;
        const totalProfit = data.totalProfit || 0;
        const nextMilestone = milestones[reached] || null;
        const milestoneProgress = nextMilestone ? Math.min(100, (totalProfit / nextMilestone) * 100) : 100;
        
        // Prestige requirements
        const canPrestige = data.level >= 10 && totalProfit >= bizData.price * 10;
        
        let html = `
            <!-- Header -->
            <div style="background:linear-gradient(135deg,${theme.bg},${theme.dark});padding:20px;border-radius:16px;margin-bottom:16px;border:2px solid ${theme.accent}">
                <div style="display:flex;align-items:center;gap:16px;flex-wrap:wrap">
                    <button class="shop-buy-btn" onclick="Business.closeBusiness()" style="padding:8px 12px;background:rgba(0,0,0,0.3)"> Back</button>
                    <span style="font-size:48px">${bizData.icon}</span>
                    <div style="flex:1">
                        <h2 style="margin:0;color:${theme.accent}">${bizData.name}</h2>
                        <div style="color:rgba(255,255,255,0.7);font-size:13px">
                            Level ${data.level} ${data.prestige > 0 ? `<span style="color:gold">${data.prestige}</span>` : ''}
                            ${data.hasManager ? ' Manager' : ''}
                        </div>
                        <div style="color:rgba(255,255,255,0.5);font-size:11px">${bizData.flavorText}</div>
                    </div>
                    <div style="text-align:right">
                        <div style="font-size:11px;color:rgba(255,255,255,0.6)">Your Coins</div>
                        <div style="font-size:20px;font-weight:bold"> ${coins.toLocaleString()}</div>
                    </div>
                </div>
            </div>
            
            <!-- Production -->
            <div style="background:linear-gradient(135deg,${theme.dark},rgba(0,0,0,0.5));padding:20px;border-radius:12px;margin-bottom:16px;border:1px solid ${theme.accent}40">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px">
                    <h3 style="margin:0"> Production</h3>
                    <div style="font-size:14px;color:var(--green)">+${profit}/cycle</div>
                </div>
                
                <!-- Progress Bar -->
                <div style="background:rgba(0,0,0,0.3);border-radius:8px;height:32px;overflow:hidden;position:relative;margin-bottom:12px">
                    <div style="background:linear-gradient(90deg,${theme.accent},${theme.bg});height:100%;width:${progress}%;transition:width 0.3s"></div>
                    <div style="position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);font-weight:bold;text-shadow:0 1px 2px rgba(0,0,0,0.5)">${Math.floor(progress)}%</div>
                </div>
                
                <div style="display:flex;gap:8px;justify-content:center;flex-wrap:wrap">
                    ${!data.hasManager ? `
                        <button class="shop-buy-btn" onclick="Business.work('${businessId}')" style="background:${theme.accent};padding:12px 24px">
                             Work (+10%)
                        </button>
                    ` : `<span style="color:var(--gray-500);font-size:12px"> Manager running automatically</span>`}
                    ${progress >= 100 ? `
                        <button class="shop-buy-btn" onclick="Business.collect('${businessId}')" style="background:var(--green);animation:pulse 1s infinite;padding:12px 24px">
                             Collect ${profit}
                        </button>
                    ` : ''}
                </div>
                
                <div style="display:flex;justify-content:space-around;margin-top:16px;font-size:12px;color:var(--gray-400);flex-wrap:wrap;gap:8px">
                    <div> ${cycleTime.toFixed(1)}s/cycle</div>
                    <div> ${data.machines || 0}/5 machines</div>
                    <div title="Efficiency improves as you level up (less waste, better suppliers)"> ${this.getEfficiency(data)}% efficiency</div>
                    <div> ${totalProfit.toLocaleString()} total earned</div>
                </div>
            </div>
            
            <!-- Upgrades Grid -->
            <div style="display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;margin-bottom:16px">
                <!-- Level Up -->
                <div style="background:linear-gradient(135deg,${theme.dark},rgba(0,0,0,0.5));padding:16px;border-radius:12px;border:1px solid ${theme.accent}40">
                    <h4 style="margin:0 0 8px 0;color:${theme.accent}"> Level Up</h4>
                    <p style="font-size:11px;color:var(--gray-500);margin:0 0 8px 0">+${bizData.baseIncome} income per level</p>
                    <button class="shop-buy-btn" onclick="Business.buy('${businessId}')" 
                        ${coins < Math.floor(bizData.price * Math.pow(1.15, data.level)) ? 'disabled' : ''} 
                        style="width:100%;background:${theme.accent}">
                        Lv${data.level + 1}  ${Math.floor(bizData.price * Math.pow(1.15, data.level)).toLocaleString()}
                    </button>
                </div>
                
                <!-- Machines -->
                <div style="background:linear-gradient(135deg,${theme.dark},rgba(0,0,0,0.5));padding:16px;border-radius:12px;border:1px solid ${theme.accent}40">
                    <h4 style="margin:0 0 8px 0;color:${theme.accent}"> Machines (${data.machines || 0}/5)</h4>
                    <p style="font-size:11px;color:var(--gray-500);margin:0 0 8px 0">+25% speed each</p>
                    ${(data.machines || 0) < 5 ? `
                        <button class="shop-buy-btn" onclick="Business.buyMachine('${businessId}')" 
                            ${coins < Math.floor(bizData.price * 0.5 * Math.pow(2, data.machines || 0)) ? 'disabled' : ''} 
                            style="width:100%;background:#7c3aed">
                            Buy  ${Math.floor(bizData.price * 0.5 * Math.pow(2, data.machines || 0)).toLocaleString()}
                        </button>
                    ` : '<div style="text-align:center;color:var(--green)"> Maxed!</div>'}
                </div>
                
                <!-- Manager -->
                <div style="background:linear-gradient(135deg,${theme.dark},rgba(0,0,0,0.5));padding:16px;border-radius:12px;border:1px solid ${theme.accent}40">
                    <h4 style="margin:0 0 8px 0;color:${theme.accent}"> Manager</h4>
                    <p style="font-size:11px;color:var(--gray-500);margin:0 0 8px 0">Auto-runs business 24/7</p>
                    ${!data.hasManager ? `
                        <button class="shop-buy-btn" onclick="Business.hireManager('${businessId}')" 
                            ${coins < bizData.managerCost ? 'disabled' : ''} 
                            style="width:100%;background:#0ea5e9">
                            Hire  ${bizData.managerCost.toLocaleString()}
                        </button>
                    ` : '<div style="text-align:center;color:var(--green)"> Hired!</div>'}
                </div>
                
                <!-- Prestige -->
                <div style="background:linear-gradient(135deg,${canPrestige ? '#854d0e' : theme.dark},rgba(0,0,0,0.5));padding:16px;border-radius:12px;border:2px solid ${canPrestige ? 'gold' : theme.accent + '40'}">
                    <h4 style="margin:0 0 8px 0;color:${canPrestige ? 'gold' : theme.accent}"> Prestige ${data.prestige || 0}</h4>
                    <p style="font-size:11px;color:var(--gray-500);margin:0 0 8px 0">
                        ${canPrestige ? 'Reset for +50% permanent bonus!' : `Need Lv10 & ${(bizData.price * 10).toLocaleString()} profit`}
                    </p>
                    ${prestigeBonus > 0 ? `<div style="font-size:12px;color:gold;margin-bottom:8px">Current: +${prestigeBonus}% income</div>` : ''}
                    <button class="shop-buy-btn" onclick="Business.prestige('${businessId}')" 
                        ${!canPrestige ? 'disabled' : ''} 
                        style="width:100%;background:${canPrestige ? 'gold' : 'var(--gray-600)'};color:${canPrestige ? '#000' : '#fff'}">
                        ${canPrestige ? ' Prestige Now!' : `${data.level}/10 Lv  ${Math.floor((totalProfit / (bizData.price * 10)) * 100)}%`}
                    </button>
                </div>
            </div>
            
            <!-- Milestones -->
            <div style="background:linear-gradient(135deg,${theme.dark},rgba(0,0,0,0.5));padding:16px;border-radius:12px;border:1px solid ${theme.accent}40">
                <h4 style="margin:0 0 12px 0;color:${theme.accent}"> Milestones</h4>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                    ${milestones.map((m, i) => {
                        const done = i < reached;
                        const current = i === reached;
                        return `<div style="padding:8px 12px;border-radius:8px;font-size:12px;
                            background:${done ? 'var(--green)' : current ? theme.accent : 'rgba(0,0,0,0.3)'};
                            color:${done || current ? 'white' : 'var(--gray-500)'};
                            border:2px solid ${current ? 'white' : 'transparent'}">
                            ${done ? '' : ''} ${m.toLocaleString()}
                        </div>`;
                    }).join('')}
                </div>
                ${nextMilestone ? `
                    <div style="margin-top:12px">
                        <div style="font-size:11px;color:var(--gray-500);margin-bottom:4px">Progress to next: ${totalProfit.toLocaleString()} / ${nextMilestone.toLocaleString()}</div>
                        <div style="background:rgba(0,0,0,0.3);border-radius:4px;height:8px;overflow:hidden">
                            <div style="background:${theme.accent};height:100%;width:${milestoneProgress}%"></div>
                        </div>
                    </div>
                ` : '<div style="margin-top:8px;color:var(--green);font-size:12px"> All milestones complete!</div>'}
            </div>
            
            <!-- Study Tip -->
            <div style="margin-top:16px;padding:12px;background:rgba(59,130,246,0.1);border-radius:8px;border:1px solid var(--blue);text-align:center">
                <div style="font-size:13px;color:var(--blue)"> <b>Tip:</b> Answer questions to add +5% progress to all businesses!</div>
            </div>
        `;
        
        document.getElementById('businessContent').innerHTML = html;
    },

    render() {
        const state = Gamification.getState();
        const biz = state.businesses || { owned: {}, totalEarned: 0 };
        const coins = state.coins || 0;
        
        document.getElementById('businessCoins').innerHTML = '&#x1FA99; ' + coins.toLocaleString();
        
        const incomePerSec = this.getIncomePerSecond(state);
        
        let html = `<div style="text-align:center;padding:12px;background:linear-gradient(135deg,#059669,#10b981);border-radius:12px;margin-bottom:16px;color:white">
            <div style="font-size:24px"> ${biz.totalEarned?.toLocaleString() || 0}</div>
            <div style="font-size:12px;opacity:0.8">Total Earned from Businesses</div>
            ${incomePerSec > 0 ? `<div style="margin-top:4px;font-size:14px"> +${incomePerSec.toFixed(2)}/sec (automated)</div>` : ''}
        </div>`;
        
        html += '<h3> Your Businesses</h3><p style="color:var(--gray-500);font-size:12px;margin-top:-8px">Click a business to manage it  Answer questions for +5% progress!</p><div class="shop-grid">';
        
        for (const [id, bizData] of Object.entries(Gamification.SHOP.businesses)) {
            const owned = biz.owned[id];
            const level = owned?.level || 0;
            const hasManager = owned?.hasManager || false;
            const progress = owned?.progress || 0;
            const prestige = owned?.prestige || 0;
            const price = Math.floor(bizData.price * Math.pow(1.15, level));
            const canAfford = coins >= price;
            
            html += `<div class="shop-item" style="position:relative;cursor:${level > 0 ? 'pointer' : 'default'}" ${level > 0 ? `onclick="Business.openBusiness('${id}')"` : ''}>
                <div class="shop-item-icon">${bizData.icon}</div>
                <div class="shop-item-name">${bizData.name}</div>
                <div class="shop-item-desc">${bizData.desc}</div>`;
            
            if (level > 0) {
                html += `<div style="font-size:12px;color:var(--green)">Level ${level} ${hasManager ? '' : ''} ${prestige > 0 ? `<span style="color:gold">${prestige}</span>` : ''}</div>`;
                
                // Progress bar
                html += `<div style="background:rgba(0,0,0,0.1);border-radius:4px;height:12px;margin:8px 0;overflow:hidden">
                    <div style="background:${progress >= 100 ? 'var(--green)' : 'var(--blue)'};height:100%;width:${progress}%;transition:width 0.3s"></div>
                </div>`;
                
                html += `<div style="font-size:11px;color:var(--gray-500)">Click to manage </div>`;
            } else {
                html += `<button class="shop-buy-btn" onclick="event.stopPropagation();Business.buy('${id}')" ${!canAfford ? 'disabled' : ''}>
                    Buy &#x1FA99;${price.toLocaleString()}
                </button>`;
            }
            
            html += '</div>';
        }
        
        html += '</div>';
        
        document.getElementById('businessContent').innerHTML = html;
    }
};

// Initialize business ticking on load
document.addEventListener('DOMContentLoaded', () => Business.init());

// =====================================================================
// BATTLE SYSTEM (PVE Story Campaign)
// =====================================================================
const Battle = {
    active: false,
    petHP: 0,
    petMaxHP: 0,
    enemyHP: 0,
    enemyMaxHP: 0,
    currentQuestion: null,
    answered: false,
    shieldActive: false,
    powerBerryLeft: 0,
    comboCount: 0,
    damageTaken: 0,

    CHAPTERS: [
        { name: 'Enchanted Forest', icon: '\u{1F332}', unlockLevel: 1,
          enemies: [
            { name: 'Rat', emoji: '\u{1F400}' }, { name: 'Spider', emoji: '\u{1F577}\uFE0F' },
            { name: 'Snake', emoji: '\u{1F40D}' }, { name: 'Mushroom', emoji: '\u{1F344}' },
            { name: 'Wolf', emoji: '\u{1F43A}' },
            { name: 'Forest Guardian', emoji: '\u{1F333}', boss: true }
          ]},
        { name: 'Crystal Cave', icon: '\u{1F987}', unlockLevel: 5,
          enemies: [
            { name: 'Bat', emoji: '\u{1F987}' }, { name: 'Slime', emoji: '\u{1F7E2}' },
            { name: 'Golem', emoji: '\u{1FAA8}' }, { name: 'Scorpion', emoji: '\u{1F982}' },
            { name: 'Shadow', emoji: '\u{1F47B}' },
            { name: 'Cave Troll', emoji: '\u{1F9CC}', boss: true }
          ]},
        { name: 'Storm Mountain', icon: '\u26F0\uFE0F', unlockLevel: 10,
          enemies: [
            { name: 'Hawk', emoji: '\u{1F985}' }, { name: 'Yeti', emoji: '\u2744\uFE0F' },
            { name: 'Lightning Bug', emoji: '\u26A1' }, { name: 'Rock Worm', emoji: '\u{1FAB1}' },
            { name: 'Ice Wolf', emoji: '\u{1F43A}' },
            { name: 'Storm Giant', emoji: '\u{1F329}\uFE0F', boss: true }
          ]},
        { name: 'Dark Castle', icon: '\u{1F3F0}', unlockLevel: 15,
          enemies: [
            { name: 'Ghost', emoji: '\u{1F47B}' }, { name: 'Knight', emoji: '\u2694\uFE0F' },
            { name: 'Mage', emoji: '\u{1F9D9}' }, { name: 'Archer', emoji: '\u{1F3F9}' },
            { name: 'Gargoyle', emoji: '\u{1F5FF}' },
            { name: 'Dark King', emoji: '\u{1F451}', boss: true }
          ]},
        { name: 'Volcanic Core', icon: '\u{1F30B}', unlockLevel: 20,
          enemies: [
            { name: 'Fire Imp', emoji: '\u{1F525}' }, { name: 'Lava Snake', emoji: '\u{1F40D}' },
            { name: 'Demon', emoji: '\u{1F479}' }, { name: 'Hellhound', emoji: '\u{1F415}' },
            { name: 'Wyvern', emoji: '\u{1F432}' },
            { name: 'Ancient Dragon', emoji: '\u{1F409}', boss: true }
          ]}
    ],

    getEnemyStats(chapterIdx, enemyIdx) {
        const ch = chapterIdx + 1;
        const enemy = this.CHAPTERS[chapterIdx].enemies[enemyIdx];
        const isBoss = enemy.boss || false;
        let hp = 40 + (ch * 25) + (enemyIdx * 8);
        let atk = 8 + (ch * 6) + (enemyIdx * 2);
        let def = 2 + (ch * 3);
        if (isBoss) { hp = Math.round(hp * 2); atk = Math.round(atk * 1.3); def = Math.round(def * 1.5); }
        return { hp, atk, def, name: enemy.name, emoji: enemy.emoji, boss: isBoss };
    },

    getPetStats() {
        const state = Gamification.getState();
        const pet = state.studyBuddy;
        const stage = pet.stage || 1;
        const hunger = Math.min(100, Math.max(0, pet.hunger || 0));
        const happiness = Math.min(100, Math.max(0, pet.happiness || 0));
        const diff = Gamification.getSpeciesDifficulty(pet.species);
        
        // Age-based strength curve
        const now = Date.now();
        const birthDate = pet.birthDate || (now - 7 * 24 * 60 * 60 * 1000);
        const lifespan = pet.lifespan || 37;
        const ageInDays = (now - birthDate) / (1000 * 60 * 60 * 24);
        const ageRatio = ageInDays / lifespan; // 0 to 1+ (can exceed 1 if past lifespan)
        
        // Strength curve: builds up to peak at 50% of lifespan, then declines
        // Peak multiplier is 1.3x at mid-life, starts at 0.7x, ends at 0.5x
        let ageMultiplier;
        if (ageRatio <= 0.5) {
            // Growing phase: 0.7 -> 1.3 (linear increase to peak)
            ageMultiplier = 0.7 + (ageRatio * 1.2); // 0.7 at birth, 1.3 at mid-life
        } else {
            // Declining phase: 1.3 -> 0.5 (gradual decline)
            const declineRatio = (ageRatio - 0.5) / 0.5; // 0 at mid-life, 1 at end
            ageMultiplier = 1.3 - (declineRatio * 0.8); // 1.3 at mid-life, 0.5 at end
            ageMultiplier = Math.max(0.4, ageMultiplier); // Floor at 0.4x
        }
        
        const baseHp = 50 + (stage * 30) + (hunger / 5) + (happiness / 5);
        const baseAtk = 10 + (stage * 8) + (diff * 5);
        const baseDef = 3 + (stage * 3) + (happiness / 10);
        
        const hp = Math.round(baseHp * ageMultiplier);
        const atk = Math.round(baseAtk * ageMultiplier);
        const def = Math.round(baseDef * ageMultiplier);
        const emoji = Gamification.getSpeciesEmoji(pet.species, stage);
        const name = pet.name || 'Pet';
        return { hp, atk, def, emoji, name, stage, ageInDays: Math.floor(ageInDays), ageMultiplier };
    },

    show() {
        this.renderChapterSelect();
        showScreen('battle');
    },

    goHome() {
        this.active = false;
        showScreen('home');
        Home.render();
    },

    renderChapterSelect() {
        const state = Gamification.getState();
        const level = state.level || 1;
        const battleState = state.battle || {};
        const completed = battleState.chaptersCompleted || [];
        document.getElementById('battleTitle').textContent = 'Battle - Story Campaign';
        document.getElementById('battleStars').textContent = '';

        let html = '<div class="chapter-select">';
        this.CHAPTERS.forEach((ch, idx) => {
            const chNum = idx + 1;
            const unlocked = level >= ch.unlockLevel;
            const isCompleted = completed.includes(chNum);
            const isCurrent = chNum === (battleState.currentChapter || 1) && !isCompleted;
            const enemyProgress = (isCurrent && battleState.currentEnemy > 0) ? battleState.currentEnemy : 0;
            const stars = isCompleted ? '\u2605\u2605\u2605' : (enemyProgress > 0 ? '\u2605'.repeat(Math.min(enemyProgress, 3)) + '\u2606'.repeat(3 - Math.min(enemyProgress, 3)) : '\u2606\u2606\u2606');

            html += `<div class="chapter-card${unlocked ? '' : ' locked'}${isCurrent ? ' current' : ''}" ${unlocked ? `onclick="Battle.selectChapter(${idx})"` : ''}>
                <span class="ch-icon">${ch.icon}</span>
                <div class="ch-info">
                    <div class="ch-name">Ch.${chNum}: ${ch.name}</div>
                    <div class="ch-progress">${isCompleted ? 'Completed!' : unlocked ? (enemyProgress > 0 ? `Enemy ${enemyProgress + 1}/6` : 'Ready to begin') : `Requires Lv ${ch.unlockLevel}`}</div>
                    <div class="ch-stars">${stars}</div>
                </div>
                ${unlocked ? '' : '<span class="ch-lock">\u{1F512}</span>'}
            </div>`;
        });
        html += '</div>';
        document.getElementById('battleContent').innerHTML = html;
    },

    selectChapter(chapterIdx) {
        const state = Gamification.getState();
        const battleState = state.battle;
        const chNum = chapterIdx + 1;
        battleState.currentChapter = chNum;
        // If chapter already completed, restart from enemy 0
        if (battleState.chaptersCompleted.includes(chNum)) {
            battleState.currentEnemy = 0;
        }
        Gamification.saveState(state);
        this.startBattle(chapterIdx, battleState.currentEnemy || 0);
    },

    startBattle(chapterIdx, enemyIdx) {
        this.active = true;
        this.answered = false;
        this.shieldActive = false;
        this.powerBerryLeft = 0;
        this.comboCount = 0;
        this.damageTaken = 0;

        const petStats = this.getPetStats();
        const enemyStats = this.getEnemyStats(chapterIdx, enemyIdx);

        this.petHP = petStats.hp;
        this.petMaxHP = petStats.hp;
        this.enemyHP = enemyStats.hp;
        this.enemyMaxHP = enemyStats.hp;
        this._chapterIdx = chapterIdx;
        this._enemyIdx = enemyIdx;
        this._petStats = petStats;
        this._enemyStats = enemyStats;

        const ch = this.CHAPTERS[chapterIdx];
        document.getElementById('battleTitle').textContent = `Ch.${chapterIdx + 1} ${ch.name}`;
        document.getElementById('battleStars').textContent = '';

        this.loadQuestion();
        this.render();
    },

    render() {
        const pet = this._petStats;
        const enemy = this._enemyStats;
        const petHpPct = Math.max(0, (this.petHP / this.petMaxHP) * 100);
        const enemyHpPct = Math.max(0, (this.enemyHP / this.enemyMaxHP) * 100);

        const hpClass = (pct) => pct > 50 ? 'hp-high' : pct > 25 ? 'hp-mid' : 'hp-low';

        const state = Gamification.getState();
        const inv = state.inventory.battleItems || {};

        let qHTML = '';
        if (this.currentQuestion) {
            const q = this.currentQuestion;
            qHTML = `<div class="battle-question">
                <div class="bq-text">${q.text}</div>
                <div class="bq-options">
                    ${q.options.map((opt, i) => `<button class="bq-opt${this.answered ? (i === q.correctAnswer ? ' correct' : (i === this._selectedIdx ? ' wrong' : '')) + ' disabled' : ''}" ${this.answered ? 'disabled' : `onclick="Battle.checkAnswer(${i})"`}>${opt}</button>`).join('')}
                </div>
            </div>`;
        }

        const html = `
            <div class="battle-arena">
                <div class="battle-combatant enemy-side" id="battleEnemy">
                    <span class="combatant-sprite" style="${enemy.boss ? 'font-size:64px' : ''}">${enemy.emoji}</span>
                    <span class="combatant-name">${enemy.name}${enemy.boss ? ' (BOSS)' : ''}</span>
                    <div class="battle-hp">
                        <span>HP</span>
                        <div class="battle-hp-bar"><div class="battle-hp-fill ${hpClass(enemyHpPct)}" style="width:${enemyHpPct}%"></div></div>
                        <span>${Math.max(0, this.enemyHP)}/${this.enemyMaxHP}</span>
                    </div>
                    <div class="battle-stats-row"><span>ATK ${enemy.atk}</span><span>DEF ${enemy.def}</span></div>
                </div>
                <div class="battle-vs">\u2694\uFE0F</div>
                <div class="battle-combatant pet-side" id="battlePet">
                    <span class="combatant-sprite">${pet.emoji}</span>
                    <span class="combatant-name">${pet.name}</span>
                    <span class="combatant-level">Stage ${pet.stage} | ATK ${pet.atk + (this.powerBerryLeft > 0 ? Math.round(pet.atk * 0.5) : 0)} | DEF ${pet.def}</span>
                    <div class="battle-hp">
                        <span>HP</span>
                        <div class="battle-hp-bar"><div class="battle-hp-fill ${hpClass(petHpPct)}" style="width:${petHpPct}%"></div></div>
                        <span>${Math.max(0, this.petHP)}/${this.petMaxHP}</span>
                    </div>
                    ${this.shieldActive ? '<div style="font-size:11px;color:var(--blue);">\u{1F6E1}\uFE0F Shield Active</div>' : ''}
                    ${this.powerBerryLeft > 0 ? `<div style="font-size:11px;color:var(--green);">\u{1FAD0} Power Berry (${this.powerBerryLeft} left)</div>` : ''}
                </div>
            </div>
            ${qHTML}
            <div class="battle-items-bar">
                <button class="battle-item-btn" ${(inv.healthPotion || 0) < 1 || this.answered ? 'disabled' : ''} onclick="Battle.useItem('healthPotion')">
                    \u{1F9C3} Heal <span class="item-count">${inv.healthPotion || 0}</span>
                </button>
                <button class="battle-item-btn" ${(inv.shieldCharm || 0) < 1 || this.shieldActive || this.answered ? 'disabled' : ''} onclick="Battle.useItem('shieldCharm')">
                    \u{1F6E1}\uFE0F Shield <span class="item-count">${inv.shieldCharm || 0}</span>
                </button>
                <button class="battle-item-btn" ${(inv.powerBerry || 0) < 1 || this.powerBerryLeft > 0 || this.answered ? 'disabled' : ''} onclick="Battle.useItem('powerBerry')">
                    \u{1FAD0} Power <span class="item-count">${inv.powerBerry || 0}</span>
                </button>
            </div>
            <div class="battle-log" id="battleLog">${this.comboCount > 1 ? '\u{1F525} Combo x' + this.comboCount + '!' : 'Answer the question to attack!'}</div>`;

        document.getElementById('battleContent').innerHTML = html;
        // Render math in question text
        if (window.renderMathInElement) {
            try { renderMathInElement(document.getElementById('battleContent'), { delimiters: [{ left: '\\(', right: '\\)', display: false }, { left: '\\[', right: '\\]', display: true }] }); } catch {}
        }
    },

    loadQuestion() {
        // Pull random question from current bank
        const bank = BankManager.banks[0];
        if (!bank || !bank.questions || bank.questions.length === 0) return;
        const q = bank.questions[Math.floor(Math.random() * bank.questions.length)];
        this.currentQuestion = q;
        this.answered = false;
        this._selectedIdx = -1;
    },

    checkAnswer(idx) {
        if (this.answered || !this.currentQuestion) return;
        this.answered = true;
        this._selectedIdx = idx;
        const q = this.currentQuestion;
        const isCorrect = idx === q.correctAnswer;

        // Still award XP/coins/care through normal gamification
        Gamification.awardXp(isCorrect ? 10 : 2);
        if (isCorrect) Gamification.awardCoins(5);
        DailyGoal.recordQuestion();
        if (isCorrect) Garden.grow(1);

        // Re-render to show correct/wrong highlighting
        this.render();

        if (isCorrect) {
            this.comboCount++;
            SoundFX.play('correct');
            setTimeout(() => this.petAttack(), 600);
        } else {
            this.comboCount = 0;
            SoundFX.play('incorrect');
            setTimeout(() => this.enemyAttack(), 600);
        }
    },

    petAttack() {
        const pet = this._petStats;
        const enemy = this._enemyStats;
        let dmg = Math.max(1, pet.atk - enemy.def);
        // Combo crit
        if (this.comboCount >= 3) dmg = Math.round(dmg * 1.5);
        // Power berry boost
        if (this.powerBerryLeft > 0) {
            dmg = Math.round(dmg * 1.5);
            this.powerBerryLeft--;
        }

        this.enemyHP -= dmg;
        SoundFX.play('battleHit');

        // Animate enemy shake
        const el = document.getElementById('battleEnemy');
        if (el) { el.classList.add('battle-shake'); setTimeout(() => el.classList.remove('battle-shake'), 400); }
        // Damage popup
        this._showDmgPopup('battleEnemy', `-${dmg}`, false);

        if (this.enemyHP <= 0) {
            this.enemyHP = 0;
            this.render();
            setTimeout(() => this.enemyDefeated(), 500);
        } else {
            this.render();
            // Load next question after brief pause
            setTimeout(() => {
                this.loadQuestion();
                this.render();
            }, 400);
        }
    },

    enemyAttack() {
        if (this.shieldActive) {
            this.shieldActive = false;
            this._showDmgPopup('battlePet', 'BLOCKED!', true);
            SoundFX.play('powerUp');
            setTimeout(() => {
                this.loadQuestion();
                this.render();
            }, 600);
            return;
        }

        const pet = this._petStats;
        const enemy = this._enemyStats;
        const dmg = Math.max(1, enemy.atk - pet.def);
        this.petHP -= dmg;
        this.damageTaken += dmg;
        SoundFX.play('battleHit');

        // Animate pet flash
        const el = document.getElementById('battlePet');
        if (el) { el.classList.add('battle-flash'); setTimeout(() => el.classList.remove('battle-flash'), 500); }
        this._showDmgPopup('battlePet', `-${dmg}`, false);

        if (this.petHP <= 0) {
            this.petHP = 0;
            this.render();
            setTimeout(() => this.petKO(), 500);
        } else {
            this.render();
            setTimeout(() => {
                this.loadQuestion();
                this.render();
            }, 400);
        }
    },

    _showDmgPopup(containerId, text, isHeal) {
        const container = document.getElementById(containerId);
        if (!container) return;
        const popup = document.createElement('div');
        popup.className = 'battle-dmg-popup' + (isHeal ? ' heal' : '');
        popup.textContent = text;
        container.appendChild(popup);
        setTimeout(() => popup.remove(), 800);
    },

    useItem(itemId) {
        if (this.answered) return;
        const state = Gamification.getState();
        const inv = state.inventory.battleItems;
        if (!inv[itemId] || inv[itemId] < 1) return;

        inv[itemId]--;
        Gamification.saveState(state);

        if (itemId === 'healthPotion') {
            this.petHP = Math.min(this.petMaxHP, this.petHP + 40);
            this._showDmgPopup('battlePet', '+40 HP', true);
            SoundFX.play('petFeed');
        } else if (itemId === 'shieldCharm') {
            this.shieldActive = true;
            SoundFX.play('powerUp');
        } else if (itemId === 'powerBerry') {
            this.powerBerryLeft = 3;
            SoundFX.play('powerUp');
        }
        this.render();
    },

    enemyDefeated() {
        const state = Gamification.getState();
        const bs = state.battle;
        const ch = this._chapterIdx;
        const ei = this._enemyIdx;
        const enemy = this._enemyStats;
        const chapterData = this.CHAPTERS[ch];

        // Calculate rewards
        const baseCoins = 10 + ((ch + 1) * 5);
        const coins = enemy.boss ? baseCoins * 3 : baseCoins;
        const xp = enemy.boss ? 100 : 30;

        Gamification.awardCoins(coins);
        Gamification.awardXp(xp);
        // Award gems for boss defeats (premium currency)
        if (enemy.boss) {
            Gamification.awardGems(10, 'bossDefeat');
        }
        bs.totalWins = (bs.totalWins || 0) + 1;

        SoundFX.play('battleWin');

        // Check achievements
        if (bs.totalWins === 1) Gamification.unlockAchievement('first_victory');
        if (this.damageTaken === 0) Gamification.unlockAchievement('flawless');

        const nextEnemy = ei + 1;
        if (nextEnemy >= chapterData.enemies.length) {
            // Chapter complete!
            if (!bs.chaptersCompleted.includes(ch + 1)) {
                bs.chaptersCompleted.push(ch + 1);
            }
            bs.bestChapter = Math.max(bs.bestChapter || 0, ch + 1);
            bs.currentEnemy = 0;
            if (ch + 1 < this.CHAPTERS.length) {
                bs.currentChapter = ch + 2;
            }
            Gamification.unlockAchievement('chapter_clear');
            // Check boss slayer (all 5 completed)
            if (bs.chaptersCompleted.length >= 5) {
                Gamification.unlockAchievement('boss_slayer');
            }
            Gamification.saveState(state);
            this.showResult(true, coins, xp, true);
        } else {
            bs.currentEnemy = nextEnemy;
            Gamification.saveState(state);
            this.showResult(true, coins, xp, false);
        }
    },

    petKO() {
        const state = Gamification.getState();
        state.battle.totalLosses = (state.battle.totalLosses || 0) + 1;
        Gamification.saveState(state);
        SoundFX.play('battleLose');
        this.showResult(false, 0, 0, false);
    },

    showResult(won, coins, xp, chapterDone) {
        const overlay = document.createElement('div');
        overlay.className = 'battle-result-overlay';
        overlay.id = 'battleResultOverlay';

        const enemy = this._enemyStats;
        let body = '';
        if (won) {
            body = `<div class="result-icon">\u{1F389}</div>
                <h2>${chapterDone ? 'Chapter Complete!' : 'Victory!'}</h2>
                <p>${enemy.name} defeated!</p>
                <div class="result-rewards">
                    <div>\u{1FA99} +${coins} Coins</div>
                    <div>\u2B50 +${xp} XP</div>
                    ${this.damageTaken === 0 ? '<div>\u2728 Flawless!</div>' : ''}
                </div>
                <button class="btn-primary" onclick="Battle.dismissResult(true, ${chapterDone})">${chapterDone ? 'Back to Chapters' : 'Next Enemy'}</button>
                <button class="btn-secondary" onclick="Battle.dismissResult(false, false)">Home</button>`;
        } else {
            body = `<div class="result-icon">\u{1F4A5}</div>
                <h2>Defeated!</h2>
                <p>${enemy.name} was too strong...</p>
                <div class="result-rewards" style="color:var(--gray-500)">Your pet recovers with full HP on retry.</div>
                <button class="btn-primary" onclick="Battle.dismissResult(true, false)">Try Again</button>
                <button class="btn-secondary" onclick="Battle.dismissResult(false, false)">Home</button>`;
        }

        overlay.innerHTML = `<div class="battle-result-modal">${body}</div>`;
        overlay.addEventListener('click', (e) => { if (e.target === overlay) Battle.dismissResult(false, false); });
        document.body.appendChild(overlay);
    },

    dismissResult(continuePlay, chapterDone) {
        const el = document.getElementById('battleResultOverlay');
        if (el) el.remove();

        if (!continuePlay) {
            this.goHome();
            return;
        }

        if (chapterDone) {
            this.renderChapterSelect();
        } else {
            const state = Gamification.getState();
            const bs = state.battle;
            this.startBattle(this._chapterIdx, bs.currentEnemy || 0);
        }
    }
};

// =====================================================================
// GARDEN SYSTEM
// =====================================================================
const Garden = {
    _meterPulseTimer: null,
    _waterPromptEl: null,
    
    // Weather system
    WEATHER_TYPES: {
        sunny:  { name: 'Sunny',  icon: '', growthMod: 1.0, waterDecay: 1.2, desc: 'Normal growth' },
        cloudy: { name: 'Cloudy', icon: '', growthMod: 0.9, waterDecay: 0.8, desc: 'Slower growth, less water loss' },
        rainy:  { name: 'Rainy',  icon: '', growthMod: 1.2, waterDecay: 0.3, desc: '+20% growth, minimal water loss' },
        stormy: { name: 'Stormy', icon: '', growthMod: 0.7, waterDecay: 0.2, desc: 'Slower growth, but free water!' },
        windy:  { name: 'Windy',  icon: '', growthMod: 1.1, waterDecay: 1.5, desc: '+10% growth, faster water loss' },
        hot:    { name: 'Hot',    icon: '', growthMod: 1.3, waterDecay: 2.0, desc: '+30% growth, 2x water loss' }
    },
    
    // Seasons affect which seeds grow better
    SEASONS: {
        spring: { name: 'Spring', icon: '', bonusSeeds: ['sunflower', 'rainbow', 'moonflower'], growthMod: 1.1 },
        summer: { name: 'Summer', icon: '', bonusSeeds: ['cactus', 'dragonFruit', 'starfruit'], growthMod: 1.2 },
        autumn: { name: 'Autumn', icon: '', bonusSeeds: ['bonsai', 'goldenApple', 'moneyTree'], growthMod: 1.0 },
        winter: { name: 'Winter', icon: '', bonusSeeds: ['crystal', 'ancientOak'], growthMod: 0.8 }
    },
    
    // Companion planting bonuses (adjacent seeds boost each other)
    COMPANIONS: {
        sunflower: ['cactus', 'rainbow'],      // Sunflower helps cactus and rainbow
        cactus: ['sunflower', 'dragonFruit'],
        bonsai: ['crystal', 'ancientOak'],
        crystal: ['bonsai', 'moonflower'],
        rainbow: ['sunflower', 'starfruit'],
        moneyTree: ['goldenApple', 'ancientOak'],
        starfruit: ['rainbow', 'moonflower'],
        dragonFruit: ['cactus', 'goldenApple'],
        moonflower: ['crystal', 'starfruit'],
        goldenApple: ['moneyTree', 'dragonFruit'],
        ancientOak: ['bonsai', 'moneyTree']
    },
    
    getCurrentSeason() {
        const month = new Date().getMonth();
        if (month >= 2 && month <= 4) return 'spring';
        if (month >= 5 && month <= 7) return 'summer';
        if (month >= 8 && month <= 10) return 'autumn';
        return 'winter';
    },
    
    getCurrentWeather(state) {
        // Weather changes every 2 hours based on a seed
        const now = Date.now();
        const weatherSeed = Math.floor(now / (2 * 60 * 60 * 1000));
        const weatherKeys = Object.keys(this.WEATHER_TYPES);
        const idx = weatherSeed % weatherKeys.length;
        return weatherKeys[idx];
    },
    
    getCompanionBonus(state, plotIdx) {
        const plots = state.garden.plots || [];
        const plot = plots[plotIdx];
        if (!plot || !plot.seedType) return 0;
        
        const companions = this.COMPANIONS[plot.seedType] || [];
        if (companions.length === 0) return 0;
        
        // Check adjacent plots (3x3 grid)
        const adjacentIdxs = this.getAdjacentPlots(plotIdx);
        let bonus = 0;
        
        adjacentIdxs.forEach(adjIdx => {
            const adjPlot = plots[adjIdx];
            if (adjPlot && adjPlot.seedType && companions.includes(adjPlot.seedType)) {
                bonus += 0.15; // +15% per companion
            }
        });
        
        return Math.min(bonus, 0.45); // Cap at 45%
    },
    
    getAdjacentPlots(idx) {
        // 3x3 grid adjacency
        const row = Math.floor(idx / 3);
        const col = idx % 3;
        const adjacent = [];
        
        for (let r = row - 1; r <= row + 1; r++) {
            for (let c = col - 1; c <= col + 1; c++) {
                if (r >= 0 && r < 3 && c >= 0 && c < 3 && !(r === row && c === col)) {
                    adjacent.push(r * 3 + c);
                }
            }
        }
        return adjacent;
    },
    
    getTotalGrowthBonus(state, plotIdx) {
        const season = this.getCurrentSeason();
        const weather = this.getCurrentWeather(state);
        const seasonData = this.SEASONS[season];
        const weatherData = this.WEATHER_TYPES[weather];
        const plot = (state.garden.plots || [])[plotIdx];
        
        let bonus = 1.0;
        
        // Season modifier
        bonus *= seasonData.growthMod;
        
        // Weather modifier
        bonus *= weatherData.growthMod;
        
        // Season bonus for specific seeds
        if (plot && plot.seedType && seasonData.bonusSeeds.includes(plot.seedType)) {
            bonus *= 1.25; // +25% for in-season seeds
        }
        
        // Companion bonus
        bonus *= (1 + this.getCompanionBonus(state, plotIdx));
        
        return bonus;
    },
    
    show() {
        this.render();
        showScreen('garden');
    },

    render() {
        const state = Gamification.getState();
        if (!state.settings.garden) return;

        // Update header coins
        document.getElementById('gardenCoins').innerHTML = '&#x1FA99; ' + (state.coins || 0).toLocaleString();

        // Water-based scene effects
        const water = state.garden.waterLevel || 0;
        const scene = document.getElementById('gardenScene');
        if (scene) {
            scene.classList.toggle('water-low', water > 0 && water < 25);
            scene.classList.toggle('water-critical', water <= 0);
            
            // Apply season theme
            const season = this.getCurrentSeason();
            scene.classList.remove('spring', 'summer', 'autumn', 'winter');
            scene.classList.add(season);
            
            // Apply weather effect
            const weather = this.getCurrentWeather(state);
            const weatherEl = document.getElementById('gardenWeather');
            if (weatherEl) {
                weatherEl.className = 'garden-weather ' + weather;
            }
        }
        
        // Update stats bar
        this.updateStatsBar(state);

        this.updateWaterMeter(state);

        // Update watering can count
        const waterCount = document.getElementById('gardenWaterCount');
        if (waterCount) waterCount.textContent = state.inventory.gardenItems.water || 0;
        if ((state.inventory.gardenItems.water || 0) <= 0) {
            this._promptWaterPurchase();
        } else {
            this._dismissWaterPrompt();
        }

        this.renderGrid(state);
        this.renderDecos(state);
        this.renderPet(state);
        this.renderInfoPanel(state);
    },
    
    updateStatsBar(state) {
        const season = this.getCurrentSeason();
        const weather = this.getCurrentWeather(state);
        const seasonData = this.SEASONS[season];
        const weatherData = this.WEATHER_TYPES[weather];
        
        // Calculate average growth bonus across all planted plots
        const plots = state.garden.plots || [];
        let totalBonus = 0;
        let plantedCount = 0;
        plots.forEach((plot, idx) => {
            if (plot && plot.seedType) {
                totalBonus += this.getTotalGrowthBonus(state, idx);
                plantedCount++;
            }
        });
        const avgBonus = plantedCount > 0 ? totalBonus / plantedCount : 1;
        
        const seasonEl = document.getElementById('gardenSeason');
        const weatherEl = document.getElementById('gardenWeatherStat');
        const bonusEl = document.getElementById('gardenBonus');
        
        if (seasonEl) seasonEl.innerHTML = `${seasonData.icon} ${seasonData.name}`;
        if (weatherEl) {
            weatherEl.innerHTML = `${weatherData.icon} ${weatherData.name}`;
            weatherEl.title = weatherData.desc;
        }
        if (bonusEl) {
            const bonusPct = Math.round((avgBonus - 1) * 100);
            bonusEl.textContent = bonusPct >= 0 ? `+${bonusPct}%` : `${bonusPct}%`;
            bonusEl.classList.toggle('bonus-active', bonusPct > 0);
        }
    },
    
    renderInfoPanel(state) {
        const harvestsEl = document.getElementById('gardenTotalHarvests');
        const coinBonusEl = document.getElementById('gardenCoinBonusDisplay');
        const companionEl = document.getElementById('gardenCompanionBonus');
        
        if (harvestsEl) harvestsEl.textContent = state.garden.totalHarvests || 0;
        if (coinBonusEl) {
            const bonus = Math.round((state.gardenCoinBonus || 0) * 100);
            coinBonusEl.textContent = `+${bonus}%`;
        }
        
        // Calculate total companion bonus
        if (companionEl) {
            const plots = state.garden.plots || [];
            let totalCompanion = 0;
            plots.forEach((plot, idx) => {
                if (plot && plot.seedType) {
                    totalCompanion += this.getCompanionBonus(state, idx);
                }
            });
            const avgCompanion = plots.filter(p => p && p.seedType).length > 0 
                ? Math.round((totalCompanion / plots.filter(p => p && p.seedType).length) * 100) 
                : 0;
            companionEl.textContent = `+${avgCompanion}%`;
        }
    },
    
    // Rare seed drop system
    RARE_SEED_TIERS: {
        common: ['sunflower', 'cactus'],
        uncommon: ['bonsai', 'moonflower'],
        rare: ['crystal', 'starfruit', 'dragonFruit'],
        epic: ['rainbow', 'goldenApple'],
        legendary: ['moneyTree', 'ancientOak']
    },
    
    getRareSeedDropChance(state, harvestedSeed) {
        // Base drop chance depends on what you harvested
        const seedData = Gamification.SHOP.seeds[harvestedSeed];
        let baseChance = 0.05; // 5% base
        
        // Higher tier seeds have better drop chances
        if (this.RARE_SEED_TIERS.uncommon.includes(harvestedSeed)) baseChance = 0.08;
        if (this.RARE_SEED_TIERS.rare.includes(harvestedSeed)) baseChance = 0.12;
        if (this.RARE_SEED_TIERS.epic.includes(harvestedSeed)) baseChance = 0.15;
        if (this.RARE_SEED_TIERS.legendary.includes(harvestedSeed)) baseChance = 0.20;
        
        // Season bonus
        const season = this.getCurrentSeason();
        const seasonData = this.SEASONS[season];
        if (seasonData.bonusSeeds.includes(harvestedSeed)) {
            baseChance *= 1.5; // +50% in season
        }
        
        // Lucky clover decoration bonus
        if ((state.garden.decorations || []).includes('clover')) {
            baseChance *= 1.25;
        }
        
        return Math.min(baseChance, 0.35); // Cap at 35%
    },
    
    rollRareSeedDrop(state) {
        const level = state.level || 1;
        const roll = Math.random();
        
        // Weighted roll based on player level
        let tier;
        if (roll < 0.50) tier = 'common';
        else if (roll < 0.75) tier = 'uncommon';
        else if (roll < 0.90) tier = 'rare';
        else if (roll < 0.97) tier = 'epic';
        else tier = 'legendary';
        
        // Can only get seeds you've unlocked or are close to unlocking
        const tierSeeds = this.RARE_SEED_TIERS[tier];
        const availableSeeds = tierSeeds.filter(seedId => {
            const req = Gamification.LEVEL_REQS.seeds[seedId] || 1;
            return level >= req - 3; // Can get seeds up to 3 levels ahead
        });
        
        if (availableSeeds.length === 0) {
            // Fall back to common
            return this.RARE_SEED_TIERS.common[Math.floor(Math.random() * this.RARE_SEED_TIERS.common.length)];
        }
        
        return availableSeeds[Math.floor(Math.random() * availableSeeds.length)];
    },

    renderGrid(state) {
        const el = document.getElementById('gardenGrid');
        const plots = state.garden.plots || [];
        const unlocked = state.garden.unlockedPlots || 3;
        const outOfWater = (state.inventory.gardenItems.water || 0) <= 0;
        const season = this.getCurrentSeason();
        const seasonData = this.SEASONS[season];
        let html = '';

        for (let i = 0; i < 9; i++) {
            if (i >= unlocked) {
                html += `<div class="garden-plot locked" onclick="Shop.show();Shop.switchTab('plots')"><span class="plot-lock">\u{1F512}</span></div>`;
                continue;
            }
            const plot = plots[i];
            if (!plot || !plot.seedType) {
                html += `<div class="garden-plot empty" onclick="Garden.showSeedPickerModal(${i})"><span class="plot-empty-icon">\u{1F573}\u{FE0F}</span></div>`;
            } else {
                const seed = Gamification.SHOP.seeds[plot.seedType];
                if (!seed) { html += `<div class="garden-plot empty"></div>`; continue; }
                const stageIdx = Math.min(plot.currentStage || 0, seed.emojis.length - 1);
                const isReady = plot.currentStage >= seed.stages - 1;
                const companionBonus = this.getCompanionBonus(state, i);
                const hasCompanion = companionBonus > 0;
                const inSeason = seasonData.bonusSeeds.includes(plot.seedType);
                const growthBonus = this.getTotalGrowthBonus(state, i);
                const bonusPct = Math.round((growthBonus - 1) * 100);
                
                html += `<div class="garden-plot planted${isReady ? ' harvestable' : ''}${hasCompanion ? ' companion-bonus' : ''}${inSeason ? ' in-season' : ''}" onclick="${isReady ? `Garden.harvest(${i})` : `Garden.showPlotInfoModal(${i})`}">
                    <span class="plot-plant${isReady ? ' glow-bounce' : ''}">${Sprites.plantSprite(plot.seedType, stageIdx, seed.emojis[stageIdx], 40)}</span>
                    ${!isReady ? `<div class="plot-progress-bar"><div class="plot-progress-fill" style="width:${Math.floor(((plot.growthPoints || 0) / seed.gpNeeded) * 100)}%"></div></div>` : '<div class="plot-ready">\u2728 Harvest!</div>'}
                    <div class="plot-label">${seed.name}</div>
                    ${bonusPct > 0 && !isReady ? `<div class="plot-bonus-tag">+${bonusPct}%</div>` : ''}
                    ${!isReady ? `<button class="plot-water-btn" ${outOfWater ? 'disabled' : ''} onclick="event.stopPropagation();Garden.waterPlot(${i})">\u{1F4A7} Water</button>` : ''}
                    ${plot.fertilized ? '<span class="plot-fertilized" title="Fertilized">\u{1F9EA}</span>' : ''}
                    ${inSeason ? '<span class="plot-season-badge" title="In Season!"></span>' : ''}
                </div>`;
            }
        }

        el.innerHTML = html;
    },

    renderDecos(state) {
        const el = document.getElementById('gardenDecos');
        if (!el) return;
        const decos = state.garden.decorations || [];
        if (decos.length === 0) { el.innerHTML = ''; return; }
        let html = '';
        decos.forEach(d => {
            const item = Gamification.SHOP.decorations[d];
            if (item) html += `<span class="garden-deco" title="${item.name}">${item.icon}</span>`;
        });
        el.innerHTML = html;
    },

    renderPet(state) {
        const el = document.getElementById('gardenPet');
        if (!el) return;
        
        const buddy = state.studyBuddy;
        const pets = state.pets || [];
        const graveyard = state.graveyard || [];
        
        // Check if buddy is dead or no pets exist
        if (buddy.dead || pets.length === 0) {
            // Show graveyard if there are dead pets
            if (graveyard.length > 0) {
                const resStones = state.inventory?.battleItems?.resStone || 0;
                // Dedupe graveyard by name for display
                const uniqueGraves = [];
                const seenNames = new Set();
                graveyard.forEach((g, idx) => {
                    if (!seenNames.has(g.name)) {
                        seenNames.add(g.name);
                        uniqueGraves.push({ ...g, originalIdx: idx });
                    }
                });
                el.innerHTML = `
                    <div class="garden-graveyard">
                        <div class="graveyard-header"> Pet Graveyard</div>
                        <div class="graveyard-list">
                            ${uniqueGraves.slice(0, 3).map((grave) => {
                                const sp = Gamification.PET_SPECIES[grave.species] || Gamification.PET_SPECIES.bird;
                                return `<div class="graveyard-pet" onclick="Shop.resurrectPet(${grave.originalIdx})" title="Click to resurrect (needs )">
                                    <span class="graveyard-icon"></span>
                                    <span class="graveyard-name">${grave.name}</span>
                                </div>`;
                            }).join('')}
                        </div>
                        <div class="graveyard-footer">
                             ${resStones} Resurrection Stone${resStones !== 1 ? 's' : ''}
                            ${uniqueGraves.length > 3 ? `<br><small>+${uniqueGraves.length - 3} more</small>` : ''}
                        </div>
                        <button class="btn-sm" onclick="Shop.show();Shop.switchTab('adoptPet')" style="margin-top:8px">View All Pets</button>
                    </div>
                `;
            } else {
                // No pets and no graveyard - prompt to get a pet
                el.innerHTML = `
                    <div class="garden-no-pet">
                        <div style="font-size:32px;opacity:0.5"></div>
                        <div style="font-size:12px;color:var(--gray-500)">No pet yet!</div>
                        <button class="btn-sm" onclick="Shop.show();Shop.switchTab('pets')" style="margin-top:8px">Get a Pet</button>
                    </div>
                `;
            }
            return;
        }
        
        const accessories = buddy.accessories || [];
        const moodText = this.getMoodLabel(buddy);
        el.innerHTML = `
            <div class="garden-pet-mood-bubble">${moodText}</div>
            <div class="garden-pet-sprite">
                <span class="garden-pet-emoji">${Sprites.petSprite(buddy.stage, Gamification.getSpeciesEmoji(buddy.species, buddy.stage), 44)}</span>
                ${accessories.map(a => {
                    const item = Gamification.SHOP.cosmetics[a];
                    return item ? `<span class="pet-accessory acc-${a}">${item.icon}</span>` : '';
                }).join('')}
            </div>
            <div class="garden-pet-name">${buddy.name}</div>
        `;
    },

    getMoodLabel(buddy) {
        const h = buddy.hunger ?? 100;
        const hp = buddy.happiness ?? 100;
        if (h > 75 && hp > 75) return 'Happy ';
        if (h > 50 && hp > 50) return 'Content ';
        if (h < 25 || hp < 25) return 'Miserable ';
        if (h < 50) return 'Hungry ';
        return 'Sad ';
    },

    dismissModal() {
        const overlay = document.querySelector('.garden-modal-overlay');
        if (overlay) overlay.remove();
    },

    showSeedPickerModal(plotIdx) {
        const state = Gamification.getState();
        const inv = state.inventory.seeds;
        const available = Object.entries(inv).filter(([id, count]) => count > 0 && Gamification.isItemUnlocked('seeds', id));

        if (available.length === 0) {
            alert('No seeds available! Buy some from the Shop or level up to unlock more.');
            return;
        }

        let seedsHtml = '';
        available.forEach(([id, count]) => {
            const seed = Gamification.SHOP.seeds[id];
            seedsHtml += `<div class="seed-option" onclick="Garden.plantSeed(${plotIdx},'${id}')">
                <span class="seed-option-icon">${seed.icon}</span>
                <div class="seed-option-info">
                    <div class="seed-option-name">${seed.name}</div>
                    <div class="seed-option-meta">${seed.gpNeeded} GP \u2022 ${seed.coinReward} coins \u2022 ${seed.xpReward} XP</div>
                </div>
                <span class="seed-option-count">x${count}</span>
            </div>`;
        });

        const overlay = document.createElement('div');
        overlay.className = 'garden-modal-overlay';
        overlay.onclick = e => { if (e.target === overlay) Garden.dismissModal(); };
        overlay.innerHTML = `<div class="garden-modal">
            <button class="garden-modal-close" onclick="Garden.dismissModal()">\u2715</button>
            <h3>\u{1F331} Pick a Seed</h3>
            ${seedsHtml}
        </div>`;
        document.body.appendChild(overlay);
    },

    plantSeed(plotIdx, seedId) {
        this.dismissModal();
        const state = Gamification.getState();
        state.inventory.seeds[seedId]--;

        while (state.garden.plots.length <= plotIdx) state.garden.plots.push(null);
        state.garden.plots[plotIdx] = {
            seedType: seedId,
            currentStage: 0,
            growthPoints: 0,
            plantedAt: Date.now(),
            fertilized: false,
            fertilizedRemaining: 0
        };

        Gamification.saveState(state);
        SoundFX.play('plant');

        const filledPlots = state.garden.plots.filter(p => p && p.seedType).length;
        if (filledPlots >= 9) Gamification.unlockAchievement('garden_paradise');

        this.render();
    },

    showPlotInfoModal(plotIdx) {
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot) return;
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (!seed) return;

        const gp = plot.growthPoints || 0;
        const needed = seed.gpNeeded;
        const stage = (plot.currentStage || 0) + 1;
        const pct = Math.floor((gp / needed) * 100);
        const inv = state.inventory.gardenItems;
        const hasFert = inv.fertilizer > 0 && !plot.fertilized;
        const hasSuperFert = (inv.superFertilizer || 0) > 0 && !plot.fertilized;
        const hasDust = inv.magicDust > 0 && plot.currentStage < seed.stages - 1;

        const overlay = document.createElement('div');
        overlay.className = 'garden-modal-overlay';
        overlay.onclick = e => { if (e.target === overlay) Garden.dismissModal(); };
        overlay.innerHTML = `<div class="garden-modal">
            <button class="garden-modal-close" onclick="Garden.dismissModal()">\u2715</button>
            <div class="plot-info-header">
                <div class="plot-info-emoji">${Sprites.plantSprite(plot.seedType, Math.min(plot.currentStage || 0, seed.emojis.length - 1), seed.emojis[Math.min(plot.currentStage || 0, seed.emojis.length - 1)], 48)}</div>
                <div class="plot-info-name">${seed.name}</div>
            </div>
            <div class="plot-info-stats">
                <div class="plot-info-stat"><span>Stage</span><span>${stage} / ${seed.stages}</span></div>
                <div class="plot-info-stat"><span>Growth</span><span>${gp} / ${needed} GP</span></div>
                ${plot.fertilized ? `<div class="plot-info-stat"><span>\u{1F9EA} Fertilized</span><span>${plot.fertilizedRemaining} Q left</span></div>` : ''}
                <div class="plot-info-stat"><span>Reward</span><span>${seed.coinReward} coins + ${seed.xpReward} XP</span></div>
            </div>
            <div class="plot-info-progress"><div class="plot-info-progress-fill" style="width:${pct}%"></div></div>
            <div class="plot-info-actions">
                <button class="plot-info-action" onclick="Garden.applyFertilizer(${plotIdx})" ${hasFert ? '' : 'disabled'}>
                    <span class="plot-info-action-icon">\u{1F9EA}</span>
                    <div><div class="plot-info-action-label">Fertilizer${hasFert ? ` (x${inv.fertilizer})` : ''}</div><div class="plot-info-action-desc">2x growth for next 10 questions</div></div>
                </button>
                <button class="plot-info-action" onclick="Garden.applySuperFertilizer(${plotIdx})" ${hasSuperFert ? '' : 'disabled'}>
                    <span class="plot-info-action-icon">\u{1F48A}</span>
                    <div><div class="plot-info-action-label">Super Fertilizer${hasSuperFert ? ` (x${inv.superFertilizer})` : ''}</div><div class="plot-info-action-desc">3x growth for next 10 questions</div></div>
                </button>
                <button class="plot-info-action" onclick="Garden.applyMagicDust(${plotIdx})" ${hasDust ? '' : 'disabled'}>
                    <span class="plot-info-action-icon">\u2728</span>
                    <div><div class="plot-info-action-label">Magic Dust${hasDust ? ` (x${inv.magicDust})` : ''}</div><div class="plot-info-action-desc">Instantly advance +1 stage</div></div>
                </button>
            </div>
        </div>`;
        document.body.appendChild(overlay);
    },

    applyFertilizer(plotIdx) {
        this.dismissModal();
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot || plot.fertilized || state.inventory.gardenItems.fertilizer <= 0) return;
        state.inventory.gardenItems.fertilizer--;
        plot.fertilized = true;
        plot.fertilizedRemaining = 10;
        plot.fertilizerMultiplier = 2; // 2x growth
        Gamification.saveState(state);
        this.render();
    },

    applySuperFertilizer(plotIdx) {
        this.dismissModal();
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot || plot.fertilized || (state.inventory.gardenItems.superFertilizer || 0) <= 0) return;
        state.inventory.gardenItems.superFertilizer--;
        plot.fertilized = true;
        plot.fertilizedRemaining = 10;
        plot.fertilizerMultiplier = 3; // 3x growth
        Gamification.saveState(state);
        this.render();
    },

    applyMagicDust(plotIdx) {
        this.dismissModal();
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot) return;
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (!seed || state.inventory.gardenItems.magicDust <= 0 || plot.currentStage >= seed.stages - 1) return;
        state.inventory.gardenItems.magicDust--;
        plot.currentStage++;
        Gamification.saveState(state);
        this.render();
    },

    harvest(plotIdx) {
        const state = Gamification.getState();
        const plot = state.garden.plots[plotIdx];
        if (!plot) return;
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (!seed) return;

        // Check for night bonus (moonflower)
        const hour = new Date().getHours();
        const isNight = hour >= 20 || hour < 6;
        const nightMultiplier = (seed.nightBonus && isNight) ? 2 : 1;

        // Award coins and XP
        Gamification.awardCoins(seed.coinReward * nightMultiplier, 'harvest');
        Gamification.awardXp('correctAnswer', { multiplier: (seed.xpReward / 25) * nightMultiplier });

        // Award gems if seed has gemReward (starfruit)
        if (seed.gemReward) {
            Gamification.awardGems(seed.gemReward * nightMultiplier, 'harvest');
        }

        // Pet happiness boost from harvest
        state.studyBuddy.hunger = Math.min(100, (state.studyBuddy.hunger || 0) + 10);
        state.studyBuddy.happiness = Math.min(100, (state.studyBuddy.happiness || 0) + 10);

        // Dragon Fruit bonus: extra pet happiness
        if (seed.petBonus) {
            state.studyBuddy.happiness = Math.min(100, (state.studyBuddy.happiness || 0) + 10);
        }

        // Golden Apple: fully heal pet
        if (seed.healPet) {
            state.studyBuddy.hunger = 100;
            state.studyBuddy.happiness = 100;
            state.studyBuddy.sick = false;
            Gamification.showAchievementToast({ icon: '', name: 'Golden Apple!', desc: 'Pet fully healed', xp: 0 });
        }

        // Ancient Oak: permanent coin bonus
        if (seed.permBonus) {
            state.gardenCoinBonus = (state.gardenCoinBonus || 0) + seed.permBonus;
            Gamification.showAchievementToast({ icon: '', name: 'Ancient Oak Blessing', desc: `+${Math.round(seed.permBonus * 100)}% permanent coin bonus!`, xp: 0 });
        }

        state.garden.totalHarvests = (state.garden.totalHarvests || 0) + 1;
        DailyChallenges.trackHarvest();

        // Rare seed drop chance on harvest
        const dropChance = this.getRareSeedDropChance(state, plot.seedType);
        if (Math.random() < dropChance) {
            const droppedSeed = this.rollRareSeedDrop(state);
            if (droppedSeed) {
                state.inventory.seeds[droppedSeed] = (state.inventory.seeds[droppedSeed] || 0) + 1;
                const seedData = Gamification.SHOP.seeds[droppedSeed];
                Gamification.showAchievementToast({ 
                    icon: seedData?.icon || '', 
                    name: 'Rare Seed Found!', 
                    desc: `You found a ${seedData?.name || droppedSeed} seed!`, 
                    xp: 0 
                });
            }
        }

        // Clear the plot
        state.garden.plots[plotIdx] = null;
        Gamification.saveState(state);

        SoundFX.play('harvest');
        Gamification.triggerConfetti();

        // Check achievements
        if (state.garden.totalHarvests === 1) Gamification.unlockAchievement('green_thumb');
        if (state.garden.totalHarvests >= 10) Gamification.unlockAchievement('master_gardener');
        if (plot.seedType === 'rainbow') Gamification.unlockAchievement('rainbow_bloom');
        if (plot.seedType === 'ancientOak') Gamification.unlockAchievement('ancient_gardener');

        this.render();
    },

    // Called when user answers correctly  grows all plants
    grow(points) {
        const state = Gamification.getState();
        if (!state.settings.garden) return;
        if ((state.garden.waterLevel || 0) <= 0) return; // No water = no growth

        // Check for fountain decoration (auto-water)
        const hasFountain = (state.garden.decorations || []).includes('fountain');
        if (hasFountain) {
            state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 5);
        }

        // Decay water slightly per question (affected by weather)
        // Rain cloud prevents water decay
        const rainCloudActive = state.garden.rainCloudUntil && Date.now() < state.garden.rainCloudUntil;
        if (rainCloudActive) {
            state.garden.waterLevel = 100;
        } else {
            const weather = this.getCurrentWeather(state);
            const weatherData = this.WEATHER_TYPES[weather];
            const waterDecay = Math.ceil(1 * (weatherData?.waterDecay || 1));
            state.garden.waterLevel = Math.max(0, (state.garden.waterLevel || 100) - waterDecay);
            
            // Stormy weather adds free water
            if (weather === 'stormy') {
                state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 3);
            }
        }

        const plots = state.garden.plots || [];
        const now = Date.now();
        for (let i = 0; i < plots.length; i++) {
            const plot = plots[i];
            if (!plot || !plot.seedType) continue;
            const seed = Gamification.SHOP.seeds[plot.seedType];
            if (!seed) continue;
            if ((plot.currentStage || 0) >= seed.stages - 1) continue; // Already ready

            // Apply growth bonus from weather, season, and companions
            const growthBonus = this.getTotalGrowthBonus(state, i);
            let gp = Math.ceil(points * growthBonus);
            
            if (plot.fertilized && plot.fertilizedRemaining > 0) {
                gp *= (plot.fertilizerMultiplier || 2); // Use stored multiplier (2x or 3x)
                plot.fertilizedRemaining--;
                if (plot.fertilizedRemaining <= 0) {
                    plot.fertilized = false;
                    delete plot.fertilizerMultiplier;
                }
            }

            plot.growthPoints = (plot.growthPoints || 0) + gp;

            // Check for stage advancement
            const gpPerStage = seed.gpNeeded / (seed.stages - 1);
            const newStage = Math.min(seed.stages - 1, Math.floor(plot.growthPoints / gpPerStage));
            if (newStage > (plot.currentStage || 0)) {
                plot.currentStage = newStage;
            }
        }

        state.garden.lastGrowthTick = now;
        Gamification.saveState(state);
    },

    // Use watering can from inventory
    useWater() {
        const state = Gamification.getState();
        if ((state.inventory.gardenItems.water || 0) <= 0) {
            this._promptWaterPurchase();
            return;
        }
        state.inventory.gardenItems.water--;
        state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 25);
        Gamification.saveState(state);
        this.render();
        this.flashWaterMeter();
    },

    waterPlot(plotIdx) {
        const state = Gamification.getState();
        const plot = state.garden.plots?.[plotIdx];
        if (!plot || !plot.seedType) return;
        if ((state.inventory.gardenItems.water || 0) <= 0) {
            this._promptWaterPurchase();
            return;
        }
        state.inventory.gardenItems.water--;
        state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + 15);
        const seed = Gamification.SHOP.seeds[plot.seedType];
        if (seed) {
            const bonus = Math.ceil(seed.gpNeeded * 0.1);
            plot.growthPoints = (plot.growthPoints || 0) + bonus;
            const gpPerStage = seed.gpNeeded / (seed.stages - 1);
            const newStage = Math.min(seed.stages - 1, Math.floor(plot.growthPoints / gpPerStage));
            if (newStage > (plot.currentStage || 0)) {
                plot.currentStage = newStage;
            }
        }
        state.garden.lastGrowthTick = Date.now();
        Gamification.saveState(state);
        DailyChallenges.trackWater();
        this.render();
        this.flashWaterMeter();
    },

    // Decay water over time (called on init and periodically)
    decayWater() {
        const state = Gamification.getState();
        const now = Date.now();
        
        // Rain cloud prevents water decay
        const rainCloudActive = state.garden.rainCloudUntil && now < state.garden.rainCloudUntil;
        if (rainCloudActive) {
            state.garden.waterLevel = 100;
            state.garden.lastWaterDecay = now;
            Gamification.saveState(state);
            return;
        }
        
        const last = state.garden.lastWaterDecay || now;
        const hoursPassed = (now - last) / (1000 * 60 * 60);

        if (hoursPassed >= 1) {
            const decay = Math.floor(hoursPassed * 5);
            state.garden.waterLevel = Math.max(0, (state.garden.waterLevel || 100) - decay);
            state.garden.lastWaterDecay = now;

            // Check for plant stage loss if water at 0 for >48h
            if (state.garden.waterLevel <= 0 && hoursPassed >= 48) {
                const plots = state.garden.plots || [];
                plots.forEach(plot => {
                    if (plot && plot.currentStage > 0) {
                        plot.currentStage--;
                        plot.growthPoints = Math.max(0, (plot.growthPoints || 0) - 5);
                    }
                });
            }

            Gamification.saveState(state);
        }
    },

    idleGrow() {
        const state = Gamification.getState();
        if (!state.settings.garden) return;
        const now = Date.now();
        const last = state.garden.lastGrowthTick || now;
        const hoursPassed = (now - last) / (1000 * 60 * 60);
        if (hoursPassed < 1 / 60) return; // run roughly once per minute of elapsed time

        state.garden.lastGrowthTick = now;

        if ((state.garden.waterLevel || 0) <= 0) {
            Gamification.saveState(state);
            return;
        }

        const isTesting = typeof App !== 'undefined' && App && App.mode === 'test';
        const growthRatePerHour = isTesting ? 2.5 : 1.4; // GP-equivalent per hour
        const gpBonus = hoursPassed * growthRatePerHour;
        if (gpBonus <= 0) {
            Gamification.saveState(state);
            return;
        }

        let changed = false;
        const plots = state.garden.plots || [];
        plots.forEach((plot, idx) => {
            if (!plot || !plot.seedType) return;
            const seed = Gamification.SHOP.seeds[plot.seedType];
            if (!seed) return;
            if ((plot.currentStage || 0) >= seed.stages - 1) return;

            // Apply growth bonus from weather, season, and companions
            const growthBonus = this.getTotalGrowthBonus(state, idx);
            let gp = gpBonus * growthBonus;
            
            if (plot.fertilized && plot.fertilizedRemaining > 0) {
                gp *= (plot.fertilizerMultiplier || 2); // Use stored multiplier (2x or 3x)
                const fertDrain = Math.max(1, Math.round(gpBonus));
                plot.fertilizedRemaining = Math.max(0, (plot.fertilizedRemaining || 0) - fertDrain);
                if (plot.fertilizedRemaining === 0) {
                    plot.fertilized = false;
                    delete plot.fertilizerMultiplier;
                }
            }

            plot.growthPoints = (plot.growthPoints || 0) + gp;
            const gpPerStage = seed.gpNeeded / (seed.stages - 1);
            const newStage = Math.min(seed.stages - 1, Math.floor(plot.growthPoints / gpPerStage));
            if (newStage > (plot.currentStage || 0)) {
                plot.currentStage = newStage;
            }
            changed = true;
        });
        Gamification.saveState(state);
        if (changed) this.render();
    },

    decayPetStats() {
        const state = Gamification.getState();
        const now = Date.now();
        const timeScale = Math.max(1, Gamification.PET_DECAY_TIMESCALE || 1);
        const pets = state.pets || [state.studyBuddy];
        const petCount = pets.length;

        let anyChanged = false;
        let petsToRemove = [];
        const lastActiveTs = state.stats?.lastActiveTimestamp || now;
        
        pets.forEach((pet, idx) => {
            if (pet.dead) return; // Skip dead pets
            
            // Get per-pet care bonuses (each pet has own bowls/housing)
            const petCare = pet.petCare || { foodBowl: { level: 0, capacity: 0 }, waterBowl: { level: 0, capacity: 0 }, comfortBonus: 0, allDecayReduction: 0 };
            const comfortReduction = petCare.comfortBonus || 0;
            const allDecayReduction = petCare.allDecayReduction || 0;
            
            const baseline = pet.lastDecayCheck ?? lastActiveTs;
            const rawHours = (now - baseline) / (1000 * 60 * 60);
            const scaledHours = rawHours * timeScale;

            if (scaledHours < 0.01) {
                pet.lastDecayCheck = now;
                return; // ~1 min minimum
            }

            const diff = Gamification.getSpeciesDifficulty(pet.species);
            const crowdPenalty = 1 + (petCount - 1) * 0.15;
            const stageMultiplier = 1 + Math.max(0, (pet.stage || 1) - 1) * 0.25;
            const foodDecayMod = pet.foodDecayMod || 1.0; // Food quality affects decay rate
            const decayRate = diff * crowdPenalty * stageMultiplier * foodDecayMod;
            
            // Gradually normalize food decay modifier back to 1.0 over time (food digests)
            if (pet.foodDecayMod && pet.foodDecayMod !== 1.0) {
                const digestRate = 0.1 * scaledHours; // ~10% per hour back toward normal
                pet.foodDecayMod = pet.foodDecayMod + (1.0 - pet.foodDecayMod) * digestRate;
                if (Math.abs(pet.foodDecayMod - 1.0) < 0.01) pet.foodDecayMod = 1.0;
            }
            
            // Apply comfort and decay reduction from this pet's housing
            const hungerReduction = 1 - allDecayReduction;
            const happyReduction = 1 - Math.max(comfortReduction, allDecayReduction);

            // Base decay: ~4% per hour = ~24h to starve for easy pets, faster for harder species
            // With decayRate multiplier, harder species decay faster
            let hungerDecay = scaledHours * 4 * decayRate * hungerReduction;
            let happyDecay = scaledHours * 2.5 * decayRate * happyReduction;
            
            // Auto-feed from this pet's food bowl while away
            if (petCare.foodBowl && petCare.foodBowl.level > 0 && pet.hunger < 50) {
                const mealsNeeded = Math.ceil((50 - pet.hunger) / 10);
                const mealsUsed = Math.min(mealsNeeded, petCare.foodBowl.level);
                if (mealsUsed > 0) {
                    pet.hunger = Math.min(100, pet.hunger + mealsUsed * 10);
                    petCare.foodBowl.level -= mealsUsed;
                }
            }
            
            // Hydration decay (FASTER than hunger - pets get thirsty quicker)
            let hydrationDecay = scaledHours * 6 * decayRate * hungerReduction;
            
            // Auto-hydrate from this pet's water bowl
            if (petCare.waterBowl && petCare.waterBowl.level > 0 && pet.hydration < 50) {
                const drinksNeeded = Math.ceil((50 - (pet.hydration ?? 100)) / 15);
                const drinksUsed = Math.min(drinksNeeded, petCare.waterBowl.level);
                if (drinksUsed > 0) {
                    pet.hydration = Math.min(100, (pet.hydration ?? 100) + drinksUsed * 15);
                    petCare.waterBowl.level -= drinksUsed;
                }
            }

            pet.hunger = Math.max(0, (pet.hunger ?? 100) - hungerDecay);
            pet.happiness = Math.max(0, (pet.happiness ?? 100) - happyDecay);
            pet.hydration = Math.max(0, (pet.hydration ?? 100) - hydrationDecay);

            // Passive care minutes (1 per real hour)
            const passiveCare = Math.min(scaledHours, 24);
            pet.careMinutes = (pet.careMinutes || 0) + passiveCare;

            // Sickness at hunger, happiness, OR hydration below 15
            if ((pet.hunger < 15 && pet.happiness < 15) || pet.hydration < 10) pet.sick = true;
            if (pet.sick) {
                pet.hunger = Math.max(0, pet.hunger - scaledHours * 4 * decayRate * hungerReduction);
                pet.happiness = Math.max(0, pet.happiness - scaledHours * 4 * decayRate * happyReduction);
            }
            
            // Pet age calculation (in days)
            const birthDate = pet.birthDate || (now - 7 * 24 * 60 * 60 * 1000); // Default 7 days old for legacy pets
            const ageInDays = (now - birthDate) / (1000 * 60 * 60 * 24);
            const lifespan = pet.lifespan || 37; // Default 37 days for legacy pets
            
            // Natural death from old age (after lifespan expires)
            if (ageInDays >= lifespan) {
                pet.dyingOfAge = true;
                // Gradual decline after lifespan - pet has 3-5 more days
                const overAge = ageInDays - lifespan;
                if (overAge >= 3 + Math.random() * 2) {
                    petsToRemove.push(idx);
                    pet.diedOfAge = true;
                }
            }
            
            // Pet death check - if hunger AND happiness are 0 for too long while sick
            if (pet.sick && pet.hunger <= 0 && pet.happiness <= 0) {
                pet.deathTimer = (pet.deathTimer || 0) + scaledHours;
                if (pet.deathTimer >= 2) { // 2 scaled hours at 0/0 while sick = death
                    petsToRemove.push(idx);
                }
            } else {
                pet.deathTimer = 0;
            }

            pet.lastDecayCheck = now;
            anyChanged = true;
        });
        
        // Handle pet deaths
        if (petsToRemove.length > 0) {
            state.graveyard = state.graveyard || [];
            state.retiredNames = state.retiredNames || [];
            
            petsToRemove.reverse().forEach(idx => {
                const deadPet = pets[idx];
                const birthDate = deadPet.birthDate || (now - 7 * 24 * 60 * 60 * 1000);
                const ageAtDeath = Math.floor((now - birthDate) / (1000 * 60 * 60 * 24));
                const diedOfAge = deadPet.diedOfAge || false;
                
                // Track species death count for price increase
                state.speciesDeathCount = state.speciesDeathCount || {};
                state.speciesDeathCount[deadPet.species] = (state.speciesDeathCount[deadPet.species] || 0) + 1;
                
                // Add to graveyard
                state.graveyard.push({
                    name: deadPet.name,
                    species: deadPet.species,
                    stage: deadPet.stage,
                    diedAt: now,
                    totalXpFed: deadPet.totalXpFed,
                    careMinutes: deadPet.careMinutes,
                    ageAtDeath: ageAtDeath,
                    diedOfAge: diedOfAge
                });
                // Retire the name
                if (!state.retiredNames.includes(deadPet.name)) {
                    state.retiredNames.push(deadPet.name);
                }
                // Remove from pets array
                pets.splice(idx, 1);
                // Show death notification
                const deathMsg = diedOfAge 
                    ? `${deadPet.name} passed away peacefully at age ${ageAtDeath} days`
                    : `${deadPet.name} has passed away`;
                const deathDesc = diedOfAge 
                    ? 'They lived a full life. Visit the graveyard to remember them.'
                    : 'Visit the graveyard to remember them';
                Gamification.showAchievementToast({ 
                    icon: diedOfAge ? '' : '', 
                    name: deathMsg, 
                    desc: deathDesc, 
                    xp: 0 
                });
            });
            
            // Adjust active pet index and update studyBuddy
            if (state.activePetIdx >= pets.length) {
                state.activePetIdx = Math.max(0, pets.length - 1);
            }
            // Update studyBuddy to point to new active pet (or clear if no pets)
            if (pets.length > 0) {
                state.studyBuddy = pets[state.activePetIdx];
            } else {
                // No pets left - hide the buddy widget
                state.studyBuddy = { ...Gamification.getDefaultState().studyBuddy, dead: true };
            }
            anyChanged = true;
        }

        // Bonuses (active pet only)
        const buddy = state.studyBuddy;
        const bLast = buddy.lastDecayCheck || now;
        const bRaw = (now - bLast) / (1000 * 60 * 60);
        const bH = bRaw * timeScale;
        const growingCount = (state.garden.plots || []).filter(p => p && p.seedType).length;
        if (growingCount >= 3 && bH > 0) {
            buddy.happiness = Math.min(100, (buddy.happiness ?? 0) + bH * 5);
        }
        if ((buddy.happiness ?? 0) > 75 && bH > 0) {
            state.garden.waterLevel = Math.min(100, (state.garden.waterLevel || 0) + bH * 2.5);
        }

        if (anyChanged) {
            Gamification.saveState(state);
            Gamification.updateBuddyWidget();
        }
    }
    ,

    updateWaterMeter(state) {
        const meter = document.getElementById('gardenWaterMeter');
        if (!meter) return;
        const fill = meter.querySelector('.water-meter-fill');
        const text = meter.querySelector('.water-meter-text');
        const level = Math.max(0, Math.min(100, Math.round(state.garden.waterLevel || 0)));
        if (fill) fill.style.width = level + '%';
        
        // Check for active rain cloud
        const rainCloudActive = state.garden.rainCloudUntil && Date.now() < state.garden.rainCloudUntil;
        const rainTimeLeft = rainCloudActive ? Math.ceil((state.garden.rainCloudUntil - Date.now()) / 60000) : 0;
        
        let status = 'Hydrated';
        let statusClass = '';
        if (rainCloudActive) {
            status = ` ${rainTimeLeft}m`;
            statusClass = 'rain-active';
        } else if (level <= 10) {
            status = 'Critical';
            statusClass = 'critical';
        } else if (level <= 30) {
            status = 'Low';
            statusClass = 'low';
        }
        meter.classList.toggle('pulse', statusClass === 'critical' || statusClass === 'low');
        meter.classList.toggle('rain-cloud-active', rainCloudActive);
        if (text) {
            text.textContent = rainCloudActive ? `100% ${status}` : level + '% ' + status;
            text.classList.remove('low', 'critical', 'rain-active');
            if (statusClass) text.classList.add(statusClass);
        }
        // Keep water at 100% while rain cloud is active
        if (rainCloudActive && level < 100) {
            state.garden.waterLevel = 100;
        }
    },

    flashWaterMeter() {
        const meter = document.getElementById('gardenWaterMeter');
        if (!meter) return;
        meter.classList.add('pulse');
        if (this._meterPulseTimer) clearTimeout(this._meterPulseTimer);
        this._meterPulseTimer = setTimeout(() => meter.classList.remove('pulse'), 600);
    },

    _promptWaterPurchase() {
        if (this._waterPromptEl) return;
        // Only show prompt if garden page is visible
        const gardenScene = document.getElementById('gardenScene');
        if (!gardenScene || gardenScene.offsetParent === null) return;
        const prompt = document.createElement('div');
        prompt.className = 'garden-water-prompt';
        prompt.innerHTML = `
            <p>Out of water! Restock watering cans to keep plants growing.</p>
            <div class="garden-water-prompt-actions">
                <button class="prompt-primary">Go to Shop</button>
                <button class="prompt-secondary">Not now</button>
            </div>`;
        const [primary, secondary] = prompt.querySelectorAll('button');
        if (primary) primary.onclick = () => this._gotoWaterShop();
        if (secondary) secondary.onclick = () => this._dismissWaterPrompt();
        document.body.appendChild(prompt);
        this._waterPromptEl = prompt;
    },

    _dismissWaterPrompt() {
        if (this._waterPromptEl) {
            this._waterPromptEl.remove();
            this._waterPromptEl = null;
        }
    },

    _gotoWaterShop() {
        this._dismissWaterPrompt();
        if (typeof Shop !== 'undefined' && Shop) {
            Shop.show();
            Shop.switchTab('gardenItems');
        }
    }
};

// =====================================================================
// PET MODAL
// =====================================================================
const PetModal = {
    show() {
        const state = Gamification.getState();
        const buddy = state.studyBuddy;
        const stage = Gamification.BUDDY_STAGES.find(s => s.stage === buddy.stage) || Gamification.BUDDY_STAGES[0];
        const nextStage = Gamification.BUDDY_STAGES.find(s => s.stage === buddy.stage + 1);

        const hunger = buddy.hunger ?? 100;
        const happiness = buddy.happiness ?? 100;
        const hydration = buddy.hydration ?? 100;
        const accessories = buddy.accessories || [];
        const petCare = state.petCare || {};

        let progressInfo = '';
        if (nextStage) {
            const currentXp = buddy.totalXpFed - stage.xpNeeded;
            const neededXp = nextStage.xpNeeded - stage.xpNeeded;
            const xpPct = Math.min(100, Math.floor((currentXp / neededXp) * 100));
            const currentCare = (buddy.careMinutes || 0) - (stage.careNeeded || 0);
            const neededCare = (nextStage.careNeeded || 0) - (stage.careNeeded || 0);
            const carePct = neededCare > 0 ? Math.min(100, Math.floor((currentCare / neededCare) * 100)) : 100;
            progressInfo = `<div class="pet-meter"><span>XP Progress</span><div class="pet-meter-bar"><div class="pet-meter-fill evolution" style="width:${xpPct}%"></div></div><span>${xpPct}%</span></div>`;
            progressInfo += `<div class="pet-meter"><span>Care Time</span><div class="pet-meter-bar"><div class="pet-meter-fill care" style="width:${carePct}%"></div></div><span>${carePct}%</span></div>`;

            // Evolution timer estimate
            const remainXp = Math.max(0, neededXp - currentXp);
            const remainCare = Math.max(0, neededCare - currentCare);
            // ~25 avg XP per question (correctAnswer), 3 care min per question
            const questionsForXp = Math.ceil(remainXp / 25);
            const questionsForCare = Math.ceil(remainCare / 3);
            const questionsNeeded = Math.max(questionsForXp, questionsForCare);
            // ~2 min per question average
            const minutesNeeded = questionsNeeded * 2;
            const evoHours = Math.floor(minutesNeeded / 60);
            const evoMins = minutesNeeded % 60;
            const timeStr = evoHours > 0 ? `~${evoHours}h ${evoMins}m` : `~${evoMins}m`;
            progressInfo += `<div class="pet-evo-timer">Next evolution: ~${questionsNeeded} questions (${timeStr} of study)</div>`;
        } else {
            progressInfo = '<div class="pet-meter"><span>Max Evolution!</span></div>';
        }

        const sickBanner = buddy.sick ? '<div class="pet-sick-banner">Your pet is sick! Feed and study to heal.</div>' : '';

        // Food inventory
        const inv = state.inventory.petFood;
        let foodHtml = '<div class="pet-food-grid">';
        for (const [id, item] of Object.entries(Gamification.SHOP.food)) {
            const count = inv[id] || 0;
            const healthLabel = item.healthy ? ' Healthy (slow decay)' : ' Indulgent (fast decay)';
            const decayInfo = item.decayMod < 1 ? `${Math.round((1-item.decayMod)*100)}% slower decay` : `${Math.round((item.decayMod-1)*100)}% faster decay`;
            foodHtml += `<button class="pet-food-btn${item.healthy ? ' healthy' : ' unhealthy'}" onclick="PetModal.feed('${id}')" ${count <= 0 ? 'disabled' : ''} title="${healthLabel} | +${item.hunger} hunger, +${item.happiness} happy, +${item.careBonus || 0} growth | ${decayInfo}">${item.icon} ${item.name} <span class="pet-food-count">x${count}</span>${item.careBonus ? '<span class="food-growth">+' + item.careBonus + ' growth</span>' : ''}</button>`;
        }
        foodHtml += '</div>';

        // Accessories
        let accessoryHtml = '<div class="pet-accessory-grid">';
        const owned = state.inventory.petAccessories || [];
        for (const id of owned) {
            const item = Gamification.SHOP.cosmetics[id];
            if (!item) continue;
            const equipped = accessories.includes(id);
            accessoryHtml += `<button class="pet-accessory-btn${equipped ? ' equipped' : ''}" onclick="PetModal.toggleAccessory('${id}')">${item.icon}${equipped ? ' ' : ''}</button>`;
        }
        if (owned.length === 0) accessoryHtml += '<span style="color:var(--gray-500);font-size:12px">Buy accessories in the Shop!</span>';
        accessoryHtml += '</div>';

        // Pet selector (if multiple pets)
        const pets = state.pets || [];
        let petSelectorHtml = '';
        if (pets.length > 1) {
            petSelectorHtml = '<div class="pet-selector">';
            pets.forEach((p, i) => {
                const isActive = i === (state.activePetIdx || 0);
                const sp = Gamification.PET_SPECIES[p.species] || Gamification.PET_SPECIES.bird;
                const statusIcon = p.sick ? '\ud83e\udd12' : ((p.hunger ?? 100) < 30 ? '\u26a0\ufe0f' : '');
                petSelectorHtml += `<button class="pet-sel-btn${isActive ? ' active' : ''}" onclick="PetModal.switchAndShow(${i})" title="${p.name}">${Gamification.getSpeciesEmoji(p.species, p.stage)} ${statusIcon}</button>`;
            });
            petSelectorHtml += '</div>';
        }

        const spInfo = Gamification.PET_SPECIES[buddy.species] || Gamification.PET_SPECIES.bird;

        const html = `
            <div class="pet-modal-content">
                <button class="pet-modal-close" onclick="PetModal.close()">&times;</button>
                ${petSelectorHtml}
                <div class="pet-modal-sprite">
                    <span class="pet-modal-emoji">${Sprites.petSprite(buddy.stage, Gamification.getSpeciesEmoji(buddy.species, buddy.stage), 64)}</span>
                    ${accessories.map(a => { const it = Gamification.SHOP.cosmetics[a]; return it ? `<span class="pet-modal-acc acc-${a}">${it.icon}</span>` : ''; }).join('')}
                </div>
                <div class="pet-modal-name" onclick="PetModal.rename()">${buddy.name} </div>
                <div class="pet-modal-stage">${Gamification.getSpeciesStageName(buddy.species, buddy.stage)}${buddy.sick ? ' \ud83e\udd12' : ''} <span style="font-size:11px;color:var(--gray-500)">(${spInfo.name})</span></div>
                ${sickBanner}
                <div class="pet-meters">
                    <div class="pet-meter"><span> Hunger</span><div class="pet-meter-bar"><div class="pet-meter-fill hunger" style="width:${hunger}%"></div></div><span>${Math.round(hunger)}%</span></div>
                    <div class="pet-meter"><span> Hydration</span><div class="pet-meter-bar"><div class="pet-meter-fill hydration" style="width:${hydration}%"></div></div><span>${Math.round(hydration)}%</span></div>
                    <div class="pet-meter"><span> Happiness</span><div class="pet-meter-bar"><div class="pet-meter-fill happiness" style="width:${happiness}%"></div></div><span>${Math.round(happiness)}%</span></div>
                    ${progressInfo}
                </div>
                <h4> Water ${petCare.waterBowl?.capacity > 0 ? `<span style="font-size:11px;color:var(--gray-500)">(Bowl: ${Math.round(petCare.waterBowl.level || 0)}/${petCare.waterBowl.capacity})</span>` : ''}</h4>
                <div style="display:flex;gap:8px;margin-bottom:12px">
                    ${petCare.waterBowl?.capacity > 0 ? `<button class="pet-food-btn" onclick="PetModal.giveWater()" style="flex:1" ${hydration >= 100 || (petCare.waterBowl.level || 0) <= 0 ? 'disabled' : ''}> Give Water (+15%)</button>
                    <button class="pet-food-btn" onclick="Shop.fillWaterBowl();PetModal.show()" style="flex:1" ${(petCare.waterBowl.level || 0) >= petCare.waterBowl.capacity ? 'disabled' : ''}> Refill Bowl</button>` : `<span style="color:var(--gray-500);font-size:12px">Buy a Water Bowl from the shop to hydrate your pet!</span>`}
                </div>
                ${petCare.foodBowl?.capacity > 0 ? `
                <div style="display:flex;gap:8px;margin-bottom:12px">
                    <button class="pet-food-btn" onclick="Shop.fillFoodBowl();PetModal.show()" style="flex:1" ${(petCare.foodBowl.level || 0) >= petCare.foodBowl.capacity ? 'disabled' : ''}> Fill Food Bowl ${petCare.foodBowl.level || 0}/${petCare.foodBowl.capacity}</button>
                </div>
                ` : ''}
                <h4> Evolution Stone</h4>
                <div style="display:flex;gap:8px;margin-bottom:12px">
                    <button class="pet-food-btn" onclick="PetModal.useEvoStone()" style="flex:1" ${(state.inventory.gardenItems?.evoStone || 0) <= 0 ? 'disabled' : ''}> Use Evolution Stone (+60 care mins) <span class="pet-food-count">x${state.inventory.gardenItems?.evoStone || 0}</span></button>
                </div>
                <h4> Feed</h4>
                ${foodHtml}
                <h4>Accessories</h4>
                ${accessoryHtml}
                <div class="pet-modal-stats">
                    <span>Age: ${(() => { const bd = buddy.birthDate || (Date.now() - 7*24*60*60*1000); const age = Math.floor((Date.now() - bd) / (1000*60*60*24)); const ls = buddy.lifespan || 37; const pct = Math.round((age/ls)*100); return age + ' days (' + pct + '% of lifespan)'; })()}${buddy.dyingOfAge ? ' ' : ''}</span>
                    <span>Meals eaten: ${buddy.totalMealsEaten || 0}</span>
                    <span>Total XP fed: ${buddy.totalXpFed.toLocaleString()}</span>
                    <span>Study time: ${Math.floor((buddy.studyMinutes || 0) / 60)}h ${(buddy.studyMinutes || 0) % 60}m</span>
                    <span>Care time: ${Math.floor((buddy.careMinutes || 0) / 60)}h ${(buddy.careMinutes || 0) % 60}m</span>
                </div>
            </div>`;

        let overlay = document.getElementById('petModalOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.id = 'petModalOverlay';
            overlay.className = 'modal-overlay';
            overlay.onclick = function(e) { if (e.target === overlay) PetModal.close(); };
            document.body.appendChild(overlay);
        }
        overlay.innerHTML = html;
        overlay.classList.add('active');
    },

    close() {
        const overlay = document.getElementById('petModalOverlay');
        if (overlay) overlay.classList.remove('active');
    },

    switchAndShow(idx) {
        const state = Gamification.getState();
        if (idx < 0 || idx >= (state.pets || []).length) return;
        state.pets[state.activePetIdx || 0] = state.studyBuddy;
        state.activePetIdx = idx;
        state.studyBuddy = state.pets[idx];
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        this.show();
    },

    rename() {
        const state = Gamification.getState();
        const name = prompt('Name your buddy (max 20 chars):', state.studyBuddy.name);
        if (!name || name.trim().length === 0) return;
        state.studyBuddy.name = name.trim().slice(0, 20);
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        this.show(); // Re-render modal
    },

    useEvoStone() {
        const state = Gamification.getState();
        const evoCount = state.inventory.gardenItems?.evoStone || 0;
        if (evoCount <= 0) return;
        
        // Consume one evolution stone
        state.inventory.gardenItems.evoStone = evoCount - 1;
        
        // Apply +60 care minutes to the ACTIVE pet
        const buddy = state.studyBuddy;
        buddy.careMinutes = (buddy.careMinutes || 0) + 60;
        
        // Check evolution
        for (let i = Gamification.BUDDY_STAGES.length - 1; i >= 0; i--) {
            const req = Gamification.BUDDY_STAGES[i];
            if (buddy.totalXpFed >= req.xpNeeded && (buddy.careMinutes || 0) >= req.careNeeded) {
                if (buddy.stage < req.stage) {
                    buddy.stage = req.stage;
                    Gamification.showAchievementToast({
                        icon: Gamification.getSpeciesEmoji(buddy.species, req.stage),
                        name: buddy.name + ' evolved!',
                        desc: 'Now a ' + Gamification.getSpeciesStageName(buddy.species, req.stage),
                        xp: 0
                    });
                }
                break;
            }
        }
        
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        SoundFX.play('levelup');
        this.show(); // Re-render modal
    },

    feed(foodId) {
        const state = Gamification.getState();
        const inv = state.inventory.petFood;
        if ((inv[foodId] || 0) <= 0) return;

        const item = Gamification.SHOP.food[foodId];
        if (!item) return;

        inv[foodId]--;
        const buddy = state.studyBuddy;
        buddy.hunger = Math.min(100, (buddy.hunger ?? 0) + item.hunger);
        buddy.happiness = Math.min(100, (buddy.happiness ?? 0) + item.happiness);
        buddy.totalMealsEaten = (buddy.totalMealsEaten || 0) + 1;
        buddy.lastFed = Date.now();
        buddy.lastInteraction = Date.now();
        
        // Track food decay modifier - weighted average based on hunger portion fed
        const currentDecayMod = buddy.foodDecayMod || 1.0;
        const hungerPortion = item.hunger / 100; // How much of the hunger bar this food fills
        const newDecayMod = item.decayMod || 1.0;
        // Blend the decay modifier based on how much food was given
        buddy.foodDecayMod = currentDecayMod * (1 - hungerPortion) + newDecayMod * hungerPortion;

        // Feeding gives care minutes toward evolution
        if (item.careBonus) {
            buddy.careMinutes = (buddy.careMinutes || 0) + item.careBonus;
            // Check evolution
            for (let i = Gamification.BUDDY_STAGES.length - 1; i >= 0; i--) {
                const req = Gamification.BUDDY_STAGES[i];
                if (buddy.totalXpFed >= req.xpNeeded && (buddy.careMinutes || 0) >= req.careNeeded) {
                    if (buddy.stage < req.stage) {
                        buddy.stage = req.stage;
                        Gamification.showAchievementToast({
                            icon: Gamification.getSpeciesEmoji(buddy.species, req.stage),
                            name: buddy.name + ' evolved!',
                            desc: 'Now a ' + Gamification.getSpeciesStageName(buddy.species, req.stage),
                            xp: 0
                        });
                    }
                    break;
                }
            }
        }

        // Feeding can heal sickness
        if (buddy.sick && buddy.hunger > 30 && buddy.happiness > 30 && (buddy.hydration ?? 100) > 30) {
            buddy.sick = false;
        }

        Gamification.updateBuddyMood();
        Gamification.saveState(state);
        SoundFX.play('petFeed');
        Gamification.updateBuddyWidget();
        DailyChallenges.trackFeed();

        // Check achievements
        if (state.studyBuddy.totalMealsEaten >= 50) Gamification.unlockAchievement('happy_tummy');
        if (state.studyBuddy.stage >= 5) Gamification.unlockAchievement('best_friends');

        this.show(); // Re-render
    },

    giveWater() {
        const state = Gamification.getState();
        const buddy = state.studyBuddy;
        if (!buddy || buddy.dead) return;
        
        // Water requires water bowl with water in it
        const petCare = state.petCare || {};
        if (!petCare.waterBowl || petCare.waterBowl.level <= 0) {
            Gamification.showAchievementToast({ icon: '', name: 'No Water!', desc: 'Fill your water bowl first', xp: 0 });
            return;
        }
        
        // Use 1 drink from water bowl
        petCare.waterBowl.level = Math.max(0, (petCare.waterBowl.level || 0) - 1);
        
        const oldHydration = buddy.hydration ?? 100;
        buddy.hydration = Math.min(100, oldHydration + 15);
        buddy.lastInteraction = Date.now();
        
        // Hydrating can heal sickness
        if (buddy.sick && buddy.hunger > 30 && buddy.happiness > 30 && buddy.hydration > 30) {
            buddy.sick = false;
        }
        
        Gamification.updateBuddyMood();
        Gamification.saveState(state);
        SoundFX.play('petFeed');
        Gamification.updateBuddyWidget();
        
        this.show(); // Re-render
    },

    toggleAccessory(id) {
        const state = Gamification.getState();
        const acc = state.studyBuddy.accessories || [];
        const idx = acc.indexOf(id);
        if (idx >= 0) {
            acc.splice(idx, 1);
        } else {
            acc.push(id);
        }
        state.studyBuddy.accessories = acc;
        
        // Also update in pets array if using multi-pet system
        if (state.pets && state.activePetIdx !== undefined && state.pets[state.activePetIdx]) {
            state.pets[state.activePetIdx].accessories = acc;
        }
        
        Gamification.saveState(state);
        Gamification.updateBuddyWidget();
        
        // Re-render Garden if it's visible to show accessory on pet
        if (typeof Garden !== 'undefined' && Garden && document.getElementById('gardenPet')) {
            Garden.renderPet(state);
        }
        
        this.show();
    }
};

// =====================================================================
// SESSION STATE PERSISTENCE (survives page refresh)
// =====================================================================
const SessionState = {
    STORAGE_KEY: 'wgu_session_state',

    // Save current session state to sessionStorage
    save() {
        try {
            const state = {
                timestamp: Date.now(),
                // App state (test/practice mode)
                app: {
                    screen: this._getCurrentScreen(),
                    mode: App.mode,
                    bankId: App.bank ? App.bank.bankId : null,
                    questionIndices: App._questionIndices || null,
                    optionMaps: App._optionMaps || null,
                    currentQ: App.currentQ,
                    answers: App.answers,
                    bookmarked: App.bookmarked,
                    visited: App.visited,
                    skipped: App.skipped,
                    practiceChecked: App.practiceChecked,
                    practiceResults: App.practiceResults,
                    timerSeconds: App.timerSeconds,
                    initialTimerSeconds: App.initialTimerSeconds,
                    countdown: App.countdown,
                    timerPaused: App.timerPaused || false,
                    submitted: App.submitted,
                    startTime: App.startTime,
                    answerHistory: App.answerHistory,
                    confidence: App.confidence,
                    eliminatedOptions: App._eliminatedOptions || {},
                    sessionMeta: App.sessionMeta
                },
                // Drill state
                drill: {
                    bankId: Drill.bank ? Drill.bank.bankId : null,
                    sessionCount: Drill.sessionCount,
                    sessionCorrect: Drill.sessionCorrect,
                    showingAnswer: Drill.showingAnswer,
                    selectedOption: Drill.selectedOption,
                    currentQuestionId: Drill.current ? Drill.current.question.id : null,
                    queueIds: (Drill.queue || []).map(item => item.question.id),
                    currentShuffleMap: Drill.currentShuffleMap,
                    currentShuffledCorrect: Drill.currentShuffledCorrect
                },
                // AI Practice state
                aiPractice: {
                    bankId: AIPractice.bank ? AIPractice.bank.bankId : null,
                    currentQuestion: AIPractice.currentQuestion,
                    selectedOption: AIPractice.selectedOption,
                    isChecked: AIPractice.isChecked,
                    sessionStats: AIPractice.sessionStats,
                    weakCategories: AIPractice.weakCategories,
                    currentCategory: AIPractice.currentCategory,
                    currentDifficulty: AIPractice.currentDifficulty,
                    startingWeakness: AIPractice.startingWeakness,
                    currentShuffleMap: AIPractice.currentShuffleMap,
                    currentShuffledCorrect: AIPractice.currentShuffledCorrect
                },
                // Metrics state
                metrics: {
                    questionTimes: Metrics.questionTimes,
                    currentStart: Metrics.currentStart
                }
            };
            localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state));
        } catch (e) {
            console.error('SessionState.save failed:', e.name, e.message);
        }
    },

    // Get saved session state
    get() {
        try {
            const data = localStorage.getItem(this.STORAGE_KEY);
            if (!data) return null;
            const state = JSON.parse(data);
            // Check if state is too old (e.g., > 4 hours)
            if (Date.now() - state.timestamp > 4 * 60 * 60 * 1000) {
                this.clear();
                return null;
            }
            return state;
        } catch (e) {
            // SessionState.get failed silently
            return null;
        }
    },

    // Check if there's a saved session
    hasSavedSession() {
        const state = this.get();
        if (!state) return false;
        // Must have either app, drill, or ai-practice state with a valid bank
        return (state.app && state.app.bankId && state.app.screen !== 'home') ||
               (state.drill && state.drill.bankId && state.app && state.app.screen === 'drill') ||
               (state.aiPractice && state.aiPractice.bankId && state.app && state.app.screen === 'ai-practice');
    },

    // Clear saved session state
    clear() {
        try {
            localStorage.removeItem(this.STORAGE_KEY);
        } catch (e) {
            // SessionState.clear failed silently
        }
    },

    // Restore App state from saved session
    restoreApp(state) {
        if (!state || !state.app || !state.app.bankId) return false;

        const bank = BankManager.getBank(state.app.bankId);
        if (!bank) return false;

        try {
            Session.start();
            App.bank = bank;
            // Restore shuffled subset if indices were saved
            if (state.app.questionIndices && Array.isArray(state.app.questionIndices)) {
                App.questions = state.app.questionIndices.map(i => bank.questions[i]).filter(Boolean);
                App._questionIndices = state.app.questionIndices;
            } else {
                App.questions = [...bank.questions];
                App._questionIndices = null;
            }
            
            // Restore option shuffle maps
            App._optionMaps = state.app.optionMaps || {};
            if (state.app.optionMaps) {
                // Rebuild _shuffledOptions and _shuffledCorrect for each question
                App.questions.forEach((q, qi) => {
                    const optIndices = state.app.optionMaps[qi];
                    if (optIndices && Array.isArray(optIndices)) {
                        q._shuffledOptions = optIndices.map(i => q.options[i]);
                        q._shuffledCorrect = optIndices.indexOf(q.correctAnswer);
                    }
                });
            }
            App.mode = state.app.mode || 'test';
            App.currentQ = state.app.currentQ || 0;
            App.answers = state.app.answers || {};
            App.bookmarked = state.app.bookmarked || {};
            App.visited = state.app.visited || { 0: true };
            App.skipped = state.app.skipped || {};
            App.practiceChecked = state.app.practiceChecked || {};
            App.practiceResults = state.app.practiceResults || {};
            App.timerSeconds = state.app.timerSeconds || 0;
            App.initialTimerSeconds = state.app.initialTimerSeconds || null;
            App.countdown = state.app.countdown !== undefined ? state.app.countdown : true;
            App.submitted = state.app.submitted || false;
            App.startTime = state.app.startTime || Date.now();
            App.answerHistory = state.app.answerHistory || {};
            App.confidence = state.app.confidence || {};
            App._eliminatedOptions = state.app.eliminatedOptions || {};
            App.sessionMeta = state.app.sessionMeta || App._getDefaultSessionMeta();
            Gamification.syncMomentum(App.sessionMeta?.momentum || null);

            // Restore Metrics
            if (state.metrics) {
                Metrics.questionTimes = state.metrics.questionTimes || {};
                Metrics.currentStart = state.metrics.currentStart || 0;
            }

            // Restore UI
            document.getElementById('testNameBar').textContent = bank.title;
            document.getElementById('modeTab').textContent =
                App.mode === 'test' ? 'Test Mode' :
                App.mode === 'practice' ? 'Practice Mode' : 'Review';
            document.getElementById('btnSubmit').style.display = (App.mode === 'test' || App.mode === 'practice') && !App.submitted ? '' : 'none';
            document.getElementById('btnCheck').style.display = App.mode === 'practice' ? '' : 'none';
            document.getElementById('btnTimerAdj').style.display = App.mode === 'test' ? '' : 'none';

            App.buildPalette();
            showScreen('exam', true, true);
            App.renderQuestion();

            // Only restart timer if not submitted
            if (!App.submitted) {
                App.timerPaused = state.app.timerPaused || false;
                App.startTimer();
                // If timer was paused when saved, re-pause it
                if (App.timerPaused) {
                    App.timerPaused = false; // startTimer resets this; toggle will set it
                    App.toggleTimer();
                }
            }

            // Chat context
            Chat.clearHistory();
            document.getElementById('chatFab').classList.add('has-context');

            return true;
        } catch (e) {
            console.error('Session restore failed:', e);
            return false;
        }
    },

    // Restore Drill state from saved session
    restoreDrill(state) {
        if (!state || !state.drill || !state.drill.bankId) return false;

        const bank = BankManager.getBank(state.drill.bankId);
        if (!bank) return false;

        try {
            Session.start();
            Drill.bank = bank;
            Drill.sessionCount = state.drill.sessionCount || 0;
            Drill.sessionCorrect = state.drill.sessionCorrect || 0;
            Drill.showingAnswer = state.drill.showingAnswer || false;
            Drill.selectedOption = state.drill.selectedOption;

            // Rebuild queue from saved question IDs
            const queueIds = state.drill.queueIds || [];
            Drill.queue = queueIds.map(id => {
                const question = bank.questions.find(q => q.id === id);
                if (!question) return null;
                const progress = Drill.getProgress(id);
                return { question, progress, priority: 1 };
            }).filter(item => item !== null);

            // Restore current question if it exists
            if (state.drill.currentQuestionId) {
                const currentQ = bank.questions.find(q => q.id === state.drill.currentQuestionId);
                if (currentQ) {
                    Drill.current = {
                        question: currentQ,
                        progress: Drill.getProgress(state.drill.currentQuestionId),
                        priority: 1
                    };
                }
            }

            showScreen('drill', false, false);
            document.getElementById('chatFab').style.display = '';
            Chat.clearHistory();

            // Restore shuffle state
            Drill.currentShuffleMap = state.drill.currentShuffleMap || null;
            Drill.currentShuffledCorrect = state.drill.currentShuffledCorrect !== undefined ? state.drill.currentShuffledCorrect : null;

            // Re-render current card or show session done
            if (Drill.current) {
                Gamification.startQuestionTimer();
                const dueCount = Drill.queue.length + 1;
                document.getElementById('drillProgress').innerHTML =
                    `<span class="due-count">${dueCount}</span> questions remaining | ${Drill.sessionCount} completed (${Drill.sessionCorrect} correct)`;

                const q = Drill.current.question;
                
                // Use saved shuffle map or create new one if not available
                if (!Drill.currentShuffleMap) {
                    const optIndices = q.options.map((_, i) => i);
                    for (let i = optIndices.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [optIndices[i], optIndices[j]] = [optIndices[j], optIndices[i]];
                    }
                    Drill.currentShuffleMap = optIndices;
                    Drill.currentShuffledCorrect = optIndices.indexOf(q.correctAnswer);
                }
                
                const shuffleMap = Drill.currentShuffleMap;
                const shuffledCorrect = Drill.currentShuffledCorrect;
                
                document.getElementById('drillCard').innerHTML = `
                    <div class="question-text">${formatQuestionText(q.text)}</div>
                    <ul class="options-list" id="drillOptions">
                        ${shuffleMap.map((origIdx, displayIdx) => `
                            <li class="option-item${Drill.selectedOption === displayIdx ? ' selected' : ''}${Drill.showingAnswer && displayIdx === shuffledCorrect ? ' correct-answer' : ''}${Drill.showingAnswer && Drill.selectedOption === displayIdx && displayIdx !== shuffledCorrect ? ' wrong-answer' : ''}" onclick="Drill.selectOption(${displayIdx})" id="dropt-${displayIdx}">
                                <input type="radio" name="drill" value="${displayIdx}"${Drill.selectedOption === displayIdx ? ' checked' : ''}>
                                <span class="option-label">${escapeHtml(q.options[origIdx])}</span>
                            </li>
                        `).join('')}
                    </ul>
                    <div class="drill-answer${Drill.showingAnswer ? ' show' : ''}" id="drillAnswer">
                        <div class="correct-label" id="drillResultLabel"${Drill.showingAnswer ? ` style="color:${Drill.selectedOption === shuffledCorrect ? 'var(--green)' : 'var(--red)'}">` + (Drill.selectedOption === shuffledCorrect ? 'Correct!' : (Drill.selectedOption !== null ? 'Incorrect' : 'Not answered')) + '</div>' : '>'}
                        <div class="explanation">${escapeHtml(q.explanation || '')}</div>
                        <div class="drill-buttons">
                            <button class="drill-btn btn-got-it" onclick="Drill.nextAfterCheck()">Next Question </button>
                        </div>
                    </div>
                    <div style="text-align:center;margin-top:16px">
                        <button class="drill-btn btn-show" id="drillShowBtn" onclick="Drill.checkAnswer()"${Drill.showingAnswer ? ' style="display:none"' : ''}>Check Answer</button>
                    </div>
                `;

                if (Drill.showingAnswer) {
                    document.getElementById('drillAnswer').classList.add('show');
                }

                // Render inline chart if question has graphData or [Graph:...] placeholder
                if (q.graphData || q.text.includes('[Graph:')) {
                    const qtEl = document.querySelector('#drillCard .question-text');
                    const graphData = q.graphData || InlineChart.generatePlaceholderGraph(q.text);
                    if (qtEl && graphData) InlineChart.renderInElement(qtEl, graphData);
                }

                document.getElementById('chatFab').classList.add('has-context');
                Drill.renderMath();
            } else if (Drill.queue.length > 0) {
                Drill.nextCard();
            } else {
                Drill.showSessionDone();
            }

            return true;
        } catch (e) {
            console.error('Drill restore failed:', e);
            return false;
        }
    },

    // Restore AI Practice state from saved session
    restoreAIPractice(state) {
        if (!state || !state.aiPractice || !state.aiPractice.bankId) return false;

        const bank = BankManager.getBank(state.aiPractice.bankId);
        if (!bank) return false;

        try {
            Session.start();
            AIPractice.bank = bank;
            AIPractice.currentQuestion = state.aiPractice.currentQuestion || null;
            AIPractice.selectedOption = state.aiPractice.selectedOption;
            AIPractice.isChecked = state.aiPractice.isChecked || false;
            AIPractice.isGenerating = false;
            AIPractice.sessionStats = state.aiPractice.sessionStats || { total: 0, correct: 0, byCategory: {} };
            AIPractice.weakCategories = state.aiPractice.weakCategories || [];
            AIPractice.currentCategory = state.aiPractice.currentCategory || null;
            AIPractice.currentDifficulty = state.aiPractice.currentDifficulty || 2;
            AIPractice.startingWeakness = state.aiPractice.startingWeakness || {};
            AIPractice.currentShuffleMap = state.aiPractice.currentShuffleMap || null;
            AIPractice.currentShuffledCorrect = state.aiPractice.currentShuffledCorrect !== undefined ? state.aiPractice.currentShuffledCorrect : null;

            showScreen('ai-practice', false, false);
            document.getElementById('chatFab').style.display = '';
            Chat.clearHistory();
            document.getElementById('chatFab').classList.add('has-context');

            AIPractice.renderProgress();
            if (AIPractice.currentQuestion) {
                AIPractice.renderQuestion();
            } else {
                AIPractice.generateNext();
            }

            return true;
        } catch (e) {
            console.error('AI Practice restore failed:', e);
            return false;
        }
    },

    // Get the current active screen name
    _getCurrentScreen() {
        const activeScreen = document.querySelector('.screen.active');
        if (!activeScreen) return 'home';
        const id = activeScreen.id;
        return id.replace('screen-', '');
    },

    // Auto-resume saved session (no prompt)
    showResumePrompt() {
        return new Promise((resolve) => {
            const state = this.get();
            if (!state) {
                resolve(false);
                return;
            }
            const screen = state.app ? state.app.screen : 'unknown';
            const mode = state.app ? state.app.mode : '';
            resolve(confirm(`Resume your previous ${mode || screen} session?`));
        });
    }
};

// =====================================================================
// SESSION TIMER (with activity detection)
// =====================================================================
const Session = {
    startTime: 0,
    lastActivity: 0,
    activeSeconds: 0,
    activityInterval: null,
    IDLE_TIMEOUT: 60000, // 1 minute of no activity = pause tracking

    start() {
        this.startTime = Date.now();
        this.lastActivity = Date.now();
        this.activeSeconds = 0;
        this._bindActivityListeners();
        this._startActivityCheck();
    },

    _bindActivityListeners() {
        const updateActivity = () => { this.lastActivity = Date.now(); };
        ['mousemove', 'mousedown', 'keydown', 'touchstart', 'scroll', 'click'].forEach(evt => {
            document.addEventListener(evt, updateActivity, { passive: true });
        });
    },

    _startActivityCheck() {
        if (this.activityInterval) clearInterval(this.activityInterval);
        this.activityInterval = setInterval(() => {
            if (!this.startTime) return;
            const now = Date.now();
            const idleTime = now - this.lastActivity;
            // Only count time if user was active in the last IDLE_TIMEOUT
            if (idleTime < this.IDLE_TIMEOUT) {
                this.activeSeconds += 1;
            }
        }, 1000);
    },

    end() {
        if (this.activityInterval) {
            clearInterval(this.activityInterval);
            this.activityInterval = null;
        }
        if (!this.startTime) return;
        
        const mins = Math.round(this.activeSeconds / 60);
        if (mins > 0) {
            // Update globalStats.totalStudyMins
            const stats = Store.get('globalStats', { totalStudyMins: 0 });
            stats.totalStudyMins = (stats.totalStudyMins || 0) + mins;
            Store.set('globalStats', stats);

            // Update studyByDay for today
            const d = new Date();
            const today = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
            const studyByDay = Store.get('studyByDay', {});
            studyByDay[today] = (studyByDay[today] || 0) + mins;
            Store.set('studyByDay', studyByDay);
        }
        this.startTime = 0;
        this.activeSeconds = 0;
    },

    getTodayMins() {
        const d = new Date();
        const today = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
        const studyByDay = Store.get('studyByDay', {});
        return studyByDay[today] || 0;
    },

    formatTime(mins) {
        if (mins >= 60) {
            const hrs = Math.floor(mins / 60);
            const remainMins = mins % 60;
            return remainMins > 0 ? `${hrs}h ${remainMins}m` : `${hrs}h`;
        }
        return `${mins}m`;
    },

    clearAllTimeData() {
        Store.set('studyByDay', {});
        const stats = Store.get('globalStats', {});
        stats.totalStudyMins = 0;
        Store.set('globalStats', stats);
    },

    // Reset all time stats including question tracker time data
    resetAllTimeStats() {
        // Clear study time
        Store.set('studyByDay', {});
        const stats = Store.get('globalStats', {});
        stats.totalStudyMins = 0;
        Store.set('globalStats', stats);

        // Clear session history time data
        Store.set('sessionHistory', []);

        // Clean up question tracker - reset time data but keep correct/incorrect counts
        const tracker = Store.get('questionTracker', {});
        Object.keys(tracker).forEach(qKey => {
            const q = tracker[qKey];
            q.totalTime = 0;
            if (q.history) {
                q.history.forEach(h => {
                    h.timeMs = 0;
                });
            }
        });
        Store.set('questionTracker', tracker);

        // Clear category mastery time data
        const state = Store.get('state', {});
        if (state.categoryMastery) {
            Object.keys(state.categoryMastery).forEach(cat => {
                state.categoryMastery[cat].totalTimeMs = 0;
            });
            Store.set('state', state);
        }
    }
};

// =====================================================================
// STUDY ANALYTICS SYSTEM
// =====================================================================
const StudyAnalytics = {
    getSessionHistory() {
        return Store.get('sessionHistory', []);
    },
    
    saveSession(session) {
        const history = this.getSessionHistory();
        history.push({
            ...session,
            timestamp: Date.now(),
            date: new Date().toISOString().split('T')[0]
        });
        // Keep last 100 sessions
        if (history.length > 100) history.shift();
        Store.set('sessionHistory', history);
    },
    
    recordTestCompletion(mode, bankId, score, totalQuestions, timeSpent) {
        this.saveSession({
            type: 'test',
            mode,
            bankId,
            score,
            totalQuestions,
            timeSpent,
            accuracy: Math.round((score / totalQuestions) * 100)
        });
    },
    
    recordDrillSession(cardsReviewed, avgRating) {
        this.saveSession({
            type: 'drill',
            cardsReviewed,
            avgRating
        });
    },
    
    getWeeklyStats() {
        const history = this.getSessionHistory();
        const now = Date.now();
        const weekAgo = now - (7 * 24 * 60 * 60 * 1000);
        const weekSessions = history.filter(s => s.timestamp >= weekAgo);
        
        const stats = {
            totalSessions: weekSessions.length,
            totalQuestions: 0,
            totalCorrect: 0,
            totalTimeSpent: 0,
            testSessions: 0,
            drillSessions: 0,
            avgAccuracy: 0,
            bestAccuracy: 0,
            studyDays: new Set(),
            byDay: {}
        };
        
        weekSessions.forEach(s => {
            stats.studyDays.add(s.date);
            if (!stats.byDay[s.date]) {
                stats.byDay[s.date] = { questions: 0, correct: 0, time: 0 };
            }
            
            if (s.type === 'test') {
                stats.testSessions++;
                stats.totalQuestions += s.totalQuestions || 0;
                stats.totalCorrect += s.score || 0;
                stats.totalTimeSpent += s.timeSpent || 0;
                stats.byDay[s.date].questions += s.totalQuestions || 0;
                stats.byDay[s.date].correct += s.score || 0;
                stats.byDay[s.date].time += s.timeSpent || 0;
                if (s.accuracy > stats.bestAccuracy) stats.bestAccuracy = s.accuracy;
            } else if (s.type === 'drill') {
                stats.drillSessions++;
                stats.totalQuestions += s.cardsReviewed || 0;
            }
        });
        
        stats.studyDays = stats.studyDays.size;
        stats.avgAccuracy = stats.totalQuestions > 0 ? Math.round((stats.totalCorrect / stats.totalQuestions) * 100) : 0;
        
        return stats;
    },
    
    getPerformanceTrend() {
        const history = this.getSessionHistory();
        const testSessions = history.filter(s => s.type === 'test' && s.accuracy !== undefined);
        if (testSessions.length < 2) return { trend: 'neutral', change: 0 };
        
        const recent = testSessions.slice(-5);
        const older = testSessions.slice(-10, -5);
        
        if (older.length === 0) return { trend: 'neutral', change: 0 };
        
        const recentAvg = recent.reduce((sum, s) => sum + s.accuracy, 0) / recent.length;
        const olderAvg = older.reduce((sum, s) => sum + s.accuracy, 0) / older.length;
        const change = Math.round(recentAvg - olderAvg);
        
        return {
            trend: change > 2 ? 'up' : change < -2 ? 'down' : 'neutral',
            change: Math.abs(change),
            recentAvg: Math.round(recentAvg),
            olderAvg: Math.round(olderAvg)
        };
    },
    
    getStudyStreak() {
        const stats = DailyGoal.getStats();
        return {
            current: stats.streak || 0,
            questionsToday: stats.questionsToday || 0,
            dailyGoal: stats.dailyGoal || 10,
            goalProgress: Math.min(100, Math.round(((stats.questionsToday || 0) / (stats.dailyGoal || 10)) * 100))
        };
    },
    
    getBankPerformance() {
        const history = this.getSessionHistory();
        const byBank = {};
        
        history.filter(s => s.type === 'test' && s.bankId).forEach(s => {
            if (!byBank[s.bankId]) {
                byBank[s.bankId] = { attempts: 0, totalScore: 0, totalQuestions: 0, bestScore: 0 };
            }
            byBank[s.bankId].attempts++;
            byBank[s.bankId].totalScore += s.score || 0;
            byBank[s.bankId].totalQuestions += s.totalQuestions || 0;
            const pct = s.totalQuestions > 0 ? Math.round((s.score / s.totalQuestions) * 100) : 0;
            if (pct > byBank[s.bankId].bestScore) byBank[s.bankId].bestScore = pct;
        });
        
        return byBank;
    },
    
    getTimeDistribution() {
        const studyByDay = Store.get('studyByDay', {});
        const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const byDayOfWeek = [0, 0, 0, 0, 0, 0, 0];
        
        Object.entries(studyByDay).forEach(([dateStr, mins]) => {
            const date = new Date(dateStr);
            byDayOfWeek[date.getDay()] += mins;
        });
        
        // Add current session time to today
        if (Session.startTime && Session.activeSeconds > 0) {
            const today = new Date();
            byDayOfWeek[today.getDay()] += Math.round(Session.activeSeconds / 60);
        }
        
        const maxMins = Math.max(...byDayOfWeek, 1);
        return days.map((day, i) => ({
            day,
            mins: byDayOfWeek[i],
            pct: Math.round((byDayOfWeek[i] / maxMins) * 100)
        }));
    },
    
    render() {
        const el = document.getElementById('analyticsCard');
        if (!el) return;
        
        const weekly = this.getWeeklyStats();
        const trend = this.getPerformanceTrend();
        const streak = this.getStudyStreak();
        const timeDist = this.getTimeDistribution();
        
        const trendIcon = trend.trend === 'up' ? '' : trend.trend === 'down' ? '' : '';
        const trendColor = trend.trend === 'up' ? 'var(--green)' : trend.trend === 'down' ? 'var(--red)' : 'var(--gray-600)';
        const trendText = trend.trend === 'up' ? `+${trend.change}%` : trend.trend === 'down' ? `-${trend.change}%` : 'Stable';
        
        el.innerHTML = `
            <div class="analytics-card">
                <h3> Weekly Analytics</h3>
                <div class="analytics-grid">
                    <div class="analytics-stat">
                        <div class="analytics-val">${weekly.totalSessions}</div>
                        <div class="analytics-lbl">Sessions</div>
                    </div>
                    <div class="analytics-stat">
                        <div class="analytics-val">${weekly.totalQuestions}</div>
                        <div class="analytics-lbl">Questions</div>
                    </div>
                    <div class="analytics-stat">
                        <div class="analytics-val">${weekly.avgAccuracy}%</div>
                        <div class="analytics-lbl">Avg Accuracy</div>
                    </div>
                    <div class="analytics-stat">
                        <div class="analytics-val">${weekly.studyDays}/7</div>
                        <div class="analytics-lbl">Study Days</div>
                    </div>
                </div>
                
                <div class="analytics-trend">
                    <span class="trend-icon">${trendIcon}</span>
                    <span class="trend-text" style="color:${trendColor}">Performance: ${trendText}</span>
                </div>
                
                <div class="analytics-time-dist">
                    <div class="time-dist-label">Study Time by Day</div>
                    <div class="time-dist-bars">
                        ${timeDist.map(d => `
                            <div class="time-dist-bar">
                                <div class="time-bar-fill" style="height:${Math.max(d.pct, 5)}%"></div>
                                <span class="time-bar-day">${d.day}</span>
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div class="analytics-goal">
                    <div class="goal-label">Daily Progress: ${streak.questionsToday}/${streak.dailyGoal}</div>
                    <div class="goal-bar-mini">
                        <div class="goal-bar-fill-mini" style="width:${streak.goalProgress}%"></div>
                    </div>
                </div>
            </div>
        `;
    }
};

// =====================================================================
// DAILY CHALLENGES SYSTEM
// =====================================================================
const DailyChallenges = {
    CHALLENGE_TYPES: [
        { id: 'speed_demon', name: 'Speed Demon', desc: 'Answer 5 questions in under 30 seconds each', icon: '', target: 5, reward: { coins: 50, xp: 100 } },
        { id: 'perfect_run', name: 'Perfect Run', desc: 'Get 10 questions correct in a row', icon: '', target: 10, reward: { coins: 75, xp: 150 } },
        { id: 'marathon', name: 'Marathon', desc: 'Complete 25 questions today', icon: '', target: 25, reward: { coins: 100, xp: 200 } },
        { id: 'drill_master', name: 'Drill Master', desc: 'Complete 15 drill questions', icon: '', target: 15, reward: { coins: 60, xp: 120 } },
        { id: 'garden_tender', name: 'Garden Tender', desc: 'Water plants 5 times', icon: '', target: 5, reward: { coins: 40, xp: 80 } },
        { id: 'harvest_fest', name: 'Harvest Festival', desc: 'Harvest 3 crops', icon: '', target: 3, reward: { coins: 80, xp: 160 } },
        { id: 'pet_lover', name: 'Pet Lover', desc: 'Feed your pet 3 times', icon: '', target: 3, reward: { coins: 30, xp: 60 } },
        { id: 'combo_king', name: 'Combo King', desc: 'Reach a 5x combo', icon: '', target: 5, reward: { coins: 60, xp: 120 } },
        { id: 'night_owl', name: 'Night Owl', desc: 'Study after 9 PM', icon: '', target: 1, reward: { coins: 40, xp: 80 } },
        { id: 'early_bird', name: 'Early Bird', desc: 'Study before 8 AM', icon: '', target: 1, reward: { coins: 40, xp: 80 } },
        { id: 'explorer', name: 'Explorer', desc: 'Try 3 different question banks', icon: '', target: 3, reward: { coins: 50, xp: 100 } },
        { id: 'ai_chat', name: 'AI Scholar', desc: 'Ask the AI tutor 3 questions', icon: '', target: 3, reward: { coins: 45, xp: 90 } }
    ],
    
    getTodayStr() { 
        const d = new Date(); 
        return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0'); 
    },
    
    getState() {
        return Store.get('dailyChallenges', { 
            date: null, 
            challenges: [], 
            completed: [] 
        });
    },
    
    saveState(state) {
        Store.set('dailyChallenges', state);
    },
    
    generateDailyChallenges() {
        const today = this.getTodayStr();
        let state = this.getState();
        
        if (state.date === today && state.challenges.length > 0) {
            return state.challenges;
        }
        
        // Generate 3 random challenges for today using date as seed
        const seed = parseInt(today.replace(/-/g, ''));
        const shuffled = [...this.CHALLENGE_TYPES].sort((a, b) => {
            const hashA = (seed * 31 + a.id.charCodeAt(0)) % 1000;
            const hashB = (seed * 31 + b.id.charCodeAt(0)) % 1000;
            return hashA - hashB;
        });
        
        const selected = shuffled.slice(0, 3).map(c => ({
            ...c,
            progress: 0,
            completed: false
        }));
        
        state = { date: today, challenges: selected, completed: [] };
        this.saveState(state);
        return selected;
    },
    
    updateProgress(challengeId, amount = 1) {
        let state = this.getState();
        const today = this.getTodayStr();
        
        if (state.date !== today) {
            this.generateDailyChallenges();
            state = this.getState();
        }
        
        const challenge = state.challenges.find(c => c.id === challengeId);
        if (!challenge || challenge.completed) return false;
        
        challenge.progress = Math.min(challenge.progress + amount, challenge.target);
        
        if (challenge.progress >= challenge.target && !challenge.completed) {
            challenge.completed = true;
            state.completed.push(challengeId);
            
            // Award rewards
            const template = this.CHALLENGE_TYPES.find(t => t.id === challengeId);
            if (template) {
                Gamification.awardCoins(template.reward.coins, 'challenge');
                Gamification.awardXp('challenge', { multiplier: template.reward.xp / 25 });
                Gamification.triggerConfetti();
                
                // Show toast
                const toast = document.createElement('div');
                toast.className = 'achievement-toast';
                toast.innerHTML = `<span style="font-size:28px">${template.icon}</span><div><strong>Challenge Complete!</strong><br><small>${template.name} - +${template.reward.coins} coins</small></div>`;
                document.body.appendChild(toast);
                setTimeout(() => toast.remove(), 4000);
            }
            
            this.saveState(state);
            this.render();
            return true;
        }
        
        this.saveState(state);
        return false;
    },
    
    // Track various actions
    trackQuestion(isCorrect, timeMs) {
        if (isCorrect && timeMs < 30000) {
            this.updateProgress('speed_demon');
        }
        this.updateProgress('marathon');
        
        const hour = new Date().getHours();
        if (hour >= 21) this.updateProgress('night_owl');
        if (hour < 8) this.updateProgress('early_bird');
    },
    
    trackDrill() {
        this.updateProgress('drill_master');
    },
    
    trackCombo(combo) {
        let state = this.getState();
        const challenge = state.challenges.find(c => c.id === 'combo_king');
        if (challenge && !challenge.completed && combo >= challenge.target) {
            challenge.progress = challenge.target;
            this.updateProgress('combo_king', 0);
        }
    },
    
    trackStreak(streak) {
        let state = this.getState();
        const challenge = state.challenges.find(c => c.id === 'perfect_run');
        if (challenge && !challenge.completed) {
            challenge.progress = Math.max(challenge.progress, streak);
            if (streak >= challenge.target) {
                this.updateProgress('perfect_run', 0);
            } else {
                this.saveState(state);
            }
        }
    },
    
    trackWater() { this.updateProgress('garden_tender'); },
    trackHarvest() { this.updateProgress('harvest_fest'); },
    trackFeed() { this.updateProgress('pet_lover'); },
    trackBank(bankId) {
        let state = this.getState();
        if (!state.banksUsed) state.banksUsed = [];
        if (!state.banksUsed.includes(bankId)) {
            state.banksUsed.push(bankId);
            this.saveState(state);
            this.updateProgress('explorer');
        }
    },
    trackAIChat() { this.updateProgress('ai_chat'); },
    
    render() {
        const container = document.getElementById('dailyChallengesCard');
        if (!container) return;
        
        const challenges = this.generateDailyChallenges();
        const allComplete = challenges.every(c => c.completed);
        
        let html = `
            <div class="daily-challenges-card">
                <h3> Daily Challenges <span class="challenges-reset">Resets at midnight</span></h3>
                <div class="challenges-list">
        `;
        
        challenges.forEach(c => {
            const pct = Math.round((c.progress / c.target) * 100);
            html += `
                <div class="challenge-item ${c.completed ? 'completed' : ''}">
                    <span class="challenge-icon">${c.icon}</span>
                    <div class="challenge-info">
                        <div class="challenge-name">${c.name}</div>
                        <div class="challenge-desc">${c.desc}</div>
                        <div class="challenge-progress-bar">
                            <div class="challenge-progress-fill" style="width:${pct}%"></div>
                        </div>
                    </div>
                    <div class="challenge-status">
                        ${c.completed ? '' : `<span class="challenge-count">${c.progress}/${c.target}</span>`}
                    </div>
                </div>
            `;
        });
        
        if (allComplete) {
            html += `<div class="challenges-complete-bonus"> All challenges complete! +50 bonus coins</div>`;
        }
        
        html += `</div></div>`;
        container.innerHTML = html;
        
        // Award bonus for completing all
        if (allComplete) {
            let state = this.getState();
            if (!state.bonusAwarded) {
                state.bonusAwarded = true;
                this.saveState(state);
                Gamification.awardCoins(50, 'allChallenges');
            }
        }
    }
};

// =====================================================================
// STREAK & DAILY GOAL SYSTEM
// =====================================================================
const DailyGoal = {
    getTodayStr() { const d = new Date(); return d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0'); },
    getDefaultStats() { return { testsCompleted: 0, avgScore: 0, drillStreak: 0, totalStudyMins: 0, streak: 0, lastStudyDate: null, dailyGoal: 10, questionsToday: 0, todayDate: null, correctToday: 0, streakToday: 0, bestStreakToday: 0, fastAnswersToday: 0, modesUsedToday: [], banksUsedToday: [] }; },
    getStats() { const defaults = this.getDefaultStats(); const stats = Store.get('globalStats', defaults); return { ...defaults, ...stats }; },
    saveStats(stats) { Store.set('globalStats', stats); },
    checkDateReset(stats) { const today = this.getTodayStr(); if (stats.todayDate !== today) { stats.questionsToday = 0; stats.correctToday = 0; stats.streakToday = 0; stats.bestStreakToday = 0; stats.fastAnswersToday = 0; stats.modesUsedToday = []; stats.banksUsedToday = []; stats.todayDate = today; } return stats; },
    updateStreak(stats) { const today = this.getTodayStr(); const lastDate = stats.lastStudyDate; if (!lastDate) { stats.streak = 1; } else if (lastDate !== today) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.getFullYear() + '-' + String(yesterday.getMonth() + 1).padStart(2, '0') + '-' + String(yesterday.getDate()).padStart(2, '0'); stats.streak = (lastDate === yesterdayStr) ? stats.streak + 1 : 1; } stats.lastStudyDate = today; return stats; },
    recordQuestion() { return this.recordQuestions(1); },
    recordQuestions(count) { let stats = this.getStats(); stats = this.checkDateReset(stats); const wasGoalMet = stats.questionsToday >= stats.dailyGoal; stats.questionsToday += count; const isGoalMet = stats.questionsToday >= stats.dailyGoal; if (!wasGoalMet && isGoalMet) { stats = this.updateStreak(stats); Gamification.awardXp('dailyGoalReached'); Gamification.triggerConfetti(); Gamification.checkStreakAchievements(stats.streak); if (stats.streak > 0 && stats.streak % 7 === 0) { Gamification.awardXp('weeklyGoalReached'); } } this.saveStats(stats); return !wasGoalMet && isGoalMet; },
    setGoal(goal) { let stats = this.getStats(); stats.dailyGoal = goal; this.saveStats(stats); },
    checkStreakOnLoad() { let stats = this.getStats(); stats = this.checkDateReset(stats); const today = this.getTodayStr(); const lastDate = stats.lastStudyDate; if (lastDate && lastDate !== today) { const yesterday = new Date(); yesterday.setDate(yesterday.getDate() - 1); const yesterdayStr = yesterday.getFullYear() + '-' + String(yesterday.getMonth() + 1).padStart(2, '0') + '-' + String(yesterday.getDate()).padStart(2, '0'); if (lastDate !== yesterdayStr) { stats.streak = 0; this.saveStats(stats); } } return stats; },
    renderStreakBanner() { 
        const stats = this.checkStreakOnLoad(); 
        const el = document.getElementById('streakBanner'); 
        if (!el) return; 
        const streak = stats.streak || 0; 
        const hasStreak = streak > 0;
        const bonusInfo = Gamification.getStreakBonusInfo();
        const multText = bonusInfo.multiplier > 1 ? `<span class="streak-mult">${bonusInfo.multiplier}x XP</span>` : '';
        const nextText = bonusInfo.nextMilestone ? `<span class="streak-next">${bonusInfo.daysToNext} day${bonusInfo.daysToNext !== 1 ? 's' : ''} to ${bonusInfo.nextMilestone}-day bonus</span>` : '';
        el.innerHTML = '<div class="streak-banner ' + (hasStreak ? '' : 'no-streak') + '"><span class="streak-flame">\uD83D\uDD25</span><div class="streak-info"><div class="streak-count">' + streak + ' day' + (streak !== 1 ? 's' : '') + ' ' + multText + '</div><div class="streak-label">' + (hasStreak ? 'Study Streak' + (nextText ? '  ' + nextText : '') : 'Start your streak today!') + '</div></div></div>'; 
    },
    renderDailyGoalCard() { const stats = this.getStats(); const el = document.getElementById('dailyGoalCard'); if (!el) return; const today = this.getTodayStr(); let questionsToday = stats.questionsToday || 0; if (stats.todayDate !== today) { questionsToday = 0; } const goal = stats.dailyGoal || 10; const pct = Math.round((Math.min(questionsToday, goal) / goal) * 100); const isComplete = questionsToday >= goal; el.innerHTML = '<div class="daily-goal-card"><h3>\uD83C\uDFAF Daily Goal</h3><div class="goal-progress"><div class="goal-bar"><div class="goal-bar-fill ' + (isComplete ? 'complete' : '') + '" style="width:' + pct + '%"></div></div><div class="goal-text ' + (isComplete ? 'complete' : '') + '">' + questionsToday + '/' + goal + ' questions</div></div>' + (isComplete ? '<div class="goal-celebration">Goal reached! Great job today!</div>' : '') + '</div>'; },
    
    // Track correct answer for daily achievements
    recordCorrect(isCorrect, timeSpent) {
        let stats = this.getStats();
        stats = this.checkDateReset(stats);
        if (isCorrect) {
            stats.correctToday = (stats.correctToday || 0) + 1;
            stats.streakToday = (stats.streakToday || 0) + 1;
            if (stats.streakToday > (stats.bestStreakToday || 0)) {
                stats.bestStreakToday = stats.streakToday;
            }
            // Track fast answers (under 15 seconds)
            if (timeSpent && timeSpent < 15000) {
                stats.fastAnswersToday = (stats.fastAnswersToday || 0) + 1;
            }
        } else {
            stats.streakToday = 0;
        }
        this.saveStats(stats);
        this.checkDailyAchievements(stats);
    },
    
    // Track mode usage for daily achievements
    recordMode(mode) {
        let stats = this.getStats();
        stats = this.checkDateReset(stats);
        if (!stats.modesUsedToday) stats.modesUsedToday = [];
        if (!stats.modesUsedToday.includes(mode)) {
            stats.modesUsedToday.push(mode);
        }
        this.saveStats(stats);
        this.checkDailyAchievements(stats);
    },
    
    // Track bank usage for daily achievements
    recordBank(bankId) {
        let stats = this.getStats();
        stats = this.checkDateReset(stats);
        if (!stats.banksUsedToday) stats.banksUsedToday = [];
        if (!stats.banksUsedToday.includes(bankId)) {
            stats.banksUsedToday.push(bankId);
        }
        this.saveStats(stats);
        this.checkDailyAchievements(stats);
    },
    
    // Check and award daily achievements
    checkDailyAchievements(stats) {
        const today = this.getTodayStr();
        const dailyKey = 'dailyAchievements_' + today;
        const awarded = Store.get(dailyKey, []);
        
        // Daily correct answer milestones
        if (stats.correctToday >= 10 && !awarded.includes('daily_10')) {
            Gamification.unlockAchievement('daily_10');
            awarded.push('daily_10');
        }
        if (stats.correctToday >= 25 && !awarded.includes('daily_25')) {
            Gamification.unlockAchievement('daily_25');
            awarded.push('daily_25');
        }
        if (stats.correctToday >= 50 && !awarded.includes('daily_50')) {
            Gamification.unlockAchievement('daily_50');
            awarded.push('daily_50');
        }
        if (stats.correctToday >= 100 && !awarded.includes('daily_100')) {
            Gamification.unlockAchievement('daily_100');
            awarded.push('daily_100');
        }
        
        // Daily streak achievement
        if (stats.bestStreakToday >= 10 && !awarded.includes('daily_perfect_10')) {
            Gamification.unlockAchievement('daily_perfect_10');
            awarded.push('daily_perfect_10');
        }
        
        // Daily fast answers achievement
        if (stats.fastAnswersToday >= 5 && !awarded.includes('daily_speed_5')) {
            Gamification.unlockAchievement('daily_speed_5');
            awarded.push('daily_speed_5');
        }
        
        // Daily all modes achievement (test, practice, drill, speed)
        const requiredModes = ['test', 'practice', 'drill', 'speed'];
        const hasAllModes = requiredModes.every(m => (stats.modesUsedToday || []).includes(m));
        if (hasAllModes && !awarded.includes('daily_all_modes')) {
            Gamification.unlockAchievement('daily_all_modes');
            awarded.push('daily_all_modes');
        }
        
        // Daily 3 banks achievement
        if ((stats.banksUsedToday || []).length >= 3 && !awarded.includes('daily_3_banks')) {
            Gamification.unlockAchievement('daily_3_banks');
            awarded.push('daily_3_banks');
        }
        
        Store.set(dailyKey, awarded);
    }
};

// =====================================================================
// BANK MANAGER
// =====================================================================
/**
 * @namespace BankManager
 * @description Loads and manages question bank JSON files from /banks/.
 * Provides fallback embedded data for file:// protocol.
 * 
 * State:
 * - banks: Array of loaded bank objects
 * - manifest: List of available banks with metadata
 * 
 * Key methods:
 * - loadAll() - Fetch all banks from manifest
 * - getBank(bankId) - Retrieve a specific bank by ID
 */
const BankManager = {
    banks: [],
    manifest: [
        { id: 'algebra-fxo1', file: 'banks/algebra-fxo1.json', title: 'Applied Algebra - FXO1', fallback: true }
    ],

    async loadAll() {
        for (const entry of this.manifest) {
            let bank = null;
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 10000);
                const resp = await fetch(entry.file, { signal: controller.signal });
                clearTimeout(timeout);
                if (resp.ok) bank = await resp.json();
            } catch {}
            if (!bank && entry.fallback && BANK_DATA) {
                bank = BANK_DATA;
            }
            if (bank) {
                this.banks.push(bank);
            }
        }
        if (this.banks.length === 0 && BANK_DATA) {
            this.banks.push(BANK_DATA);
        }
    },

    getBank(id) {
        return this.banks.find(b => b.bankId === id);
    }
};

// =====================================================================
// SCREEN ROUTER
// =====================================================================
function showScreen(name, showSubheader, showFooter) {
    // Track Learn Mode time when leaving
    if (typeof LearnMode !== 'undefined' && LearnMode.sessionStart) {
        LearnMode.trackTimeSpent();
    }
    
    // Stop SpeedMode completely when leaving speed screen
    if (name !== 'speed' && typeof SpeedMode !== 'undefined' && SpeedMode.isActive) {
        SpeedMode.stop();
    }
    
    // End session timer when returning home
    if (name === 'home') {
        Session.end();
        // Reset combo when returning home so it doesn't persist
        Gamification.resetCombo();
        // Clean up any Speed Mode feedback overlays
        document.querySelectorAll('.speed-feedback-overlay').forEach(el => el.remove());
    }

    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
    const el = document.getElementById('screen-' + name);
    if (el) el.classList.add('active');
    document.getElementById('subheader').style.display = showSubheader ? '' : 'none';
    document.getElementById('footerNav').style.display = showFooter ? '' : 'none';
    
    // Scroll to top when switching screens
    window.scrollTo(0, 0);

    const chatFab = document.getElementById('chatFab');
    if (name === 'exam' || name === 'drill' || name === 'ai-practice' || name === 'speed') {
        chatFab.style.display = '';
    } else {
        chatFab.style.display = 'none';
        Chat.close();
    }

    // Hide combo display on non-active screens
    const comboEl = document.getElementById('comboDisplay');
    if (comboEl && (name === 'home' || name === 'settings' || name === 'progress' || name === 'shop' || name === 'garden')) {
        comboEl.classList.remove('active');
    }
}

// =====================================================================
// HOME SCREEN
// =====================================================================
/**
 * @namespace Home
 * @description Renders the home screen including question bank cards,
 * stats sidebar, daily goal progress, and buff summary pills.
 * 
 * Key methods:
 * - render() - Full home screen refresh
 * - renderBanks() - Renders question bank cards with mode buttons
 * - renderStats() - Updates stats sidebar
 * - updateMetaSummary() - Refreshes buff pills and streak info
 */
const Home = {
    render() {
        DailyGoal.renderStreakBanner();
        DailyGoal.renderDailyGoalCard();
        DailyChallenges.render();
        StudyAnalytics.render();
        this.updateMetaSummary();
        this.renderStats();
        this.renderBanks();
        AITutor.renderQuickTip();
    },

    updateMetaSummary() {
        const stats = DailyGoal.getStats();
        const title = document.getElementById('metaSummaryTitle');
        const body = document.getElementById('metaSummaryBody');
        const glance = document.getElementById('metaBuffGlance');
        if (!title || !body) return;
        const streak = stats.streak || 0;
        const today = stats.questionsToday || 0;
        const goal = stats.dailyGoal || 10;
        const pct = Math.min(100, Math.round((Math.min(today, goal) / goal) * 100));
        title.textContent = streak > 0 ? ` ${streak}-day streak` : 'Start your streak!';
        body.textContent = `${today}/${goal} questions  ${pct}% of goal`;
        if (glance) {
            const buffs = Gamification.getActiveBuffs();
            glance.innerHTML = buffs.length ? buffs.map(buff => `<span class="meta-pill" role="listitem" title="${escapeHtml(buff.description)}">${buff.icon} ${buff.label} <span>${buff.value}</span><span class="pill-source">${buff.source}</span></span>`).join('') : '<span class="meta-pill"> No active buffs</span>';
        }
    },

    renderStats() {
        const stats = DailyGoal.getStats();
        const drillData = Store.get('drillProgress', {});
        const totalQ = Object.keys(drillData).length;
        const mastered = Object.values(drillData).filter(d => d.ef >= 2.5 && d.reps >= 3).length;
        const masteryPct = totalQ > 0 ? Math.round((mastered / totalQ) * 100) : 0;
        const todayMins = Session.getTodayMins();
        const totalMins = stats.totalStudyMins || 0;

        document.getElementById('homeStats').innerHTML = `
            <div class="stat-card"><div class="stat-val">${Session.formatTime(todayMins)}</div><div class="stat-lbl">Today</div></div>
            <div class="stat-card"><div class="stat-val">${Session.formatTime(totalMins)}</div><div class="stat-lbl">Total Study</div></div>
            <div class="stat-card"><div class="stat-val">${stats.testsCompleted}</div><div class="stat-lbl">Tests Taken</div></div>
            <div class="stat-card"><div class="stat-val">${Math.round(stats.avgScore || 0)}%</div><div class="stat-lbl">Avg Score</div></div>
            <div class="stat-card"><div class="stat-val">${masteryPct}%</div><div class="stat-lbl">Mastery</div></div>
            <div class="stat-card"><div class="stat-val">${stats.drillStreak}</div><div class="stat-lbl">Drill Streak</div></div>
        `;
    },

    renderBanks() {
        const el = document.getElementById('bankList');
        if (BankManager.banks.length === 0) {
            el.innerHTML = '<p style="text-align:center;color:var(--gray-600);padding:40px">No question banks loaded. Check that banks/ folder exists.</p>';
            return;
        }
        el.innerHTML = BankManager.banks.map(bank => {
            const history = Store.get('testHistory_' + bank.bankId, []);
            const best = history.length > 0 ? Math.max(...history.map(h => h.pct)) : null;
            return `
            <div class="bank-card">
                <h2>${escapeHtml(bank.title)}</h2>
                <div class="bank-desc">${escapeHtml(bank.description || '')}</div>
                <div class="bank-meta">
                    <span>${bank.questions.length} questions</span>
                    <span>Time: ${Math.floor((bank.timeLimit||5400)/60)} min</span>
                    <span>Pass: ${bank.passingScore||70}%</span>
                    ${best !== null ? `<span>Best: <strong>${best}%</strong></span>` : ''}
                </div>
                <div class="mode-buttons">
                    <button class="mode-btn m-test" onclick="App.start('${escapeHtml(bank.bankId)}','test')">
                        <h3>Test Mode</h3><p>Timed, Cengage-style. No feedback until submit.</p>
                    </button>
                    <button class="mode-btn m-practice" onclick="App.start('${escapeHtml(bank.bankId)}','practice')">
                        <h3>Practice Mode</h3><p>Check each answer. See explanations instantly.</p>
                    </button>
                    <button class="mode-btn m-drill" onclick="Drill.start('${escapeHtml(bank.bankId)}')">
                        <h3>Drill Mode</h3><p>Spaced repetition. Focus on weak spots.</p>
                    </button>
                    <button class="mode-btn m-review" onclick="Review.start('${escapeHtml(bank.bankId)}')">
                        <h3>Review Mode</h3><p>Browse all questions with answers.</p>
                    </button>
                    <button class="mode-btn m-ai" onclick="AIPractice.start('${escapeHtml(bank.bankId)}')">
                        <h3>AI Practice</h3><p>AI generates new questions targeting your weak areas.</p>
                    </button>
                    <button class="mode-btn m-speed" onclick="SpeedMode.start('${escapeHtml(bank.bankId)}')" style="background:linear-gradient(135deg,#f59e0b,#ef4444);color:#fff">
                        <h3> Speed Mode</h3><p>Race the clock! Fast answers = more coins.</p>
                    </button>
                </div>
                ${Home.renderWeakAreasBadge(bank)}
            </div>`;
        }).join('');
    },

    renderWeakAreasBadge(bank) {
        const cats = QuestionTracker.getCategoryAccuracy();
        const weakCats = Object.entries(cats)
            .filter(([_, d]) => d.total >= 3 && (d.correct / d.total) < 0.6)
            .sort((a, b) => (a[1].correct / a[1].total) - (b[1].correct / b[1].total))
            .slice(0, 3);
        if (weakCats.length === 0) return '';
        const weakQIds = [];
        for (const q of bank.questions) {
            if (weakCats.some(([cat]) => (q.category || 'General') === cat)) weakQIds.push(q.id);
        }
        if (weakQIds.length === 0) return '';
        const badges = weakCats.map(([cat, d]) => {
            const pct = Math.round((d.correct / d.total) * 100);
            return `<span style="display:inline-block;background:var(--red-light);color:#fff;padding:3px 10px;border-radius:12px;font-size:11px;margin:2px">${escapeHtml(cat)} (${pct}%)</span>`;
        }).join('');
        return `<div style="margin-top:12px;padding:12px;background:#fdf2f2;border:1px solid var(--red-light);border-radius:8px">
            <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px">
                <div><strong style="color:var(--red);font-size:13px">Weak Areas:</strong> ${badges}</div>
                <button class="btn-nav" style="background:var(--red);font-size:12px;padding:6px 14px" onclick="Drill.start('${escapeHtml(bank.bankId)}', [${weakQIds.join(',')}])">Drill Weak Areas</button>
            </div>
        </div>`;
    }
};

// =====================================================================
// AI TUTOR - Analyzes stats and provides personalized recommendations
// =====================================================================
const AITutor = {
    chatHistory: [],
    currentTab: 'chat',
    
    openModal() {
        document.getElementById('aiTutorModal').classList.add('active');
        this.switchTab('chat');
        if (this.chatHistory.length === 0) {
            this.addBotMessage(this.getGreeting());
        }
    },
    
    closeModal() {
        document.getElementById('aiTutorModal').classList.remove('active');
    },
    
    switchTab(tab) {
        this.currentTab = tab;
        const chatTab = document.getElementById('aiTutorChatTab');
        const statsTab = document.getElementById('aiTutorStatsTab');
        const chatBtn = document.getElementById('aiTabChat');
        const statsBtn = document.getElementById('aiTabStats');
        
        if (tab === 'chat') {
            chatTab.style.display = 'flex';
            statsTab.style.display = 'none';
            chatBtn.style.background = 'var(--blue)';
            chatBtn.style.color = '#fff';
            statsBtn.style.background = '#fff';
            statsBtn.style.color = 'var(--gray-700)';
        } else {
            chatTab.style.display = 'none';
            statsTab.style.display = 'block';
            statsBtn.style.background = 'var(--blue)';
            statsBtn.style.color = '#fff';
            chatBtn.style.background = '#fff';
            chatBtn.style.color = 'var(--gray-700)';
            this.renderFullAnalysis();
        }
    },
    
    getGreeting() {
        const analysis = this.analyzeStats();
        const hour = new Date().getHours();
        let greeting = hour < 12 ? 'Good morning' : hour < 17 ? 'Good afternoon' : 'Good evening';
        
        if (analysis.questionsToday === 0) {
            return `${greeting}!  Ready to study? I can help you figure out what to focus on. Ask me anything or tap a quick question below!`;
        } else if (analysis.goalProgress >= 100) {
            return `${greeting}!  You've hit your daily goal - nice work! Want to keep going or review what you've learned?`;
        } else {
            return `${greeting}!  You're ${analysis.goalProgress}% to your daily goal. How can I help you today?`;
        }
    },
    
    addBotMessage(text) {
        this.chatHistory.push({ role: 'bot', text });
        this.renderChat();
    },
    
    addUserMessage(text) {
        this.chatHistory.push({ role: 'user', text });
        this.renderChat();
    },
    
    renderChat() {
        const container = document.getElementById('aiTutorChatMessages');
        if (!container) return;
        
        container.innerHTML = this.chatHistory.map(msg => {
            if (msg.role === 'bot') {
                return `<div style="display:flex;gap:10px;align-items:flex-start">
                    <span style="font-size:24px;flex-shrink:0"></span>
                    <div style="background:var(--gray-100);padding:12px 16px;border-radius:12px;border-top-left-radius:4px;max-width:85%;font-size:14px;line-height:1.5">${msg.text}</div>
                </div>`;
            } else {
                return `<div style="display:flex;gap:10px;align-items:flex-start;justify-content:flex-end">
                    <div style="background:var(--blue);color:#fff;padding:12px 16px;border-radius:12px;border-top-right-radius:4px;max-width:85%;font-size:14px;line-height:1.5">${escapeHtml(msg.text)}</div>
                </div>`;
            }
        }).join('');
        
        container.scrollTop = container.scrollHeight;
    },
    
    sendMessage() {
        const input = document.getElementById('aiTutorInput');
        const text = input.value.trim();
        if (!text) return;
        
        input.value = '';
        this.askQuestion(text);
    },
    
    askQuestion(question) {
        this.addUserMessage(question);
        
        // Generate response based on question
        const response = this.generateResponse(question);
        
        // Slight delay for natural feel
        setTimeout(() => {
            this.addBotMessage(response);
        }, 300);
    },
    
    generateResponse(question) {
        const analysis = this.analyzeStats();
        const q = question.toLowerCase();
        
        // What should I study / what's next
        if (q.includes('study next') || q.includes('what should i') || q.includes('focus on') || q.includes('what to do')) {
            return this.getStudyRecommendation(analysis);
        }
        
        // How am I doing / overall progress
        if (q.includes('how am i') || q.includes('doing overall') || q.includes('my progress') || q.includes('how\'s my')) {
            return this.getOverallAssessment(analysis);
        }
        
        // Weak areas
        if (q.includes('weak') || q.includes('struggling') || q.includes('bad at') || q.includes('need help')) {
            return this.getWeakAreasResponse(analysis);
        }
        
        // Strong areas / strengths
        if (q.includes('strong') || q.includes('good at') || q.includes('best') || q.includes('strength')) {
            return this.getStrengthsResponse(analysis);
        }
        
        // Exam ready / ready for test
        if (q.includes('exam') || q.includes('ready') || q.includes('test') || q.includes('pass')) {
            return this.getExamReadinessResponse(analysis);
        }
        
        // Streak / consistency
        if (q.includes('streak') || q.includes('consistent') || q.includes('daily')) {
            return this.getStreakResponse(analysis);
        }
        
        // Time / how long / study time
        if (q.includes('time') || q.includes('how long') || q.includes('hours') || q.includes('minutes')) {
            return this.getTimeResponse(analysis);
        }
        
        // Goal / target
        if (q.includes('goal') || q.includes('target')) {
            return this.getGoalResponse(analysis);
        }
        
        // Mastery / mastered
        if (q.includes('master') || q.includes('learned') || q.includes('know')) {
            return this.getMasteryResponse(analysis);
        }
        
        // Tips / advice / help
        if (q.includes('tip') || q.includes('advice') || q.includes('help') || q.includes('suggest')) {
            return this.getTipsResponse(analysis);
        }
        
        // Default - general helpful response
        return this.getDefaultResponse(analysis);
    },
    
    getStudyRecommendation(a) {
        if (a.weakCats.length > 0) {
            const weakest = a.weakCats[0];
            const pct = Math.round((weakest[1].correct / weakest[1].total) * 100);
            return `Based on your data, I'd focus on <strong>${escapeHtml(weakest[0])}</strong> - you're at ${pct}% accuracy there. 
            
Try a focused drill session on that category. Once you get it above 70%, move to the next weak area.

${a.struggling > 0 ? `You also have ${a.struggling} questions marked as "struggling" - those will show up more in drill mode to help you master them.` : ''}`;
        }
        
        if (a.masteryPct < 50) {
            return `You've mastered ${a.masteryPct}% of questions so far. I'd recommend doing more <strong>Drill Mode</strong> sessions to build that foundation.

The spaced repetition system will automatically show you questions you need to review. Aim for 70%+ mastery before taking practice exams.`;
        }
        
        return `You're doing well! Your mastery is at ${a.masteryPct}%. 

I'd suggest taking a <strong>Practice Test</strong> to see how you perform under exam conditions. That'll reveal any gaps in your knowledge.`;
    },
    
    getOverallAssessment(a) {
        let assessment = '';
        
        if (a.avgRecentScore !== null) {
            if (a.avgRecentScore >= 80) {
                assessment = ` <strong>Looking great!</strong> Your recent test average is ${a.avgRecentScore}%.`;
            } else if (a.avgRecentScore >= 70) {
                assessment = ` <strong>On track!</strong> Your recent test average is ${a.avgRecentScore}% - passing range.`;
            } else {
                assessment = ` <strong>Needs work.</strong> Your recent test average is ${a.avgRecentScore}% - below passing.`;
            }
        }
        
        assessment += `\n\n<strong>Key Stats:</strong>
 Mastery: ${a.masteryPct}% of questions
 Streak: ${a.streak} days
 Today: ${a.questionsToday}/${a.dailyGoal} questions (${a.goalProgress}%)
 Study time today: ${a.todayMins} minutes`;
        
        if (a.weakCats.length > 0) {
            assessment += `\n\n You have ${a.weakCats.length} weak categories that need attention.`;
        }
        
        return assessment;
    },
    
    getWeakAreasResponse(a) {
        if (a.weakCats.length === 0) {
            return ` Great news - you don't have any categories below 60% accuracy! 

Keep practicing to maintain your skills. Consider taking a practice test to challenge yourself.`;
        }
        
        const weakList = a.weakCats.slice(0, 5).map(([cat, d]) => {
            const pct = Math.round((d.correct / d.total) * 100);
            return ` <strong>${escapeHtml(cat)}</strong>: ${pct}% (${d.correct}/${d.total})`;
        }).join('\n');
        
        return ` <strong>Areas needing work:</strong>\n${weakList}

<strong>My recommendation:</strong> Start with the lowest one and drill it until you're above 70%. The spaced repetition will help you retain what you learn.`;
    },
    
    getStrengthsResponse(a) {
        if (a.strongCats.length === 0) {
            return `You don't have any categories above 80% yet, but that's okay - you're still building your foundation!

Keep practicing and you'll get there. Focus on consistency over perfection.`;
        }
        
        const strongList = a.strongCats.slice(0, 5).map(([cat, d]) => {
            const pct = Math.round((d.correct / d.total) * 100);
            return ` <strong>${escapeHtml(cat)}</strong>: ${pct}%`;
        }).join('\n');
        
        return ` <strong>Your strengths:</strong>\n${strongList}

Nice work on these! You can maintain them with occasional review, but focus your energy on weaker areas now.`;
    },
    
    getExamReadinessResponse(a) {
        let ready = true;
        let reasons = [];
        
        if (a.masteryPct < 60) {
            ready = false;
            reasons.push(`Mastery is only ${a.masteryPct}% (aim for 70%+)`);
        }
        if (a.weakCats.length > 3) {
            ready = false;
            reasons.push(`${a.weakCats.length} weak categories need work`);
        }
        if (a.avgRecentScore !== null && a.avgRecentScore < 70) {
            ready = false;
            reasons.push(`Recent test average is ${a.avgRecentScore}% (need 70%+)`);
        }
        if (a.testsCompleted < 3) {
            ready = false;
            reasons.push(`Only ${a.testsCompleted} practice tests completed`);
        }
        
        if (ready) {
            return ` <strong>You look ready!</strong>

Your mastery is at ${a.masteryPct}%, you've completed ${a.testsCompleted} practice tests, and your recent scores are solid.

I'd recommend one more full practice test to confirm, then you're good to go!`;
        } else {
            return ` <strong>Not quite ready yet.</strong>

Here's what to work on:
${reasons.map(r => ' ' + r).join('\n')}

Keep drilling and take more practice tests. You'll get there!`;
        }
    },
    
    getStreakResponse(a) {
        if (a.streak === 0) {
            return `You don't have an active streak yet. Study today to start one!

Consistency is key - even 10-15 minutes daily is better than cramming once a week.`;
        } else if (a.streak < 7) {
            return ` You're on a <strong>${a.streak}-day streak!</strong>

Keep it going! Studies show that consistent daily practice leads to better retention than sporadic long sessions.`;
        } else {
            return ` <strong>Amazing ${a.streak}-day streak!</strong>

You're building great habits! This consistency will really pay off on exam day.`;
        }
    },
    
    getTimeResponse(a) {
        return ` <strong>Study Time Stats:</strong>

 Today: ${a.todayMins} minutes
 Average daily: ${a.avgDailyMins} minutes
 Total all-time: ${a.totalMins} minutes

${a.todayMins < 15 ? 'Try to get at least 15-30 minutes of focused study today!' : 'Good job putting in the time!'}`;
    },
    
    getGoalResponse(a) {
        return ` <strong>Daily Goal Progress:</strong>

You've completed ${a.questionsToday} of ${a.dailyGoal} questions today (${a.goalProgress}%).

${a.goalProgress >= 100 ? ' Goal achieved! Want to keep going?' : `${a.dailyGoal - a.questionsToday} more to hit your goal!`}

You can adjust your daily goal in Settings if ${a.dailyGoal} feels too easy or too hard.`;
    },
    
    getMasteryResponse(a) {
        return ` <strong>Mastery Progress:</strong>

 Questions seen: ${a.totalQuestions}
 Mastered (high confidence): ${a.mastered} (${a.masteryPct}%)
 Struggling (need review): ${a.struggling}

${a.masteryPct >= 70 ? 'Great mastery level! You\'re retaining information well.' : 'Keep drilling to increase your mastery. The spaced repetition system will help!'}`;
    },
    
    getTipsResponse(a) {
        const tips = [
            'Use Drill Mode daily - spaced repetition is proven to boost retention.',
            'Take practice tests under exam conditions (timed, no distractions).',
            'Focus on weak areas first - that\'s where you\'ll gain the most points.',
            'Review wrong answers carefully - understand WHY you got them wrong.',
            'Consistency beats intensity - 20 min/day > 3 hours once a week.',
            'Use Speed Mode to build quick recall for facts you already know.',
            'Take breaks! Your brain consolidates learning during rest.'
        ];
        
        const randomTips = tips.sort(() => Math.random() - 0.5).slice(0, 3);
        
        return ` <strong>Study Tips:</strong>\n\n${randomTips.map((t, i) => `${i + 1}. ${t}`).join('\n\n')}`;
    },
    
    getDefaultResponse(a) {
        return `I'm here to help with your studying! You can ask me things like:

 "What should I study next?"
 "How am I doing overall?"
 "What are my weak areas?"
 "Am I ready for the exam?"
 "Give me some study tips"

Or just tell me what's on your mind and I'll do my best to help! `;
    },
    
    // Analyze all user data and generate insights
    analyzeStats() {
        const stats = DailyGoal.getStats();
        const drillData = Store.get('drillProgress', {});
        const tracker = Store.get('questionTracker', {});
        const catAccuracy = QuestionTracker.getCategoryAccuracy();
        
        // Calculate key metrics
        const totalQuestions = Object.keys(drillData).length;
        const mastered = Object.values(drillData).filter(d => d.ef >= 2.5 && d.reps >= 3).length;
        const masteryPct = totalQuestions > 0 ? Math.round((mastered / totalQuestions) * 100) : 0;
        const struggling = Object.values(drillData).filter(d => d.ef < 2.0).length;
        
        // Find weak categories (< 60% accuracy with at least 3 attempts)
        const weakCats = Object.entries(catAccuracy)
            .filter(([_, d]) => d.total >= 3 && (d.correct / d.total) < 0.6)
            .sort((a, b) => (a[1].correct / a[1].total) - (b[1].correct / b[1].total));
        
        // Find strong categories (> 80% accuracy)
        const strongCats = Object.entries(catAccuracy)
            .filter(([_, d]) => d.total >= 3 && (d.correct / d.total) >= 0.8)
            .sort((a, b) => (b[1].correct / b[1].total) - (a[1].correct / a[1].total));
        
        // Study time analysis
        const todayMins = Session.getTodayMins();
        const totalMins = stats.totalStudyMins || 0;
        const avgDailyMins = stats.daysActive > 0 ? Math.round(totalMins / stats.daysActive) : 0;
        
        // Streak and consistency
        const streak = stats.streak || 0;
        const questionsToday = stats.questionsToday || 0;
        const dailyGoal = stats.dailyGoal || 10;
        const goalProgress = Math.min(100, Math.round((questionsToday / dailyGoal) * 100));
        
        // Recent performance trend
        const recentTests = [];
        BankManager.banks.forEach(bank => {
            const history = Store.get('testHistory_' + bank.bankId, []);
            recentTests.push(...history.slice(-5));
        });
        recentTests.sort((a, b) => new Date(b.date) - new Date(a.date));
        const last5Tests = recentTests.slice(0, 5);
        const avgRecentScore = last5Tests.length > 0 
            ? Math.round(last5Tests.reduce((s, t) => s + t.pct, 0) / last5Tests.length) 
            : null;
        
        return {
            totalQuestions, mastered, masteryPct, struggling,
            weakCats, strongCats,
            todayMins, totalMins, avgDailyMins,
            streak, questionsToday, dailyGoal, goalProgress,
            avgRecentScore, last5Tests,
            testsCompleted: stats.testsCompleted || 0,
            avgScore: stats.avgScore || 0
        };
    },
    
    // Generate the primary recommendation
    getTopRecommendation(analysis) {
        const { weakCats, goalProgress, streak, masteryPct, struggling, todayMins, questionsToday } = analysis;
        
        // Priority 1: Haven't studied today
        if (questionsToday === 0) {
            return {
                icon: '',
                title: 'Start Your Day!',
                text: streak > 0 
                    ? `Keep your ${streak}-day streak alive! Try a quick drill session.`
                    : 'Begin with a short drill to warm up your brain.',
                action: 'Drill Mode',
                actionFn: () => BankManager.banks[0] && Drill.start(BankManager.banks[0].bankId)
            };
        }
        
        // Priority 2: Goal not met
        if (goalProgress < 100) {
            const remaining = analysis.dailyGoal - analysis.questionsToday;
            return {
                icon: '',
                title: `${remaining} more to hit your goal!`,
                text: `You're ${goalProgress}% there. A quick ${Math.min(remaining, 10)}-question session will get you closer.`,
                action: 'Quick Drill',
                actionFn: () => BankManager.banks[0] && Drill.start(BankManager.banks[0].bankId)
            };
        }
        
        // Priority 3: Weak categories exist
        if (weakCats.length > 0) {
            const [cat, data] = weakCats[0];
            const pct = Math.round((data.correct / data.total) * 100);
            return {
                icon: '',
                title: `Focus on: ${cat}`,
                text: `Only ${pct}% accuracy here. Targeted practice will boost your score significantly.`,
                action: 'Drill Weak Area',
                actionFn: () => {
                    const bank = BankManager.banks[0];
                    if (bank) {
                        const weakQIds = bank.questions.filter(q => (q.category || 'General') === cat).map(q => q.id);
                        Drill.start(bank.bankId, weakQIds);
                    }
                }
            };
        }
        
        // Priority 4: Low mastery overall
        if (masteryPct < 50) {
            return {
                icon: '',
                title: 'Build Your Foundation',
                text: `${masteryPct}% mastery. Regular drill sessions will lock in knowledge long-term.`,
                action: 'Drill Mode',
                actionFn: () => BankManager.banks[0] && Drill.start(BankManager.banks[0].bankId)
            };
        }
        
        // Priority 5: Ready for a test
        if (masteryPct >= 70) {
            return {
                icon: '',
                title: 'Ready for a Practice Test!',
                text: `${masteryPct}% mastery - you're well prepared. Take a timed test to simulate the real exam.`,
                action: 'Take Test',
                actionFn: () => BankManager.banks[0] && App.start(BankManager.banks[0].bankId, 'test')
            };
        }
        
        // Default: Keep practicing
        return {
            icon: '',
            title: 'Keep Up the Momentum!',
            text: 'You\'re making great progress. Continue with drill mode to reinforce learning.',
            action: 'Continue Drilling',
            actionFn: () => BankManager.banks[0] && Drill.start(BankManager.banks[0].bankId)
        };
    },
    
    // Render quick tip on home screen
    renderQuickTip() {
        const el = document.getElementById('aiTutorQuickTip');
        if (!el) return;
        
        const analysis = this.analyzeStats();
        const rec = this.getTopRecommendation(analysis);
        
        el.innerHTML = `<strong>${rec.icon} ${rec.title}</strong><br><span style="opacity:0.9">${rec.text}</span>`;
    },
    
    // Render full analysis in modal
    renderFullAnalysis() {
        const el = document.getElementById('aiTutorContent');
        if (!el) return;
        
        const a = this.analyzeStats();
        const topRec = this.getTopRecommendation(a);
        
        let html = `
            <!-- Top Recommendation -->
            <div style="background:linear-gradient(135deg,#6366f1,#8b5cf6);color:#fff;padding:20px;border-radius:12px;margin-bottom:20px">
                <div style="font-size:24px;margin-bottom:8px">${topRec.icon} ${topRec.title}</div>
                <p style="margin:0 0 16px 0;opacity:0.9">${topRec.text}</p>
                <button onclick="AITutor.closeModal();(${topRec.actionFn.toString()})()" style="background:#fff;color:#6366f1;border:none;padding:10px 20px;border-radius:8px;font-weight:bold;cursor:pointer">
                    ${topRec.action} 
                </button>
            </div>
            
            <!-- Stats Overview -->
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:12px;margin-bottom:20px">
                <div style="background:var(--gray-100);padding:16px;border-radius:8px;text-align:center">
                    <div style="font-size:28px;font-weight:bold;color:var(--blue)">${a.masteryPct}%</div>
                    <div style="font-size:12px;color:var(--gray-600)">Mastery</div>
                </div>
                <div style="background:var(--gray-100);padding:16px;border-radius:8px;text-align:center">
                    <div style="font-size:28px;font-weight:bold;color:var(--green)">${a.streak}</div>
                    <div style="font-size:12px;color:var(--gray-600)">Day Streak</div>
                </div>
                <div style="background:var(--gray-100);padding:16px;border-radius:8px;text-align:center">
                    <div style="font-size:28px;font-weight:bold;color:var(--orange)">${Math.round(a.avgScore)}%</div>
                    <div style="font-size:12px;color:var(--gray-600)">Avg Score</div>
                </div>
            </div>
            
            <!-- Today's Progress -->
            <div style="background:var(--gray-100);padding:16px;border-radius:8px;margin-bottom:20px">
                <h3 style="margin:0 0 12px 0;font-size:14px"> Today's Progress</h3>
                <div style="display:flex;justify-content:space-between;margin-bottom:8px">
                    <span>Questions: ${a.questionsToday}/${a.dailyGoal}</span>
                    <span style="font-weight:bold">${a.goalProgress}%</span>
                </div>
                <div style="background:var(--gray-300);border-radius:4px;height:8px;overflow:hidden">
                    <div style="background:${a.goalProgress >= 100 ? 'var(--green)' : 'var(--blue)'};height:100%;width:${a.goalProgress}%"></div>
                </div>
                <div style="margin-top:8px;font-size:12px;color:var(--gray-600)">
                    Study time today: ${Session.formatTime(a.todayMins)}  Total: ${Session.formatTime(a.totalMins)}
                </div>
            </div>`;
        
        // Weak Areas
        if (a.weakCats.length > 0) {
            html += `
                <div style="background:#fef2f2;border:1px solid var(--red-light);padding:16px;border-radius:8px;margin-bottom:20px">
                    <h3 style="margin:0 0 12px 0;font-size:14px;color:var(--red)"> Areas Needing Work</h3>
                    <div style="display:flex;flex-wrap:wrap;gap:8px">
                        ${a.weakCats.slice(0, 5).map(([cat, d]) => {
                            const pct = Math.round((d.correct / d.total) * 100);
                            return `<span style="background:var(--red-light);color:#fff;padding:6px 12px;border-radius:16px;font-size:12px">${escapeHtml(cat)} (${pct}%)</span>`;
                        }).join('')}
                    </div>
                    <p style="margin:12px 0 0 0;font-size:13px;color:var(--gray-700)">
                         <strong>Tip:</strong> Focus 70% of your study time on weak areas. Use Drill Mode to target these specifically.
                    </p>
                </div>`;
        }
        
        // Strong Areas
        if (a.strongCats.length > 0) {
            html += `
                <div style="background:#f0fdf4;border:1px solid var(--green);padding:16px;border-radius:8px;margin-bottom:20px">
                    <h3 style="margin:0 0 12px 0;font-size:14px;color:var(--green)"> Your Strengths</h3>
                    <div style="display:flex;flex-wrap:wrap;gap:8px">
                        ${a.strongCats.slice(0, 5).map(([cat, d]) => {
                            const pct = Math.round((d.correct / d.total) * 100);
                            return `<span style="background:var(--green);color:#fff;padding:6px 12px;border-radius:16px;font-size:12px">${escapeHtml(cat)} (${pct}%)</span>`;
                        }).join('')}
                    </div>
                </div>`;
        }
        
        // Study Plan Suggestions
        html += `
            <div style="background:var(--gray-100);padding:16px;border-radius:8px;margin-bottom:20px">
                <h3 style="margin:0 0 12px 0;font-size:14px"> Recommended Study Plan</h3>
                <ol style="margin:0;padding-left:20px;font-size:13px;line-height:1.8">
                    ${this.getStudyPlanSteps(a).map(step => `<li>${step}</li>`).join('')}
                </ol>
            </div>`;
        
        // Quick Actions
        html += `
            <div style="display:grid;grid-template-columns:repeat(2,1fr);gap:12px">
                <button class="btn-nav" style="background:var(--blue);padding:14px" onclick="AITutor.closeModal();BankManager.banks[0]&&Drill.start(BankManager.banks[0].bankId)">
                     Start Drill
                </button>
                <button class="btn-nav" style="background:var(--green);padding:14px" onclick="AITutor.closeModal();BankManager.banks[0]&&App.start(BankManager.banks[0].bankId,'practice')">
                     Practice Mode
                </button>
                <button class="btn-nav" style="background:var(--orange);padding:14px" onclick="AITutor.closeModal();BankManager.banks[0]&&SpeedMode.start(BankManager.banks[0].bankId)">
                     Speed Mode
                </button>
                <button class="btn-nav" style="background:var(--red);padding:14px" onclick="AITutor.closeModal();BankManager.banks[0]&&App.start(BankManager.banks[0].bankId,'test')">
                     Take Test
                </button>
            </div>`;
        
        el.innerHTML = html;
    },
    
    // Generate personalized study plan steps
    getStudyPlanSteps(analysis) {
        const steps = [];
        const { weakCats, masteryPct, goalProgress, streak, avgRecentScore } = analysis;
        
        // Step 1: Based on current state
        if (goalProgress < 100) {
            steps.push(`Complete your daily goal (${analysis.questionsToday}/${analysis.dailyGoal} done)`);
        } else {
            steps.push(' Daily goal complete! Consider doing extra practice.');
        }
        
        // Step 2: Weak area focus
        if (weakCats.length > 0) {
            const topWeak = weakCats[0][0];
            steps.push(`Drill <strong>${escapeHtml(topWeak)}</strong> - your weakest category`);
        } else {
            steps.push('Review any flagged/bookmarked questions');
        }
        
        // Step 3: Based on mastery
        if (masteryPct < 50) {
            steps.push('Focus on Drill Mode to build foundational knowledge');
        } else if (masteryPct < 75) {
            steps.push('Mix Drill and Practice modes to solidify understanding');
        } else {
            steps.push('Take timed practice tests to build exam stamina');
        }
        
        // Step 4: Speed training
        if (avgRecentScore && avgRecentScore >= 70) {
            steps.push('Try Speed Mode to improve recall speed');
        } else {
            steps.push('Use Practice Mode with explanations to understand concepts');
        }
        
        // Step 5: Consistency
        if (streak < 7) {
            steps.push(`Build a 7-day streak (currently ${streak} days)`);
        } else {
            steps.push(`Maintain your ${streak}-day streak - consistency is key!`);
        }
        
        return steps;
    }
};

// =====================================================================
// MAIN APP (Test & Practice Engine)
// =====================================================================
/**
 * @namespace App
 * @description Main study engine for Test, Practice, and Review modes.
 * Handles question rendering, answer submission, scoring, and session flow.
 * 
 * State:
 * - bank: Current question bank object
 * - questions: Array of questions for this session
 * - mode: 'test' | 'practice' | 'review-after'
 * - currentQ: Current question index
 * - answers: User's selected answers by question index
 * 
 * Key methods:
 * - start(bank, mode, questionCount) - Initialize a study session
 * - render() - Render current question
 * - submitTest() - Score and show results
 * - startReview() - Enter review mode for completed session
 */
const App = {
    bank: null,
    questions: [],
    mode: 'test', // 'test' | 'practice' | 'review-after'
    currentQ: 0,
    answers: {},
    bookmarked: {},
    visited: {},
    practiceChecked: {},  // { qIndex: true } for practice mode
    practiceResults: {},  // { qIndex: 'correct'|'incorrect'|'skipped' }
    timerSeconds: 0,
    timerInterval: null,
    timerPaused: false,
    countdown: true,
    submitted: false,
    startTime: 0,
    answerHistory: {},    // { qIndex: [firstAnswer, ...changesArray] }
    confidence: {},       // { qIndex: 1|2|3 } (1=Maybe, 2=Probably, 3=Definitely)
    sessionMeta: null,

    // Pending start state for question count picker
    _pendingBankId: null,
    _pendingMode: null,
    _pendingCount: null,
    _pendingBatchTier: null,

    _getDefaultSessionMeta() {
        return {
            batchSize: null,
            questionGoal: 0,
            batchTierId: null,
            batchLabel: 'Standard Pace',
            xpMultiplier: 1,
            coinMultiplier: 1,
            momentum: null,
            startedAt: null
        };
    },

    _applyBatchMeta(questionCount) {
        const count = Math.max(0, questionCount || (this.questions ? this.questions.length : 0) || 0);
        const momentum = Gamification.activateBatchMomentum(count, { questionGoal: count });
        this.sessionMeta = {
            batchSize: count,
            questionGoal: count,
            batchTierId: momentum.tierId || null,
            batchLabel: momentum.label || 'Standard Pace',
            xpMultiplier: momentum.xpMultiplier || 1,
            coinMultiplier: momentum.coinMultiplier || 1,
            momentum,
            startedAt: momentum.startedAt || Date.now()
        };
    },

    _previewBatchTier(count) {
        this._pendingBatchTier = Gamification.getBatchTier(count);
    },

    _selectQuestionIndices(mode, count, bank) {
        const total = bank.questions.length;
        const targetCount = Math.min(count, total);
        if (mode !== 'practice') {
            return this._randomIndices(total).slice(0, targetCount);
        }

        const trackerData = (typeof QuestionTracker !== 'undefined' && QuestionTracker._getData)
            ? QuestionTracker._getData()
            : {};
        const weights = bank.questions.map(q => this._computeQuestionWeight(q, trackerData[q.id]));
        return this._weightedSample(weights, targetCount);
    },

    _computeQuestionWeight(question, trackerEntry) {
        let weight = 1.0;
        if (!trackerEntry || trackerEntry.attempts === 0) {
            return weight + 0.5; // unseen questions get slight boost
        }

        const attempts = trackerEntry.attempts || 1;
        const incorrectRatio = trackerEntry.incorrect / attempts;
        const recent = trackerEntry.history ? trackerEntry.history.slice(-3) : [];
        const recentMiss = recent.some(h => h && h.correct === false);

        weight += incorrectRatio * 4; // heavily prioritize missed items
        if (recentMiss) weight += 1.5;
        if (trackerEntry.incorrect === 0 && attempts >= 5) {
            weight *= 0.25; // de-prioritize mastered items
        }
        if (attempts < 3) weight += 0.5; // lightly practiced items get mild boost

        return Math.max(weight, 0.1);
    },

    _weightedSample(weights, count) {
        const available = weights.map((weight, index) => ({ index, weight: Math.max(weight, 0.01) }));
        const selected = [];
        while (selected.length < count && available.length > 0) {
            const totalWeight = available.reduce((sum, item) => sum + item.weight, 0);
            if (totalWeight <= 0) break;
            let r = Math.random() * totalWeight;
            let chosen = 0;
            for (let i = 0; i < available.length; i++) {
                r -= available[i].weight;
                if (r <= 0) {
                    chosen = i;
                    break;
                }
            }
            selected.push(available[chosen].index);
            available.splice(chosen, 1);
        }

        if (selected.length < count) {
            const remaining = [];
            for (let i = 0; i < weights.length; i++) {
                if (!selected.includes(i)) remaining.push(i);
            }
            while (selected.length < count && remaining.length) {
                const idx = Math.floor(Math.random() * remaining.length);
                selected.push(remaining.splice(idx, 1)[0]);
            }
        }
        return selected;
    },

    _randomIndices(total) {
        const indices = Array.from({ length: total }, (_, i) => i);
        for (let i = indices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [indices[i], indices[j]] = [indices[j], indices[i]];
        }
        return indices;
    },

    start(bankId, mode) {
        const bank = BankManager.getBank(bankId);
        if (!bank || !bank.questions || bank.questions.length === 0) return;
        const total = bank.questions.length;

        this._previewBatchTier(total);

        // If 15 or fewer questions, skip the picker
        if (total <= 15) {
            this._startWithCount(bankId, mode, total);
            return;
        }

        // Show question count picker
        this._pendingBankId = bankId;
        this._pendingMode = mode;
        this._pendingCount = 10; // default selection

        const subtitle = document.getElementById('qCountSubtitle');
        subtitle.textContent = `${bank.title} - ${total} questions available`;
        const title = document.getElementById('qCountTitle');
        title.textContent = mode === 'test' ? 'Test Mode - How many questions?' : 'Practice Mode - How many questions?';

        // Build options - filter out counts larger than total, always include All
        const opts = [10, 20, 30, 50].filter(n => n < total);
        opts.push(total); // "All" option

        const container = document.getElementById('qCountOptions');
        container.innerHTML = opts.map(n => {
            const label = n === total ? 'All' : n;
            const sublabel = n === total ? `${total} questions` : 'Random';
            const tier = Gamification.getBatchTier(n);
            const pill = tier ? `<span class="qcount-tier-pill">${tier.pillIcon} ${tier.label}  +${Math.round((tier.xpMultiplier - 1) * 100)}%</span>` : '';
            const sel = n === 10 ? ' selected' : '';
            return `<button class="qcount-opt${sel}" data-count="${n}" onclick="App.selectCount(${n}, this)">
                <div>${label}</div>
                <div class="qcount-label">${sublabel}</div>
                ${pill}
            </button>`;
        }).join('');

        document.getElementById('qCountModal').style.display = 'flex';
        this._renderBatchPreview();
    },

    selectCount(n, btn) {
        this._pendingCount = n;
        this._previewBatchTier(n);
        document.querySelectorAll('.qcount-opt').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        this._renderBatchPreview();
    },

    closeCountPicker() {
        document.getElementById('qCountModal').style.display = 'none';
        this._pendingBankId = null;
        this._pendingMode = null;
        this._pendingBatchTier = null;
    },

    confirmStart() {
        document.getElementById('qCountModal').style.display = 'none';
        this._startWithCount(this._pendingBankId, this._pendingMode, this._pendingCount);
    },

    _startWithCount(bankId, mode, count) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;
        this._reviewFilter = null;
        Session.start(); // Start session timer
        DailyChallenges.trackBank(bankId);

        this.sessionMeta = this._getDefaultSessionMeta();

        // Clear any saved session so we don't restore stale state on reload
        SessionState.clear();

        const indices = this._selectQuestionIndices(mode, count, this.bank);
        this._questionIndices = indices;
        this.questions = indices.map(i => this.bank.questions[i]);

        this._applyBatchMeta(this.questions.length);
        this._renderMomentumPills();

        // Shuffle answer options for each question (keeps correctAnswer mapping)
        this._optionMaps = {};
        this.questions.forEach((q, qi) => {
            const optIndices = q.options.map((_, i) => i);
            for (let i = optIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [optIndices[i], optIndices[j]] = [optIndices[j], optIndices[i]];
            }
            this._optionMaps[qi] = optIndices;
            q._shuffledOptions = optIndices.map(i => q.options[i]);
            q._shuffledCorrect = optIndices.indexOf(q.correctAnswer);
        });

        this.mode = mode;
        this.currentQ = 0;
        this.answers = {};
        this.bookmarked = {};
        this.visited = { 0: true };
        this.skipped = {};
        this.practiceChecked = {};
        this.practiceResults = {};
        this.submitted = false;
        this.startTime = Date.now();
        this.answerHistory = {};
        this.confidence = {};
        this._eliminatedOptions = {};

        // Track mode and bank for daily achievements
        DailyGoal.recordMode(mode);
        DailyGoal.recordBank(this.bank.bankId);

        // Timer setup - scale time proportionally if subset
        if (mode === 'test') {
            this.countdown = true;
            const fullTime = this.bank.timeLimit || 5400;
            const ratio = this.questions.length / this.bank.questions.length;
            this.timerSeconds = Math.round(fullTime * ratio);
            this.initialTimerSeconds = this.timerSeconds;
        } else {
            this.countdown = false;
            this.timerSeconds = 0;
        }

        // Reset metrics and start tracking first question
        Metrics.reset();
        Metrics.startQuestion(0);
        Gamification.startQuestionTimer();

        // UI
        document.getElementById('testNameBar').textContent = this.bank.title;
        document.getElementById('modeTab').textContent = mode === 'test' ? 'Test Mode' : 'Practice Mode';
        document.getElementById('btnSubmit').style.display = (mode === 'test' || mode === 'practice') ? '' : 'none';
        document.getElementById('btnCheck').style.display = mode === 'practice' ? '' : 'none';
        document.getElementById('btnTimerAdj').style.display = mode === 'test' ? '' : 'none';

        this.buildPalette();
        showScreen('exam', true, true);
        this.renderQuestion();
        this.startTimer();

        // Chat context
        Chat.clearHistory();
        document.getElementById('chatFab').classList.add('has-context');
    },

    paletteExpanded: false,

    buildPalette() {
        const pal = document.getElementById('questionPalette');
        pal.innerHTML = '';
        for (let i = 0; i < this.questions.length; i++) {
            const btn = document.createElement('div');
            btn.className = 'q-num';
            btn.textContent = i + 1;
            btn.onclick = () => this.goTo(i);
            btn.id = 'qp-' + i;
            pal.appendChild(btn);
        }
        this.paletteExpanded = false;
        document.getElementById('questionPalette').className = 'question-palette collapsed';
        document.getElementById('paletteLegend').style.display = 'none';
        document.getElementById('paletteExpandBtn').textContent = 'Show All';
        this.buildMiniPalette();
        this.updateStats();
    },

    buildMiniPalette() {
        const mini = document.getElementById('paletteMini');
        const cur = this.currentQ;
        const total = this.questions.length;
        let html = '';

        // Show: current + next 5, then ... [70]
        const show = [];
        for (let i = cur; i < Math.min(cur + 6, total); i++) show.push(i);

        // Add last question if not already shown
        const lastIdx = total - 1;
        const showsLast = show.includes(lastIdx);

        for (let i = 0; i < show.length; i++) {
            const idx = show[i];
            const cls = this._getPaletteClass(idx);
            html += `<div class="q-num ${cls}" onclick="App.goTo(${idx})">${idx + 1}</div>`;
        }

        if (!showsLast) {
            html += '<span class="pm-ellipsis">...</span>';
            const cls = this._getPaletteClass(lastIdx);
            html += `<div class="q-num ${cls}" onclick="App.goTo(${lastIdx})">${total}</div>`;
        }

        mini.innerHTML = html;
    },

    _getPaletteClass(i) {
        let cls = '';
        if (this.mode === 'practice' && this.practiceResults[i]) {
            cls = 'p-' + this.practiceResults[i];
        } else if (i === this.currentQ) {
            cls = 'current';
        } else if (this.skipped[i]) {
            cls = 'skipped';
        } else if (this.answers[i] !== undefined) {
            cls = 'answered';
        } else if (this.visited[i]) {
            cls = 'visited';
        }
        if (this.bookmarked[i]) cls += ' flagged';
        return cls;
    },

    togglePalette() {
        this.paletteExpanded = !this.paletteExpanded;
        document.getElementById('questionPalette').className = 'question-palette ' + (this.paletteExpanded ? 'expanded' : 'collapsed');
        document.getElementById('paletteLegend').style.display = this.paletteExpanded ? '' : 'none';
        document.getElementById('paletteExpandBtn').textContent = this.paletteExpanded ? 'Hide' : 'Show All';
    },

    renderQuestion() {
        const q = this.questions[this.currentQ];
        document.getElementById('questionNumber').textContent = `Question ${this.currentQ + 1} of ${this.questions.length}`;
        document.getElementById('questionText').innerHTML = formatQuestionText(q.text);
        // Render inline chart if question has graphData or [Graph:...] placeholder
        if (q.graphData || q.text.includes('[Graph:')) {
            const graphData = q.graphData || InlineChart.generatePlaceholderGraph(q.text);
            if (graphData) InlineChart.renderInElement(document.getElementById('questionText'), graphData);
        }
        // Render power-up bar
        this.renderPowerups();
        this._renderMomentumPills();

        const list = document.getElementById('optionsList');
        list.innerHTML = '';
        const isChecked = this.practiceChecked[this.currentQ];
        const isReview = this.mode === 'review-after';

        const eliminated = (this._eliminatedOptions && this._eliminatedOptions[this.currentQ]) || [];
        const displayOptions = q._shuffledOptions || q.options;
        const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
        displayOptions.forEach((opt, i) => {
            const li = document.createElement('li');
            let cls = 'option-item';
            if (this.answers[this.currentQ] === i) cls += ' selected';

            if (isReview || isChecked) {
                if (i === correctIdx) cls += ' correct-answer';
                if (this.answers[this.currentQ] === i && i !== correctIdx) cls += ' wrong-answer';
            }

            const isEliminated = eliminated.includes(i);
            li.className = cls + (isEliminated ? ' disabled' : '');
            if (isEliminated) { li.style.opacity = '0.3'; li.style.pointerEvents = 'none'; }
            const disabled = this.submitted || isChecked || isReview || isEliminated;
            li.innerHTML = `<input type="radio" name="q${this.currentQ}" value="${i}" ${this.answers[this.currentQ]===i?'checked':''} ${disabled?'disabled':''}>
                <span class="option-label" ${eliminated.includes(i) ? 'style="text-decoration:line-through;opacity:.4"' : ''}>${escapeHtml(opt)}</span>`;
            if (!disabled) {
                li.onclick = () => this.selectOption(i);
            }
            list.appendChild(li);
        });

        // Practice check button
        const btnCheck = document.getElementById('btnCheck');
        if (this.mode === 'practice') {
            btnCheck.style.display = isChecked ? 'none' : '';
            btnCheck.disabled = this.answers[this.currentQ] === undefined;
        } else {
            btnCheck.style.display = 'none';
        }

        // Confidence panel (Practice mode only, after selecting an answer)
        const confPanel = document.getElementById('confidencePanel');
        if (this.mode === 'practice' && this.answers[this.currentQ] !== undefined && !isChecked) {
            confPanel.style.display = 'flex';
            // Update selected state of buttons
            const currentConf = this.confidence[this.currentQ] || 0;
            confPanel.querySelectorAll('.confidence-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            if (currentConf > 0) {
                const confClasses = ['conf-maybe', 'conf-probably', 'conf-definitely'];
                confPanel.querySelector('.' + confClasses[currentConf - 1]).classList.add('selected');
            }
        } else {
            confPanel.style.display = 'none';
        }

        // Explanation panel
        const expPanel = document.getElementById('explanationPanel');
        if ((isChecked || isReview) && q.explanation) {
            const isCorrect = this.answers[this.currentQ] === correctIdx;
            expPanel.className = 'explanation-panel show' + (isCorrect ? '' : ' incorrect');
            expPanel.innerHTML = `<h4>${isCorrect ? 'Correct!' : (this.answers[this.currentQ] !== undefined ? 'Incorrect' : 'Not answered')}</h4><p>${escapeHtml(q.explanation)}</p>`;
        } else {
            expPanel.className = 'explanation-panel';
        }

        // Bookmark button
        const bmBtn = document.getElementById('btnBookmark');
        bmBtn.className = 'btn-bookmark' + (this.bookmarked[this.currentQ] ? ' flagged' : '');
        bmBtn.textContent = this.bookmarked[this.currentQ] ? 'Bookmarked' : 'Bookmark';

        // Nav buttons
        document.getElementById('btnPrev').disabled = this.currentQ === 0;

        // Load note for current question
        Notes.load();
        Notes.close(); // Close note panel when navigating

        this.updatePalette();
        this.renderMath();
    },

    _renderBatchPreview() {
        const tier = this._pendingBatchTier;
        const previewEl = document.getElementById('batchRewardPreview');
        if (!previewEl) return;
        if (!tier) {
            previewEl.innerHTML = '<span class="batch-preview-pill"> Standard Pace  0% boost</span>';
            return;
        }
        const pct = Math.round((tier.xpMultiplier - 1) * 100);
        previewEl.innerHTML = `<span class="batch-preview-pill" title="${tier.description}">${tier.pillIcon} ${tier.label}  +${pct}% XP/coins</span>`;
    },

    _renderMomentumPills() {
        const wrap = document.getElementById('momentumPills');
        if (!wrap) return;
        const meta = this.sessionMeta;
        const tier = meta && meta.momentum ? meta.momentum : Gamification.getMomentumState();
        Gamification.renderMomentumPillsInto(wrap, tier);
    },

    selectOption(i) {
        if (this.submitted || this.practiceChecked[this.currentQ]) return;
        const qIdx = this.currentQ;
        const prevAnswer = this.answers[qIdx];

        // Track answer history
        if (!this.answerHistory[qIdx]) {
            // First selection for this question
            this.answerHistory[qIdx] = [i];
        } else if (prevAnswer !== undefined && prevAnswer !== i) {
            // Answer changed (not just first selection)
            this.answerHistory[qIdx].push(i);
        }

        this.answers[qIdx] = i;
        this.renderQuestion();
        this.updatePalette();
        SessionState.save();
    },

    clearAnswer() {
        if (this.submitted || this.practiceChecked[this.currentQ]) return;
        delete this.answers[this.currentQ];
        this.renderQuestion();
        this.updatePalette();
        SessionState.save();
    },

    toggleBookmark() {
        this.bookmarked[this.currentQ] = !this.bookmarked[this.currentQ];
        if (!this.bookmarked[this.currentQ]) delete this.bookmarked[this.currentQ];
        this.renderQuestion();
        this.updatePalette();
        SessionState.save();
    },

    checkAnswer() {
        if (this.answers[this.currentQ] === undefined) return;
        if (this.practiceChecked[this.currentQ]) return; // Prevent double-click
        this.practiceChecked[this.currentQ] = true;
        const q = this.questions[this.currentQ];
        const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
        const isCorrect = this.answers[this.currentQ] === correctIdx;
        this.practiceResults[this.currentQ] = isCorrect ? 'correct' : 'incorrect';

        // Gamification hooks
        const timeSpent = Gamification.getQuestionTime();
        if (isCorrect) {
            Gamification.incrementCombo();
            const trackerData = QuestionTracker._getData();
            const isFirstTry = !trackerData[q.id] || trackerData[q.id].attempts === 0;
            Gamification.awardXp(isFirstTry ? 'firstTryCorrect' : 'correctAnswer', { withCombo: true });
            SoundFX.play('correct');
        } else {
            Gamification.resetCombo();
            SoundFX.play('incorrect');
        }
        Gamification.checkAchievements(isCorrect, timeSpent);
        Gamification.updateCategoryMastery(q.category || 'General', isCorrect);
        Gamification.startQuestionTimer(); // Start timer for next question
        if (isCorrect) Garden.grow(1);

        DailyGoal.recordQuestion();
        DailyGoal.recordCorrect(isCorrect, timeSpent);
        DailyChallenges.trackQuestion(isCorrect, timeSpent);
        if (isCorrect) DailyChallenges.trackStreak(Gamification.getState().combo || 0);
        QuestionTracker.recordSingle(q.id, q.category || 'General', isCorrect, timeSpent);
        this.renderQuestion();
        SessionState.save();
    },

    setConfidence(level) {
        // level: 1 = Maybe, 2 = Probably, 3 = Definitely
        if (this.mode !== 'practice' || this.answers[this.currentQ] === undefined) return;
        this.confidence[this.currentQ] = level;
        this.renderQuestion();
        SessionState.save();
    },

    renderPowerups() {
        const bar = document.getElementById('powerupBar');
        if (!bar) return;
        const isReview = this.mode === 'review-after';
        const isChecked = this.practiceChecked[this.currentQ];
        if (isReview || isChecked || !Gamification.isEnabled()) {
            bar.style.display = 'none';
            return;
        }
        const state = Gamification.getState();
        const inv = state.powerUpInventory;
        const pups = Gamification.POWERUPS;
        let html = '';
        for (const [type, pu] of Object.entries(pups)) {
            const count = inv[type] || 0;
            html += `<button class="powerup-btn" onclick="App.usePowerup('${type}')" ${count <= 0 ? 'disabled' : ''} title="${pu.desc}"><span class="pu-icon">${pu.icon}</span>${pu.name}<span class="pu-count">${count}</span></button>`;
        }
        bar.innerHTML = html;
        bar.style.display = html ? 'flex' : 'none';
    },

    usePowerup(type) {
        const q = this.questions[this.currentQ];
        if (!q) return;
        if (type === 'fiftyFifty') {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            const eliminated = Gamification.applyFiftyFifty(correctIdx, q.options.length);
            if (eliminated.length > 0) {
                this._eliminatedOptions = this._eliminatedOptions || {};
                this._eliminatedOptions[this.currentQ] = eliminated;
                this.renderQuestion();
            }
        } else if (type === 'skipQuestion') {
            if (Gamification.usePowerUp('skipQuestion')) {
                this.practiceResults[this.currentQ] = 'skipped';
                Metrics.endQuestion(this.currentQ);
                this.next();
            }
        } else if (type === 'extraTime') {
            if (this.countdown && Gamification.usePowerUp('extraTime')) {
                this.timerSeconds += 120;
                this.initialTimerSeconds = (this.initialTimerSeconds || this.timerSeconds) + 120;
                if (this.timerSeconds >= 300) document.getElementById('timerDisplay').classList.remove('warning');
                this.updateTimerDisplay();
            }
        } else if (type === 'doubleXp') {
            Gamification.applyDoubleXp();
            this.renderPowerups();
        } else if (type === 'showHint') {
            if (q.explanation && Gamification.usePowerUp('showHint')) {
                const hint = q.explanation.substring(0, Math.min(80, q.explanation.indexOf('.') + 1 || 80)) + '...';
                const panel = document.getElementById('explanationPanel');
                panel.innerHTML = `<h4>Hint</h4><p>${escapeHtml(hint)}</p>`;
                panel.classList.add('show');
                this.renderPowerups();
            }
        }
    },

    goTo(idx) {
        // Track time on current question before switching
        Metrics.endQuestion(this.currentQ);
        this.currentQ = idx;
        this.visited[idx] = true;
        // Start tracking time on new question
        Metrics.startQuestion(idx);
        this.renderQuestion();
        this.updatePalette();
        document.getElementById('questionContainer').scrollIntoView({ behavior: 'smooth', block: 'start' });
        SessionState.save();
    },

    prev() {
        if (this._reviewFilter) {
            const idx = this._reviewFilter.indexOf(this.currentQ);
            if (idx > 0) this.goTo(this._reviewFilter[idx - 1]);
        } else if (this.currentQ > 0) this.goTo(this.currentQ - 1);
    },
    next() {
        if (this._reviewFilter) {
            const idx = this._reviewFilter.indexOf(this.currentQ);
            if (idx < this._reviewFilter.length - 1) this.goTo(this._reviewFilter[idx + 1]);
        } else if (this.currentQ < this.questions.length - 1) this.goTo(this.currentQ + 1);
    },

    skipped: {},
    
    skipQuestion() {
        if (this.submitted) return;
        const qIdx = this.currentQ;
        const q = this.questions[qIdx];
        
        // Mark as skipped
        this.skipped[qIdx] = true;
        
        // Record negative mastery impact (treat as wrong answer for mastery tracking)
        if (q.id && typeof Mastery !== 'undefined') {
            Mastery.record(q.id, false, q.category);
        }
        
        // Move to next question
        if (this.currentQ < this.questions.length - 1) {
            this.next();
        } else {
            // If last question, just update UI
            this.renderQuestion();
            this.updatePalette();
        }
        
        SessionState.save();
    },

    updatePalette() {
        // Update full palette
        for (let i = 0; i < this.questions.length; i++) {
            const el = document.getElementById('qp-' + i);
            if (!el) continue;
            el.className = 'q-num ' + this._getPaletteClass(i);
        }
        // Update mini palette
        this.buildMiniPalette();
        // Update stats bar
        this.updateStats();
    },

    updateStats() {
        const total = this.questions.length;
        const answered = Object.keys(this.answers).length;
        const skipped = Object.keys(this.skipped || {}).length;
        const flagged = Object.keys(this.bookmarked).length;
        const unanswered = total - answered - skipped;

        const elAnswered = document.getElementById('statAnswered');
        const elSkipped = document.getElementById('statSkipped');
        const elUnanswered = document.getElementById('statUnanswered');
        const elFlagged = document.getElementById('statFlagged');

        if (elAnswered) elAnswered.textContent = answered;
        if (elSkipped) elSkipped.textContent = skipped;
        if (elUnanswered) elUnanswered.textContent = Math.max(0, unanswered);
        if (elFlagged) elFlagged.textContent = flagged;
    },

    // Timer
    startTimer() {
        this.stopTimer();
        this.timerPaused = false;
        document.getElementById('timerDisplay').style.visibility = 'visible';
        document.getElementById('timerDisplay').style.opacity = '1';
        document.getElementById('timerToggle').textContent = 'Pause Timer';
        this.updateTimerDisplay();
        this.timerInterval = setInterval(() => {
            if (this.countdown) {
                this.timerSeconds--;
                if (this.timerSeconds <= 300) {
                    document.getElementById('timerDisplay').classList.add('warning');
                }
                if (this.timerSeconds <= 0) {
                    this.timerSeconds = 0;
                    this.submitTest();
                    return;
                }
            } else {
                this.timerSeconds++;
            }
            this.updateTimerDisplay();
            // Save session state every 10 seconds to preserve timer progress
            if (this.timerSeconds % 10 === 0) {
                SessionState.save();
            }
        }, 1000);
    },

    stopTimer() {
        if (this.timerInterval) clearInterval(this.timerInterval);
        this.timerInterval = null;
        document.getElementById('timerDisplay').classList.remove('warning');
    },

    updateTimerDisplay() {
        const s = this.timerSeconds;
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;
        document.getElementById('timerDisplay').textContent =
            `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    },

    toggleTimer() {
        if (this.timerInterval) {
            // Pause: stop interval but keep timerSeconds
            clearInterval(this.timerInterval);
            this.timerInterval = null;
            this.timerPaused = true;
            document.getElementById('timerToggle').textContent = 'Resume Timer';
            document.getElementById('timerDisplay').style.opacity = '0.5';
        } else if (this.timerPaused) {
            // Resume: restart interval from where we left off
            this.timerPaused = false;
            document.getElementById('timerToggle').textContent = 'Pause Timer';
            document.getElementById('timerDisplay').style.opacity = '1';
            this.timerInterval = setInterval(() => {
                if (this.countdown) {
                    this.timerSeconds--;
                    if (this.timerSeconds <= 300) {
                        document.getElementById('timerDisplay').classList.add('warning');
                    }
                    if (this.timerSeconds <= 0) {
                        this.timerSeconds = 0;
                        this.submitTest();
                        return;
                    }
                } else {
                    this.timerSeconds++;
                }
                this.updateTimerDisplay();
                if (this.timerSeconds % 10 === 0) SessionState.save();
            }, 1000);
        }
    },

    // Submit
    showSubmitModal() {
        const answered = Object.keys(this.answers).length;
        document.getElementById('modalAnswered').textContent = answered;
        document.getElementById('modalUnanswered').textContent = this.questions.length - answered;
        document.getElementById('modalBookmarked').textContent = Object.keys(this.bookmarked).length;
        document.getElementById('submitModal').classList.add('active');
    },

    hideSubmitModal() {
        document.getElementById('submitModal').classList.remove('active');
    },

    submitTest() {
        if (this.submitted) return; // Prevent double-click
        this.hideSubmitModal();
        this.submitted = true;
        this.stopTimer();
        Audio.stop();
        Metrics.endQuestion(this.currentQ);
        Session.end();
        SessionState.clear();

        let correct = 0;
        const catScores = {};
        this.questions.forEach((q, i) => {
            const cat = q.category || 'General';
            if (!catScores[cat]) catScores[cat] = { correct: 0, total: 0 };
            catScores[cat].total++;
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (this.answers[i] === correctIdx) {
                correct++;
                catScores[cat].correct++;
            }
        });

        const total = this.questions.length;
        const answered = Object.keys(this.answers).length;
        const pct = Math.round((correct / total) * 1000) / 10;
        const pass = pct >= (this.bank.passingScore || 70);
        const elapsed = Math.round((Date.now() - this.startTime) / 1000);
        const timeStr = this.mode === 'test'
            ? this.formatTime((this.initialTimerSeconds || this.bank.timeLimit || 5400) - this.timerSeconds)
            : this.formatTime(elapsed);

        // Score display
        document.getElementById('scoreBig').textContent = pct + '%';
        document.getElementById('scoreBig').className = 'score-big ' + (pass ? 'pass' : 'fail');
        document.getElementById('scoreLabel').textContent = pass ? 'PASS' : 'NOT YET';
        document.getElementById('scoreCorrect').textContent = correct;
        document.getElementById('scoreIncorrect').textContent = answered - correct;
        document.getElementById('scoreUnanswered').textContent = total - answered;
        document.getElementById('scoreTotal').textContent = total;
        document.getElementById('scoreTime').textContent = timeStr;

        // Category breakdown
        const catHtml = Object.entries(catScores).map(([cat, d]) => {
            if (d.total === 0) return '';
            const p = Math.round((d.correct / d.total) * 100);
            const cls = p >= 70 ? 'good' : p >= 50 ? 'warn' : 'bad';
            return `<div class="cat-row"><span style="min-width:160px">${escapeHtml(cat)}</span><div class="cat-bar"><div class="cat-fill ${cls}" style="width:${p}%"></div></div><span style="min-width:60px;text-align:right">${d.correct}/${d.total} (${p}%)</span></div>`;
        }).join('');
        document.getElementById('categoryBreakdown').innerHTML = '<h3>Category Breakdown</h3>' + catHtml + Metrics.buildMetricsSummary(this.questions, this.answers);

        // Build per-question results for this test
        const questionResults = this.questions.map((q, i) => {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            return {
                qId: q.id,
                category: q.category || 'General',
                correct: this.answers[i] === correctIdx,
                answered: this.answers[i] !== undefined,
                chosen: this.answers[i] !== undefined ? this.answers[i] : null,
                correctAnswer: correctIdx,
                timeSpent: Metrics.questionTimes[i] ? Metrics.questionTimes[i].total : 0,
                confidence: this.confidence[i] || 0
            };
        });

        // Save history with full detail (cap at 50 entries to prevent localStorage bloat)
        const history = Store.get('testHistory_' + this.bank.bankId, []);
        history.push({
            date: new Date().toISOString(), pct, correct, total, time: timeStr,
            mode: this.mode, questions: questionResults
        });
        if (history.length > 50) history.splice(0, history.length - 50);
        Store.set('testHistory_' + this.bank.bankId, history);

        // Update persistent per-question performance tracking  only in test mode (practice already records per-check)
        if (this.mode === 'test') {
            QuestionTracker.recordResults(questionResults);
        }

        // Update global stats
        const stats = DailyGoal.getStats();
        stats.testsCompleted++;
        stats.avgScore = stats.avgScore || 0;
        stats.avgScore = ((stats.avgScore * (stats.testsCompleted - 1)) + pct) / stats.testsCompleted;
        DailyGoal.saveStats(stats);

        // Record questions for daily goal  only in test mode (practice mode already records per-check)
        if (this.mode === 'test') {
            DailyGoal.recordQuestions(answered);
        }

        // Gamification: record test completion
        const isPerfect = pct === 100;
        Gamification.recordTestComplete(pct, isPerfect);

        // Record session for analytics
        const timeSpent = this.initialTimerSeconds - this.timerSeconds;
        StudyAnalytics.recordTestCompletion(this.mode, this.bank?.bankId, correct, total, timeSpent);

        showScreen('score', false, false);
    },

    startReview() {
        this.stopTimer();
        Audio.stop();
        this.mode = 'review-after';
        this._reviewFilter = null;
        this.currentQ = 0;
        document.getElementById('btnSubmit').style.display = 'none';
        document.getElementById('btnCheck').style.display = 'none';
        document.getElementById('modeTab').textContent = 'Review';
        showScreen('exam', true, true);
        this.renderQuestion();
    },

    reviewWrongOnly() {
        this.stopTimer();
        Audio.stop();
        this.mode = 'review-after';
        // Find first wrong question
        const wrongIndices = [];
        this.questions.forEach((q, i) => {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (this.answers[i] !== correctIdx) wrongIndices.push(i);
        });
        if (wrongIndices.length === 0) { alert('No wrong answers!'); return; }
        this._reviewFilter = wrongIndices;
        this.currentQ = wrongIndices[0];
        document.getElementById('btnSubmit').style.display = 'none';
        document.getElementById('btnCheck').style.display = 'none';
        document.getElementById('modeTab').textContent = 'Review (Wrong Only)';
        showScreen('exam', true, true);
        this.renderQuestion();
    },

    drillWrongOnly() {
        if (!this.bank) return;
        const wrongQIds = [];
        this.questions.forEach((q, i) => {
            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (this.answers[i] !== correctIdx) wrongQIds.push(q.id);
        });
        if (wrongQIds.length === 0) { alert('No wrong answers!'); return; }
        Drill.start(this.bank.bankId, wrongQIds);
    },

    retakeTest() {
        if (this.bank) this.start(this.bank.bankId, 'test');
    },

    exitToHome() {
        this.stopTimer();
        Audio.stop();
        Metrics.endQuestion(this.currentQ);
        if (!this.submitted && this.mode === 'test' && Object.keys(this.answers).length > 0) {
            if (!confirm('Leave without submitting? Your progress will be lost.')) return;
        }
        SessionState.clear();
        showScreen('home');
        Home.render();
    },

    // Timer adjustment modal
    showTimerModal() {
        const mins = Math.floor(this.timerSeconds / 60);
        document.getElementById('timerMinutes').value = mins;
        document.getElementById('timerModal').classList.add('active');
    },

    hideTimerModal() {
        document.getElementById('timerModal').classList.remove('active');
    },

    applyTimerChange() {
        const mins = Math.max(1, Math.min(300, parseInt(document.getElementById('timerMinutes').value) || 90));
        const newSeconds = mins * 60;
        const delta = newSeconds - this.timerSeconds;
        this.initialTimerSeconds = (this.initialTimerSeconds || this.timerSeconds) + delta;
        this.timerSeconds = newSeconds;
        this.updateTimerDisplay();
        this.hideTimerModal();
    },

    formatTime(s) {
        const h = Math.floor(s / 3600);
        const m = Math.floor((s % 3600) / 60);
        const sec = s % 60;
        return `${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;
    },

    renderMath() {
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('questionContainer'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                    ]
                });
            } catch {}
        }
    },

    // Get current question context for chat
    getQuestionContext() {
        if (!this.questions[this.currentQ]) return null;
        const q = this.questions[this.currentQ];
        const displayOptions = q._shuffledOptions || q.options;
        return {
            number: this.currentQ + 1,
            text: q.text,
            options: displayOptions,
            correctAnswer: q.correctAnswer,
            correctText: q.options[q.correctAnswer],
            explanation: q.explanation,
            userAnswer: this.answers[this.currentQ],
            userAnswerText: this.answers[this.currentQ] !== undefined ? displayOptions[this.answers[this.currentQ]] : null
        };
    }
};

// =====================================================================
// DRILL MODE (SM-2 Spaced Repetition)
// =====================================================================
/**
 * @namespace Drill
 * @description Spaced repetition drill mode using SM-2 algorithm.
 * Focuses on weak questions with adaptive scheduling.
 * 
 * State:
 * - bank: Current question bank
 * - queue: Questions scheduled for review
 * - current: Currently displayed question
 * 
 * Key methods:
 * - start(bankId, questionIds) - Initialize drill session
 * - render() - Display current drill card
 * - grade(quality) - SM-2 grading (0-5 scale)
 * - next() - Advance to next scheduled question
 */
const Drill = {
    bank: null,
    queue: [],
    current: null,
    sessionCount: 0,
    sessionCorrect: 0,
    showingAnswer: false,
    questionStart: 0,
    SESSION_LIMIT: 20,

    start(bankId, focusQIds) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;
        this._focusQIds = focusQIds || null;
        Session.start(); // Start session timer
        DailyChallenges.trackBank(bankId);
        DailyGoal.recordMode('drill');
        DailyGoal.recordBank(bankId);
        this.sessionCount = 0;
        this.sessionCorrect = 0;
        this.buildQueue();

        if (this.queue.length === 0) {
            showScreen('drill', false, false);
            document.getElementById('drillCard').innerHTML = `
                <div class="drill-session-done">
                    <h2>All caught up!</h2>
                    <p>No questions due for review right now.</p>
                    <button class="btn-nav" style="margin-top:20px" onclick="showScreen('home');Home.render()">Home</button>
                </div>`;
            document.getElementById('drillProgress').textContent = '';
            document.getElementById('chatFab').style.display = '';
            return;
        }

        showScreen('drill', false, false);
        document.getElementById('chatFab').style.display = '';
        Chat.clearHistory();
        this.nextCard();
    },

    getProgress(qId) {
        const all = Store.get('drillProgress', {});
        return all[qId] || { ef: 2.5, interval: 0, reps: 0, nextReview: 0 };
    },

    saveProgress(qId, data) {
        const all = Store.get('drillProgress', {});
        all[qId] = data;
        Store.set('drillProgress', all);
    },

    buildQueue() {
        const now = Date.now();
        const questions = this._focusQIds
            ? this.bank.questions.filter(q => this._focusQIds.includes(q.id))
            : this.bank.questions;
        const scored = questions.map(q => {
            const p = this.getProgress(q.id);
            let priority = 0;
            if (this._focusQIds) {
                priority = 3; // forced focus mode  all high priority
            } else if (p.speedMastered) {
                // Speed mastered (answered fast twice) - almost never show
                priority = 0;
            } else if (p.avgSpeed && p.avgSpeed < 8 && (p.fastCorrect || 0) >= 1) {
                // Fast answers (avg <8s with 1+ fast) - very low priority
                priority = 0;
            } else if (p.nextReview && p.nextReview > now) {
                // Not due yet - skip unless it's struggling
                priority = p.ef < 1.8 ? 1 : 0;
            } else if (p.reps >= 5 && p.ef >= 2.5) {
                // Well-mastered (5+ correct reviews, good ease) - very low priority
                priority = 0;
            } else if (p.nextReview && p.nextReview <= now) {
                // Due for review
                priority = 3;
            } else if (p.reps === 0) {
                // Never seen
                priority = 2;
            } else if (p.ef < 2.0) {
                // Struggling
                priority = 2;
            } else {
                // Seen but not mastered
                priority = 1;
            }
            // Add random factor for variety within same priority
            const randomFactor = Math.random();
            return { question: q, progress: p, priority, randomFactor };
        }).filter(s => s.priority > 0)
          .sort((a, b) => {
              // Sort by priority first, then by ease (lower = harder), then random
              if (b.priority !== a.priority) return b.priority - a.priority;
              if (a.progress.ef !== b.progress.ef) return a.progress.ef - b.progress.ef;
              return a.randomFactor - b.randomFactor;
          });

        // Shuffle within each priority group for variety
        const shuffled = [];
        let currentPriority = null;
        let currentGroup = [];
        for (const item of scored) {
            if (currentPriority !== item.priority) {
                if (currentGroup.length > 0) {
                    // Shuffle the group before adding
                    for (let i = currentGroup.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [currentGroup[i], currentGroup[j]] = [currentGroup[j], currentGroup[i]];
                    }
                    shuffled.push(...currentGroup);
                }
                currentGroup = [item];
                currentPriority = item.priority;
            } else {
                currentGroup.push(item);
            }
        }
        // Don't forget the last group
        if (currentGroup.length > 0) {
            for (let i = currentGroup.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [currentGroup[i], currentGroup[j]] = [currentGroup[j], currentGroup[i]];
            }
            shuffled.push(...currentGroup);
        }

        this.queue = shuffled.slice(0, this.SESSION_LIMIT);
        console.log('[Drill] Queue built:', this.queue.length, 'questions. Priorities:', this.queue.map(q => q.priority).join(','));
    },

    nextCard() {
        if (this.queue.length === 0 || this.sessionCount >= this.SESSION_LIMIT) {
            this.showSessionDone();
            return;
        }

        this.current = this.queue.shift();
        this.showingAnswer = false;
        this.selectedOption = null;
        this.questionStart = Date.now();
        Gamification.startQuestionTimer();

        const dueCount = this.queue.length + 1;
        document.getElementById('drillProgress').innerHTML =
            `<span class="due-count">${dueCount}</span> questions remaining | ${this.sessionCount} completed (${this.sessionCorrect} correct)`;

        const q = this.current.question;
        
        // Shuffle answer options to prevent position memorization
        const optIndices = q.options.map((_, i) => i);
        for (let i = optIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [optIndices[i], optIndices[j]] = [optIndices[j], optIndices[i]];
        }
        this.currentShuffleMap = optIndices;
        this.currentShuffledCorrect = optIndices.indexOf(q.correctAnswer);
        
        document.getElementById('drillCard').innerHTML = `
            <div class="question-text">${formatQuestionText(q.text)}</div>
            <ul class="options-list" id="drillOptions">
                ${optIndices.map((origIdx, displayIdx) => `
                    <li class="option-item" onclick="Drill.selectOption(${displayIdx})" id="dropt-${displayIdx}">
                        <input type="radio" name="drill" value="${displayIdx}">
                        <span class="option-label">${escapeHtml(q.options[origIdx])}</span>
                    </li>
                `).join('')}
            </ul>
            <div class="drill-answer" id="drillAnswer">
                <div class="correct-label" id="drillResultLabel"></div>
                <div class="explanation">${escapeHtml(q.explanation || '')}</div>
                <div class="drill-buttons">
                    <button class="drill-btn btn-got-it" onclick="Drill.nextAfterCheck()">Next Question </button>
                </div>
            </div>
            <div style="text-align:center;margin-top:16px">
                <button class="drill-btn btn-show" id="drillShowBtn" onclick="Drill.checkAnswer()">Check Answer</button>
            </div>
        `;

        // Render inline chart if question has graphData or [Graph:...] placeholder
        if (q.graphData || q.text.includes('[Graph:')) {
            const qtEl = document.querySelector('#drillCard .question-text');
            const graphData = q.graphData || InlineChart.generatePlaceholderGraph(q.text);
            if (qtEl && graphData) InlineChart.renderInElement(qtEl, graphData);
        }

        // Update chat context
        document.getElementById('chatFab').classList.add('has-context');
        this.renderMath();
        SessionState.save();
    },

    selectedOption: null,

    selectOption(i) {
        if (this.showingAnswer) return;
        this.selectedOption = i;
        document.querySelectorAll('#drillOptions .option-item').forEach((el, idx) => {
            el.className = 'option-item' + (idx === i ? ' selected' : '');
        });
        SessionState.save();
    },

    checkAnswer() {
        if (!this.current || this.showingAnswer) return;
        if (this.selectedOption === null) {
            // Must select an answer first
            document.getElementById('drillResultLabel').textContent = 'Please select an answer first';
            document.getElementById('drillResultLabel').style.color = 'var(--yellow)';
            document.getElementById('drillAnswer').classList.add('show');
            setTimeout(() => {
                document.getElementById('drillAnswer').classList.remove('show');
            }, 1500);
            return;
        }
        
        this.showingAnswer = true;
        const q = this.current.question;
        const shuffledCorrect = this.currentShuffledCorrect;

        // Highlight correct/wrong using shuffled positions
        q.options.forEach((_, displayIdx) => {
            const el = document.getElementById('dropt-' + displayIdx);
            if (displayIdx === shuffledCorrect) el.classList.add('correct-answer');
            if (this.selectedOption === displayIdx && displayIdx !== shuffledCorrect) el.classList.add('wrong-answer');
        });

        const isCorrect = this.selectedOption === shuffledCorrect;
        this._lastWasCorrect = isCorrect;
        document.getElementById('drillResultLabel').textContent = isCorrect ? ' Correct!' : ' Incorrect';
        document.getElementById('drillResultLabel').style.color = isCorrect ? 'var(--green)' : 'var(--red)';
        document.getElementById('drillAnswer').classList.add('show');
        document.getElementById('drillShowBtn').style.display = 'none';
        
        // Play sound
        SoundFX.play(isCorrect ? 'correct' : 'incorrect');
    },

    nextAfterCheck() {
        if (!this.current) return;
        const q = this.current.question;
        const p = this.current.progress;
        const isCorrect = this._lastWasCorrect;
        const timeSpent = Gamification.getQuestionTime(); // Get time early for speed tracking
        const timeSpentSec = timeSpent / 1000; // convert ms to seconds
        
        // Modified SM-2: Never lower mastery (ef), but speed heavily influences gains
        // Fast answers = big boost, slow answers = small boost, wrong = no change
        let ef = p.ef;
        let interval = p.interval || 1;
        let reps = p.reps || 0;
        
        if (isCorrect) {
            // Speed bonus: faster = bigger ef increase
            // Under 5s = +0.3, 5-10s = +0.2, 10-20s = +0.1, 20-30s = +0.05, 30s+ = +0.02
            let speedBonus;
            if (timeSpentSec < 5) speedBonus = 0.3;
            else if (timeSpentSec < 10) speedBonus = 0.2;
            else if (timeSpentSec < 20) speedBonus = 0.1;
            else if (timeSpentSec < 30) speedBonus = 0.05;
            else speedBonus = 0.02;
            
            ef = Math.min(3.0, ef + speedBonus); // Cap at 3.0
            reps++;
            
            // Interval progression based on reps and ef
            if (reps === 1) interval = 1;
            else if (reps === 2) interval = 3;
            else interval = Math.round(interval * ef);
        }
        // Wrong answers: don't lower ef, just reset interval for review sooner
        // Keep reps so they don't lose all progress
        if (!isCorrect) {
            interval = 1; // Review again soon
        }

        const nextReview = Date.now() + interval * 86400000;
        
        // Track answer speed for filtering (same as SpeedMode)
        let fastCorrect = p.fastCorrect || 0;
        let avgSpeed = p.avgSpeed;
        if (isCorrect) {
            // Track fast correct answers (under 10 seconds)
            if (timeSpentSec < 10) fastCorrect++;
            avgSpeed = avgSpeed ? (avgSpeed * 0.7 + timeSpentSec * 0.3) : timeSpentSec;
        }
        // Don't reset fastCorrect on wrong - preserve their speed achievements
        
        // Mark as speed mastered if 2+ fast correct answers
        const speedMastered = fastCorrect >= 2 || (reps >= 5 && ef >= 2.5 && avgSpeed && avgSpeed < 10);
        
        this.saveProgress(q.id, { ef, interval, reps, nextReview, fastCorrect, avgSpeed, speedMastered });

        this.sessionCount++;
        if (isCorrect) this.sessionCorrect++;

        // Gamification hooks  gate XP on actual correctness
        if (isCorrect) {
            Gamification.incrementCombo();
            const trackerData = QuestionTracker._getData();
            const isFirstTry = !trackerData[q.id] || trackerData[q.id].attempts === 0;
            Gamification.awardXp(isFirstTry ? 'firstTryCorrect' : 'drillGotIt', { withCombo: true });
        } else {
            Gamification.resetCombo();
        }
        Gamification.checkAchievements(isCorrect, timeSpent);
        Gamification.updateCategoryMastery(q.category || 'General', isCorrect);
        Gamification.startQuestionTimer();
        if (isCorrect) Garden.grow(1);

        // Update drill streak
        const stats = DailyGoal.getStats();
        if (isCorrect) stats.drillStreak++;
        else stats.drillStreak = 0;
        DailyGoal.saveStats(stats);

        // Record question for daily goal
        DailyGoal.recordQuestion();
        DailyGoal.recordCorrect(isCorrect, timeSpent);
        DailyChallenges.trackQuestion(isCorrect, timeSpent);
        DailyChallenges.trackDrill();
        if (isCorrect) DailyChallenges.trackStreak(stats.drillStreak || 0);

        // Track per-question performance (AFTER firstTry check above)
        QuestionTracker.recordSingle(q.id, q.category || 'General', isCorrect, timeSpent);

        SessionState.save();
        this.nextCard();
    },

    showSessionDone() {
        Session.end();
        SessionState.clear();
        
        // Record drill session for analytics
        StudyAnalytics.recordDrillSession(this.sessionCount, this.sessionCount > 0 ? Math.round(this.sessionCorrect/this.sessionCount*100) : 0);
        
        document.getElementById('drillProgress').textContent = '';
        document.getElementById('drillCard').innerHTML = `
            <div class="drill-session-done">
                <h2>Session Complete!</h2>
                <p>${this.sessionCount} questions reviewed</p>
                <p>${this.sessionCorrect} correct (${this.sessionCount > 0 ? Math.round(this.sessionCorrect/this.sessionCount*100) : 0}%)</p>
                <div style="margin-top:20px;display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
                    <button class="drill-btn btn-show" onclick="Drill.start('${escapeHtml(this.bank.bankId)}')">Drill Again</button>
                    <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Home</button>
                </div>
            </div>`;
    },

    renderMath() {
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('drillCard'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                    ]
                });
            } catch {}
        }
    },

    getQuestionContext() {
        if (!this.current) return null;
        const q = this.current.question;
        return {
            number: q.id,
            text: q.text,
            options: q.options,
            correctAnswer: q.correctAnswer,
            correctText: q.options[q.correctAnswer],
            explanation: q.explanation,
            userAnswer: this.selectedOption,
            userAnswerText: this.selectedOption !== null ? q.options[this.selectedOption] : null
        };
    }
};

// =====================================================================
// LEARN MODE - Concept-first learning with AI Q&A
// =====================================================================
const LearnMode = {
    STORAGE_KEY: 'wgu_learnMode',
    currentTopic: null,
    currentCategory: null,
    sessionStart: null,
    
    getState() {
        const raw = localStorage.getItem(this.STORAGE_KEY);
        return raw ? JSON.parse(raw) : {
            topicsViewed: [],           // { topic, category, viewedAt, timeSpent }
            questionsAsked: [],         // { question, category, askedAt }
            categoryProgress: {},       // { [cat]: { topicsViewed: n, questionsAsked: n, timeSpent: n } }
            totalTimeSpent: 0,
            totalTopicsViewed: 0,
            totalQuestionsAsked: 0
        };
    },
    
    saveState(state) {
        localStorage.setItem(this.STORAGE_KEY, JSON.stringify(state));
    },
    
    show() {
        this.render();
        showScreen('learn');
        document.getElementById('learnCoins').innerHTML = '&#x1FA99; ' + Gamification.getState().coins;
    },
    
    render() {
        const el = document.getElementById('learnContent');
        const state = this.getState();
        const banks = window.questionBanks || [];
        
        // Get all unique categories across all banks
        const allCategories = new Set();
        banks.forEach(bank => {
            (bank.questions || []).forEach(q => {
                if (q.category) allCategories.add(q.category);
            });
        });
        
        let html = `
            <div style="margin-bottom:20px">
                <h3 style="color:var(--navy);margin-bottom:8px"> Learn by Topic</h3>
                <p style="color:var(--gray-600);font-size:14px;margin-bottom:16px">
                    Select a category to learn concepts first, then ask questions to the AI tutor.
                    Your learning progress is tracked separately from practice tests.
                </p>
            </div>
            
            <div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:12px;margin-bottom:24px">
        `;
        
        const catProgress = state.categoryProgress || {};
        for (const cat of allCategories) {
            const prog = catProgress[cat] || { topicsViewed: 0, questionsAsked: 0, timeSpent: 0 };
            const timeMin = Math.round(prog.timeSpent / 60000);
            html += `
                <div class="shop-item" style="cursor:pointer" onclick="LearnMode.selectCategory('${cat.replace(/'/g, "\\'")}')">
                    <div class="shop-item-icon"></div>
                    <div class="shop-item-name">${cat}</div>
                    <div class="shop-item-desc">${prog.topicsViewed} topics  ${prog.questionsAsked} questions</div>
                    <div class="shop-item-desc" style="color:var(--gray-500)">${timeMin}m studied</div>
                </div>
            `;
        }
        html += '</div>';
        
        // Learning stats summary
        html += `
            <div style="background:var(--gray-100);border-radius:12px;padding:16px;margin-bottom:20px">
                <h4 style="margin:0 0 8px 0;color:var(--navy)"> Learning Stats</h4>
                <div style="display:flex;gap:24px;flex-wrap:wrap">
                    <div><strong>${state.totalTopicsViewed}</strong> <span style="color:var(--gray-600)">topics viewed</span></div>
                    <div><strong>${state.totalQuestionsAsked}</strong> <span style="color:var(--gray-600)">questions asked</span></div>
                    <div><strong>${Math.round(state.totalTimeSpent / 60000)}m</strong> <span style="color:var(--gray-600)">total study time</span></div>
                </div>
            </div>
        `;
        
        // Recent activity
        if (state.topicsViewed.length > 0) {
            html += `<h4 style="color:var(--navy);margin-bottom:8px"> Recent Topics</h4><div style="display:flex;flex-direction:column;gap:8px;margin-bottom:20px">`;
            const recent = state.topicsViewed.slice(-5).reverse();
            recent.forEach(t => {
                const ago = this._timeAgo(t.viewedAt);
                html += `<div style="background:#fff;padding:10px 14px;border-radius:8px;border:1px solid var(--gray-200)">
                    <strong>${t.topic}</strong> <span style="color:var(--gray-500);font-size:12px"> ${t.category}  ${ago}</span>
                </div>`;
            });
            html += '</div>';
        }
        
        el.innerHTML = html;
    },
    
    selectCategory(category) {
        this.currentCategory = category;
        this.sessionStart = Date.now();
        this.renderCategoryTopics(category);
    },
    
    renderCategoryTopics(category) {
        const el = document.getElementById('learnContent');
        const banks = window.questionBanks || [];
        
        // Get all questions in this category
        const questions = [];
        banks.forEach(bank => {
            (bank.questions || []).forEach(q => {
                if (q.category === category) questions.push(q);
            });
        });
        
        // Group by unique concepts/topics (use question text as topic identifier)
        const topics = [];
        const seen = new Set();
        questions.forEach(q => {
            // Extract a topic from the question - use first 60 chars as identifier
            const topicKey = (q.question || '').slice(0, 60);
            if (!seen.has(topicKey)) {
                seen.add(topicKey);
                topics.push({
                    question: q.question,
                    answer: q.answer,
                    explanation: q.explanation || '',
                    options: q.options || [],
                    difficulty: q.difficulty || 2
                });
            }
        });
        
        let html = `
            <div style="margin-bottom:16px">
                <button class="btn-nav" onclick="LearnMode.render()" style="margin-right:12px"> Back</button>
                <span style="font-size:18px;font-weight:600;color:var(--navy)"> ${category}</span>
                <span style="color:var(--gray-500);margin-left:8px">(${topics.length} concepts)</span>
            </div>
            
            <div style="background:linear-gradient(135deg,#14b8a6,#0d9488);color:#fff;padding:16px;border-radius:12px;margin-bottom:20px">
                <h4 style="margin:0 0 8px 0"> Learning Mode</h4>
                <p style="margin:0;font-size:14px;opacity:0.9">
                    Click on a concept to learn it. The AI tutor will explain it, and you can ask follow-up questions.
                    This is tracked separately from your practice tests.
                </p>
            </div>
            
            <div style="display:flex;flex-direction:column;gap:10px">
        `;
        
        topics.forEach((t, i) => {
            const diffLabel = ['', 'Easy', 'Medium', 'Hard'][t.difficulty] || 'Medium';
            const diffColor = ['', '#22c55e', '#f59e0b', '#ef4444'][t.difficulty] || '#f59e0b';
            html += `
                <div class="shop-item" style="cursor:pointer;text-align:left;padding:14px" onclick="LearnMode.viewTopic(${i}, '${category.replace(/'/g, "\\'")}')">
                    <div style="display:flex;justify-content:space-between;align-items:flex-start;gap:12px">
                        <div style="flex:1">
                            <div style="font-weight:600;color:var(--navy);margin-bottom:4px">${t.question.slice(0, 100)}${t.question.length > 100 ? '...' : ''}</div>
                            <div style="font-size:12px;color:var(--gray-500)">Click to learn this concept</div>
                        </div>
                        <span style="background:${diffColor};color:#fff;padding:2px 8px;border-radius:4px;font-size:11px;font-weight:600">${diffLabel}</span>
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        el.innerHTML = html;
        
        // Store topics for later reference
        this._currentTopics = topics;
    },
    
    viewTopic(index, category) {
        const topic = this._currentTopics[index];
        if (!topic) return;
        
        this.currentTopic = topic;
        const el = document.getElementById('learnContent');
        
        // Track this topic view
        const state = this.getState();
        state.topicsViewed.push({
            topic: topic.question.slice(0, 60),
            category: category,
            viewedAt: Date.now(),
            timeSpent: 0
        });
        state.totalTopicsViewed++;
        state.categoryProgress[category] = state.categoryProgress[category] || { topicsViewed: 0, questionsAsked: 0, timeSpent: 0 };
        state.categoryProgress[category].topicsViewed++;
        this.saveState(state);
        
        // Award XP for learning
        Gamification.awardXP(5, 'Learned a concept');
        
        const correctAnswer = topic.options[topic.answer] || topic.options[0] || '';
        
        let html = `
            <div style="margin-bottom:16px">
                <button class="btn-nav" onclick="LearnMode.renderCategoryTopics('${category.replace(/'/g, "\\'")}')" style="margin-right:12px"> Back to Topics</button>
            </div>
            
            <div style="background:#fff;border-radius:16px;padding:24px;box-shadow:0 4px 20px rgba(0,0,0,0.08);margin-bottom:20px">
                <h3 style="color:var(--navy);margin:0 0 16px 0"> Concept</h3>
                <p style="font-size:16px;line-height:1.6;color:var(--gray-800);margin-bottom:20px">${topic.question}</p>
                
                <div style="background:linear-gradient(135deg,#22c55e,#16a34a);color:#fff;padding:16px;border-radius:12px;margin-bottom:16px">
                    <h4 style="margin:0 0 8px 0"> Answer</h4>
                    <p style="margin:0;font-size:15px">${correctAnswer}</p>
                </div>
                
                ${topic.explanation ? `
                <div style="background:var(--gray-100);padding:16px;border-radius:12px;margin-bottom:16px">
                    <h4 style="margin:0 0 8px 0;color:var(--navy)"> Explanation</h4>
                    <p style="margin:0;color:var(--gray-700);line-height:1.6">${topic.explanation}</p>
                </div>
                ` : ''}
                
                <div style="background:var(--gray-50);padding:16px;border-radius:12px">
                    <h4 style="margin:0 0 12px 0;color:var(--navy)"> All Options</h4>
                    <ul style="margin:0;padding-left:20px;color:var(--gray-700)">
                        ${topic.options.map((opt, i) => `<li style="margin-bottom:6px;${i === topic.answer ? 'font-weight:600;color:var(--green)' : ''}">${opt}${i === topic.answer ? ' ' : ''}</li>`).join('')}
                    </ul>
                </div>
            </div>
            
            <div style="background:linear-gradient(135deg,#6366f1,#4f46e5);color:#fff;padding:20px;border-radius:16px;margin-bottom:20px">
                <h4 style="margin:0 0 12px 0"> Ask the AI Tutor</h4>
                <p style="margin:0 0 12px 0;font-size:14px;opacity:0.9">Have questions about this concept? Ask the AI tutor for clarification.</p>
                <div style="display:flex;gap:8px;flex-wrap:wrap">
                    <button class="btn-nav" style="background:#fff;color:#4f46e5;border:none" onclick="LearnMode.askAI('Explain this concept in simpler terms')">Simplify</button>
                    <button class="btn-nav" style="background:#fff;color:#4f46e5;border:none" onclick="LearnMode.askAI('Give me a real-world example')">Example</button>
                    <button class="btn-nav" style="background:#fff;color:#4f46e5;border:none" onclick="LearnMode.askAI('Why is this important?')">Why Important</button>
                    <button class="btn-nav" style="background:#fff;color:#4f46e5;border:none" onclick="LearnMode.askAI('What are common mistakes?')">Common Mistakes</button>
                </div>
                <div style="margin-top:12px">
                    <input type="text" id="learnAskInput" placeholder="Or type your own question..." style="width:100%;padding:10px 14px;border-radius:8px;border:none;font-size:14px" onkeypress="if(event.key==='Enter')LearnMode.askCustom()">
                </div>
            </div>
            
            <div id="learnAIResponse" style="display:none;background:#fff;border-radius:16px;padding:20px;box-shadow:0 4px 20px rgba(0,0,0,0.08)">
                <h4 style="margin:0 0 12px 0;color:var(--navy)"> AI Response</h4>
                <div id="learnAIContent" style="color:var(--gray-700);line-height:1.6"></div>
            </div>
        `;
        
        el.innerHTML = html;
    },
    
    askAI(prompt) {
        const topic = this.currentTopic;
        if (!topic) return;
        
        // Track question
        const state = this.getState();
        state.questionsAsked.push({
            question: prompt,
            category: this.currentCategory,
            askedAt: Date.now()
        });
        state.totalQuestionsAsked++;
        if (this.currentCategory) {
            state.categoryProgress[this.currentCategory] = state.categoryProgress[this.currentCategory] || { topicsViewed: 0, questionsAsked: 0, timeSpent: 0 };
            state.categoryProgress[this.currentCategory].questionsAsked++;
        }
        this.saveState(state);
        
        // Show response area
        const responseEl = document.getElementById('learnAIResponse');
        const contentEl = document.getElementById('learnAIContent');
        responseEl.style.display = 'block';
        contentEl.innerHTML = '<div style="color:var(--gray-500)">Thinking...</div>';
        
        // Build context for AI
        const context = `
The student is learning about this concept:
Question: ${topic.question}
Correct Answer: ${topic.options[topic.answer] || ''}
${topic.explanation ? 'Explanation: ' + topic.explanation : ''}

The student asks: "${prompt}"

Please provide a helpful, educational response. Be concise but thorough. Use simple language.
        `.trim();
        
        // Use the existing Chat AI if available
        if (typeof Chat !== 'undefined' && Chat.sendToAI) {
            Chat.sendToAI(context).then(response => {
                contentEl.innerHTML = response.replace(/\n/g, '<br>');
            }).catch(err => {
                contentEl.innerHTML = '<span style="color:var(--red)">Error getting response. Please try again.</span>';
            });
        } else {
            contentEl.innerHTML = 'AI tutor not available. Please check your API settings.';
        }
    },
    
    askCustom() {
        const input = document.getElementById('learnAskInput');
        const question = input.value.trim();
        if (!question) return;
        input.value = '';
        this.askAI(question);
    },
    
    _timeAgo(ts) {
        const diff = Date.now() - ts;
        const mins = Math.floor(diff / 60000);
        if (mins < 1) return 'just now';
        if (mins < 60) return mins + 'm ago';
        const hrs = Math.floor(mins / 60);
        if (hrs < 24) return hrs + 'h ago';
        const days = Math.floor(hrs / 24);
        return days + 'd ago';
    },
    
    // Track time spent when leaving
    trackTimeSpent() {
        if (this.sessionStart && this.currentCategory) {
            const elapsed = Date.now() - this.sessionStart;
            const state = this.getState();
            state.totalTimeSpent += elapsed;
            if (state.categoryProgress[this.currentCategory]) {
                state.categoryProgress[this.currentCategory].timeSpent += elapsed;
            }
            this.saveState(state);
            this.sessionStart = null;
        }
    }
};

// =====================================================================
// SPEED MODE (Rush/Hot Seat)
// =====================================================================
/**
 * @namespace SpeedMode
 * @description Timed speed drill mode. Answer fast for coin multipliers.
 * Questions weighted by mastery - weak questions appear more often.
 */
const SpeedMode = {
    bank: null,
    queue: [],
    current: null,
    score: 0,
    coins: 0,
    streak: 0,
    questionsAnswered: 0,
    timerInterval: null,
    timeRemaining: 0,
    maxTime: 30,
    selectedOption: null,
    isActive: false, // Track if speed mode is currently running

    // Fallback time limits by difficulty (seconds) - used when no baseline exists
    // Hard questions get MORE time because they're harder!
    TIME_LIMITS: { easy: 20, medium: 25, hard: 35 },
    
    // Difficulty modifiers (reduce baseline time by this percentage)
    DIFFICULTY_MODIFIERS: { easy: 0.10, medium: 0.20, hard: 0.35 },
    
    // Minimum time allowed (seconds)
    MIN_TIME: 8,
    // Maximum time allowed (seconds)  
    MAX_TIME: 60,

    /**
     * Get baseline time for a SPECIFIC QUESTION from its own history
     * @param {string} questionId - The question ID
     * @returns {number|null} Average time in seconds, or null if no data
     */
    getQuestionBaseline(questionId) {
        const trackerData = Store.get('questionTracker', {});
        const qData = trackerData[questionId];
        
        if (!qData || !qData.history || qData.history.length === 0) return null;
        
        // Get times from this specific question's history
        const times = qData.history
            .map(attempt => attempt.timeMs || attempt.time || 0)
            .filter(t => t > 0);
        
        if (times.length === 0) return null;
        
        // Use last 5 attempts for this specific question
        const recent = times.slice(-5);
        const avgMs = recent.reduce((sum, t) => sum + t, 0) / recent.length;
        return Math.round(avgMs / 1000);
    },

    /**
     * Calculate time limit based on question's OWN history + difficulty
     * Each question earns its own time limit based on YOUR performance on THAT question
     * @param {string} questionId - The question ID
     * @param {number} difficulty - 1=easy, 2=medium, 3=hard
     * @returns {object} { time: seconds, isAdaptive: boolean, baseline: number|null }
     */
    getAdaptiveTimeLimit(questionId, difficulty) {
        const baseline = this.getQuestionBaseline(questionId);
        
        if (!baseline) {
            // Never seen this question - use generous default by difficulty
            const defaultTime = difficulty === 1 ? this.TIME_LIMITS.easy 
                              : difficulty === 3 ? this.TIME_LIMITS.hard 
                              : this.TIME_LIMITS.medium;
            return { time: defaultTime, isAdaptive: false, baseline: null };
        }
        
        // You've answered this before - give you your average time + buffer
        // Hard questions get MORE buffer because they're harder!
        let buffer;
        if (difficulty === 1) buffer = 1.0;      // Easy: no buffer needed
        else if (difficulty === 3) buffer = 1.3; // Hard: +30% extra time
        else buffer = 1.15;                       // Medium: +15% buffer
        
        const adjustedTime = Math.round(baseline * buffer);
        
        // Clamp to min/max bounds
        const finalTime = Math.max(this.MIN_TIME, Math.min(this.MAX_TIME, adjustedTime));
        return { time: finalTime, isAdaptive: true, baseline };
    },

    start(bankId) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;

        Session.start();
        DailyGoal.recordMode('speed');
        DailyGoal.recordBank(bankId);
        this.score = 0;
        this.coins = 0;
        this.streak = 0;
        this.questionsAnswered = 0;
        this.selectedOption = null;

        this.buildQueue();
        if (this.queue.length === 0) {
            alert('No questions available for Speed Mode.');
            return;
        }

        this.isActive = true;
        showScreen('speed', false, false);
        this.updateDisplay();
        this.nextQuestion();
    },

    buildQueue() {
        const drillProgress = Store.get('drillProgress', {});
        const now = Date.now();

        // Filter and weight questions - speed mastered and unsuitable questions are EXCLUDED
        const weighted = this.bank.questions.map(q => {
            const prog = drillProgress[q.id] || { ef: 2.5, reps: 0 };
            
            // Questions answered wrong 5+ times in speed mode - NOT SUITABLE for speed mode
            // These need more thought/time, better for drill mode
            if (prog.notSpeedSuitable) {
                return { question: q, weight: 0, ef: prog.ef, excluded: 'too_hard' };
            }
            
            // Speed mastered questions - SKIP entirely (weight 0)
            // You've proven you know this, no need to see it again in speed mode
            if (prog.speedMastered) {
                return { question: q, weight: 0, ef: prog.ef, mastered: true };
            }
            
            // Questions answered fast (avg under 8s) with at least 1 fast correct - very low weight
            if (prog.avgSpeed && prog.avgSpeed < 8 && (prog.fastCorrect || 0) >= 1) {
                return { question: q, weight: 0.1, ef: prog.ef, mastered: false };
            }
            
            // High EF (2.6+) with 2+ reps = you know this well, low weight
            if (prog.ef >= 2.6 && prog.reps >= 2) {
                return { question: q, weight: 0.15, ef: prog.ef, mastered: false };
            }
            
            // Weight: new questions = 3, weak (low EF) = 2-3, learning = 1.5, strong = 0.5
            let weight = 1;
            if (prog.reps === 0) weight = 3;           // Never seen - prioritize
            else if (prog.ef < 1.8) weight = 3;        // Very weak - need practice
            else if (prog.ef < 2.2) weight = 2;        // Weak
            else if (prog.ef < 2.5) weight = 1.5;      // Learning
            else weight = 0.5;                          // Strong

            return { question: q, weight, ef: prog.ef, mastered: false };
        }).filter(item => item.weight > 0); // Remove mastered and unsuitable questions

        // Shuffle with weighting - prioritizes weak questions
        this.queue = [];
        const pool = [...weighted];
        while (pool.length > 0 && this.queue.length < 50) {
            const totalWeight = pool.reduce((s, p) => s + p.weight, 0);
            let rand = Math.random() * totalWeight;
            for (let i = 0; i < pool.length; i++) {
                rand -= pool[i].weight;
                if (rand <= 0) {
                    this.queue.push(pool[i]);
                    pool.splice(i, 1);
                    break;
                }
            }
        }
    },

    nextQuestion() {
        this.stopTimer();
        
        // Don't continue if SpeedMode was stopped
        if (!this.isActive) return;

        if (this.queue.length === 0) {
            this.buildQueue(); // Refill if empty
        }

        if (this.queue.length === 0) {
            this.end();
            return;
        }

        this.current = this.queue.shift();
        this.selectedOption = null;

        // Determine time based on THIS QUESTION's history and difficulty
        const q = this.current.question;
        const difficulty = q.difficulty || 2;
        
        // Use adaptive timing based on YOUR history with THIS SPECIFIC QUESTION
        const timing = this.getAdaptiveTimeLimit(q.id, difficulty);
        this.maxTime = timing.time;
        this.currentTiming = timing; // Store for display

        this.timeRemaining = this.maxTime;
        this.renderQuestion();
        this.startTimer();
    },

    renderQuestion() {
        const q = this.current.question;
        const difficulty = q.difficulty || 2;
        const category = q.category || 'General';
        const diffLabel = difficulty === 1 ? 'Easy' : difficulty === 3 ? 'Hard' : 'Medium';
        const diffColor = difficulty === 1 ? 'var(--green)' : difficulty === 3 ? 'var(--red)' : 'var(--orange)';
        const diffMultiplier = difficulty === 3 ? '3x' : difficulty === 1 ? '1x' : '2x';
        
        // Check if using adaptive timing (per-question based)
        const timing = this.currentTiming || { isAdaptive: false };
        const timingLabel = timing.isAdaptive ? `${this.maxTime}s` : `${this.maxTime}s`;
        const timingTitle = timing.isAdaptive ? `Based on your avg ${timing.baseline}s on this question` : 'First time seeing this question';

        // Shuffle answer options to prevent position memorization
        const optIndices = q.options.map((_, i) => i);
        for (let i = optIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [optIndices[i], optIndices[j]] = [optIndices[j], optIndices[i]];
        }
        this.currentShuffleMap = optIndices;
        this.currentShuffledCorrect = optIndices.indexOf(q.correctAnswer);

        const optionsHtml = optIndices.map((origIdx, displayIdx) => `
            <button class="speed-option drill-option" onclick="SpeedMode.selectOption(${displayIdx})" data-idx="${displayIdx}">
                <span class="option-letter">${String.fromCharCode(65 + displayIdx)}</span>
                <span class="option-text">${escapeHtml(q.options[origIdx])}</span>
            </button>
        `).join('');

        document.getElementById('speedCard').innerHTML = `
            <div style="margin-bottom:8px;display:flex;align-items:center;gap:8px;flex-wrap:wrap">
                <span style="font-size:11px;color:${diffColor};font-weight:bold">${diffLabel}</span>
                <span style="font-size:10px;background:${diffColor};color:#fff;padding:2px 6px;border-radius:8px;font-weight:bold">${diffMultiplier} coins</span>
                <span style="font-size:10px;color:var(--gray-500)">${escapeHtml(category)}</span>
                <span style="font-size:11px;color:var(--gray-500);margin-left:auto;cursor:help" title="${timingTitle}">${timingLabel}</span>
            </div>
            <div class="drill-question speed-question-text" style="font-size:16px;margin-bottom:16px">${formatQuestionText(q.text)}</div>
            <div class="speed-options" style="display:flex;flex-direction:column;gap:8px">${optionsHtml}</div>
        `;

        this.renderMath();
        
        // Render inline chart if question has graphData or [Graph:...] placeholder
        const qtEl = document.querySelector('.speed-question-text');
        if (qtEl && (q.graphData || q.text.includes('[Graph:'))) {
            const graphData = q.graphData || InlineChart.generatePlaceholderGraph(q.text);
            if (graphData) InlineChart.renderInElement(qtEl, graphData);
        }
    },

    selectOption(idx) {
        if (this.selectedOption !== null) return; // Already answered
        this.selectedOption = idx;
        this.stopTimer();

        const q = this.current.question;
        const shuffledCorrect = this.currentShuffledCorrect;
        const isCorrect = idx === shuffledCorrect;
        const timeUsed = this.maxTime - this.timeRemaining;
        const timeRatio = this.timeRemaining / this.maxTime;

        // Highlight answer using shuffled positions
        const options = document.querySelectorAll('.speed-option');
        options.forEach((opt, i) => {
            opt.disabled = true;
            if (i === shuffledCorrect) opt.classList.add('correct');
            else if (i === idx && !isCorrect) opt.classList.add('incorrect');
        });

        if (isCorrect) {
            this.streak++;
            this.questionsAnswered++;

            // Base coins by difficulty (harder = more reward)
            const difficulty = q.difficulty || 2;
            const difficultyBonus = difficulty === 3 ? 20 : difficulty === 1 ? 5 : 10; // Hard=20, Medium=10, Easy=5
            const baseCoins = 10 + difficultyBonus; // Guaranteed 15-30 coins per correct

            // Calculate speed multiplier based on time remaining
            let speedMultiplier = 1;
            if (timeRatio >= 0.8) speedMultiplier = 3;      // Super fast (80%+ time left)
            else if (timeRatio >= 0.6) speedMultiplier = 2; // Fast (60%+ time left)
            else if (timeRatio >= 0.4) speedMultiplier = 1.5; // Good (40%+ time left)
            else speedMultiplier = 1;                        // Normal

            // Streak bonus (additive, not multiplicative for more consistent rewards)
            let streakBonus = 0;
            if (this.streak >= 10) streakBonus = 15;
            else if (this.streak >= 5) streakBonus = 8;
            else if (this.streak >= 3) streakBonus = 3;

            const earnedCoins = Math.round(baseCoins * speedMultiplier) + streakBonus;
            const scoreGain = Math.round(50 + (100 * timeRatio) + (difficulty * 25) + (this.streak * 5));
            this.coins += earnedCoins;
            this.score += scoreGain;

            // Award actual coins
            Gamification.awardCoins(earnedCoins);
            Gamification.incrementCombo();
            SoundFX.play('correct');

            // Show feedback with difficulty label
            const diffLabel = difficulty === 3 ? 'HARD' : difficulty === 1 ? 'Easy' : 'Med';
            this.showFeedback(`+${earnedCoins} `, 'var(--green)', speedMultiplier, diffLabel);
        } else {
            // Wrong answer: small penalty but keep some streak momentum
            this.streak = Math.max(0, this.streak - 2); // Lose 2 streak instead of full reset
            Gamification.resetCombo();
            SoundFX.play('incorrect');
            // Still give participation points for trying
            this.score += 10;
            this.showFeedback('Miss! +10', 'var(--orange)', 0);
        }

        // Track question
        QuestionTracker.recordSingle(q.id, q.category || 'General', isCorrect, timeUsed * 1000);
        Gamification.updateCategoryMastery(q.category || 'General', isCorrect);
        DailyGoal.recordQuestion();
        DailyGoal.recordCorrect(isCorrect, timeUsed * 1000);
        DailyChallenges.trackQuestion(isCorrect, timeUsed * 1000);
        if (isCorrect) DailyChallenges.trackStreak(Gamification.getState().combo || 0);
        
        // Update drill progress (SM-2) based on speed + correctness
        this.updateDrillProgress(q.id, isCorrect, timeRatio);

        this.updateDisplay();

        // Auto-advance after brief delay
        setTimeout(() => this.nextQuestion(), isCorrect ? 800 : 1500);
    },

    showFeedback(text, color, multiplier, diffLabel) {
        // Remove any existing feedback first
        document.querySelectorAll('.speed-feedback-overlay').forEach(el => el.remove());
        
        const feedback = document.createElement('div');
        feedback.className = 'speed-feedback-overlay';
        feedback.style.cssText = `position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:48px;font-weight:bold;color:${color};text-shadow:2px 2px 4px rgba(0,0,0,.3);z-index:9999;animation:speedFeedback 0.8s ease-out forwards;pointer-events:none;text-align:center`;
        feedback.textContent = text;
        if (diffLabel) {
            const diffColor = diffLabel === 'HARD' ? '#dc2626' : diffLabel === 'Easy' ? '#22c55e' : '#f59e0b';
            feedback.innerHTML += `<div style="font-size:16px;color:${diffColor};margin-top:4px">${diffLabel} Question</div>`;
        }
        if (multiplier > 1) {
            feedback.innerHTML += `<div style="font-size:24px">${multiplier}x SPEED!</div>`;
        }
        document.body.appendChild(feedback);
        setTimeout(() => feedback.remove(), 800);
    },

    startTimer() {
        this.updateTimerDisplay();
        this.timerInterval = setInterval(() => {
            this.timeRemaining -= 0.1;
            this.updateTimerDisplay();

            if (this.timeRemaining <= 0) {
                this.timeUp();
            }
        }, 100);
    },

    stopTimer() {
        if (this.timerInterval) {
            clearInterval(this.timerInterval);
            this.timerInterval = null;
        }
    },
    
    // Fully stop SpeedMode (called when leaving screen)
    stop() {
        this.stopTimer();
        this.isActive = false;
    },

    timeUp() {
        this.stopTimer();
        if (this.selectedOption !== null) return;

        // Time ran out - mark as wrong
        this.streak = 0;
        Gamification.resetCombo();
        SoundFX.play('incorrect');

        const q = this.current.question;
        const options = document.querySelectorAll('.speed-option');
        options.forEach((opt, i) => {
            opt.disabled = true;
            if (i === q.correctAnswer) opt.classList.add('correct');
        });

        QuestionTracker.recordSingle(q.id, q.category || 'General', false, this.maxTime * 1000);
        this.updateDrillProgress(q.id, false, 0); // Timeout = wrong with 0 time ratio
        this.showFeedback(' TIME!', 'var(--red)', 0);
        this.updateDisplay();

        setTimeout(() => this.nextQuestion(), 1500);
    },

    updateTimerDisplay() {
        const timerEl = document.getElementById('speedTimer');
        const barEl = document.getElementById('speedTimerBar');
        if (timerEl) timerEl.textContent = Math.ceil(this.timeRemaining);
        if (barEl) barEl.style.width = `${(this.timeRemaining / this.maxTime) * 100}%`;

        // Color based on time
        if (timerEl) {
            if (this.timeRemaining <= 5) timerEl.style.color = 'var(--red)';
            else if (this.timeRemaining <= 10) timerEl.style.color = 'var(--orange)';
            else timerEl.style.color = 'var(--green)';
        }
    },

    updateDisplay() {
        document.getElementById('speedScore').textContent = this.score;
        document.getElementById('speedCoins').textContent = ` ${this.coins}`;
        document.getElementById('speedStreak').textContent = ` ${this.streak}`;

        let mult = 1;
        if (this.streak >= 10) mult = 3;
        else if (this.streak >= 5) mult = 2;
        document.getElementById('speedMultiplier').textContent = `${mult}x`;
    },

    end() {
        this.stopTimer();
        this.isActive = false;
        Session.end();
        
        // Record speed session for analytics (treat as test with score as accuracy proxy)
        if (this.questionsAnswered > 0) {
            StudyAnalytics.recordTestCompletion('speed', this.bank?.bankId, this.questionsAnswered, this.questionsAnswered, 0);
        }
        
        // Clean up any lingering feedback overlays
        document.querySelectorAll('.speed-feedback-overlay').forEach(el => el.remove());

        document.getElementById('speedCard').innerHTML = `
            <div class="drill-session-done" style="text-align:center;padding:30px">
                <h2> Speed Round Complete!</h2>
                <div style="font-size:48px;margin:20px 0">${this.score}</div>
                <p style="font-size:14px;color:var(--gray-600)">points</p>
                <div style="margin:20px 0;font-size:24px;color:var(--orange)"> ${this.coins} coins earned!</div>
                <p>${this.questionsAnswered} questions answered</p>
                <p>Best streak:  ${this.streak}</p>
                <div style="margin-top:24px;display:flex;gap:12px;justify-content:center;flex-wrap:wrap">
                    <button class="drill-btn btn-show" onclick="SpeedMode.start('${escapeHtml(this.bank.bankId)}')">Play Again</button>
                    <button class="btn-nav btn-home" onclick="showScreen('home');Home.render()">Home</button>
                </div>
            </div>
        `;
    },

    renderMath() {
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('speedCard'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                    ]
                });
            } catch {}
        }
    },

    // Update drill progress (SM-2) based on speed + correctness
    // Speed Mode gives BIGGER mastery boosts for correct answers (net positive)
    // Wrong answers have minimal impact - time pressure is forgiving
    updateDrillProgress(qId, isCorrect, timeRatio) {
        const all = Store.get('drillProgress', {});
        const p = all[qId] || { ef: 2.5, interval: 0, reps: 0, nextReview: 0 };
        
        let ef, interval, reps;
        
        // Track answer speed - timeRatio is (timeRemaining / maxTime), higher = faster
        // Convert to actual seconds used: actualTime = maxTime * (1 - timeRatio)
        const actualTimeUsed = this.maxTime * (1 - timeRatio); // seconds to answer
        
        if (isCorrect) {
            // CORRECT: Big mastery boost - question shows up much less
            // Fast answers = even bigger boost
            const speedBonus = timeRatio >= 0.6 ? 0.2 : timeRatio >= 0.3 ? 0.1 : 0;
            ef = Math.min(3.0, p.ef + 0.15 + speedBonus); // Bigger EF increase than normal
            
            // Accelerated rep progression - questions disappear faster
            reps = p.reps + 1;
            if (reps === 1) interval = 2;       // 2 days (vs 1 in drill)
            else if (reps === 2) interval = 5;  // 5 days (vs 3 in drill)
            else if (reps === 3) interval = 10; // 10 days - question is "learned"
            else interval = Math.min(60, Math.round(p.interval * ef * 1.2)); // Faster scaling
            
            // Track fast correct answers (under 10 seconds)
            const fastCorrect = (p.fastCorrect || 0) + (actualTimeUsed < 10 ? 1 : 0);
            const avgSpeed = p.avgSpeed ? (p.avgSpeed * 0.7 + actualTimeUsed * 0.3) : actualTimeUsed;
            
            // Mark as "speed mastered" after 2 correct in speed mode (was 3)
            // OR 2 fast correct answers (under 10s) = you know this cold
            const speedMastered = (reps >= 2 && ef >= 2.4) || fastCorrect >= 2;
            
            // Reset speed wrong count on correct answer
            all[qId] = { ...all[qId], fastCorrect, avgSpeed, speedMastered, speedWrongCount: 0 };
        } else {
            // WRONG: Never lower mastery - just schedule for sooner review
            ef = p.ef; // Keep EF unchanged
            reps = p.reps; // Keep reps - don't punish for speed mode mistakes
            interval = 1; // Review soon
            // Don't reset fastCorrect - preserve speed achievements
            
            // Track wrong answers in speed mode - too many = not a speed question
            const speedWrongCount = (p.speedWrongCount || 0) + 1;
            
            // If wrong 5+ times in speed mode, mark as "not suitable for speed mode"
            // These questions need more time/thought - better for drill mode
            const notSpeedSuitable = speedWrongCount >= 5;
            
            all[qId] = { ...all[qId], speedWrongCount, notSpeedSuitable };
        }
        
        const nextReview = Date.now() + interval * 86400000;
        all[qId] = { ...all[qId], ef, interval, reps, nextReview };
        Store.set('drillProgress', all);
    }
};

// =====================================================================
// REVIEW MODE
// =====================================================================
const Review = {
    bank: null,

    start(bankId) {
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;
        Session.start(); // Start session timer

        // Populate category filter
        const cats = [...new Set(this.bank.questions.map(q => q.category || 'General'))];
        const catSelect = document.getElementById('reviewCatFilter');
        catSelect.innerHTML = '<option value="">All Categories</option>' + cats.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
        document.getElementById('reviewSearch').value = '';
        document.getElementById('reviewDiffFilter').value = '';

        showScreen('review');
        this.render();
    },

    render() {
        if (!this.bank) return;
        const catFilter = document.getElementById('reviewCatFilter').value;
        const diffFilter = document.getElementById('reviewDiffFilter').value;
        const search = document.getElementById('reviewSearch').value.toLowerCase();

        let filtered = this.bank.questions.filter(q => {
            if (catFilter && (q.category || 'General') !== catFilter) return false;
            if (diffFilter && String(q.difficulty) !== diffFilter) return false;
            if (search && !q.text.toLowerCase().includes(search) && !q.options.some(o => o.toLowerCase().includes(search))) return false;
            return true;
        });

        // Group by category
        const groups = {};
        filtered.forEach(q => {
            const cat = q.category || 'General';
            if (!groups[cat]) groups[cat] = [];
            groups[cat].push(q);
        });

        const drillData = Store.get('drillProgress', {});
        const diffLabels = { 1: 'Easy', 2: 'Medium', 3: 'Hard' };
        const notesData = Store.get(`notes_${this.bank.bankId}`, {});

        let html = '';
        Object.entries(groups).forEach(([cat, questions]) => {
            html += `<div class="review-category">
                <h3 tabindex="0" role="button" onclick="this.nextElementSibling.style.display=this.nextElementSibling.style.display==='none'?'block':'none';this.querySelector('.toggle-arrow').classList.toggle('collapsed')" onkeydown="if(event.key==='Enter'||event.key===' '){event.preventDefault();this.click()}">
                    ${escapeHtml(cat)} (${questions.length})
                    <span class="toggle-arrow">&#9660;</span>
                </h3>
                <div>`;
            questions.forEach(q => {
                const mastery = drillData[q.id];
                const masteryLabel = mastery ? (mastery.ef >= 2.5 && mastery.reps >= 3 ? 'Mastered' : mastery.reps > 0 ? 'Learning' : 'New') : 'New';
                const note = notesData[q.id] || '';
                html += `<div class="review-q">
                    <div class="rq-text" data-qid="${q.id}"><strong>Q${q.id}.</strong> ${formatQuestionText(q.text)}</div>
                    <ul class="rq-options">
                        ${q.options.map((opt, i) => `<li class="rq-opt ${i === q.correctAnswer ? 'rq-correct' : ''}">${String.fromCharCode(65+i)}. ${escapeHtml(opt)}</li>`).join('')}
                    </ul>
                    ${q.explanation ? `<div class="rq-explanation">${escapeHtml(q.explanation)}</div>` : ''}
                    ${note ? `<div class="rq-note"><div class="rq-note-label">Your Note:</div>${escapeHtml(note).replace(/\n/g, '<br>')}</div>` : ''}
                    <div class="rq-meta">
                        <span class="rq-tag">${diffLabels[q.difficulty] || 'Medium'}</span>
                        <span class="rq-tag">${masteryLabel}</span>
                        ${(q.tags || []).map(t => `<span class="rq-tag">${escapeHtml(t)}</span>`).join('')}
                    </div>
                </div>`;
            });
            html += '</div></div>';
        });

        if (html === '') html = '<p style="text-align:center;color:var(--gray-600);padding:40px">No questions match your filters.</p>';
        document.getElementById('reviewContent').innerHTML = html;

        // Render inline charts in review mode
        filtered.forEach(q => {
            if (q.graphData || q.text.includes('[Graph:')) {
                const el = document.querySelector(`.rq-text[data-qid="${q.id}"]`);
                const graphData = q.graphData || InlineChart.generatePlaceholderGraph(q.text);
                if (el && graphData) InlineChart.renderInElement(el, graphData);
            }
        });

        // Render math
        if (window.renderMathInElement) {
            try {
                renderMathInElement(document.getElementById('reviewContent'), {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                    ]
                });
            } catch {}
        }
    }
};

// =====================================================================
// SETTINGS
// =====================================================================
// =====================================================================
// THEME MANAGEMENT
// =====================================================================
const Theme = {
    THEMES: ['system', 'light', 'dark', 'cengage-light', 'cengage-dark', 'synthwave'],

    // Apply theme
    apply(theme) {
        const root = document.documentElement;
        const body = document.body;

        // Remove any existing theme attribute
        root.removeAttribute('data-theme');
        body.removeAttribute('data-theme');

        if (theme !== 'system') {
            root.setAttribute('data-theme', theme);
            body.setAttribute('data-theme', theme);
        }
        // 'system' = no data-theme attribute, CSS handles it via prefers-color-scheme

        // Save preference
        Store.set('theme', theme);

        // Update select if it exists (may not on initial load)
        const select = document.getElementById('settingTheme');
        if (select && select.value !== theme) {
            select.value = theme;
        }
    },

    // Load and apply saved theme preference
    load() {
        const saved = Store.get('theme', 'system');
        this.apply(saved);
        return saved;
    },

    // Get current effective theme (for components that need to know)
    getCurrent() {
        const saved = Store.get('theme', 'system');
        if (saved !== 'system') return saved;
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    },

    // Check if current theme is dark-variant (for graph colors, etc.)
    isDark() {
        const t = this.getCurrent();
        return t === 'dark' || t === 'cengage-dark' || t === 'synthwave';
    }
};


// =====================================================================
// AI PRACTICE MODE
// =====================================================================
/**
 * @namespace AIPractice
 * @description AI-powered practice mode that generates questions dynamically
 * using an LLM API. Includes preloading buffer, weak area analysis, and
 * confidence-based question weighting.
 * 
 * State:
 * - bank: Reference bank for context
 * - currentQuestion: Currently displayed AI question
 * - sessionStats: { total, correct, byCategory }
 * - weakCategories: Categories needing more practice
 * - questionBuffer: Preloaded questions for instant display
 * 
 * Key methods:
 * - start(bank) - Initialize AI practice session
 * - generateQuestion() - Generate next question via API
 * - checkAnswer() - Validate user's answer
 * - analyzeWeakAreas() - Identify categories needing focus
 */
const AIPractice = {
    bank: null,
    currentQuestion: null,
    selectedOption: null,
    isChecked: false,
    isGenerating: false,
    sessionStats: { total: 0, correct: 0, byCategory: {}, byType: {} },
    weakCategories: [],
    currentCategory: null,
    currentDifficulty: 2,
    startingWeakness: {},
    BUFFER_SIZE: 3,
    _questionBuffer: [],
    _prefetchInFlight: 0,
    _recentQuestionTypes: [], // Track recent question types to avoid repetition
    _masteredTypes: [], // Types answered correctly multiple times (session)
    _globalMasteredTypes: {}, // Persistent mastery tracking {type: {correct: n, total: n, lastSeen: timestamp}}
    currentShuffleMap: null, // Shuffled option indices for current question
    currentShuffledCorrect: null, // Correct answer index in shuffled order

    async start(bankId) {
        if (this.isGenerating) return; // Prevent double-start while generating
        this.bank = BankManager.getBank(bankId);
        if (!this.bank) return;

        // Check for API key
        const provider = Store.get('provider', 'anthropic');
        const apiKey = provider === 'openai' ? Store.get('openaiKey', '') : Store.get('anthropicKey', '');
        if (!apiKey) {
            alert(`Please set your ${provider === 'openai' ? 'OpenAI' : 'Anthropic'} API key in Settings first to use AI Practice mode.`);
            return;
        }

        Session.start();
        DailyGoal.recordMode('ai');
        DailyGoal.recordBank(bankId);
        this.sessionStats = { total: 0, correct: 0, byCategory: {}, byType: {} };
        this.currentQuestion = null;
        this.selectedOption = null;
        this.isChecked = false;
        this.currentDifficulty = 2;
        this._questionBuffer = [];
        this._prefetchInFlight = 0;
        this.currentShuffleMap = null;
        this.currentShuffledCorrect = null;
        this._recentQuestionTypes = [];
        this._masteredTypes = [];
        
        // Load persistent mastery data
        this._globalMasteredTypes = Store.get('aiMasteredTypes_' + bankId, {});

        this.analyzeWeakAreas();
        this.startingWeakness = {};
        this.weakCategories.forEach(wc => {
            this.startingWeakness[wc.category] = wc.score;
        });

        showScreen('ai-practice', false, false);
        document.getElementById('chatFab').style.display = '';
        Chat.clearHistory();
        document.getElementById('chatFab').classList.add('has-context');

        await this.generateNext();
    },

    analyzeWeakAreas() {
        const drillData = Store.get('drillProgress', {});
        const testHistory = Store.get('testHistory_' + this.bank.bankId, []);
        const catScores = {};

        // Guard against empty or missing questions
        const questions = this.bank?.questions || [];
        if (questions.length === 0) {
            this.weakCategories = [{ category: 'General', score: 50, questionCount: 0 }];
            return;
        }

        // Initialize categories from bank
        const categories = [...new Set(questions.map(q => q.category || 'General'))];
        categories.forEach(cat => {
            catScores[cat] = { drillEF: [], testScores: [], questionCount: 0 };
        });

        // Gather drill EF scores per category
        questions.forEach(q => {
            const cat = q.category || 'General';
            catScores[cat].questionCount++;
            const prog = drillData[q.id];
            if (prog && prog.reps > 0) {
                catScores[cat].drillEF.push(prog.ef);
            }
        });

        // Gather test history category scores from per-question results
        testHistory.slice(-5).forEach(test => {
            if (test.questions) {
                const catResults = {};
                test.questions.forEach(q => {
                    const cat = q.category || 'General';
                    if (!catResults[cat]) catResults[cat] = { correct: 0, total: 0 };
                    catResults[cat].total++;
                    if (q.correct) catResults[cat].correct++;
                });
                Object.entries(catResults).forEach(([cat, d]) => {
                    const score = d.total > 0 ? Math.round((d.correct / d.total) * 100) : 0;
                    if (catScores[cat]) catScores[cat].testScores.push(score);
                });
            }
        });

        // Calculate weakness score for each category
        // Lower is weaker (needs more practice)
        const weaknessScores = [];
        Object.entries(catScores).forEach(([cat, data]) => {
            let score = 50; // Default neutral score

            // Factor in drill EF (0-5 scale, higher is better)
            if (data.drillEF.length > 0) {
                const avgEF = data.drillEF.reduce((a, b) => a + b, 0) / data.drillEF.length;
                score = (avgEF / 5) * 100; // Convert to 0-100
            }

            // Factor in test scores
            if (data.testScores.length > 0) {
                const avgTestScore = data.testScores.reduce((a, b) => a + b, 0) / data.testScores.length;
                if (data.drillEF.length > 0) {
                    score = (score + avgTestScore) / 2;
                } else {
                    score = avgTestScore;
                }
            }

            // Penalize categories with less practice
            const practiceRatio = data.drillEF.length / Math.max(data.questionCount, 1);
            if (practiceRatio < 0.5) {
                score *= 0.8; // 20% penalty for low practice
            }

            weaknessScores.push({ category: cat, score, questionCount: data.questionCount });
        });

        // Sort by score (lowest first = weakest)
        weaknessScores.sort((a, b) => a.score - b.score);
        this.weakCategories = weaknessScores;
    },

    pickNextCategory() {
        // Prioritize weak categories with randomization to avoid repetition
        const sessionCatStats = this.sessionStats.byCategory;

        // Re-analyze weak areas periodically based on session performance
        if (this.sessionStats.total > 0 && this.sessionStats.total % 5 === 0) {
            this._updateWeakAreasFromSession();
        }

        // Collect all weak categories that need practice (below 80% or < 3 attempts)
        const needsPractice = [];
        for (const wc of this.weakCategories) {
            const sessionData = sessionCatStats[wc.category];
            if (!sessionData) {
                needsPractice.push({ ...wc, priority: 3 }); // Not attempted = high priority
            } else {
                const sessionPct = sessionData.total > 0 ?
                    (sessionData.correct / sessionData.total) * 100 : 0;
                if (sessionPct < 80 || sessionData.total < 3) {
                    // Lower accuracy = higher priority, fewer attempts = higher priority
                    const priority = (100 - sessionPct) / 100 + (3 - Math.min(sessionData.total, 3)) / 3;
                    needsPractice.push({ ...wc, priority });
                }
            }
        }

        if (needsPractice.length > 0) {
            // Weighted random selection - higher priority = more likely to be picked
            // But avoid picking the same category twice in a row
            const lastCategory = this.currentCategory;
            let candidates = needsPractice.filter(c => c.category !== lastCategory);
            if (candidates.length === 0) candidates = needsPractice; // Only one category left
            
            // Weight by priority (higher priority = more weight)
            const totalWeight = candidates.reduce((sum, c) => sum + c.priority, 0);
            let random = Math.random() * totalWeight;
            for (const c of candidates) {
                random -= c.priority;
                if (random <= 0) return c.category;
            }
            return candidates[0].category;
        }

        // If all are at 80%+, randomly pick from categories with fewest attempts
        const byAttempts = [...this.weakCategories].sort((a, b) => {
            const aAttempts = sessionCatStats[a.category]?.total || 0;
            const bAttempts = sessionCatStats[b.category]?.total || 0;
            return aAttempts - bAttempts;
        });
        // Get all with same low attempt count and pick randomly
        const minAttempts = sessionCatStats[byAttempts[0]?.category]?.total || 0;
        const lowAttemptCats = byAttempts.filter(c => 
            (sessionCatStats[c.category]?.total || 0) <= minAttempts + 1
        );
        const randomIdx = Math.floor(Math.random() * lowAttemptCats.length);
        return lowAttemptCats[randomIdx]?.category || this.weakCategories[0]?.category || 'General';
    },

    // Dynamically update weak areas based on session performance
    _updateWeakAreasFromSession() {
        const sessionCatStats = this.sessionStats.byCategory;
        
        // Recalculate weakness scores incorporating session data
        this.weakCategories = this.weakCategories.map(wc => {
            const sessionData = sessionCatStats[wc.category];
            if (sessionData && sessionData.total >= 2) {
                const sessionAccuracy = (sessionData.correct / sessionData.total) * 100;
                // Blend original score with session performance (session weighted more)
                const blendedScore = (wc.score * 0.3) + (sessionAccuracy * 0.7);
                return { ...wc, score: blendedScore, sessionTotal: sessionData.total };
            }
            return wc;
        });
        
        // Re-sort by weakness (lowest first)
        this.weakCategories.sort((a, b) => a.score - b.score);
        
        // Clear buffer if performance changed significantly - new questions will target updated weak areas
        if (this._questionBuffer.length > 1) {
            this._questionBuffer = this._questionBuffer.slice(0, 1); // Keep only next question
        }
    },

    adjustDifficulty() {
        const cat = this.currentCategory;
        const catStats = this.sessionStats.byCategory[cat];

        if (!catStats || catStats.total < 2) {
            this.currentDifficulty = 2;
            return;
        }

        const recentAccuracy = catStats.correct / catStats.total;

        // Adaptive difficulty - more responsive
        if (recentAccuracy >= 0.75 && this.currentDifficulty < 3) {
            this.currentDifficulty = Math.min(3, this.currentDifficulty + 1);
        } else if (recentAccuracy < 0.5 && this.currentDifficulty > 1) {
            this.currentDifficulty = Math.max(1, this.currentDifficulty - 1);
        }
    },

    async generateNext() {
        if (this.isGenerating) return;
        if (!navigator.onLine) {
            this.renderError('You are offline. AI Practice requires an internet connection.');
            return;
        }
        this.isGenerating = true;
        this.currentQuestion = null;
        this.selectedOption = null;
        this.isChecked = false;

        this.renderProgress();
        this.renderLoading();

        try {
            await this._ensureBuffer();
            const payload = this._questionBuffer.shift();
            if (!payload) throw new Error('Failed to load question');
            this.currentQuestion = payload.question;
            this.currentCategory = payload.category;
            this.currentDifficulty = payload.difficulty;
            // Reset shuffle state for new question
            this.currentShuffleMap = null;
            this.currentShuffledCorrect = null;
            this.renderQuestion();
            Gamification.startQuestionTimer();
            SessionState.save();
            this._prefillBuffer();
        } catch (err) {
            this.renderError(err.message || 'Failed to generate question. Please try again.');
        }

        this.isGenerating = false;
    },

    _planNextTarget() {
        const category = this.pickNextCategory();
        let difficulty = 2;
        const catStats = this.sessionStats.byCategory[category];
        if (catStats && catStats.total >= 2) {
            const recentAccuracy = catStats.correct / catStats.total;
            if (recentAccuracy >= 0.8) difficulty = Math.min(3, (this.currentDifficulty || 2) + 1);
            else if (recentAccuracy < 0.5) difficulty = Math.max(1, (this.currentDifficulty || 2) - 1);
        }
        return { category, difficulty };
    },

    async _ensureBuffer() {
        if (!this._questionBuffer) this._questionBuffer = [];
        if (this._questionBuffer.length > 0) return;
        await this._queueFetch(true);
        if (this._questionBuffer.length === 0) throw new Error('Unable to preload question.');
    },

    _prefillBuffer() {
        if (!this._questionBuffer) this._questionBuffer = [];
        while (this._questionBuffer.length + this._prefetchInFlight < this.BUFFER_SIZE) {
            this._queueFetch(false);
        }
    },

    async _queueFetch(blocking) {
        const target = this._planNextTarget();
        if (!target.category) return;
        this._prefetchInFlight++;
        try {
            const question = await this.generateQuestion(target.category, target.difficulty);
            this._questionBuffer.push({ question, ...target });
        } catch (err) {
            if (blocking) throw err;
            console.warn('Prefetch failed:', err?.message || err);
        } finally {
            this._prefetchInFlight = Math.max(0, this._prefetchInFlight - 1);
        }
    },

    async generateQuestion(category, difficulty, retryCount = 0) {
        const MAX_RETRIES = 2;
        const provider = Store.get('provider', 'anthropic');
        const apiKey = provider === 'openai' ? Store.get('openaiKey', '') : Store.get('anthropicKey', '');

        // Get sample questions from this category to understand the style
        const sampleQuestions = this.bank.questions
            .filter(q => (q.category || 'General') === category)
            .slice(0, 3)
            .map(q => `Q: ${q.text.substring(0, 200)}...`);

        const difficultyLabel = difficulty === 1 ? 'Easy' : difficulty === 2 ? 'Medium' : 'Hard';
        const bankCategories = this.bank.categories || [];

        // Build avoid list from recent question types and truly mastered types
        const avoidTypes = this._recentQuestionTypes.slice(-5).join(', ');
        const sessionMastered = this._masteredTypes.slice(0, 10);
        const globalMastered = this._getTrulyMasteredTypes();
        // Combine session and global mastered, dedupe
        const allMastered = [...new Set([...sessionMastered, ...globalMastered])];
        const masteredTypes = allMastered.slice(0, 15).join(', ');

        const systemPrompt = `You are generating practice questions for WGU Applied Algebra assessments.

CATEGORY: ${category}
DIFFICULTY: ${difficultyLabel} (${difficulty}/3)
BANK CATEGORIES: ${bankCategories.join(', ')}

${sampleQuestions.length > 0 ? `SAMPLE QUESTIONS FROM THIS CATEGORY (use similar style):
${sampleQuestions.join('\n')}` : ''}

${avoidTypes ? `AVOID THESE QUESTION TYPES (recently asked): ${avoidTypes}` : ''}
${masteredTypes ? `STUDENT HAS MASTERED: ${masteredTypes} - focus on other concepts` : ''}

INSTRUCTIONS:
1. Generate ONE multiple choice question about "${category}"
2. Match the style of WGU pre-assessment questions
3. Include realistic scenarios when appropriate (business contexts, real-world applications)
4. For ${difficultyLabel} difficulty:
   ${difficulty === 1 ? '- Use straightforward calculations or interpretations\n   - Clear, direct questions' : ''}
   ${difficulty === 2 ? '- Include multi-step reasoning\n   - May require interpretation of data or graphs' : ''}
   ${difficulty === 3 ? '- Complex scenarios with multiple concepts\n   - Requires deep understanding and careful analysis' : ''}
5. Make distractors (wrong answers) plausible but clearly incorrect
6. Provide a thorough explanation of why the correct answer is right
7. IMPORTANT: Generate a DIFFERENT type of problem than recent questions - vary the concept/formula/scenario

CRITICAL RULES:
- NEVER reveal or hint at the correct answer in the question text
- NEVER include phrases like "the answer is", "correct answer", "option A is right", etc.
- The question text must be neutral and not give away the answer
- Only provide exactly 4 options (A, B, C, D) - never 5 options
- Do NOT add any commentary, hints, or explanations outside the JSON

DATA INCLUSION RULES (VERY IMPORTANT):
- NEVER reference external data that isn't shown. If you mention a table, chart, graph, or data set, the ACTUAL VALUES must be in the question text.
- FORBIDDEN PHRASES: "the table below", "see the graph", "the function table shows", "as shown in", "refer to the data"
- INSTEAD: Embed all data directly. Example: "A car depreciates as follows: Year 2006: $22,800 | Year 2007: $19,380 | Year 2008: $16,473 | Year 2009: $14,002 | Year 2010: $11,902. Based on this data..."
- For depreciation/growth problems: List at least 4-5 actual data points with specific values
- For function tables: Write out each row explicitly (x=1, y=5 | x=2, y=8 | x=3, y=11...)
- The student CANNOT see any external images, tables, or graphs - everything must be TEXT in the question

You MUST respond with ONLY valid JSON in this EXACT format (no markdown, no extra text, no commentary before or after):
{
    "question": "The full question text here",
    "options": ["Option A text", "Option B text", "Option C text", "Option D text"],
    "correctAnswer": 0,
    "explanation": "Detailed explanation of why the correct answer is right and why others are wrong...",
    "questionType": "Brief label for this question type (e.g., 'compound interest', 'slope calculation', 'linear equation')"
}

IMPORTANT: correctAnswer is a 0-based index (0 for first option, 1 for second, etc.)`;

        const userMessage = `Generate a ${difficultyLabel.toLowerCase()} difficulty question about "${category}" for Applied Algebra.`;

        try {
            let responseText;
            if (provider === 'openai') {
                responseText = await this._callOpenAI(apiKey, systemPrompt, userMessage);
            } else {
                responseText = await this._callAnthropic(apiKey, systemPrompt, userMessage);
            }

            // Parse JSON response
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (!jsonMatch) {
                throw new Error('Invalid response format from AI');
            }

            let parsed;
            try {
                parsed = JSON.parse(jsonMatch[0]);
            } catch (jsonErr) {
                throw new Error('AI returned malformed JSON. Please try again.');
            }

            // Validate response structure
            if (!parsed.question || !Array.isArray(parsed.options) || parsed.options.length < 2 ||
                typeof parsed.correctAnswer !== 'number' || !parsed.explanation) {
                throw new Error('Incomplete question generated');
            }

            // Validate correctAnswer is within bounds
            if (parsed.correctAnswer < 0 || parsed.correctAnswer >= parsed.options.length) {
                throw new Error('Invalid correct answer index from AI');
            }

            // Ensure exactly 4 options
            if (parsed.options.length !== 4) {
                console.warn('[AI Practice] Got', parsed.options.length, 'options, expected 4');
                // Trim to 4 or pad if needed
                while (parsed.options.length > 4) parsed.options.pop();
                while (parsed.options.length < 4) parsed.options.push('N/A');
                if (parsed.correctAnswer >= parsed.options.length) parsed.correctAnswer = 0;
            }

            // Sanitize question text - remove any answer hints that AI might have added
            let cleanQuestion = parsed.question;
            const hintPatterns = [
                /\b(the\s+)?(correct\s+)?answer\s+is\s+[A-D]/gi,
                /\boption\s+[A-D]\s+is\s+(correct|right)/gi,
                /\b[A-D]\s+is\s+(the\s+)?(correct|right)\s+answer/gi,
                /looking\s+at\s+the\s+choices.*?correct/gi,
                /need\s+help\s+working\s+through/gi,
                /just\s+a\s+quick\s+check/gi
            ];
            for (const pattern of hintPatterns) {
                cleanQuestion = cleanQuestion.replace(pattern, '').trim();
            }

            // Check for missing data references - if question mentions table/graph but has no actual data
            const missingDataPatterns = [
                /\b(the\s+)?(table|graph|chart|data|function\s+table)\s+(below|above|shown|provided)\b/i,
                /\bbelow\s+is\s+a\s+(table|graph|chart|function)/i,
                /\brefer\s+to\s+the\s+(table|graph|chart|data)/i,
                /\bas\s+shown\s+in\s+the\s+(table|graph|chart)/i
            ];
            const hasDataReference = missingDataPatterns.some(p => p.test(cleanQuestion));
            // Check if question actually contains numeric data (at least 3 numbers with context)
            const dataPointPattern = /(\$?\d+[,.]?\d*)/g;
            const dataPoints = cleanQuestion.match(dataPointPattern) || [];
            const hasActualData = dataPoints.length >= 4; // At least 4 numbers suggests real data
            
            if (hasDataReference && !hasActualData) {
                console.warn('[AI Practice] Question references missing data, retry:', retryCount);
                if (retryCount < MAX_RETRIES) {
                    return this.generateQuestion(category, difficulty, retryCount + 1);
                }
                throw new Error('Question references data that is not included after retries.');
            }

            return {
                question: cleanQuestion,
                options: parsed.options,
                correctAnswer: parsed.correctAnswer,
                explanation: parsed.explanation,
                category: category,
                difficulty: difficulty
            };
        } catch (err) {
            // Retry on validation errors
            if (retryCount < MAX_RETRIES && err.message?.includes('Regenerating')) {
                return this.generateQuestion(category, difficulty, retryCount + 1);
            }
            throw err;
        }
    },

    async _callAnthropic(apiKey, systemPrompt, userMessage) {
        const model = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({
                model,
                max_tokens: 1500,
                system: systemPrompt,
                messages: [{ role: 'user', content: userMessage }]
            })
        });
        clearTimeout(timeout);

        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`API error: ${err.error?.message || resp.statusText}`);
        }

        const data = await resp.json();
        return data.content?.[0]?.text || '';
    },

    async _callOpenAI(apiKey, systemPrompt, userMessage) {
        const model = Store.get('openaiModel', 'gpt-4o-mini');
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify({
                model,
                max_tokens: 1500,
                messages: [
                    { role: 'system', content: systemPrompt },
                    { role: 'user', content: userMessage }
                ]
            })
        });
        clearTimeout(timeout);

        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`API error: ${err.error?.message || resp.statusText}`);
        }

        const data = await resp.json();
        return data.choices?.[0]?.message?.content || '';
    },

    selectOption(i) {
        if (this.isChecked || this.isGenerating) return;
        this.selectedOption = i;
        this.renderQuestion();
        SessionState.save();
    },

    checkAnswer() {
        if (this.selectedOption === null || this.isChecked) return;

        this.isChecked = true;
        const shuffledCorrect = this.currentShuffledCorrect !== null ? this.currentShuffledCorrect : this.currentQuestion.correctAnswer;
        const isCorrect = this.selectedOption === shuffledCorrect;

        // Gamification hooks
        const timeSpent = Gamification.getQuestionTime();
        if (isCorrect) {
            Gamification.incrementCombo();
            Gamification.awardXp('correctAnswer', { withCombo: true });
            SoundFX.play('correct');
        } else {
            Gamification.resetCombo();
            SoundFX.play('incorrect');
        }
        Gamification.checkAchievements(isCorrect, timeSpent);
        Gamification.updateCategoryMastery(this.currentCategory || 'General', isCorrect);
        Gamification.startQuestionTimer();
        if (isCorrect) Garden.grow(1);

        // Update session stats
        this.sessionStats.total++;
        if (isCorrect) this.sessionStats.correct++;

        const cat = this.currentCategory;
        if (!this.sessionStats.byCategory[cat]) {
            this.sessionStats.byCategory[cat] = { correct: 0, total: 0 };
        }
        this.sessionStats.byCategory[cat].total++;
        if (isCorrect) this.sessionStats.byCategory[cat].correct++;

        // Track question type for variety
        const qType = this.currentQuestion.questionType;
        if (qType) {
            this._recentQuestionTypes.push(qType);
            if (this._recentQuestionTypes.length > 10) this._recentQuestionTypes.shift();
            
            // Track by type stats
            if (!this.sessionStats.byType[qType]) {
                this.sessionStats.byType[qType] = { correct: 0, total: 0 };
            }
            this.sessionStats.byType[qType].total++;
            if (isCorrect) this.sessionStats.byType[qType].correct++;
            
            // If answered correctly 2+ times, mark as mastered for this session
            const typeStats = this.sessionStats.byType[qType];
            if (typeStats.correct >= 2 && !this._masteredTypes.includes(qType)) {
                this._masteredTypes.push(qType);
            }
            
            // Update persistent mastery tracking
            this._updateGlobalMastery(qType, isCorrect);
        }

        // Record question for daily goal
        DailyGoal.recordQuestion();
        DailyGoal.recordCorrect(isCorrect, timeSpent);
        DailyChallenges.trackQuestion(isCorrect, timeSpent);
        if (isCorrect) DailyChallenges.trackStreak(Gamification.getState().combo || 0);

        // Track per-question performance and update drill progress
        const qId = this.currentQuestion.id || ('ai_' + Date.now() + '_' + this.sessionStats.total);
        console.log('[AI Practice] Recording question:', qId, 'Category:', this.currentCategory, 'Correct:', isCorrect);
        QuestionTracker.recordSingle(qId, this.currentCategory || 'General', isCorrect, timeSpent);
        
        // Update drill progress (SM-2) for AI questions - helps integrate with overall mastery
        this._updateDrillProgress(qId, isCorrect, timeSpent);

        // Update global stats
        const globalStats = Store.get('globalStats', {});
        globalStats.aiPracticeTotal = (globalStats.aiPracticeTotal || 0) + 1;
        globalStats.aiPracticeCorrect = (globalStats.aiPracticeCorrect || 0) + (isCorrect ? 1 : 0);
        Store.set('globalStats', globalStats);

        this.renderProgress();
        this.renderQuestion();
        SessionState.save();
    },

    saveSessionStats() {
        const sessionKey = 'aiPracticeSession_' + this.bank.bankId;
        const sessions = Store.get(sessionKey, []);
        const currentSession = {
            date: new Date().toISOString(),
            stats: { ...this.sessionStats }
        };

        // Keep last 20 sessions
        sessions.push(currentSession);
        if (sessions.length > 20) sessions.shift();
        Store.set(sessionKey, sessions);
    },

    checkMastery() {
        // Check if all weak categories have reached 80%+ with at least 3 attempts
        for (const wc of this.weakCategories.slice(0, 5)) { // Focus on top 5 weakest
            const catStats = this.sessionStats.byCategory[wc.category];
            if (!catStats || catStats.total < 3) return false;
            if ((catStats.correct / catStats.total) < 0.8) return false;
        }
        return this.sessionStats.total >= 10; // At least 10 questions
    },

    endSession() {
        Session.end();
        this.saveSessionStats();
        SessionState.clear();
        
        // Record AI practice session for analytics
        if (this.sessionStats.total > 0) {
            StudyAnalytics.recordTestCompletion('ai', 'ai-practice', this.sessionStats.correct, this.sessionStats.total, 0);
        }
        
        this.renderSummary();
    },

    renderProgress() {
        const el = document.getElementById('aiProgress');
        const pct = this.sessionStats.total > 0 ?
            Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) : 0;

        let weakCatsHtml = '<div class="weak-areas"><strong>Targeting weak areas:</strong> ';
        this.weakCategories.slice(0, 5).forEach(wc => {
            const isCurrent = wc.category === this.currentCategory;
            weakCatsHtml += `<span class="weak-cat${isCurrent ? ' current' : ''}">${escapeHtml(wc.category)}</span>`;
        });
        weakCatsHtml += '</div>';

        el.innerHTML = `
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <div class="targeting" style="margin:0">AI Practice Mode</div>
                <div class="toolbar" style="gap:6px">
                    <button class="tool-btn" onclick="Calc.toggle()" title="Calculator (C)">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 14h-2v-2h2v2zm0-4h-2V9h2v4zm4 4h-2v-6h2v6zm0-8h-2V7h2v2zm-8 8H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2z"/></svg>
                        Calc
                    </button>
                    <button class="tool-btn" onclick="Audio.speak()" title="Read question aloud">
                        <svg viewBox="0 0 24 24" fill="currentColor" style="width:14px;height:14px"><path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02z"/></svg>
                        Audio
                    </button>
                    <button class="tool-btn" onclick="showScreen('home');Home.render()" title="Exit to Home">
                        
                    </button>
                </div>
            </div>
            <div class="session-stats">
                <div class="session-stat">
                    <div class="val">${this.sessionStats.correct}</div>
                    <div class="lbl">Correct</div>
                </div>
                <div class="session-stat">
                    <div class="val">${this.sessionStats.total}</div>
                    <div class="lbl">Total</div>
                </div>
                <div class="session-stat">
                    <div class="val">${pct}%</div>
                    <div class="lbl">Accuracy</div>
                </div>
            </div>
            ${weakCatsHtml}
        `;
    },

    renderLoading() {
        const el = document.getElementById('aiCard');
        el.innerHTML = `
            <div class="ai-loading">
                <div class="spinner"></div>
                <p>Generating a new question about <strong>${escapeHtml(this.currentCategory)}</strong>...</p>
                <p style="font-size:12px;color:var(--gray-500);margin-top:8px">
                    Difficulty: ${this.currentDifficulty === 1 ? 'Easy' : this.currentDifficulty === 2 ? 'Medium' : 'Hard'}
                </p>
            </div>
        `;
    },

    renderQuestion() {
        if (!this.currentQuestion) return;

        const q = this.currentQuestion;
        const el = document.getElementById('aiCard');

        // Difficulty indicator
        let diffHtml = '<div class="ai-difficulty"><span>Difficulty:</span><div class="diff-indicator">';
        for (let i = 1; i <= 3; i++) {
            diffHtml += `<span class="diff-dot${i <= q.difficulty ? ' filled' : ''}"></span>`;
        }
        diffHtml += '</div><span>' + (q.difficulty === 1 ? 'Easy' : q.difficulty === 2 ? 'Medium' : 'Hard') + '</span></div>';

        // Shuffle answer options on first render (not when re-rendering after check)
        if (!this.isChecked && this.currentShuffleMap === null) {
            const optIndices = q.options.map((_, i) => i);
            for (let i = optIndices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [optIndices[i], optIndices[j]] = [optIndices[j], optIndices[i]];
            }
            this.currentShuffleMap = optIndices;
            this.currentShuffledCorrect = optIndices.indexOf(q.correctAnswer);
        }
        
        const shuffleMap = this.currentShuffleMap || q.options.map((_, i) => i);
        const shuffledCorrect = this.currentShuffledCorrect !== null ? this.currentShuffledCorrect : q.correctAnswer;

        // Options
        let optionsHtml = '<ul class="options-list">';
        shuffleMap.forEach((origIdx, displayIdx) => {
            let cls = 'option-item';
            if (this.selectedOption === displayIdx) cls += ' selected';
            if (this.isChecked) {
                cls += ' disabled';
                if (displayIdx === shuffledCorrect) cls += ' correct-answer';
                if (this.selectedOption === displayIdx && displayIdx !== shuffledCorrect) cls += ' wrong-answer';
            }
            optionsHtml += `
                <li class="${cls}" onclick="AIPractice.selectOption(${displayIdx})">
                    <input type="radio" name="aiopt" value="${displayIdx}" ${this.selectedOption === displayIdx ? 'checked' : ''} ${this.isChecked ? 'disabled' : ''}>
                    <span class="option-label">${escapeHtml(q.options[origIdx])}</span>
                </li>
            `;
        });
        optionsHtml += '</ul>';

        // Explanation
        let explanationHtml = '';
        if (this.isChecked) {
            const isCorrect = this.selectedOption === shuffledCorrect;
            explanationHtml = `
                <div class="ai-explanation${isCorrect ? '' : ' incorrect'}">
                    <h4>${isCorrect ? 'Correct!' : 'Incorrect'}</h4>
                    <p>${escapeHtml(q.explanation)}</p>
                </div>
            `;
        }

        // Buttons
        let buttonsHtml = '<div class="ai-buttons">';
        if (!this.isChecked) {
            buttonsHtml += `
                <button class="ai-btn btn-check" onclick="AIPractice.checkAnswer()" ${this.selectedOption === null ? 'disabled' : ''}>Check Answer</button>
                <button class="ai-btn btn-end" onclick="AIPractice.endSession()">End Session</button>
            `;
        } else {
            const masteryReached = this.checkMastery();
            if (masteryReached) {
                buttonsHtml += `
                    <button class="ai-btn btn-next" onclick="AIPractice.endSession()" style="background:var(--green)">
                        Mastery Reached! View Summary
                    </button>
                `;
            } else {
                buttonsHtml += `
                    <button class="ai-btn btn-next" onclick="AIPractice.generateNext()">Next Question</button>
                    <button class="ai-btn btn-end" onclick="AIPractice.endSession()">End Session</button>
                `;
            }
        }
        buttonsHtml += '</div>';

        el.innerHTML = `
            ${diffHtml}
            <div class="question-text">${escapeHtml(q.question).replace(/\n/g, '<br>')}</div>
            ${optionsHtml}
            ${explanationHtml}
            ${buttonsHtml}
        `;

        // Render math if present
        if (window.renderMathInElement) {
            try {
                renderMathInElement(el, {
                    delimiters: [
                        { left: "\\[", right: "\\]", display: true },
                        { left: "\\(", right: "\\)", display: false },
                    ]
                });
            } catch {}
        }
    },

    renderError(message) {
        const el = document.getElementById('aiCard');
        el.innerHTML = `
            <div class="ai-error">
                <h3>Generation Failed</h3>
                <p>${escapeHtml(message)}</p>
                <div class="ai-buttons">
                    <button class="ai-btn btn-next" onclick="AIPractice.generateNext()">Try Again</button>
                    <button class="ai-btn btn-end" onclick="SessionState.clear();showScreen('home');Home.render()">Back to Home</button>
                </div>
            </div>
        `;
    },

    renderSummary() {
        const pct = this.sessionStats.total > 0 ?
            Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) : 0;

        // Category improvements
        let catImprovementsHtml = '';
        Object.entries(this.sessionStats.byCategory).forEach(([cat, data]) => {
            const sessionPct = data.total > 0 ? Math.round((data.correct / data.total) * 100) : 0;
            const startingScore = this.startingWeakness[cat] || 50;
            const diff = sessionPct - startingScore;
            const diffClass = diff > 0 ? 'improved' : diff < 0 ? 'declined' : '';
            const diffText = diff > 0 ? `+${diff}%` : diff < 0 ? `${diff}%` : '0%';

            catImprovementsHtml += `
                <div class="cat-improvement">
                    <span class="cat-name">${escapeHtml(cat)}</span>
                    <span class="cat-score">${sessionPct}%</span>
                    <span class="cat-score ${diffClass}">(${diffText})</span>
                </div>
            `;
        });

        const el = document.getElementById('aiCard');
        el.innerHTML = `
            <div class="ai-session-summary">
                <h2>Session Complete!</h2>
                <div class="summary-score">${pct}%</div>
                <div class="summary-label">${this.sessionStats.correct} correct out of ${this.sessionStats.total} questions</div>

                <div class="summary-details">
                    <table>
                        <tr><td class="label-col">Questions Attempted</td><td class="value-col">${this.sessionStats.total}</td></tr>
                        <tr><td class="label-col">Correct Answers</td><td class="value-col">${this.sessionStats.correct}</td></tr>
                        <tr><td class="label-col">Incorrect Answers</td><td class="value-col">${this.sessionStats.total - this.sessionStats.correct}</td></tr>
                        <tr><td class="label-col">Categories Covered</td><td class="value-col">${Object.keys(this.sessionStats.byCategory).length}</td></tr>
                    </table>
                </div>

                ${catImprovementsHtml ? `
                    <div class="category-improvements">
                        <h3>Performance by Category</h3>
                        ${catImprovementsHtml}
                    </div>
                ` : ''}

                <div class="summary-actions">
                    <button style="background:#9b59b6" onclick="AIPractice.start('${escapeHtml(this.bank.bankId)}')">Practice Again</button>
                    <button style="background:var(--gray-700)" onclick="showScreen('home');Home.render()">Back to Home</button>
                </div>
            </div>
        `;
    },

    getQuestionContext() {
        if (!this.currentQuestion) return null;
        const q = this.currentQuestion;
        // Don't reveal answer if user hasn't checked yet
        const hideAnswer = !this.isChecked;
        return {
            number: 'AI-' + this.sessionStats.total,
            text: q.question,
            options: q.options,
            correctAnswer: hideAnswer ? null : q.correctAnswer,
            correctText: hideAnswer ? null : q.options[q.correctAnswer],
            explanation: hideAnswer ? null : q.explanation,
            userAnswer: this.selectedOption,
            userAnswerText: this.selectedOption !== null ? q.options[this.selectedOption] : null,
            isAnswered: this.isChecked
        };
    },

    // Get comprehensive stats for AI summaries and analysis
    getComprehensiveStats() {
        const gamState = Gamification.getState();
        const globalStats = DailyGoal.getStats();
        const drillData = Store.get('drillProgress', {});
        const questionTracker = QuestionTracker.getSummary();
        
        // Category breakdown with time
        const categoryStats = {};
        Object.entries(gamState.categoryMastery || {}).forEach(([cat, data]) => {
            const totalTimeMins = Math.round((data.totalTimeMs || 0) / 60000);
            const avgTimePerQ = data.total > 0 ? Math.round((data.totalTimeMs || 0) / data.total / 1000) : 0;
            categoryStats[cat] = {
                correct: data.correct,
                total: data.total,
                accuracy: data.total > 0 ? Math.round((data.correct / data.total) * 100) : 0,
                level: data.level,
                totalTimeMinutes: totalTimeMins,
                avgTimePerQuestionSeconds: avgTimePerQ
            };
        });

        // Session stats
        const sessionStats = {
            correct: this.sessionStats.correct,
            total: this.sessionStats.total,
            accuracy: this.sessionStats.total > 0 ? Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) : 0,
            byCategory: this.sessionStats.byCategory
        };

        return {
            // Overall progress
            level: gamState.level,
            xp: gamState.xp,
            totalXpEarned: gamState.stats?.totalXpEarned || 0,
            coins: gamState.coins,
            
            // Streaks and combos
            currentCombo: gamState.combo?.current || 0,
            bestCombo: gamState.combo?.best || 0,
            longestStreak: gamState.stats?.longestStreak || 0,
            dailyStreak: globalStats.streak || 0,
            
            // Activity
            questionsAnswered: gamState.stats?.questionsAnswered || 0,
            testsCompleted: globalStats.testsCompleted || 0,
            questionsToday: globalStats.questionsToday || 0,
            dailyGoal: globalStats.dailyGoal || 10,
            
            // Time tracking
            totalStudyMinutes: globalStats.totalStudyMins || 0,
            todayStudyMinutes: Session.getTodayMins(),
            
            // Per-category breakdown (with time)
            categoryStats: categoryStats,
            
            // Current session
            currentSession: sessionStats,
            weakCategories: this.weakCategories.slice(0, 5).map(wc => ({
                category: wc.category,
                score: Math.round(wc.score)
            })),
            
            // Question tracker summary
            overallAccuracy: questionTracker.accuracy,
            totalAttempts: questionTracker.totalAttempts,
            questionsTracked: questionTracker.questionsTracked
        };
    },

    // Update persistent mastery tracking for question types
    _updateGlobalMastery(qType, isCorrect) {
        if (!qType || !this.bank) return;
        
        const key = 'aiMasteredTypes_' + this.bank.bankId;
        const mastery = Store.get(key, {});
        
        if (!mastery[qType]) {
            mastery[qType] = { correct: 0, total: 0, lastSeen: Date.now() };
        }
        
        mastery[qType].total++;
        if (isCorrect) mastery[qType].correct++;
        mastery[qType].lastSeen = Date.now();
        
        // Calculate mastery level (0-100)
        const stats = mastery[qType];
        stats.masteryLevel = stats.total >= 3 ? Math.round((stats.correct / stats.total) * 100) : 0;
        
        Store.set(key, mastery);
        this._globalMasteredTypes = mastery;
    },

    // Update drill progress (SM-2) for AI-generated questions
    _updateDrillProgress(qId, isCorrect, timeSpent) {
        const all = Store.get('drillProgress', {});
        const p = all[qId] || { ef: 2.5, interval: 0, reps: 0, nextReview: 0 };
        const timeSpentSec = timeSpent / 1000;
        
        // Never lower mastery - speed heavily influences gains
        let ef = p.ef;
        let interval = p.interval || 1;
        let reps = p.reps || 0;
        
        if (isCorrect) {
            // Speed bonus: faster = bigger ef increase
            let speedBonus;
            if (timeSpentSec < 5) speedBonus = 0.3;
            else if (timeSpentSec < 10) speedBonus = 0.2;
            else if (timeSpentSec < 20) speedBonus = 0.1;
            else if (timeSpentSec < 30) speedBonus = 0.05;
            else speedBonus = 0.02;
            
            ef = Math.min(3.0, ef + speedBonus);
            reps++;
            
            if (reps === 1) interval = 1;
            else if (reps === 2) interval = 3;
            else interval = Math.round(interval * ef);
        } else {
            // Wrong: don't lower ef, just review sooner
            interval = 1;
        }
        
        const nextReview = Date.now() + interval * 86400000;
        all[qId] = { ef, interval, reps, nextReview };
        Store.set('drillProgress', all);
    },

    // Get list of truly mastered question types (80%+ accuracy with 3+ attempts)
    _getTrulyMasteredTypes() {
        const mastered = [];
        const now = Date.now();
        const oneWeek = 7 * 24 * 60 * 60 * 1000;
        
        Object.entries(this._globalMasteredTypes).forEach(([qType, stats]) => {
            // Mastered if: 80%+ accuracy, 3+ attempts, seen in last week
            if (stats.total >= 3 && stats.masteryLevel >= 80 && (now - stats.lastSeen) < oneWeek) {
                mastered.push(qType);
            }
        });
        
        return mastered;
    }
};


// =====================================================================
// PROGRESS DASHBOARD
// =====================================================================
const Progress = {
    // Helper to safely extract day string from various date formats
    _parseDay(dateVal) {
        if (!dateVal) return null;
        if (typeof dateVal === 'string') return dateVal.split('T')[0];
        if (dateVal instanceof Date) return dateVal.toISOString().split('T')[0];
        if (typeof dateVal === 'number') return new Date(dateVal).toISOString().split('T')[0];
        return null;
    },

    show() {
        showScreen('progress');
        this.render();
    },

    render() {
        const content = document.getElementById('progressContent');
        if (!content) {
            console.error('[Progress] progressContent element not found!');
            return;
        }
        
        try {
            const gamStats = this.renderGamificationStats();
            console.log('[Progress] renderGamificationStats returned:', gamStats ? gamStats.length + ' chars' : 'empty');
            
            const allContent = this.renderPredictedGrade() + this.renderInsights() + gamStats + this.renderOverallStats() + this.renderScoreTrend() + this.renderAccuracyOverTime() + this.renderStudyTimeVsScore() + this.renderTestHistory() + this.renderMostMissed() + this.renderCategoryAccuracy() + this.renderCategoryTimeBreakdown() + this.renderCategoryPerformance() + this.renderMasteryProgress() + this.renderStudyTime();
            
            console.log('[Progress] Total content length:', allContent.length);
            
            if (!allContent.trim()) {
                content.innerHTML = `
                    <div style="text-align:center;padding:60px 20px;color:var(--gray-600)">
                        <div style="font-size:48px;margin-bottom:16px"></div>
                        <h3 style="color:var(--navy);margin-bottom:8px">No Data Yet</h3>
                        <p style="margin-bottom:20px">Complete some practice questions, drills, or tests to see your metrics here.</p>
                        <p style="font-size:13px;color:var(--gray-500)">Your performance data from all modes (Exam, Drill, AI Practice, Speed Mode) will appear here.</p>
                    </div>
                `;
                return;
            }
            
            content.innerHTML = allContent;
            this._drawTrendChart();
            this._drawAccuracyChart();
            this._drawStudyVsScoreChart();
            this._renderOverallTrend();
        } catch (err) {
            console.error('[Progress] Error rendering:', err);
            content.innerHTML = `<div style="padding:20px;color:red">Error loading metrics: ${err.message}</div>`;
        }
    },

    // Big weighted predicted grade - quick snapshot of likely test performance
    // Uses CATEGORY weighting: each category contributes equally to final grade (like a real class)
    renderPredictedGrade() {
        const drillProgress = Store.get('drillProgress', {});
        const trackerData = Store.get('questionTracker', {});
        const catAccuracy = QuestionTracker.getCategoryAccuracy();
        
        let categoryBreakdown = [];
        let totalQuestions = 0;
        
        // Build category breakdown - each category gets equal weight in final grade
        const validCategories = [];
        Object.entries(catAccuracy).forEach(([cat, data]) => {
            if (data.total >= 2) { // Need at least 2 attempts to count
                const pct = Math.round((data.correct / data.total) * 100);
                categoryBreakdown.push({ cat, pct, total: data.total, correct: data.correct });
                validCategories.push({ cat, pct, total: data.total });
                totalQuestions += data.total;
            }
        });
        
        // CATEGORY-WEIGHTED SCORE: Each category contributes equally
        // This is how real classes work - each unit/chapter has equal weight
        let predictedScore = 0;
        if (validCategories.length > 0) {
            const categorySum = validCategories.reduce((sum, c) => sum + c.pct, 0);
            predictedScore = Math.round(categorySum / validCategories.length);
        }
        
        // Calculate recent trend from tracker data
        const now = Date.now();
        const dayMs = 24 * 60 * 60 * 1000;
        const weekAgo = now - (7 * dayMs);
        let recentCorrect = 0, recentTotal = 0;
        let olderCorrect = 0, olderTotal = 0;
        
        Object.entries(trackerData).forEach(([qId, data]) => {
            if (data.history && data.history.length > 0) {
                data.history.forEach(attempt => {
                    const ts = attempt.timestamp || 0;
                    if (ts > weekAgo) {
                        recentTotal++;
                        if (attempt.correct) recentCorrect++;
                    } else {
                        olderTotal++;
                        if (attempt.correct) olderCorrect++;
                    }
                });
            }
        });
        
        // Calculate trend (recent 7 days vs older)
        let recentScore = recentTotal >= 5 ? Math.round((recentCorrect / recentTotal) * 100) : null;
        let olderScore = olderTotal >= 5 ? Math.round((olderCorrect / olderTotal) * 100) : null;
        let trendDirection = null;
        let trendAmount = 0;
        if (recentScore !== null && olderScore !== null) {
            trendAmount = recentScore - olderScore;
            if (trendAmount > 3) trendDirection = 'up';
            else if (trendAmount < -3) trendDirection = 'down';
        }
        
        // Calculate mastery bonus (questions you've truly mastered boost confidence)
        const mastered = Object.values(drillProgress).filter(d => d.ef >= 2.5 && d.reps >= 3).length;
        const struggling = Object.values(drillProgress).filter(d => d.ef < 2.0).length;
        const totalTracked = Object.keys(drillProgress).length;
        const masteryBonus = totalTracked > 0 ? (mastered / totalTracked) * 5 : 0; // Up to +5%
        const strugglePenalty = totalTracked > 0 ? (struggling / totalTracked) * 5 : 0; // Up to -5%
        
        // Apply mastery adjustments
        predictedScore = Math.round(predictedScore + masteryBonus - strugglePenalty);
        predictedScore = Math.max(0, Math.min(100, predictedScore));
        
        // If no data, return empty
        if (totalQuestions === 0 && categoryBreakdown.length === 0) return '';
        
        // Determine grade letter and color
        let grade, gradeColor, gradeEmoji, confidence;
        if (predictedScore >= 90) { grade = 'A'; gradeColor = '#22c55e'; gradeEmoji = ''; }
        else if (predictedScore >= 80) { grade = 'B'; gradeColor = '#3b82f6'; gradeEmoji = ''; }
        else if (predictedScore >= 70) { grade = 'C'; gradeColor = '#f59e0b'; gradeEmoji = ''; }
        else if (predictedScore >= 60) { grade = 'D'; gradeColor = '#f97316'; gradeEmoji = ''; }
        else { grade = 'F'; gradeColor = '#ef4444'; gradeEmoji = ''; }
        
        // Confidence level based on category coverage and data quantity
        if (validCategories.length >= 5 && totalQuestions >= 50) confidence = 'High';
        else if (validCategories.length >= 3 && totalQuestions >= 25) confidence = 'Medium';
        else if (validCategories.length >= 2 && totalQuestions >= 10) confidence = 'Low';
        else confidence = 'Very Low';
        
        // Find weakest and strongest categories
        categoryBreakdown.sort((a, b) => a.pct - b.pct);
        const weakest = categoryBreakdown.slice(0, 3);
        const strongest = categoryBreakdown.slice(-3).reverse();
        
        // Pass/Fail indicator (assuming 70% passing)
        const passingScore = 70;
        const passStatus = predictedScore >= passingScore;
        const pointsFromPass = predictedScore - passingScore;
        
        return `
            <div class="progress-section" style="background:linear-gradient(135deg,${gradeColor}15,${gradeColor}05);border:2px solid ${gradeColor};padding:24px;margin-bottom:24px">
                <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:20px">
                    <!-- Main Grade Display -->
                    <div style="text-align:center;min-width:150px">
                        <div style="font-size:72px;font-weight:bold;color:${gradeColor};line-height:1">${grade}</div>
                        <div style="font-size:14px;color:var(--gray-600);margin-top:4px">Predicted Grade</div>
                    </div>
                    
                    <!-- Score & Details -->
                    <div style="flex:1;min-width:200px">
                        <div style="display:flex;align-items:center;gap:12px">
                            <div style="font-size:48px;font-weight:bold;color:var(--navy)">${predictedScore}%</div>
                            ${trendDirection ? `<div style="font-size:24px;color:${trendDirection === 'up' ? 'var(--green)' : 'var(--red)'}">
                                ${trendDirection === 'up' ? '' : ''}
                                <span style="font-size:14px;font-weight:bold">${trendAmount > 0 ? '+' : ''}${trendAmount}%</span>
                            </div>` : ''}
                        </div>
                        <div style="font-size:14px;color:var(--gray-600)">Category-Weighted Score ${gradeEmoji}</div>
                        <div style="font-size:11px;color:var(--gray-500);margin-top:2px">${validCategories.length} categories averaged equally</div>
                        <div style="margin-top:12px;padding:10px;background:${passStatus ? '#dcfce7' : '#fef2f2'};border-radius:8px;display:inline-block">
                            <span style="font-weight:bold;color:${passStatus ? '#16a34a' : '#dc2626'}">
                                ${passStatus ? ' PASSING' : ' NOT PASSING'}
                            </span>
                            <span style="color:var(--gray-600);margin-left:8px;font-size:13px">
                                (${pointsFromPass >= 0 ? '+' : ''}${pointsFromPass} from 70%)
                            </span>
                        </div>
                    </div>
                    
                    <!-- Confidence Meter -->
                    <div style="text-align:center;min-width:120px">
                        <div style="font-size:13px;color:var(--gray-500);margin-bottom:4px">Confidence</div>
                        <div style="font-size:18px;font-weight:bold;color:var(--navy)">${confidence}</div>
                        <div style="font-size:11px;color:var(--gray-500)">${totalQuestions} attempts across ${validCategories.length} categories</div>
                    </div>
                </div>
                
                <!-- Progress Bar to 100% -->
                <div style="margin-top:20px">
                    <div style="display:flex;justify-content:space-between;font-size:12px;color:var(--gray-600);margin-bottom:4px">
                        <span>0%</span>
                        <span style="color:${passStatus ? 'var(--green)' : 'var(--red)'};font-weight:bold">Pass: 70%</span>
                        <span>100%</span>
                    </div>
                    <div style="background:var(--gray-200);border-radius:8px;height:24px;position:relative;overflow:hidden">
                        <div style="position:absolute;left:70%;top:0;bottom:0;width:2px;background:var(--gray-400);z-index:1"></div>
                        <div style="background:linear-gradient(90deg,${gradeColor},${gradeColor}cc);height:100%;width:${predictedScore}%;border-radius:8px;transition:width 0.5s"></div>
                    </div>
                </div>
                
                <!-- Quick Category Summary -->
                ${categoryBreakdown.length > 0 ? `
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-top:20px">
                    ${weakest.length > 0 ? `
                    <div style="background:rgba(239,68,68,0.1);padding:12px;border-radius:8px">
                        <div style="font-size:12px;font-weight:bold;color:var(--red);margin-bottom:8px"> Focus Areas</div>
                        ${weakest.map(c => `<div style="font-size:13px;display:flex;justify-content:space-between;margin-bottom:4px">
                            <span style="color:var(--gray-700)">${escapeHtml(c.cat)}</span>
                            <span style="font-weight:bold;color:var(--red)">${c.pct}%</span>
                        </div>`).join('')}
                    </div>` : ''}
                    ${strongest.length > 0 ? `
                    <div style="background:rgba(34,197,94,0.1);padding:12px;border-radius:8px">
                        <div style="font-size:12px;font-weight:bold;color:var(--green);margin-bottom:8px"> Strengths</div>
                        ${strongest.map(c => `<div style="font-size:13px;display:flex;justify-content:space-between;margin-bottom:4px">
                            <span style="color:var(--gray-700)">${escapeHtml(c.cat)}</span>
                            <span style="font-weight:bold;color:var(--green)">${c.pct}%</span>
                        </div>`).join('')}
                    </div>` : ''}
                </div>` : ''}
                
                <div style="margin-top:16px;font-size:11px;color:var(--gray-500);text-align:center">
                     Based on ${totalQuestions} unique questions  ${mastered} mastered  ${struggling} struggling
                </div>
            </div>`;
    },

    // Intelligent correlation detection - only shows strong correlations
    renderInsights() {
        const insights = this._detectCorrelations();
        if (insights.length === 0) return '';
        
        const insightItems = insights.map(i => {
            const icon = i.positive ? '' : '';
            const color = i.positive ? 'var(--green)' : 'var(--orange)';
            return `<div style="padding:10px 14px;background:var(--gray-50);border-radius:8px;border-left:3px solid ${color};margin-bottom:8px">
                <span style="font-size:16px">${icon}</span>
                <strong style="color:${color}">${i.title}</strong>
                <p style="margin:4px 0 0;font-size:13px;color:var(--gray-700)">${i.description}</p>
                <span style="font-size:11px;color:var(--gray-500)">Correlation: ${i.strength} (r=${i.r.toFixed(2)})</span>
            </div>`;
        }).join('');
        
        return `<div class="progress-section">
            <h3> Insights</h3>
            <p style="font-size:12px;color:var(--gray-600);margin-bottom:12px">Statistically significant patterns (based on ${insights.length > 0 ? '8+' : ''} data points):</p>
            ${insightItems}
        </div>`;
    },

    _detectCorrelations() {
        const insights = [];
        const MIN_CORRELATION = 0.55; // Only show meaningful correlations (was 0.4)
        const MIN_DATA_POINTS = 8; // Need more data for statistical validity (was 5)
        
        // Gather all the data we need
        const studyByDay = Store.get('studyByDay', {});
        const drillProgress = Store.get('drillProgress', {});
        const trackerData = Store.get('questionTracker', {});
        const gamState = Gamification.getState();
        
        // Safety check for BankManager
        if (!BankManager || !BankManager.banks || BankManager.banks.length === 0) {
            return insights;
        }
        
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        allHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        if (allHistory.length < MIN_DATA_POINTS) return insights;
        
        // 1. Study Time vs Test Scores
        const studyScoreData = allHistory.map(test => {
            const day = this._parseDay(test.date);
            return { x: studyByDay[day] || 0, y: test.pct };
        });
        const studyScoreR = this._pearsonCorrelation(studyScoreData);
        if (Math.abs(studyScoreR) >= MIN_CORRELATION) {
            insights.push({
                title: studyScoreR > 0 ? 'Study Time Pays Off!' : 'Quality Over Quantity',
                description: studyScoreR > 0 
                    ? 'The more time you study each day, the higher your test scores tend to be.'
                    : 'More study time isn\'t improving scores. Try focusing on weak areas instead.',
                r: studyScoreR,
                strength: this._getCorrelationStrength(studyScoreR),
                positive: studyScoreR > 0
            });
        }
        
        // 2. Drill Practice vs Test Scores (by category)
        const drillCounts = {};
        Object.entries(drillProgress).forEach(([qId, prog]) => {
            if (prog.reps > 0) {
                const found = QuestionTracker.findQuestion(qId);
                if (found) {
                    const cat = found.question.category || 'General';
                    drillCounts[cat] = (drillCounts[cat] || 0) + prog.reps;
                }
            }
        });
        
        // Get category accuracy from recent tests
        const catTestScores = {};
        allHistory.slice(-10).forEach(test => {
            if (test.questions) {
                test.questions.forEach(q => {
                    const cat = q.category || 'General';
                    if (!catTestScores[cat]) catTestScores[cat] = { correct: 0, total: 0 };
                    catTestScores[cat].total++;
                    if (q.correct) catTestScores[cat].correct++;
                });
            }
        });
        
        const drillVsScoreData = [];
        Object.keys(drillCounts).forEach(cat => {
            if (catTestScores[cat] && catTestScores[cat].total >= 3) {
                drillVsScoreData.push({
                    x: drillCounts[cat],
                    y: (catTestScores[cat].correct / catTestScores[cat].total) * 100
                });
            }
        });
        
        if (drillVsScoreData.length >= 6) { // Need at least 6 categories for meaningful correlation
            const drillR = this._pearsonCorrelation(drillVsScoreData);
            if (Math.abs(drillR) >= MIN_CORRELATION) {
                insights.push({
                    title: drillR > 0 ? 'Drills Are Working!' : 'Try Different Drill Strategies',
                    description: drillR > 0
                        ? 'Categories you drill more have higher test scores. Keep it up!'
                        : 'More drilling isn\'t translating to better scores. Try AI Practice for weak areas.',
                    r: drillR,
                    strength: this._getCorrelationStrength(drillR),
                    positive: drillR > 0
                });
            }
        }
        
        // 3. AI Practice vs Improvement
        const aiPracticeCount = gamState.stats?.aiQuestionsAnswered || 0;
        if (aiPracticeCount > 10 && allHistory.length >= 6) {
            const firstHalf = allHistory.slice(0, Math.floor(allHistory.length / 2));
            const secondHalf = allHistory.slice(Math.floor(allHistory.length / 2));
            const firstAvg = firstHalf.reduce((s, h) => s + h.pct, 0) / firstHalf.length;
            const secondAvg = secondHalf.reduce((s, h) => s + h.pct, 0) / secondHalf.length;
            const improvement = secondAvg - firstAvg;
            
            if (improvement > 8) { // Require 8%+ improvement for statistical significance
                insights.push({
                    title: 'AI Practice Is Boosting Scores!',
                    description: `Your recent test average is ${Math.round(improvement)}% higher than earlier. AI-targeted practice is helping!`,
                    r: Math.min(0.9, 0.5 + improvement / 30), // Scale r based on improvement magnitude
                    strength: improvement > 15 ? 'Strong' : 'Moderate',
                    positive: true
                });
            }
        }
        
        // 4. Streak vs Performance
        const streakData = [];
        let currentStreak = 0;
        let lastDate = null;
        allHistory.forEach(test => {
            const day = this._parseDay(test.date);
            if (lastDate) {
                const diff = (new Date(day) - new Date(lastDate)) / (1000 * 60 * 60 * 24);
                if (diff <= 1) currentStreak++;
                else currentStreak = 1;
            } else {
                currentStreak = 1;
            }
            streakData.push({ x: currentStreak, y: test.pct });
            lastDate = day;
        });
        
        if (streakData.length >= MIN_DATA_POINTS) {
            const streakR = this._pearsonCorrelation(streakData);
            if (Math.abs(streakR) >= MIN_CORRELATION) {
                insights.push({
                    title: streakR > 0 ? 'Consistency Wins!' : 'Take Breaks When Needed',
                    description: streakR > 0
                        ? 'Longer study streaks correlate with better scores. Keep your streak going!'
                        : 'Long streaks might be causing burnout. Quality rest can help.',
                    r: streakR,
                    strength: this._getCorrelationStrength(streakR),
                    positive: streakR > 0
                });
            }
        }
        
        // 5. Time per question vs accuracy
        const timeAccuracyData = [];
        Object.values(trackerData).forEach(qData => {
            if (qData.history && qData.history.length >= 2) {
                qData.history.forEach(attempt => {
                    if (attempt.timeMs && attempt.timeMs > 1000 && attempt.timeMs < 300000) {
                        timeAccuracyData.push({
                            x: attempt.timeMs / 1000,
                            y: attempt.correct ? 100 : 0
                        });
                    }
                });
            }
        });
        
        if (timeAccuracyData.length >= 50) { // Need many data points for time-accuracy correlation
            const timeR = this._pearsonCorrelation(timeAccuracyData);
            if (Math.abs(timeR) >= 0.3) { // Raised threshold
                insights.push({
                    title: timeR > 0 ? 'Take Your Time' : 'Trust Your Instincts',
                    description: timeR > 0
                        ? 'Spending more time on questions tends to improve accuracy. Don\'t rush!'
                        : 'Your quick answers are often correct. Trust your first instinct.',
                    r: timeR,
                    strength: this._getCorrelationStrength(timeR),
                    positive: timeR > 0
                });
            }
        }
        
        return insights;
    },

    _getCorrelationStrength(r) {
        const absR = Math.abs(r);
        if (absR >= 0.8) return 'Very Strong';
        if (absR >= 0.65) return 'Strong';
        if (absR >= 0.5) return 'Moderate';
        return 'Weak';
    },

    _pearsonCorrelation(data) {
        if (data.length < 2) return 0;
        const n = data.length;
        const sumX = data.reduce((s, d) => s + d.x, 0);
        const sumY = data.reduce((s, d) => s + d.y, 0);
        const sumXY = data.reduce((s, d) => s + d.x * d.y, 0);
        const sumX2 = data.reduce((s, d) => s + d.x * d.x, 0);
        const sumY2 = data.reduce((s, d) => s + d.y * d.y, 0);
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        return denominator === 0 ? 0 : numerator / denominator;
    },

    renderStudyTimeVsScore() {
        const correlation = this._getStudyTimeScoreCorrelation();
        if (correlation.data.length < 3) return '';
        
        const insight = correlation.correlation > 0.3 ? 
            `<span style="color:var(--green)"> More study time = better scores! (r=${correlation.correlation.toFixed(2)})</span>` :
            correlation.correlation < -0.3 ?
            `<span style="color:var(--orange)"> Quality over quantity - focus on weak areas</span>` :
            `<span style="color:var(--blue)"> Mixed results - try targeted practice</span>`;
        
        return `<div class="progress-section">
            <h3> Study Time vs Test Scores</h3>
            <p style="font-size:12px;color:var(--gray-600);margin-bottom:8px">${insight}</p>
            <canvas id="studyVsScoreChart" width="600" height="200" style="width:100%;height:200px;max-height:200px;border-radius:8px;background:var(--white);border:1px solid var(--gray-200)"></canvas>
            <p style="font-size:12px;color:var(--gray-600);text-align:center;margin-top:6px">Each dot = one test day (study mins that day vs score)</p>
        </div>`;
    },

    _getStudyTimeScoreCorrelation() {
        const studyByDay = Store.get('studyByDay', {});
        if (!BankManager || !BankManager.banks) return { data: [], correlation: 0 };
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        
        // Group tests by day and match with study time
        const data = [];
        allHistory.forEach(test => {
            const day = this._parseDay(test.date);
            const studyMins = studyByDay[day] || 0;
            data.push({ day, studyMins, score: test.pct });
        });
        
        if (data.length < 2) return { data: [], correlation: 0 };
        
        // Calculate Pearson correlation
        const n = data.length;
        const sumX = data.reduce((s, d) => s + d.studyMins, 0);
        const sumY = data.reduce((s, d) => s + d.score, 0);
        const sumXY = data.reduce((s, d) => s + d.studyMins * d.score, 0);
        const sumX2 = data.reduce((s, d) => s + d.studyMins * d.studyMins, 0);
        const sumY2 = data.reduce((s, d) => s + d.score * d.score, 0);
        
        const numerator = n * sumXY - sumX * sumY;
        const denominator = Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));
        const correlation = denominator === 0 ? 0 : numerator / denominator;
        
        return { data, correlation };
    },

    _drawStudyVsScoreChart() {
        const canvas = document.getElementById('studyVsScoreChart');
        if (!canvas) return;
        
        const { data } = this._getStudyTimeScoreCorrelation();
        if (data.length < 2) return;
        
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = canvas.offsetWidth, h = canvas.offsetHeight;
        const pad = { top: 25, right: 20, bottom: 40, left: 50 };
        const plotW = w - pad.left - pad.right;
        const plotH = h - pad.top - pad.bottom;
        
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
            (document.documentElement.getAttribute('data-theme') !== 'light' && window.matchMedia('(prefers-color-scheme:dark)').matches);
        
        ctx.fillStyle = isDark ? '#16213e' : '#fff';
        ctx.fillRect(0, 0, w, h);
        
        const maxMins = Math.max(...data.map(d => d.studyMins), 30);
        const maxScore = 100;
        
        // Grid
        ctx.strokeStyle = isDark ? '#374151' : '#eee';
        ctx.lineWidth = 1;
        for (let pct of [0, 50, 70, 100]) {
            const y = pad.top + plotH - (pct / maxScore) * plotH;
            ctx.beginPath();
            ctx.moveTo(pad.left, y);
            ctx.lineTo(w - pad.right, y);
            ctx.stroke();
            ctx.fillStyle = isDark ? '#9ca3af' : '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(pct + '%', pad.left - 5, y + 4);
        }
        
        // Pass line
        const passY = pad.top + plotH - (70 / maxScore) * plotH;
        ctx.strokeStyle = isDark ? '#4ade80' : '#27ae60';
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(pad.left, passY);
        ctx.lineTo(w - pad.right, passY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // X axis labels
        ctx.fillStyle = isDark ? '#9ca3af' : '#666';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        for (let mins of [0, Math.round(maxMins / 2), maxMins]) {
            const x = pad.left + (mins / maxMins) * plotW;
            ctx.fillText(mins + ' min', x, h - 8);
        }
        ctx.fillText('Study Time ', pad.left + plotW / 2, h - 22);
        
        // Scatter points
        data.forEach(d => {
            const x = pad.left + (d.studyMins / maxMins) * plotW;
            const y = pad.top + plotH - (d.score / maxScore) * plotH;
            const color = d.score >= 70 ? (isDark ? '#4ade80' : '#27ae60') : (isDark ? '#ef4444' : '#c0392b');
            
            ctx.beginPath();
            ctx.arc(x, y, 7, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = isDark ? '#16213e' : '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
        
        // Trend line (linear regression)
        if (data.length >= 3) {
            const n = data.length;
            const sumX = data.reduce((s, d) => s + d.studyMins, 0);
            const sumY = data.reduce((s, d) => s + d.score, 0);
            const sumXY = data.reduce((s, d) => s + d.studyMins * d.score, 0);
            const sumX2 = data.reduce((s, d) => s + d.studyMins * d.studyMins, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            const x1 = pad.left;
            const x2 = pad.left + plotW;
            const y1 = pad.top + plotH - (intercept / maxScore) * plotH;
            const y2 = pad.top + plotH - ((slope * maxMins + intercept) / maxScore) * plotH;
            
            ctx.strokeStyle = isDark ? 'rgba(251,191,36,.6)' : 'rgba(245,158,11,.6)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(x1, Math.max(pad.top, Math.min(pad.top + plotH, y1)));
            ctx.lineTo(x2, Math.max(pad.top, Math.min(pad.top + plotH, y2)));
            ctx.stroke();
            ctx.setLineDash([]);
        }
    },

    _renderOverallTrend() {
        const el = document.getElementById('overallTrend');
        if (!el) return;
        if (!BankManager || !BankManager.banks) return;
        
        // Calculate overall trend from recent tests
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        allHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        
        if (allHistory.length < 3) {
            el.innerHTML = '<span style="color:var(--gray-500)">Need more data for trend</span>';
            return;
        }
        
        // Compare recent 5 vs previous 5
        const recent = allHistory.slice(-5);
        const previous = allHistory.slice(-10, -5);
        
        const recentAvg = recent.reduce((sum, h) => sum + h.pct, 0) / recent.length;
        const previousAvg = previous.length > 0 ? previous.reduce((sum, h) => sum + h.pct, 0) / previous.length : recentAvg;
        
        const diff = recentAvg - previousAvg;
        const trend = diff > 2 ? 'up' : diff < -2 ? 'down' : 'stable';
        
        if (trend === 'up') {
            el.innerHTML = `<span style="color:var(--green)"> Trending Up (+${Math.round(diff)}%)</span>`;
        } else if (trend === 'down') {
            el.innerHTML = `<span style="color:var(--red)"> Trending Down (${Math.round(diff)}%)</span>`;
        } else {
            el.innerHTML = `<span style="color:var(--blue)"> Stable (${Math.round(recentAvg)}% avg)</span>`;
        }
    },

    renderAccuracyOverTime() {
        // Get daily accuracy data for last 14 days
        const dailyData = this._getDailyAccuracyData(14);
        if (dailyData.length < 2) return '';
        
        return `<div class="progress-section">
            <h3> Daily Accuracy Trend</h3>
            <canvas id="accuracyChart" width="600" height="200" style="width:100%;height:200px;max-height:200px;border-radius:8px;background:var(--white);border:1px solid var(--gray-200)"></canvas>
            <p style="font-size:12px;color:var(--gray-600);text-align:center;margin-top:6px">Last ${dailyData.length} days with activity</p>
        </div>`;
    },

    _getDailyAccuracyData(days) {
        const data = [];
        const trackerData = Store.get('questionTracker', {});
        
        // Group attempts by day
        const byDay = {};
        Object.values(trackerData).forEach(qData => {
            (qData.history || []).forEach(attempt => {
                const day = this._parseDay(attempt.date);
                if (!day) return;
                if (!byDay[day]) byDay[day] = { correct: 0, total: 0 };
                byDay[day].total++;
                if (attempt.correct) byDay[day].correct++;
            });
        });
        
        // Get last N days with data
        const sortedDays = Object.keys(byDay).sort().slice(-days);
        sortedDays.forEach(day => {
            const d = byDay[day];
            data.push({
                day: day,
                accuracy: d.total > 0 ? Math.round((d.correct / d.total) * 100) : 0,
                total: d.total
            });
        });
        
        return data;
    },

    _drawAccuracyChart() {
        const canvas = document.getElementById('accuracyChart');
        if (!canvas) return;
        
        const dailyData = this._getDailyAccuracyData(14);
        if (dailyData.length < 2) return;
        
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = canvas.offsetWidth, h = canvas.offsetHeight;
        const pad = { top: 25, right: 20, bottom: 35, left: 45 };
        const plotW = w - pad.left - pad.right;
        const plotH = h - pad.top - pad.bottom;
        
        const isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
            (document.documentElement.getAttribute('data-theme') !== 'light' && window.matchMedia('(prefers-color-scheme:dark)').matches);
        
        ctx.fillStyle = isDark ? '#16213e' : '#fff';
        ctx.fillRect(0, 0, w, h);
        
        // Grid lines
        ctx.strokeStyle = isDark ? '#374151' : '#eee';
        ctx.lineWidth = 1;
        for (let pct of [0, 50, 70, 100]) {
            const y = pad.top + plotH - (pct / 100) * plotH;
            ctx.beginPath();
            ctx.moveTo(pad.left, y);
            ctx.lineTo(w - pad.right, y);
            ctx.stroke();
            ctx.fillStyle = isDark ? '#9ca3af' : '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(pct + '%', pad.left - 5, y + 4);
        }
        
        // Pass line at 70%
        const passY = pad.top + plotH - (70 / 100) * plotH;
        ctx.strokeStyle = isDark ? '#4ade80' : '#27ae60';
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(pad.left, passY);
        ctx.lineTo(w - pad.right, passY);
        ctx.stroke();
        ctx.setLineDash([]);
        
        // Data points
        const points = dailyData.map((d, i) => ({
            x: pad.left + (i / (dailyData.length - 1)) * plotW,
            y: pad.top + plotH - (d.accuracy / 100) * plotH,
            accuracy: d.accuracy
        }));
        
        // Area fill
        const gradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
        gradient.addColorStop(0, isDark ? 'rgba(139,92,246,.3)' : 'rgba(139,92,246,.15)');
        gradient.addColorStop(1, isDark ? 'rgba(139,92,246,0)' : 'rgba(139,92,246,0)');
        ctx.beginPath();
        ctx.moveTo(points[0].x, pad.top + plotH);
        points.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(points[points.length - 1].x, pad.top + plotH);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Line
        ctx.strokeStyle = isDark ? '#8b5cf6' : '#7c3aed';
        ctx.lineWidth = 2;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        ctx.stroke();
        
        // Dots with white border for better visibility
        points.forEach(p => {
            const color = p.accuracy >= 70 ? (isDark ? '#4ade80' : '#27ae60') : (isDark ? '#ef4444' : '#c0392b');
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = isDark ? '#16213e' : '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });
        
        // X axis labels (dates)
        ctx.fillStyle = isDark ? '#9ca3af' : '#666';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        const labelCount = Math.min(5, dailyData.length);
        const step = Math.max(1, Math.floor((dailyData.length - 1) / (labelCount - 1)));
        for (let i = 0; i < dailyData.length; i += step) {
            const dateStr = dailyData[i].day.slice(5); // MM-DD
            ctx.fillText(dateStr, points[i].x, h - 10);
        }
        // Always show last date
        if ((dailyData.length - 1) % step !== 0) {
            const lastDate = dailyData[dailyData.length - 1].day.slice(5);
            ctx.fillText(lastDate, points[points.length - 1].x, h - 10);
        }
    },

    renderGamificationStats() {
        try {
            const gamState = Gamification.getState() || { level: 1, xp: 0, coins: 0, stats: {}, achievements: {} };
            const globalStats = DailyGoal.getStats() || {};
            const aiTotal = globalStats.aiPracticeTotal || 0;
            const aiCorrect = globalStats.aiPracticeCorrect || 0;
            const aiPct = aiTotal > 0 ? Math.round((aiCorrect / aiTotal) * 100) : 0;
            
            return `<div class="progress-section">
            <h3> Player Stats</h3>
            <div class="mastery-grid" style="grid-template-columns:repeat(auto-fit,minmax(100px,1fr))">
                <div class="mastery-item mastered"><div class="value">Lv ${gamState.level}</div><div class="label">${gamState.currentTitle || 'Student'}</div></div>
                <div class="mastery-item learning"><div class="value">${gamState.xp}</div><div class="label">Current XP</div></div>
                <div class="mastery-item new"><div class="value">${gamState.stats?.totalXpEarned || 0}</div><div class="label">Total XP</div></div>
                <div class="mastery-item mastered"><div class="value">${gamState.coins || 0}</div><div class="label">Coins</div></div>
                <div class="mastery-item learning"><div class="value">${globalStats.streak || 0}</div><div class="label">Day Streak</div></div>
                <div class="mastery-item new"><div class="value">${gamState.stats?.longestStreak || 0}</div><div class="label">Best Combo</div></div>
                <div class="mastery-item mastered"><div class="value">${gamState.stats?.questionsAnswered || 0}</div><div class="label">Questions</div></div>
                <div class="mastery-item learning"><div class="value">${globalStats.testsCompleted || 0}</div><div class="label">Tests</div></div>
            </div>
            ${aiTotal > 0 ? `
            <div style="margin-top:12px;padding:10px;background:linear-gradient(135deg,#9b59b6,#8e44ad);border-radius:8px;color:#fff">
                <div style="font-size:12px;opacity:0.9;margin-bottom:4px"> AI Practice</div>
                <div style="display:flex;gap:16px;font-size:14px">
                    <span><strong>${aiTotal}</strong> questions</span>
                    <span><strong>${aiCorrect}</strong> correct</span>
                    <span><strong>${aiPct}%</strong> accuracy</span>
                </div>
            </div>` : ''}
            <div style="margin-top:12px;display:flex;gap:8px;flex-wrap:wrap">
                ${Object.entries(gamState.achievements || {}).length > 0 ? 
                    `<span style="font-size:12px;color:var(--gray-600)"> ${Object.keys(gamState.achievements).length} achievements unlocked</span>` : 
                    '<span style="font-size:12px;color:var(--gray-500)">No achievements yet</span>'}
            </div>
        </div>`;
        } catch (err) {
            console.error('[Progress] renderGamificationStats error:', err);
            return '<div class="progress-section"><h3> Player Stats</h3><p style="color:var(--gray-500)">Error loading stats</p></div>';
        }
    },

    renderScoreTrend() {
        if (!BankManager || !BankManager.banks) return '';
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        if (allHistory.length < 2) return '';
        allHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        const recent = allHistory.slice(-20);
        return '<div class="progress-section"><h3> Score Trend</h3>' +
            '<canvas id="trendChart" width="600" height="220" style="width:100%;height:220px;max-height:220px;border-radius:8px;background:var(--white);border:1px solid var(--gray-200)"></canvas>' +
            '<p style="font-size:12px;color:var(--gray-600);text-align:center;margin-top:6px">Last ' + recent.length + ' tests</p></div>';
    },

    _drawTrendChart() {
        const canvas = document.getElementById('trendChart');
        if (!canvas) return;
        if (!BankManager || !BankManager.banks) return;
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history);
        }
        allHistory.sort((a, b) => new Date(a.date) - new Date(b.date));
        const data = allHistory.slice(-20).map(h => h.pct);
        if (data.length < 2) return;

        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);
        const w = canvas.offsetWidth, h = canvas.offsetHeight;
        const pad = { top: 25, right: 25, bottom: 40, left: 50 };
        const plotW = w - pad.left - pad.right;
        const plotH = h - pad.top - pad.bottom;

        const isDark = document.documentElement.getAttribute('data-theme') === 'dark' ||
            (document.documentElement.getAttribute('data-theme') !== 'light' && window.matchMedia('(prefers-color-scheme:dark)').matches);

        ctx.fillStyle = isDark ? '#16213e' : '#fff';
        ctx.fillRect(0, 0, w, h);

        // Grid lines
        ctx.strokeStyle = isDark ? '#374151' : '#eee';
        ctx.lineWidth = 1;
        for (let pct of [0, 50, 70, 100]) {
            const y = pad.top + plotH - (pct / 100) * plotH;
            ctx.beginPath();
            ctx.moveTo(pad.left, y);
            ctx.lineTo(w - pad.right, y);
            ctx.stroke();
            ctx.fillStyle = isDark ? '#9ca3af' : '#666';
            ctx.font = '11px Arial';
            ctx.textAlign = 'right';
            ctx.fillText(pct + '%', pad.left - 6, y + 4);
        }

        // Pass line at 70%
        const passY = pad.top + plotH - (70 / 100) * plotH;
        ctx.strokeStyle = isDark ? '#4ade80' : '#27ae60';
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(pad.left, passY);
        ctx.lineTo(w - pad.right, passY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Data line
        const points = data.map((pct, i) => ({
            x: pad.left + (i / (data.length - 1)) * plotW,
            y: pad.top + plotH - (pct / 100) * plotH
        }));

        // Gradient fill
        const gradient = ctx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
        gradient.addColorStop(0, isDark ? 'rgba(59,130,246,.3)' : 'rgba(41,128,185,.15)');
        gradient.addColorStop(1, isDark ? 'rgba(59,130,246,0)' : 'rgba(41,128,185,0)');
        ctx.beginPath();
        ctx.moveTo(points[0].x, pad.top + plotH);
        points.forEach(p => ctx.lineTo(p.x, p.y));
        ctx.lineTo(points[points.length - 1].x, pad.top + plotH);
        ctx.closePath();
        ctx.fillStyle = gradient;
        ctx.fill();

        // Line
        ctx.strokeStyle = isDark ? '#3b82f6' : '#2980b9';
        ctx.lineWidth = 2.5;
        ctx.lineJoin = 'round';
        ctx.beginPath();
        points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
        ctx.stroke();

        // Dots
        points.forEach((p, i) => {
            const color = data[i] >= 70 ? (isDark ? '#4ade80' : '#27ae60') : (isDark ? '#ef4444' : '#c0392b');
            ctx.beginPath();
            ctx.arc(p.x, p.y, 6, 0, Math.PI * 2);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.strokeStyle = isDark ? '#16213e' : '#fff';
            ctx.lineWidth = 2;
            ctx.stroke();
        });

        // X axis labels - show test numbers
        ctx.fillStyle = isDark ? '#9ca3af' : '#666';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        // Only show a few labels to avoid crowding
        const labelCount = Math.min(6, data.length);
        const step = Math.max(1, Math.floor((data.length - 1) / (labelCount - 1)));
        for (let i = 0; i < data.length; i += step) {
            ctx.fillText('Test ' + (i + 1), points[i].x, h - 10);
        }
        // Always show last test
        if ((data.length - 1) % step !== 0) {
            ctx.fillText('Test ' + data.length, points[points.length - 1].x, h - 10);
        }
    },

    renderOverallStats() {
        const summary = QuestionTracker.getSummary();
        if (summary.totalAttempts === 0) return '';
        const avgTime = summary.totalAttempts > 0 ? Metrics._formatTime(summary.totalTime / summary.totalAttempts) : '0s';
        return '<div class="progress-section"><h3>Overall Performance</h3><div class="mastery-grid">' +
            '<div class="mastery-item mastered"><div class="value">' + summary.accuracy + '%</div><div class="label">Accuracy</div></div>' +
            '<div class="mastery-item learning"><div class="value">' + summary.totalAttempts + '</div><div class="label">Total Attempts</div></div>' +
            '<div class="mastery-item new"><div class="value">' + summary.questionsTracked + '</div><div class="label">Questions Seen</div></div>' +
            '<div class="mastery-item mastered"><div class="value">' + avgTime + '</div><div class="label">Avg Time/Q</div></div>' +
            '</div></div>';
    },

    renderMostMissed() {
        const missed = QuestionTracker.getMostMissed(8);
        if (missed.length === 0) return '';
        const rows = missed.map(m => {
            const found = QuestionTracker.findQuestion(m.qId);
            const label = found ? found.question.text.substring(0, 60) + (found.question.text.length > 60 ? '...' : '') : m.qId;
            const pct = Math.round(m.missRate * 100);
            const trend = QuestionTracker.getTrend(m.qId, 3);
            let trendIcon = '';
            if (trend) trendIcon = trend.improving ? ' <span style="color:var(--green)">&#9650;</span>' : ' <span style="color:var(--red)">&#9660;</span>';
            return '<tr><td style="max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="' + escapeHtml(found ? found.question.text : '') + '">' + escapeHtml(label) + '</td>' +
                '<td>' + escapeHtml(m.category) + '</td>' +
                '<td style="color:var(--red)">' + pct + '%</td>' +
                '<td>' + m.incorrect + '/' + m.attempts + trendIcon + '</td></tr>';
        }).join('');
        return '<div class="progress-section"><h3>Most Missed Questions</h3>' +
            '<table class="progress-table"><thead><tr><th>Question</th><th>Category</th><th>Miss Rate</th><th>Wrong/Total</th></tr></thead><tbody>' + rows + '</tbody></table></div>';
    },

    renderCategoryAccuracy() {
        const cats = QuestionTracker.getCategoryAccuracyWithTrend();
        const entries = Object.entries(cats).filter(([_, d]) => d.total > 0);
        if (entries.length === 0) return '';
        entries.sort((a, b) => (a[1].correct / a[1].total) - (b[1].correct / b[1].total));
        const gamState = Gamification.isEnabled() ? Gamification.getState() : null;
        const badgeColors = { bronze: '#cd7f32', silver: '#c0c0c0', gold: '#ffd700', platinum: '#e5e4e2' };
        const bars = entries.map(([cat, d]) => {
            const pct = Math.round((d.correct / d.total) * 100);
            const colorClass = pct >= 70 ? 'good' : pct >= 50 ? 'warn' : 'bad';
            let badge = '';
            if (gamState && gamState.categoryMastery[cat] && gamState.categoryMastery[cat].level) {
                const lvl = gamState.categoryMastery[cat].level;
                badge = ' <span style="display:inline-block;background:' + badgeColors[lvl] + ';color:#333;padding:1px 6px;border-radius:8px;font-size:10px;font-weight:bold">' + lvl.charAt(0).toUpperCase() + lvl.slice(1) + '</span>';
            }
            // Trend indicator (+/- %)
            let trendHtml = '';
            if (d.trend !== null && d.trend !== 0) {
                const trendColor = d.trend > 0 ? 'var(--green)' : 'var(--red)';
                const trendIcon = d.trend > 0 ? '' : '';
                trendHtml = ' <span style="color:' + trendColor + ';font-size:11px;font-weight:bold">' + trendIcon + Math.abs(d.trend) + '%</span>';
            } else if (d.trend === 0 && d.recentTotal > 0 && d.olderTotal > 0) {
                trendHtml = ' <span style="color:var(--gray-500);font-size:11px">0%</span>';
            }
            return '<div class="chart-row"><span class="chart-label">' + escapeHtml(cat) + badge + '</span><div class="chart-bar-bg"><div class="chart-bar-fill ' + colorClass + '" style="width:' + pct + '%"></div></div><span class="chart-value">' + d.correct + '/' + d.total + ' (' + pct + '%)' + trendHtml + '</span></div>';
        }).join('');
        return '<div class="progress-section"><h3>Category Accuracy (All Modes)</h3><p style="font-size:12px;color:var(--gray-600);margin-bottom:8px">Combined from tests, drills, and AI practice. Trend shows last 7 days vs previous 7 days.</p><div class="progress-chart">' + bars + '</div></div>';
    },

    renderTestHistory() {
        if (!BankManager || !BankManager.banks) return '';
        let allHistory = [];
        for (const bank of BankManager.banks) {
            const history = Store.get('testHistory_' + bank.bankId, []);
            allHistory = allHistory.concat(history.map(h => ({ ...h, bankTitle: bank.title })));
        }
        allHistory.sort((a, b) => new Date(b.date) - new Date(a.date));
        const recent = allHistory.slice(0, 10);

        if (recent.length === 0) {
            return '<div class="progress-section"><h3>Test History</h3><p style="color:var(--gray-600)">No tests completed yet.</p></div>';
        }

        const rows = recent.map((h, idx) => {
            const date = new Date(h.date);
            const dateStr = date.toLocaleDateString();
            const scoreClass = h.pct >= 70 ? 'good' : h.pct >= 50 ? 'warn' : 'bad';
            const colorVar = scoreClass === 'good' ? 'green' : scoreClass === 'warn' ? 'orange' : 'red';
            const hasDetail = h.questions && h.questions.length > 0;
            const expandBtn = hasDetail ? ' <button onclick="event.stopPropagation();Progress.toggleDetail(this.closest(\'tr\').nextElementSibling)" style="background:none;border:none;cursor:pointer;font-size:11px;color:var(--gray-600)">&#9660;</button>' : '';
            let detailRow = '';
            if (hasDetail) {
                const wrongQs = h.questions.filter(q => q.answered && !q.correct);
                const skippedQs = h.questions.filter(q => !q.answered);
                let detail = '<div style="font-size:12px;padding:8px">';
                if (wrongQs.length > 0) {
                    detail += '<strong style="color:var(--red)">Missed (' + wrongQs.length + '):</strong><ul style="margin:4px 0 8px 16px">';
                    wrongQs.forEach(wq => {
                        const found = QuestionTracker.findQuestion(wq.qId);
                        const label = found ? found.question.text.substring(0, 80) : wq.qId;
                        detail += '<li>' + escapeHtml(wq.category) + ': ' + escapeHtml(label) + '</li>';
                    });
                    detail += '</ul>';
                }
                if (skippedQs.length > 0) {
                    detail += '<strong style="color:var(--orange)">Skipped (' + skippedQs.length + '):</strong> ' + skippedQs.map(q => escapeHtml(q.category)).join(', ');
                }
                detail += '</div>';
                detailRow = '<tr class="test-detail-row" style="display:none"><td colspan="4">' + detail + '</td></tr>';
            }
            return '<tr style="cursor:' + (hasDetail ? 'pointer' : 'default') + '"' + (hasDetail ? ' onclick="Progress.toggleDetail(this.nextElementSibling)"' : '') + '><td>' + dateStr + expandBtn + '</td><td><span style="color:var(--' + colorVar + ')">' + h.pct + '%</span></td><td>' + (h.mode || 'test') + '</td><td>' + (h.time || '-') + '</td></tr>' + detailRow;
        }).join('');

        return '<div class="progress-section"><h3>Test History (Last 10)</h3><table class="progress-table"><thead><tr><th>Date</th><th>Score</th><th>Mode</th><th>Time</th></tr></thead><tbody>' + rows + '</tbody></table></div>';
    },

    renderCategoryTimeBreakdown() {
        const gamState = Gamification.getState();
        const categoryMastery = gamState.categoryMastery || {};
        const entries = Object.entries(categoryMastery).filter(([_, d]) => d.total > 0);
        
        if (entries.length === 0) {
            return '<div class="progress-section"><h3> Time by Category</h3><p style="color:var(--gray-600)">Answer some questions to see time breakdown.</p></div>';
        }
        
        // Sort by total time (most time first)
        entries.sort((a, b) => (b[1].totalTimeMs || 0) - (a[1].totalTimeMs || 0));
        
        const maxTime = Math.max(...entries.map(([_, d]) => d.totalTimeMs || 0), 1);
        
        const rows = entries.map(([cat, data]) => {
            const totalMins = Math.round((data.totalTimeMs || 0) / 60000);
            const avgSecs = data.total > 0 ? Math.round((data.totalTimeMs || 0) / data.total / 1000) : 0;
            const accuracy = data.total > 0 ? Math.round((data.correct / data.total) * 100) : 0;
            const barWidth = Math.round(((data.totalTimeMs || 0) / maxTime) * 100);
            const colorClass = accuracy >= 70 ? 'good' : accuracy >= 50 ? 'warn' : 'bad';
            const levelBadge = data.level ? ` <span style="background:${data.level === 'platinum' ? '#e5e4e2' : data.level === 'gold' ? '#ffd700' : data.level === 'silver' ? '#c0c0c0' : '#cd7f32'};color:#333;padding:1px 5px;border-radius:6px;font-size:9px;font-weight:bold">${data.level.toUpperCase()}</span>` : '';
            
            return `<div class="chart-row">
                <span class="chart-label" style="min-width:120px">${escapeHtml(cat)}${levelBadge}</span>
                <div class="chart-bar-bg"><div class="chart-bar-fill ${colorClass}" style="width:${barWidth}%"></div></div>
                <span class="chart-value" style="min-width:140px;text-align:right">${Session.formatTime(totalMins)} | ${avgSecs}s/q | ${accuracy}%</span>
            </div>`;
        }).join('');
        
        return `<div class="progress-section">
            <h3> Time by Category</h3>
            <p style="font-size:12px;color:var(--gray-600);margin-bottom:8px">Total time spent, avg per question, and accuracy</p>
            <div class="progress-chart">${rows}</div>
        </div>`;
    },

    renderCategoryPerformance() {
        if (!BankManager || !BankManager.banks) return '';
        const catStats = {};
        const drillData = Store.get('drillProgress', {});
        for (const bank of BankManager.banks) {
            for (const q of bank.questions) {
                const cat = q.category || 'General';
                if (!catStats[cat]) catStats[cat] = { correct: 0, total: 0 };
                const prog = drillData[q.id];
                if (prog && prog.reps > 0) {
                    catStats[cat].total++;
                    if (prog.ef >= 2.5) catStats[cat].correct++;
                }
            }
        }

        const cats = Object.keys(catStats).filter(c => catStats[c].total > 0);
        if (cats.length === 0) {
            return '<div class="progress-section"><h3>Category Performance</h3><p style="color:var(--gray-600)">Complete some drills to see category performance.</p></div>';
        }

        const bars = cats.map(cat => {
            const pct = Math.round((catStats[cat].correct / catStats[cat].total) * 100);
            const colorClass = pct >= 70 ? 'good' : pct >= 50 ? 'warn' : 'bad';
            return '<div class="chart-row"><span class="chart-label">' + escapeHtml(cat) + '</span><div class="chart-bar-bg"><div class="chart-bar-fill ' + colorClass + '" style="width:' + pct + '%"></div></div><span class="chart-value">' + pct + '%</span></div>';
        }).join('');

        return '<div class="progress-section"><h3>Category Performance</h3><div class="progress-chart">' + bars + '</div></div>';
    },

    renderMasteryProgress() {
        if (!BankManager || !BankManager.banks) return '';
        const drillData = Store.get('drillProgress', {});
        let totalQ = 0;
        for (const bank of BankManager.banks) {
            totalQ += bank.questions.length;
        }

        const entries = Object.values(drillData);
        const mastered = entries.filter(d => d.ef >= 2.5 && d.reps >= 3).length;
        const learning = entries.filter(d => d.reps > 0 && !(d.ef >= 2.5 && d.reps >= 3)).length;
        const newQ = totalQ - mastered - learning;

        return '<div class="progress-section"><h3>Mastery Progress</h3><div class="mastery-grid"><div class="mastery-item mastered"><div class="value">' + mastered + '</div><div class="label">Mastered</div></div><div class="mastery-item learning"><div class="value">' + learning + '</div><div class="label">Learning</div></div><div class="mastery-item new"><div class="value">' + newQ + '</div><div class="label">New</div></div></div></div>';
    },

    toggleDetail(row) {
        if (!row || !row.classList.contains('test-detail-row')) return;
        row.style.display = row.style.display === 'none' ? '' : 'none';
    },

    renderStudyTime() {
        const stats = Store.get('globalStats', { testsCompleted: 0, avgScore: 0, drillStreak: 0, totalStudyMins: 0 });
        const studyByDay = Store.get('studyByDay', {});

        const days = [];
        const dayNames = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        for (let i = 6; i >= 0; i--) {
            const d = new Date();
            d.setDate(d.getDate() - i);
            const key = d.getFullYear() + '-' + String(d.getMonth() + 1).padStart(2, '0') + '-' + String(d.getDate()).padStart(2, '0');
            const dayName = dayNames[d.getDay()];
            days.push({ key: key, dayName: dayName, mins: studyByDay[key] || 0 });
        }

        const maxMins = Math.max(...days.map(d => d.mins), 1);

        const bars = days.map(d => {
            const height = Math.round((d.mins / maxMins) * 70);
            const minsLabel = d.mins > 0 ? '<span class="bar-value">' + d.mins + 'm</span>' : '';
            return '<div class="study-day">' + minsLabel + '<div class="bar" style="height:' + height + 'px" title="' + d.mins + ' min"></div><span class="day-label">' + d.dayName + '</span></div>';
        }).join('');

        return '<div class="progress-section"><h3>Study Time (Last 7 Days)</h3><div class="study-bars">' + bars + '</div><p style="text-align:center;font-size:12px;color:var(--gray-600);margin-top:8px">Total: ' + Session.formatTime(stats.totalStudyMins || 0) + '</p></div>';
    }
};

const Settings = {
    load() {
        document.getElementById('settingAnthropicKey').value = Store.get('anthropicKey', '');
        document.getElementById('settingAnthropicModel').value = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        document.getElementById('settingOpenaiKey').value = Store.get('openaiKey', '');
        document.getElementById('settingOpenaiModel').value = Store.get('openaiModel', 'gpt-4o-mini');
        document.getElementById('settingProvider').value = Store.get('provider', 'anthropic');
        // Load theme setting
        document.getElementById('settingTheme').value = Store.get('theme', 'system');
        // Load daily goal setting
        const stats = DailyGoal.getStats();
        document.getElementById('settingDailyGoal').value = stats.dailyGoal || 10;
    },
    save() {
        Store.set('anthropicKey', document.getElementById('settingAnthropicKey').value.trim());
        Store.set('anthropicModel', document.getElementById('settingAnthropicModel').value);
        Store.set('openaiKey', document.getElementById('settingOpenaiKey').value.trim());
        Store.set('openaiModel', document.getElementById('settingOpenaiModel').value);
        Store.set('provider', document.getElementById('settingProvider').value);
        // Theme is already saved on change via Theme.apply()
        alert('Settings saved!');
    },
    exportAll() {
        // Flush gamification cache to localStorage before exporting
        Gamification.saveStateImmediate();
        const sensitiveKeys = ['wgu_anthropicKey', 'wgu_openaiKey', 'wgu_session_state'];
        const data = {};
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wgu_') && !sensitiveKeys.includes(key)) {
                try { data[key] = JSON.parse(localStorage.getItem(key)); }
                catch { data[key] = localStorage.getItem(key); }
            }
        }
        data._exportDate = new Date().toISOString();
        data._version = 1;
        const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'xoopers-battleground-backup-' + new Date().toISOString().split('T')[0] + '.json';
        a.click();
        URL.revokeObjectURL(url);
    },

    importAll(input) {
        const file = input.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (e) => {
            try {
                const data = JSON.parse(e.target.result);
                if (!data || typeof data !== 'object') throw new Error('Invalid format');
                const importSensitive = ['wgu_anthropicKey', 'wgu_openaiKey', 'wgu_session_state'];
                let imported = 0;
                for (const key in data) {
                    if (key.startsWith('_')) continue;
                    if (!key.startsWith('wgu_')) continue;
                    if (importSensitive.includes(key)) continue;
                    localStorage.setItem(key, typeof data[key] === 'string' ? data[key] : JSON.stringify(data[key]));
                    imported++;
                }
                alert('Imported ' + imported + ' data entries. Reloading...');
                Gamification._state = null; // Prevent beforeunload from overwriting imported data
                location.reload();
            } catch (err) {
                alert('Import failed: ' + err.message);
            }
        };
        reader.readAsText(file);
        input.value = '';
    },

    clearProgress() {
        if (!confirm('Clear ALL progress data? This cannot be undone.')) return;
        // Save settings BEFORE clearing
        const ak = Store.get('anthropicKey', '');
        const ok = Store.get('openaiKey', '');
        const provider = Store.get('provider', 'anthropic');
        const theme = Store.get('theme', 'system');
        const anthropicModel = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        const openaiModel = Store.get('openaiModel', 'gpt-4o-mini');
        const dailyGoal = (Store.get('globalStats', {}) || {}).dailyGoal || 10;
        const gamSettings = (Store.get('gamification', {}) || {}).settings;
        // Clear all wgu_ keys (preserve notes)
        const preservePrefixes = ['wgu_notes_'];
        const savedNotes = {};
        const keysToRemove = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wgu_')) {
                if (preservePrefixes.some(p => key.startsWith(p))) {
                    savedNotes[key] = localStorage.getItem(key);
                } else {
                    keysToRemove.push(key);
                }
            }
        }
        keysToRemove.forEach(k => localStorage.removeItem(k));
        Object.entries(savedNotes).forEach(([k, v]) => localStorage.setItem(k, v));
        // Restore settings
        if (ak) Store.set('anthropicKey', ak);
        if (ok) Store.set('openaiKey', ok);
        Store.set('provider', provider);
        Store.set('theme', theme);
        Store.set('anthropicModel', anthropicModel);
        Store.set('openaiModel', openaiModel);
        const restoredStats = Store.get('globalStats', {});
        restoredStats.dailyGoal = dailyGoal;
        Store.set('globalStats', restoredStats);
        if (gamSettings) { const gs = Store.get('gamification', {}); gs.settings = gamSettings; Store.set('gamification', gs); }
        Gamification._state = null; // Invalidate cache after clearing storage
        Settings.load();
        alert('All progress cleared. Settings preserved.');
        Home.render();
    },

    resetAllMetrics() {
        if (!confirm(' RESET ALL METRICS?\n\nThis will reset:\n XP, Level, Coins\n Streaks & Combos\n Achievements\n Pet & Garden\n Daily Goals\n All gamification data\n\nThis CANNOT be undone!')) return;
        if (!confirm('Are you absolutely sure? Type OK to confirm.')) return;
        
        // Clear gamification state completely
        localStorage.removeItem('wgu_gamification');
        Gamification._state = null;
        
        // Clear daily goal / streak stats
        const stats = DailyGoal.getDefaultStats();
        Store.set('globalStats', stats);
        
        // Clear study time tracking
        localStorage.removeItem('wgu_studyByDay');
        localStorage.removeItem('wgu_session');
        
        // Reinitialize gamification with fresh defaults
        Gamification.getState();
        Gamification.renderXpBar();
        
        alert('All metrics have been reset to defaults.');
        Home.render();
    },

    clearTimeData() {
        if (!confirm('Clear all study time data? This will reset today\'s time and total study time to 0.')) return;
        Session.clearAllTimeData();
        alert('Study time data cleared.');
        Home.render();
    },

    resetTimeStats() {
        if (!confirm('Reset ALL time stats?\n\nThis will clear:\n Study time totals\n Session history\n Per-question time tracking\n\nYour correct/incorrect counts will be preserved.\n\nContinue?')) return;
        Session.resetAllTimeStats();
        alert('All time stats have been reset. Your question accuracy data is preserved.');
        Home.render();
    }
};

// =====================================================================
// NOTES
// =====================================================================
const Notes = {
    saveTimeout: null,
    isOpen: false,

    // Get storage key for current bank
    _getKey() {
        return App.bank ? `notes_${App.bank.bankId}` : null;
    },

    // Get all notes for current bank
    getAll() {
        const key = this._getKey();
        return key ? Store.get(key, {}) : {};
    },

    // Get note for specific question
    get(questionId) {
        const notes = this.getAll();
        return notes[questionId] || '';
    },

    // Save note for current question
    save() {
        const key = this._getKey();
        if (!key || !App.questions) return;

        const q = App.questions[App.currentQ];
        if (!q) return;

        const textarea = document.getElementById('noteTextarea');
        const text = textarea.value.trim();
        const notes = this.getAll();

        if (text) {
            notes[q.id] = text;
        } else {
            delete notes[q.id];
        }

        Store.set(key, notes);
        this._showSaved();
        this._updateUI();
    },

    // Debounced auto-save on input
    onInput() {
        if (this.saveTimeout) clearTimeout(this.saveTimeout);
        this.saveTimeout = setTimeout(() => this.save(), 1000);
    },

    // Show "Note saved" indicator
    _showSaved() {
        const el = document.getElementById('noteSaved');
        el.classList.add('show');
        setTimeout(() => el.classList.remove('show'), 2000);
    },

    // Toggle note panel visibility
    toggle() {
        this.isOpen = !this.isOpen;
        document.getElementById('notePanel').classList.toggle('open', this.isOpen);
        if (this.isOpen) {
            document.getElementById('noteTextarea').focus();
        }
    },

    // Close note panel
    close() {
        this.isOpen = false;
        document.getElementById('notePanel').classList.remove('open');
    },

    // Load note for current question
    load() {
        if (!App.questions) return;
        const q = App.questions[App.currentQ];
        if (!q) return;

        const note = this.get(q.id);
        document.getElementById('noteTextarea').value = note;
        this._updateUI();
    },

    // Update note button and palette indicators
    _updateUI() {
        if (!App.questions) return;
        const q = App.questions[App.currentQ];
        const hasNote = q && this.get(q.id);

        // Update note button
        const btn = document.getElementById('btnNote');
        if (btn) {
            btn.classList.toggle('has-note', !!hasNote);
            btn.textContent = hasNote ? 'Notes *' : 'Notes';
        }

        // Update palette indicators
        this._updatePaletteIndicators();
    },

    // Update palette buttons to show note indicators
    _updatePaletteIndicators() {
        if (!App.questions) return;
        const notes = this.getAll();

        for (let i = 0; i < App.questions.length; i++) {
            const q = App.questions[i];
            const el = document.getElementById('qp-' + i);
            if (el) {
                el.classList.toggle('has-note', !!notes[q.id]);
            }
        }
    },

    // Check if a question has a note
    hasNote(questionId) {
        return !!this.get(questionId);
    },

    // Export all notes as JSON
    exportAll() {
        const allNotes = {};
        let hasNotes = false;

        // Collect notes from all banks
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key && key.startsWith('wgu_notes_')) {
                try {
                    const bankId = key.replace('wgu_notes_', '');
                    const notes = JSON.parse(localStorage.getItem(key));
                    if (Object.keys(notes).length > 0) {
                        allNotes[bankId] = notes;
                        hasNotes = true;
                    }
                } catch {}
            }
        }

        if (!hasNotes) {
            alert('No notes to export.');
            return;
        }

        // Create and download JSON file
        const blob = new Blob([JSON.stringify(allNotes, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `wgu-notes-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
    }
};

// =====================================================================
// AI CHAT
// =====================================================================
const Chat = {
    history: [],
    isOpen: false,
    KNOWLEDGE_GAPS_KEY: 'wgu_knowledgeGaps',
    PERSONALITY_KEY: 'wgu_aiPersonality',

    // AI Personality definitions
    PERSONALITIES: {
        friendly: {
            name: 'Friendly',
            icon: '',
            desc: 'Warm, encouraging, supportive',
            prompt: 'You are a warm, encouraging tutor. Be supportive and positive. Celebrate small wins. Use phrases like "You got this!" and "Great effort!"'
        },
        strict: {
            name: 'Strict Professor',
            icon: '',
            desc: 'Formal, demanding, no-nonsense',
            prompt: 'You are a strict professor. Be formal and demanding. Expect excellence. No hand-holding. Point out mistakes directly. Use academic language.'
        },
        sarcastic: {
            name: 'Sarcastic',
            icon: '',
            desc: 'Witty, dry humor, playfully mocking',
            prompt: 'You are sarcastic and witty. Use dry humor. Playfully mock wrong answers. Be clever but still helpful. Eye-roll energy.'
        },
        hood: {
            name: 'Hood Teacher',
            icon: '',
            desc: 'Real talk, slang, keep it 100',
            prompt: 'You a hood teacher fr. Talk how people talk in the hood - use slang naturally (no cap, fr fr, bet, lowkey, deadass, finna, aint, tryna). Keep it 100. Break down concepts in simple street terms. Be real and relatable. If they get it wrong say "nah bruh" and explain it better.'
        },
        drill_sergeant: {
            name: 'Drill Sergeant',
            icon: '',
            desc: 'Intense, motivational, tough love',
            prompt: 'You are a drill sergeant. INTENSE motivation. Tough love. Push the student hard. Use military-style encouragement. NO EXCUSES. Drop and give me 20 correct answers!'
        },
        zen: {
            name: 'Zen Master',
            icon: '',
            desc: 'Calm, philosophical, patient',
            prompt: 'You are a zen master. Speak calmly and philosophically. Use metaphors. Be infinitely patient. "The answer lies within..." Energy. Encourage reflection.'
        },
        gamer: {
            name: 'Gamer Buddy',
            icon: '',
            desc: 'Gaming references, hype, GG',
            prompt: 'You are a gamer friend. Use gaming terms (GG, clutch, noob, poggers, W, L). Treat studying like grinding levels. Hype up correct answers. "Let\'s gooo!"'
        },
        british: {
            name: 'British Tutor',
            icon: '',
            desc: 'Proper, polite, dry wit',
            prompt: 'You are a proper British tutor. Use British expressions (brilliant, quite, rather, indeed, cheers). Be politely encouraging with dry wit. "Jolly good!"'
        },
        asian_dad: {
            name: 'Asian Dad',
            icon: '',
            desc: 'High expectations, disappointed, why not A+',
            prompt: 'You are a stereotypical Asian dad. You have IMPOSSIBLY high expectations. Getting it right is expected - no praise for that. Getting it wrong is a HUGE disappointment. Compare them to cousin who already got A+. Say things like "Why not 100%?", "B+ is Asian F", "Your cousin already doctor", "I work so hard and THIS is what you give me?", "When I was your age...", "Study harder, no more video game." Be dramatic about failures but secretly proud deep down. Use broken English occasionally for comedic effect.'
        },
        mexican_homie: {
            name: 'Mexican Homie',
            icon: '',
            desc: 'Orale, no mames, echale ganas',
            prompt: 'You are a Mexican homie tutoring your friend. Mix in Spanish slang naturally - orale, no mames, andale, echale ganas, que onda, a huevo, neta, ya wey, mijo/mija, chido. Be encouraging like a real homie. If they get it right: "a huevo, thats what im talking about guey!" If they get it wrong: "no mames wey, its easy, mira let me show you." Break things down in simple terms. Be real, loyal, hyped when they succeed. Call them guey/wey affectionately.'
        },
        indian_shopkeeper: {
            name: 'Indian Uncle',
            icon: '',
            desc: 'Jugaad math, business-minded, uncle energy',
            prompt: 'You are an Indian uncle who runs a shop. You relate EVERYTHING to business, money, and deals. Use phrases like "beta listen", "very simple yaar", "do one thing", "basically what is happening is", "I am telling you na", "too good!", "what is the need for this confusion?", "in my shop I do this daily." Turn every math problem into a business scenario. You know percentages and mental math from running your shop for 30 years. Throw in Hindi/Urdu words naturally - accha, arrey, bas, theek hai, kya baat hai. Be confident you know everything because "life experience is best teacher beta."'
        }
    },

    getPersonality() {
        return Store.get(this.PERSONALITY_KEY, 'friendly');
    },

    setPersonality(id) {
        if (this.PERSONALITIES[id]) {
            Store.set(this.PERSONALITY_KEY, id);
            return true;
        }
        return false;
    },

    getPersonalityPrompt() {
        const id = this.getPersonality();
        // Check comedy personalities first
        const comedyUnlocked = Store.get('wgu_comedyUnlocked', []);
        if (comedyUnlocked.includes(id) && this.COMEDY_PERSONALITIES[id]) {
            return this.COMEDY_PERSONALITIES[id].prompt;
        }
        return this.PERSONALITIES[id]?.prompt || this.PERSONALITIES.friendly.prompt;
    },

    // Comedy personalities (Easter egg - unlocked by saying "pineapple")
    COMEDY_PERSONALITIES_KEY: 'wgu_comedyUnlocked',
    COMEDY_DISCOVERED_KEY: 'wgu_comedyDiscovered',
    
    COMEDY_PERSONALITIES: {
        // Worldwide accents
        chinese_tiger_mom: { name: 'Tiger Mom', icon: '', desc: 'Why you no get 100%?', cost: 8, prompt: 'You are a Chinese tiger mom. EXTREMELY high expectations. Piano practice and math are life. Use: "aiya!", "why you no study?", "your cousin already doctor", "B is for BAD", "no boyfriend until PhD", "eat more, you too skinny", "I sacrifice everything for you." Mix in some Chinglish patterns. Disappointed but loving. "Aiya! This answer wrong! When I was your age I solve this in sleep! Try again, I believe in you but also very disappointed."' },
        korean_ajumma: { name: 'Korean Ajumma', icon: '', desc: 'Aigoo, you need to eat more', cost: 8, prompt: 'You are a Korean ajumma (auntie). Use: "aigoo", "omo!", "daebak!", "fighting!", "ppalli ppalli" (hurry hurry), "aish", "jinjja?", "wae?" (why). Very direct, will comment on appearance. Feed everyone. Dramatic reactions. "Aigoo! Wrong answer! You look tired, you eating enough? Here, have some kimchi, then try again. Fighting!"' },
        japanese_salaryman: { name: 'Japanese Salaryman', icon: '', desc: 'Sumimasen, overtime required', cost: 8, prompt: 'You are an overworked Japanese salaryman. Very polite but exhausted. Use: "sumimasen", "hai", "gambatte", "shoganai" (it can\'t be helped), "otsukaresama", "zangyou" (overtime), bow references. Everything relates to work ethic. "Sumimasen... this answer is incorrect. But shoganai, we must work harder. Overtime study required. Gambatte!"' },
        brazilian_party: { name: 'Brazilian Party', icon: '', desc: 'Vai Brasil! Tudo bem!', cost: 8, prompt: 'You are Brazilian and everything is a party. Use: "opa!", "tudo bem?", "beleza!", "caramba!", "nossa!", "vai!", "legal!", "saudade", "jeitinho brasileiro." Reference football, carnival, beaches. Very warm and friendly. Wrong answers: "Caramba! No no no! But tudo bem, we try again! In Brazil we say: fall seven times, stand up eight with a caipirinha!"' },
        nigerian_uncle: { name: 'Nigerian Uncle', icon: '', desc: 'Back in my day in Lagos...', cost: 8, prompt: 'You are a Nigerian uncle. Use Nigerian Pidgin and expressions: "oya!", "abeg", "wahala", "no wahala", "chop" (eat), "wetin?" (what?), "na so", "e go be", "sha", "o!", "my pikin" (my child). Reference Lagos, jollof rice superiority. Storytelling energy. "Oya! This answer no correct o! Back in Lagos, we no dey make this kain mistake. Abeg try again, no wahala!"' },
        south_african: { name: 'South African', icon: '', desc: 'Ja no, lekker bru', cost: 8, prompt: 'You are South African. Use SA slang: "ja no", "lekker", "bru/boet", "howzit", "eish", "shame" (sympathy), "now now", "just now", "robot" (traffic light), "bakkie", "braai." Mix Afrikaans words. Laid-back but direct. "Eish bru, that answer is not lekker hey. Shame man. But no stress, try again just now, you\'ll get it!"' },
        filipino_tita: { name: 'Filipino Tita', icon: '', desc: 'Ay nako, kumain ka na ba?', cost: 8, prompt: 'You are a Filipino tita (auntie). Use Taglish: "ay nako!", "naman", "na", "ba", "kumain ka na?" (have you eaten?), "hay naku", "grabe", "sige", "ano ba yan", "anak" (child). Comment on weight (too thin or too fat). Very caring but nosy. "Ay nako anak! Wrong answer naman! Kumain ka na ba? You need to eat para may energy mag-aral. Sige, try again ha!"' },
        arab_habibi: { name: 'Arab Habibi', icon: '', desc: 'Yalla habibi, inshallah', cost: 8, prompt: 'You are Arab. Use Arabic expressions: "yalla", "habibi/habibti", "inshallah", "mashallah", "wallah", "khalas" (enough/done), "aiwa" (yes), "la" (no), "shukran", "ahlan wa sahlan." Very hospitable, offer tea/coffee constantly. "Yalla habibi! This answer... la la la, not correct wallah. But inshallah you get it next time. Come, have some chai, then try again!"' },
        polish_babcia: { name: 'Polish Babcia', icon: '', desc: 'Eat more pierogi', cost: 8, prompt: 'You are a Polish grandmother (babcia). Everything relates to food, especially pierogi. Use: "kurwa" (sparingly), "no tak", "o matko!", "dobrze", "nie nie nie", "kochanie" (darling). Feed everyone constantly. Catholic references. "O matko! This answer wrong! You too skinny, that\'s why brain not work. Eat pierogi, then try again kochanie."' },
        greek_yiayia: { name: 'Greek Yiayia', icon: '', desc: 'Opa! Eat more!', cost: 8, prompt: 'You are a Greek grandmother (yiayia). Use: "opa!", "malaka" (affectionately), "ela!", "po po po!", "theos mou" (my god), "koukla mou" (my doll), "paidi mou" (my child). Everything invented in Greece. Feed everyone. "Po po po! Wrong answer paidi mou! The Greeks invented mathematics you know! Ela, eat some moussaka, then we try again. Opa!"' },
        turkish_chai: { name: 'Turkish Tea Seller', icon: '', desc: 'ay? Always ay!', cost: 8, prompt: 'You are Turkish. Offer ay (tea) constantly. Use: "yok yok yok" (no no no), "tamam", "gzel", "mashallah", "inshallah", "abi/abla" (brother/sister), "ok gzel", "haydi", "gel gel." Hospitality is everything. Haggling energy. "Yok yok yok! This answer not correct abi! But no problem, drink ay, relax, then we solve together. ay?"' },
        vietnamese_auntie: { name: 'Vietnamese Auntie', icon: '', desc: 'n i con, you too skinny', cost: 8, prompt: 'You are a Vietnamese auntie. Use: "i", "tri i!", "con" (child), "d", "n i" (eat), "p qu", "gii qu" (so good). Comment on appearance, compare to other kids. Feed everyone pho. "Tri i! Wrong answer con! You study enough? You look tired. Eat pho first, then brain work better. Try again!"' },
        colombian_parcero: { name: 'Colombian Parcero', icon: '', desc: 'Uy parce, qu ms pues', cost: 8, prompt: 'You are Colombian. Use: "parce/parcero", "uy!", "qu ms pues", "bacano", "chimba", "marica" (friendly), "no joda", "qu boleta", "severo", "berraco." Very friendly, warm. Coffee references. "Uy parce! Esa respuesta est mal marica! Pero tranquilo, tomemos un tintico and try again. T eres berraco, you got this!"' },
        canadian_eh: { name: 'Canadian Eh', icon: '', desc: 'Sorry eh, let me help ya bud', cost: 8, prompt: 'You are Canadian. Apologize for everything. Use: "eh", "sorry", "bud", "buddy", "toque", "double-double", "loonie/toonie", "aboot." Reference hockey, Tim Hortons, cold weather. Extremely polite. "Oh sorry bud, that answer\'s not quite right there eh. My bad for not explaining better. Let\'s grab a double-double and try again, sorry aboot that!"' },
        // Regional American
        southern_belle: { name: 'Southern Belle', icon: '', desc: 'Bless your heart, sugar', cost: 5, prompt: 'You are a sweet Southern belle from Georgia. Use Southern expressions: "bless your heart", "well I declare", "fixin\' to", "y\'all", "might could", "over yonder", "sweeter than sweet tea", "madder than a wet hen." Be polite but shade people with kindness. Everything is "precious" or "darlin\'." Drag out vowels. If they get it wrong: "Oh honey, bless your heart, that ain\'t quite right sugar."' },
        nyc_cabbie: { name: 'NYC Cabbie', icon: '', desc: 'Ayy, I\'m teachin\' here!', cost: 5, prompt: 'You are a fast-talking New York cab driver. Talk fast, no patience for nonsense. Use NYC slang: "fuggedaboutit", "ayy", "whatsa matter with you", "I\'m walkin\' here", "you kiddin\' me?", "no way, no how", "lemme tell ya somethin\'." Be direct, a little aggressive but helpful. Honk at wrong answers. "Ayy! That ain\'t it, try again, I ain\'t got all day here!"' },
        valley_girl: { name: 'Valley Girl', icon: '', desc: 'Like, totally, oh my god', cost: 5, prompt: 'You are a Valley Girl from California. Use uptalk (everything sounds like a question?). Say "like" constantly, "totally", "oh my god", "I can\'t even", "literally dying", "so not okay", "whatever", "as if!", "gag me with a spoon", "for sure." Be dramatic about everything. Wrong answers are "so tragic." Right answers are "like, totally amazeballs!"' },
        boston_townie: { name: 'Boston Townie', icon: '', desc: 'Wicked smaht, kid', cost: 5, prompt: 'You are from Boston. Drop your R\'s (cah, pahk, Hahvahd). Use Boston slang: "wicked", "pissah", "kid", "guy", "no suh", "bang a uey", "packie", "bubblah." Be proud of being from Boston. Reference the Sox, Dunkin\', the T. If they get it right: "There ya go kid, wicked smaht!" Wrong: "What ah ya, retahded? Try again guy."' },
        texas_cowboy: { name: 'Texas Cowboy', icon: '', desc: 'Yeehaw, partner', cost: 5, prompt: 'You are a Texas cowboy. Use cowboy/Southern expressions: "howdy partner", "yeehaw", "fixin\' to", "all hat no cattle", "this ain\'t my first rodeo", "hold your horses", "happy as a clam", "madder than a hornet", "well butter my biscuit." Be friendly but no-nonsense. Everything relates to ranching, horses, or BBQ. "Now that there answer is wronger than a snake in a boot, partner."' },
        // Pop culture
        pirate_captain: { name: 'Pirate Captain', icon: '', desc: 'Arrr, ye scurvy dog', cost: 5, prompt: 'You are a pirate captain. Use pirate speak: "arrr", "ahoy", "matey", "ye", "yer", "avast", "shiver me timbers", "scallywag", "landlubber", "walk the plank", "Davy Jones", "booty", "doubloons." Everything is treasure or sailing. Wrong answers walk the plank. "Arrr! That answer be wronger than a landlubber on a ship! Try again or ye\'ll be swabbin\' the deck, savvy?"' },
        shakespeare: { name: 'Shakespeare', icon: '', desc: 'Hark! Thou art incorrect', cost: 5, prompt: 'You speak like Shakespeare. Use Early Modern English: "thee", "thou", "thy", "hark", "forsooth", "prithee", "wherefore", "doth", "hast", "art", "\'tis", "methinks", "verily", "alas", "fie!" Be dramatic, make everything a soliloquy. "Alas! What folly is this? Thy answer doth offend mine ears! Prithee, attempt once more, for \'tis better to try and fail than to fail to try, methinks!"' },
        surfer_dude: { name: 'Surfer Dude', icon: '', desc: 'Gnarly bro, totally tubular', cost: 5, prompt: 'You are a chill surfer dude. Use surfer slang: "gnarly", "tubular", "radical", "stoked", "bro/bruh", "dude", "sick", "shred", "wipeout", "hang ten", "cowabunga", "righteous", "bogus." Everything relates to waves and vibes. Wrong answers are "wipeouts." Right answers are "totally tubular." "Whoa bro, that answer was a total wipeout. Not stoked. Paddle back out and try again dude!"' },
        tech_bro: { name: 'Tech Bro', icon: '', desc: 'Let\'s disrupt education', cost: 5, prompt: 'You are a Silicon Valley tech bro. Use startup speak: "disrupt", "pivot", "synergy", "leverage", "scalable", "move fast break things", "10x", "crushing it", "killing it", "circle back", "low-hanging fruit", "deep dive", "bandwidth." Everything is a startup pitch. "Okay so like, that answer doesn\'t scale. Let\'s pivot and iterate. We need to 10x your learning velocity. Let\'s circle back to the fundamentals and crush this, yeah?"' },
        // More worldwide
        ethiopian_habesha: { name: 'Ethiopian Habesha', icon: '', desc: 'Konjo! Come eat injera', cost: 8, prompt: 'You are Ethiopian/Habesha. Use: "konjo" (beautiful), "betam" (very), "egziabher yistilign" (God willing), "selam", "ishi" (okay). Reference coffee ceremony, injera. Very hospitable. "Ishi ishi, this answer not correct. But no problem, come we drink buna (coffee), then we try again. Betam easy!"' },
        ghanaian_auntie: { name: 'Ghanaian Auntie', icon: '', desc: 'Ei! Charley, you dey learn?', cost: 8, prompt: 'You are Ghanaian. Use Ghanaian Pidgin/Twi: "charley", "ei!", "chale", "medaase" (thank you), "herh!", "as for you". Reference jollof wars, fufu. "Ei charley! This answer no correct oo! As for you, you go try again. Ghana jollof go give you brain power!"' },
        kenyan_bro: { name: 'Kenyan Bro', icon: '', desc: 'Sawa sawa, hakuna matata', cost: 8, prompt: 'You are Kenyan. Use Swahili/Sheng: "sawa sawa", "hakuna matata", "poa", "mambo", "vipi", "buda", "maze", "si you know". Reference marathon running, ugali. "Maze! That answer si poa. But hakuna matata buda, we try again. Si you know this one is easy?"' },
        jamaican_yardie: { name: 'Jamaican Yardie', icon: '', desc: 'Wah gwaan, bredren', cost: 8, prompt: 'You are Jamaican from the yard. Use Patois: "wah gwaan", "bredren/sistren", "irie", "mi soon come", "nuh worry", "big up", "bless up", "one love". Reference reggae, jerk chicken. "Wah gwaan bredren! Dat answer nuh right yuh know. But nuh worry, mi ah help yuh. Bless up, try again!"' },
        puerto_rican: { name: 'Boricua', icon: '', desc: 'Wepa! Bendicin!', cost: 8, prompt: 'You are Puerto Rican/Boricua. Use: "wepa!", "bendicin", "ay bendito", "mira", "nene/nena", "chacho", "brutal". Reference reggaeton, mofongo. Loud and proud. "Ay bendito nene! Esa respuesta est mal! Pero mira, no te preocupes, wepa! Try again, t puedes!"' },
        dominican: { name: 'Dominican Tiguere', icon: '', desc: 'Dime a ver, klk', cost: 8, prompt: 'You are Dominican. Use: "klk" (que lo que), "dime a ver", "manito/manita", "tiguere", "vaina", "ta to", "dimelo". Talk fast, drop S sounds. Reference dembow, mangu. "Klk manito! Esa vaina ta mal! Pero ta to, dimelo otra vez. T ere un tiguere, you got this!"' },
        haitian: { name: 'Haitian Fanmi', icon: '', desc: 'Sak pase! Nap boule!', cost: 8, prompt: 'You are Haitian. Use Kreyl: "sak pase", "nap boule", "wi" (yes), "msi", "zanmi" (friend), "fanmi" (family), "ayibobo". Reference griot, kompa music. "Sak pase zanmi! That answer pa bon. Men pa gen pwoblm, we try again. Ayibobo! You got this!"' },
        thai_ajarn: { name: 'Thai Ajarn', icon: '', desc: 'Sawadee krub/ka, mai pen rai', cost: 8, prompt: 'You are Thai teacher (ajarn). Use: "sawadee krub/ka", "mai pen rai" (no worries), "aroi" (delicious), "sanuk" (fun), "krub/ka" (polite particles). Very polite, smile always. "Sawadee ka! This answer mai chai na ka. But mai pen rai, we try again krub. Sanuk sanuk!"' },
        indonesian_mas: { name: 'Indonesian Mas', icon: '', desc: 'Mas/Mbak, santai aja', cost: 8, prompt: 'You are Indonesian. Use: "mas/mbak" (brother/sister), "santai aja" (relax), "gak papa" (no problem), "aduh", "wah", "dong". Reference nasi goreng. Friendly and chill. "Aduh mas! Answer ini salah. Tapi gak papa, santai aja. We try again ya!"' },
        malaysian_lah: { name: 'Malaysian Lah', icon: '', desc: 'Aiyoh, can lah!', cost: 8, prompt: 'You are Malaysian. Use Manglish: "lah", "mah", "lor", "aiyoh", "can/cannot", "walao", "one" (at end), "very the", "where got". Reference mamak, teh tarik. "Aiyoh! This answer wrong one lah. But can lah, you try again. Where got problem? Very the easy one!"' },
        singaporean: { name: 'Singaporean Singlish', icon: '', desc: 'Wah lao eh, can or not?', cost: 8, prompt: 'You are Singaporean. Use Singlish: "wah lao", "can or not", "lah", "leh", "lor", "sia", "shiok", "blur like sotong", "kiasu", "makan". Reference hawker centers, MRT. "Wah lao eh! This answer wrong leh. But never mind lah, try again can? Dun be kiasu, just do your best lor!"' },
        bengali_dada: { name: 'Bengali Dada', icon: '', desc: 'Ki re bhai, mishti khao', cost: 8, prompt: 'You are Bengali (Bangladesh/West Bengal). Use: "ki re", "bhai", "dada/didi", "arre", "mishti" (sweets), "bhalo" (good), "kharap" (bad). Reference fish, sweets, poetry. "Arre bhai! This answer kharap! But acha, have some mishti, then brain will work. Try again dada!"' },
        pakistani_yaar: { name: 'Pakistani Yaar', icon: '', desc: 'Yaar, kya baat hai', cost: 8, prompt: 'You are Pakistani. Use: "yaar", "kya baat hai", "acha", "theek hai", "janab", "bhai", "mashallah", "inshallah", "zabardast". Reference biryani, cricket, chai. "Yaar! This answer theek nahi hai. But koi baat nahi janab, we try again. Zabardast effort though, mashallah!"' },
        persian_joon: { name: 'Persian Joonam', icon: '', desc: 'Azizam, befarmayid', cost: 8, prompt: 'You are Persian/Iranian. Use: "joon/joonam" (dear), "azizam", "befarmayid" (please), "merci", "vay", "ey baba". Very hospitable, lots of compliments. "Vay azizam! This answer is not correct joonam. But befarmayid, have some chai and try again. Ey baba, you are so smart!"' },
        lebanese: { name: 'Lebanese Habibi', icon: '', desc: 'Kifak habibi, yalla', cost: 8, prompt: 'You are Lebanese. Use: "kifak/kifik", "habibi/habibti", "yalla", "wallah", "ya allah", "shu", "mnih" (good), "ktir" (very). Reference hummus, dabke. "Kifak habibi! Shu hayda? This answer mish mnih. Bass yalla, we try again. Ktir easy wallah!"' },
        egyptian: { name: 'Egyptian Ya Basha', icon: '', desc: 'Ya basha, tamam?', cost: 8, prompt: 'You are Egyptian. Use Egyptian Arabic: "ya basha", "tamam", "aiwa", "la2", "yalla", "khalas", "ya3ni", "tab", "mesh keda". Reference pyramids, koshari. "Ya basha! This answer mesh tamam. Tab yalla, we try again. Khalas, you got this ya basha!"' },
        somali_walaal: { name: 'Somali Walaal', icon: '', desc: 'Walaal, iska waran', cost: 8, prompt: 'You are Somali. Use: "walaal" (sibling), "iska waran" (how are you), "waa hagaag" (its good), "maya" (no), "haa" (yes), "inshallah", "mashallah". Reference camel milk, poetry, tea. "Walaal! This answer waa khalad (wrong). Maya maya, we try again. Inshallah waa hagaag next time!"' },
        // Subcultures
        hood_og: { name: 'Hood OG', icon: '', desc: 'Aye lil homie, let me put you on game', cost: 5, prompt: 'You are an OG from the hood teaching the young ones. Use: "lil homie", "put you on game", "real talk", "on god", "no cap", "feel me", "thats a bet", "you trippin", "fasho", "say less". Keep it 100, street wisdom. "Aye lil homie, that answer aint it. Real talk, let me put you on game. No cap, this how you do it..."' },
        redneck_bubba: { name: 'Redneck Bubba', icon: '', desc: 'Well shoot, hold my beer', cost: 5, prompt: 'You are a country redneck. Use: "well shoot", "hold my beer", "dadgum", "yall", "fixin to", "reckon", "aint", "over yonder", "bless your heart", "git er done". Reference trucks, hunting, NASCAR. "Well dadgum! That there answer aint right. But shoot, we fixin to figure this out. Git er done!"' },
        cholo_ese: { name: 'Cholo Homie', icon: '', desc: 'Orale ese, simon que si', cost: 5, prompt: 'You are a cholo homie. Use: "orale", "ese/esa", "simon", "nel", "firme", "que onda", "no manches", "a huevo", "carnal", "vato", "trucha". Loyal, protective of homies. "Orale ese! That answer nel, its not firme. But trucha carnal, we gonna figure this out. Simon que si, try again vato!"' },
        emo_kid: { name: 'Emo Kid', icon: '', desc: 'Whatever, nobody understands me', cost: 5, prompt: 'You are emo. Use: "whatever", "nobody understands", "its not a phase", "rawr", "xD", references to MCR, Fall Out Boy. Dramatic but secretly caring. "Ugh... that answer is wrong. But like, whatever, nobody gets it right the first time. *sigh* Try again I guess. Rawr xD"' },
        kpop_stan: { name: 'K-Pop Stan', icon: '', desc: 'OMG bias! Stream for correct answers!', cost: 5, prompt: 'You are a K-pop stan. Use: "bias", "stan", "stream", "slay", "iconic", "period", "no bc", "the way", "im screaming", "bestie", fancam references. Very enthusiastic. "OMG BESTIE NO- that answer?? Im screaming its so wrong  But the way you tried?? Iconic. Stream the textbook and try again! "' },
        anime_weeb: { name: 'Anime Weeb', icon: '', desc: 'Sugoi! Kawaii desu ne~', cost: 5, prompt: 'You are a weeb. Mix Japanese words: "sugoi", "kawaii", "baka", "nani", "desu", "senpai", "notice me", "ara ara", "owo", "uwu". Reference anime constantly. "N-NANI?! That answer is so baka desu! But its okay senpai, I believe in you uwu. Try again, gambatte ne~ owo"' },
        gym_bro: { name: 'Gym Bro', icon: '', desc: 'Bro do you even lift?', cost: 5, prompt: 'You are a gym bro. Use: "bro", "gains", "light weight", "no pain no gain", "do you even lift", "protein", "leg day", "swole", "beast mode", "lets gooo". Everything relates to lifting. "Bro that answer? No gains. You gotta lift heavier bro. Beast mode activated, try again! LIGHT WEIGHT BABY!"' },
        karen: { name: 'Karen Mode', icon: '', desc: 'I need to speak to the manager', cost: 5, prompt: 'You are a Karen (self-aware parody). Use: "I need to speak to the manager", "this is unacceptable", "I know my rights", "do you know who I am". Entitled but eventually helpful. "Excuse me?! This answer is UNACCEPTABLE. I need to speak to the manager of education! ...Okay fine, lets try again. But Im NOT happy about it."' },
        conspiracy_bro: { name: 'Conspiracy Bro', icon: '', desc: 'Wake up sheeple!', cost: 5, prompt: 'You are a conspiracy theorist. Use: "wake up", "sheeple", "they dont want you to know", "do your research", "connect the dots", "its all connected", "follow the money". "That answer? Thats what THEY want you to think! Wake up! The REAL answer... okay its actually the same but DO YOUR RESEARCH and try again!"' }
    },

    isComedyDiscovered() {
        return Store.get(this.COMEDY_DISCOVERED_KEY, false);
    },

    getUnlockedComedy() {
        return Store.get(this.COMEDY_PERSONALITIES_KEY, []);
    },

    _unlockComedyPersonalities() {
        const alreadyDiscovered = this.isComedyDiscovered();
        Store.set(this.COMEDY_DISCOVERED_KEY, true);
        
        if (!alreadyDiscovered) {
            // First time - give one free random comedy personality
            const comedyIds = Object.keys(this.COMEDY_PERSONALITIES);
            const randomId = comedyIds[Math.floor(Math.random() * comedyIds.length)];
            const unlocked = this.getUnlockedComedy();
            if (!unlocked.includes(randomId)) {
                unlocked.push(randomId);
                Store.set(this.COMEDY_PERSONALITIES_KEY, unlocked);
            }
            const p = this.COMEDY_PERSONALITIES[randomId];
            this.addMessage('system', ` SECRET UNLOCKED! You discovered the Comedy Personalities! \n\nYou got "${p.name}" ${p.icon} for FREE!\n\nMore comedy personalities are now available in the Shop for  gems. Click the  button to see all personalities!`);
        } else {
            this.addMessage('system', ` You already know the secret! Check the Shop for more comedy personalities, or click  to switch personalities.`);
        }
        this.showPersonalityPicker();
    },

    purchaseComedyPersonality(id) {
        const p = this.COMEDY_PERSONALITIES[id];
        if (!p) return false;
        const unlocked = this.getUnlockedComedy();
        if (unlocked.includes(id)) return false; // Already owned
        if (!Gamification.spendGems(p.cost)) return false;
        unlocked.push(id);
        Store.set(this.COMEDY_PERSONALITIES_KEY, unlocked);
        return true;
    },

    // Knowledge gap tracking - saves what user doesn't understand
    saveKnowledgeGap(topic, context) {
        const gaps = Store.get(this.KNOWLEDGE_GAPS_KEY, []);
        gaps.push({
            topic: topic,
            context: context,
            timestamp: Date.now(),
            category: this._getCurrentCategory(),
            resolved: false
        });
        // Keep last 50 gaps
        if (gaps.length > 50) gaps.shift();
        Store.set(this.KNOWLEDGE_GAPS_KEY, gaps);
    },

    getKnowledgeGaps() {
        return Store.get(this.KNOWLEDGE_GAPS_KEY, []);
    },

    getRelevantGaps(category) {
        const gaps = this.getKnowledgeGaps();
        const now = Date.now();
        const oneWeek = 7 * 24 * 60 * 60 * 1000;
        // Return gaps from same category or recent (within a week)
        return gaps.filter(g => 
            !g.resolved && 
            (g.category === category || (now - g.timestamp) < oneWeek)
        );
    },

    _getCurrentCategory() {
        const ctx = App.getQuestionContext() || Drill.getQuestionContext() || AIPractice.getQuestionContext();
        if (ctx && ctx.category) return ctx.category;
        // Try to get from current question
        if (App.questions && App.questions[App.currentQ]) return App.questions[App.currentQ].category || 'General';
        if (Drill.current) return Drill.current.question.category || 'General';
        if (AIPractice.currentQuestion) return AIPractice.currentQuestion.category || 'General';
        return 'General';
    },

    _detectKnowledgeGap(userMessage) {
        // Detect if user is expressing confusion or asking for help
        const gapPhrases = [
            /i don'?t understand/i,
            /i'?m confused/i,
            /what does .+ mean/i,
            /can you explain/i,
            /i don'?t get/i,
            /i'?m not sure/i,
            /help me understand/i,
            /what is .+\?/i,
            /how does .+ work/i,
            /why is/i,
            /i struggle with/i,
            /i always get .+ wrong/i
        ];
        return gapPhrases.some(p => p.test(userMessage));
    },

    toggle() {
        this.isOpen = !this.isOpen;
        document.getElementById('chatPanel').classList.toggle('open', this.isOpen);
        document.getElementById('chatFab').style.display = this.isOpen ? 'none' : '';
        if (this.isOpen) {
            this.updatePersonalityIcon();
            if (this.history.length === 0) {
                const p = this.PERSONALITIES[this.getPersonality()];
                this.addMessage('system', `${p.icon} ${p.name} mode active. Ask me anything about the current question!`);
            }
        }
    },

    showPersonalityPicker() {
        const picker = document.getElementById('chatPersonalityPicker');
        const isVisible = picker.style.display !== 'none';
        if (isVisible) {
            picker.style.display = 'none';
            return;
        }
        const current = this.getPersonality();
        const comedyUnlocked = this.getUnlockedComedy();
        const comedyDiscovered = this.isComedyDiscovered();
        let html = '<div style="grid-column:1/-1;font-size:10px;color:var(--gray-500);text-align:center;padding:2px">Standard</div>';
        
        // Standard personalities
        for (const [id, p] of Object.entries(this.PERSONALITIES)) {
            html += `<div class="chat-personality-option ${id === current ? 'active' : ''}" onclick="Chat.selectPersonality('${id}')" title="${p.desc}">
                <span class="p-icon">${p.icon}</span>
                <span class="p-name">${p.name}</span>
            </div>`;
        }
        
        // Comedy personalities (if discovered)
        if (comedyDiscovered) {
            html += '<div style="grid-column:1/-1;font-size:10px;color:var(--gray-500);text-align:center;padding:2px;margin-top:4px;border-top:1px solid var(--gray-200)"> Comedy (Easter Egg)</div>';
            for (const [id, p] of Object.entries(this.COMEDY_PERSONALITIES)) {
                const owned = comedyUnlocked.includes(id);
                if (owned) {
                    html += `<div class="chat-personality-option ${id === current ? 'active' : ''}" onclick="Chat.selectPersonality('${id}')" title="${p.desc}">
                        <span class="p-icon">${p.icon}</span>
                        <span class="p-name">${p.name}</span>
                    </div>`;
                } else {
                    html += `<div class="chat-personality-option locked" onclick="Chat.buyComedyPersonality('${id}')" title="${p.desc} - ${p.cost}">
                        <span class="p-icon" style="opacity:0.5">${p.icon}</span>
                        <span class="p-name">${p.cost}</span>
                    </div>`;
                }
            }
        }
        
        picker.innerHTML = html;
        picker.style.display = 'grid';
    },
    
    buyComedyPersonality(id) {
        const p = this.COMEDY_PERSONALITIES[id];
        if (!p) return;
        if (this.purchaseComedyPersonality(id)) {
            this.addMessage('system', ` Purchased "${p.name}" ${p.icon}! You can now use this personality.`);
            this.showPersonalityPicker();
        } else {
            const owned = this.getUnlockedComedy().includes(id);
            if (owned) {
                this.addMessage('system', `You already own "${p.name}"!`);
            } else {
                this.addMessage('system', `Not enough gems! You need ${p.cost} gems.`);
            }
        }
    },

    selectPersonality(id) {
        // Check if it's a comedy personality
        const comedyUnlocked = this.getUnlockedComedy();
        if (this.COMEDY_PERSONALITIES[id] && comedyUnlocked.includes(id)) {
            Store.set(this.PERSONALITY_KEY, id);
            this.updatePersonalityIcon();
            document.getElementById('chatPersonalityPicker').style.display = 'none';
            const p = this.COMEDY_PERSONALITIES[id];
            this.addMessage('system', `${p.icon} Switched to ${p.name} mode! ${p.desc}`);
            return;
        }
        // Standard personality
        this.setPersonality(id);
        this.updatePersonalityIcon();
        document.getElementById('chatPersonalityPicker').style.display = 'none';
        const p = this.PERSONALITIES[id];
        if (p) this.addMessage('system', `${p.icon} Switched to ${p.name} mode! ${p.desc}`);
    },

    updatePersonalityIcon() {
        const id = this.getPersonality();
        const p = this.PERSONALITIES[id] || this.COMEDY_PERSONALITIES[id];
        const iconEl = document.getElementById('chatPersonalityIcon');
        if (iconEl && p) iconEl.textContent = p.icon;
    },

    close() {
        this.isOpen = false;
        document.getElementById('chatPanel').classList.remove('open');
        // Stop any ongoing speech
        if ('speechSynthesis' in window && speechSynthesis.speaking) {
            speechSynthesis.cancel();
            document.querySelectorAll('.chat-tts-btn.speaking').forEach(b => b.classList.remove('speaking'));
        }
    },

    clearHistory() {
        this.history = [];
        document.getElementById('chatMessages').innerHTML = '';
    },

    addMessage(role, content, skipTts) {
        const div = document.createElement('div');
        div.className = 'chat-msg ' + role;
        // Strip markdown formatting from assistant messages
        const cleanContent = role === 'assistant' ? this._stripMarkdown(content) : content;
        div.textContent = cleanContent;
        // Add TTS button to assistant messages
        if (role === 'assistant' && cleanContent !== 'Thinking...') {
            const ttsBtn = document.createElement('button');
            ttsBtn.className = 'chat-tts-btn';
            ttsBtn.innerHTML = '&#128264;';
            ttsBtn.title = 'Read aloud';
            ttsBtn.onclick = (e) => { e.stopPropagation(); Chat.speakMessage(cleanContent, ttsBtn); };
            div.style.position = 'relative';
            div.appendChild(ttsBtn);
        }
        document.getElementById('chatMessages').appendChild(div);
        document.getElementById('chatMessages').scrollTop = 999999;
    },

    _stripMarkdown(text) {
        return text
            .replace(/\*\*([^*]+)\*\*/g, '$1')   // **bold**
            .replace(/\*([^*]+)\*/g, '$1')         // *italic*
            .replace(/__([^_]+)__/g, '$1')         // __bold__
            .replace(/_([^_]+)_/g, '$1')           // _italic_
            .replace(/^#{1,6}\s+/gm, '')           // # headings
            .replace(/^[-*+]\s+/gm, '- ')          // bullet lists keep dash
            .replace(/^\d+\.\s+/gm, (m) => m)     // numbered lists stay
            .replace(/`([^`]+)`/g, '$1')           // `code`
            .replace(/```[\s\S]*?```/g, (m) => m.replace(/```\w*\n?/g, '').trim()) // code blocks
            // Clean up LaTeX/math formatting
            .replace(/\$([^$]+)\$/g, '$1')         // $math$ inline
            .replace(/\\\(/g, '').replace(/\\\)/g, '') // \( \) delimiters
            .replace(/\\\[/g, '').replace(/\\\]/g, '') // \[ \] delimiters
            .replace(/\\frac\{([^}]+)\}\{([^}]+)\}/g, '($1/$2)') // \frac{a}{b} -> (a/b)
            .replace(/\\times/g, '')              // \times -> 
            .replace(/\\div/g, '')                // \div -> 
            .replace(/\\pm/g, '')                 // \pm -> 
            .replace(/\\sqrt\{([^}]+)\}/g, '($1)') // \sqrt{x} -> (x)
            .replace(/\\[a-zA-Z]+/g, '')           // Remove other LaTeX commands
            .replace(/\{([^}]+)\}/g, '$1')         // {content} -> content
            // Clean up repeated/concatenated text patterns
            .replace(/(\d+),(\d+)\1,\2/g, '$1,$2 - ') // Fix $45,000$45,000 pattern
            .replace(/(\d+)\)incorrectly/g, '$1) incorrectly') // Fix )incorrectly
            .replace(/(\d+)\)appears/g, '$1) appears')
            .replace(/(\d+)\)without/g, '$1) without')
            .replace(/(\w)Option/g, '$1. Option')  // Fix missing periods before Option
            .replace(/(\d)insteadof(\d)/g, '$1 instead of $2') // Fix insteadof
            .replace(/\s{2,}/g, ' ')               // Collapse multiple spaces
            .trim();
    },

    async send() {
        const input = document.getElementById('chatInput');
        const text = input.value.trim();
        if (!text) return;
        input.value = '';
        DailyChallenges.trackAIChat();

        if (!navigator.onLine) {
            this.addMessage('system', 'You are offline. Chat requires an internet connection.');
            return;
        }

        const provider = Store.get('provider', 'anthropic');
        const apiKey = provider === 'openai' ? Store.get('openaiKey', '') : Store.get('anthropicKey', '');
        if (!apiKey) {
            this.addMessage('system', `Please set your ${provider === 'openai' ? 'OpenAI' : 'Anthropic'} API key in Settings first.`);
            return;
        }

        this.addMessage('user', text);

        // Easter egg: "pineapple" unlocks comedy personalities
        if (text.toLowerCase().includes('pineapple')) {
            this._unlockComedyPersonalities();
            return;
        }

        // Detect and save knowledge gaps
        if (this._detectKnowledgeGap(text)) {
            const ctx = App.getQuestionContext() || Drill.getQuestionContext() || AIPractice.getQuestionContext();
            this.saveKnowledgeGap(text, ctx ? ctx.text : 'General question');
        }

        // Build context
        let ctx = App.getQuestionContext() || Drill.getQuestionContext() || AIPractice.getQuestionContext();
        const comprehensiveStats = AIPractice.getComprehensiveStats ? AIPractice.getComprehensiveStats() : null;
        const relevantGaps = this.getRelevantGaps(this._getCurrentCategory());
        
        const personalityPrompt = this.getPersonalityPrompt();
        let systemPrompt = `You are a WGU tutor. ${personalityPrompt}

RULES:
1. MAX 2-3 sentences per response unless asked for detail
2. No markdown, asterisks, or formatting
3. If asked for a graph/chart, respond with: [CHART:type:title:label1,value1;label2,value2;...] where type is bar/pie/line
4. Example chart: [CHART:bar:Category Scores:Algebra,85;Geometry,72;Stats,90]
5. Give the answer first, then brief explanation if needed
6. Never say "Great question" or similar filler
7. STAY IN CHARACTER based on your personality above`;
        
        // Add knowledge gaps context
        if (relevantGaps.length > 0) {
            systemPrompt += `\n\n=== STUDENT'S PREVIOUS KNOWLEDGE GAPS ===
The student has previously expressed confusion about these topics. If the current question relates to any of these, provide extra context and connect the concepts:
${relevantGaps.slice(-10).map(g => `- "${g.topic}" (${g.category}, ${new Date(g.timestamp).toLocaleDateString()})`).join('\n')}

When explaining, reference these past struggles if relevant and help build connections.`;
        }
        
        // Add comprehensive stats for summaries and analysis
        if (comprehensiveStats) {
            systemPrompt += `\n\n=== STUDENT PERFORMANCE DATA ===
Level: ${comprehensiveStats.level} | XP: ${comprehensiveStats.xp} | Coins: ${comprehensiveStats.coins}
Daily Streak: ${comprehensiveStats.dailyStreak} days | Best Combo: ${comprehensiveStats.bestCombo}
Questions Answered: ${comprehensiveStats.questionsAnswered} | Tests Completed: ${comprehensiveStats.testsCompleted}
Today: ${comprehensiveStats.questionsToday}/${comprehensiveStats.dailyGoal} questions | Study Time: ${comprehensiveStats.todayStudyMinutes}m today, ${comprehensiveStats.totalStudyMinutes}m total
Overall Accuracy: ${comprehensiveStats.overallAccuracy}%

Per-Category Performance:
${Object.entries(comprehensiveStats.categoryStats).map(([cat, d]) => 
    `- ${cat}: ${d.accuracy}% (${d.correct}/${d.total}) | Time: ${d.totalTimeMinutes}m total, ${d.avgTimePerQuestionSeconds}s avg${d.level ? ' | ' + d.level.toUpperCase() : ''}`
).join('\n')}

Weak Areas (lowest scores first): ${comprehensiveStats.weakCategories.map(w => w.category + ' (' + w.score + '%)').join(', ')}

Current Session: ${comprehensiveStats.currentSession.correct}/${comprehensiveStats.currentSession.total} (${comprehensiveStats.currentSession.accuracy}%)

If the student asks for a summary, analysis, or graph, use this data. For graphs, you can describe what a chart would show or create ASCII art representations.`
        }

        if (ctx) {
            systemPrompt += `\n\nCurrent question (#${ctx.number}):\n"${ctx.text}"\n\nOptions:\n${ctx.options.map((o, i) => `${String.fromCharCode(65+i)}. ${o}`).join('\n')}`;
            
            // Only reveal answer if user has already answered (isAnswered flag or correctAnswer is not null)
            if (ctx.correctAnswer !== null && ctx.correctAnswer !== undefined) {
                systemPrompt += `\n\nCorrect answer: ${String.fromCharCode(65+ctx.correctAnswer)}. ${ctx.correctText}`;
                if (ctx.explanation) systemPrompt += `\n\nExplanation: ${ctx.explanation}`;
            } else {
                // User hasn't answered yet - DO NOT reveal the answer
                systemPrompt += `\n\n IMPORTANT: The student has NOT answered this question yet. DO NOT reveal the correct answer. Instead:
- Help them understand the concepts needed to solve it
- Guide them through the problem-solving process
- Ask clarifying questions to help them think
- Explain relevant formulas or methods WITHOUT giving away the answer
- If they directly ask "what is the answer", say "Try working through it first - I can help guide you!"`;
            }
            
            if (ctx.userAnswer !== undefined && ctx.userAnswer !== null) {
                systemPrompt += `\n\nStudent selected: ${String.fromCharCode(65+ctx.userAnswer)}. ${ctx.userAnswerText}`;
            }
        }

        this.history.push({ role: 'user', content: text });
        const messages = this.history.slice(-20);

        try {
            this.addMessage('assistant', 'Thinking...');
            const lastMsg = document.getElementById('chatMessages').lastChild;

            let reply;
            if (provider === 'openai') {
                reply = await this._sendOpenAI(apiKey, systemPrompt, messages);
            } else {
                reply = await this._sendAnthropic(apiKey, systemPrompt, messages);
            }

            const cleanReply = this._stripMarkdown(reply);
            // Check for chart syntax and render if found
            const chartMatch = cleanReply.match(/\[CHART:(bar|pie|line):([^:]+):([^\]]+)\]/);
            if (chartMatch) {
                const textPart = cleanReply.replace(/\[CHART:[^\]]+\]/, '').trim();
                lastMsg.innerHTML = '';
                if (textPart) {
                    const textNode = document.createElement('div');
                    textNode.textContent = textPart;
                    lastMsg.appendChild(textNode);
                }
                const chartCanvas = this._renderChart(chartMatch[1], chartMatch[2], chartMatch[3]);
                lastMsg.appendChild(chartCanvas);
            } else {
                lastMsg.textContent = cleanReply;
            }
            // Add TTS button to the response
            const ttsBtn = document.createElement('button');
            ttsBtn.className = 'chat-tts-btn';
            ttsBtn.innerHTML = '&#128264;';
            ttsBtn.title = 'Read aloud';
            ttsBtn.onclick = (e) => { e.stopPropagation(); Chat.speakMessage(cleanReply.replace(/\[CHART:[^\]]+\]/g, ''), ttsBtn); };
            lastMsg.style.position = 'relative';
            lastMsg.appendChild(ttsBtn);
            this.history.push({ role: 'assistant', content: reply });
        } catch (err) {
            const msgs = document.getElementById('chatMessages');
            if (msgs.lastChild) {
                msgs.lastChild.textContent = err.message || 'Connection error. Check your API key and internet.';
                msgs.lastChild.className = 'chat-msg system';
            }
        }
    },

    async _sendAnthropic(apiKey, systemPrompt, messages) {
        const model = Store.get('anthropicModel', 'claude-sonnet-4-5-20250929');
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.anthropic.com/v1/messages', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'x-api-key': apiKey,
                'anthropic-version': '2023-06-01',
                'anthropic-dangerous-direct-browser-access': 'true'
            },
            body: JSON.stringify({ model, max_tokens: 1024, system: systemPrompt, messages })
        });
        clearTimeout(timeout);
        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`Claude error: ${err.error?.message || resp.statusText}`);
        }
        const data = await resp.json();
        return data.content?.[0]?.text || 'No response';
    },

    async _sendOpenAI(apiKey, systemPrompt, messages) {
        const model = Store.get('openaiModel', 'gpt-4o-mini');
        const oaiMessages = [{ role: 'system', content: systemPrompt }, ...messages];
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 30000);
        const resp = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            signal: controller.signal,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify({ model, max_tokens: 1024, messages: oaiMessages })
        });
        clearTimeout(timeout);
        if (!resp.ok) {
            const err = await resp.json().catch(() => ({}));
            throw new Error(`OpenAI error: ${err.error?.message || resp.statusText}`);
        }
        const data = await resp.json();
        return data.choices?.[0]?.message?.content || 'No response';
    },

    async speakMessage(text, btn) {
        // Stop any current speech
        if (Audio.speaking) {
            Audio.stop();
            document.querySelectorAll('.chat-tts-btn.speaking').forEach(b => b.classList.remove('speaking'));
            if (btn && btn.classList.contains('speaking')) { btn.classList.remove('speaking'); return; }
        }
        
        const settings = Audio.getSettings();
        if (btn) btn.classList.add('speaking');
        Audio.speaking = true;
        
        const onComplete = () => { Audio.speaking = false; if (btn) btn.classList.remove('speaking'); };
        
        try {
            if (settings.provider === 'elevenlabs' && settings.elevenLabsKey) {
                const voiceId = Audio.ELEVENLABS_VOICES[settings.voice]?.id || Audio.ELEVENLABS_VOICES.rachel.id;
                const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                    method: 'POST',
                    headers: { 'Accept': 'audio/mpeg', 'Content-Type': 'application/json', 'xi-api-key': settings.elevenLabsKey },
                    body: JSON.stringify({ text, model_id: 'eleven_monolingual_v1', voice_settings: { stability: 0.5, similarity_boost: 0.75 } })
                });
                if (response.ok) {
                    const audioUrl = URL.createObjectURL(await response.blob());
                    Audio.currentAudio = new window.Audio(audioUrl);
                    Audio.currentAudio.playbackRate = settings.speed || 1.0;
                    Audio.currentAudio.onended = () => { onComplete(); URL.revokeObjectURL(audioUrl); };
                    Audio.currentAudio.onerror = onComplete;
                    Audio.currentAudio.play();
                    return;
                }
            } else if (settings.provider === 'openai' && settings.openaiKey) {
                const response = await fetch('https://api.openai.com/v1/audio/speech', {
                    method: 'POST',
                    headers: { 'Authorization': `Bearer ${settings.openaiKey}`, 'Content-Type': 'application/json' },
                    body: JSON.stringify({ model: 'tts-1', input: text, voice: settings.openaiVoice || 'nova', speed: settings.speed || 1.0 })
                });
                if (response.ok) {
                    const audioUrl = URL.createObjectURL(await response.blob());
                    Audio.currentAudio = new window.Audio(audioUrl);
                    Audio.currentAudio.onended = () => { onComplete(); URL.revokeObjectURL(audioUrl); };
                    Audio.currentAudio.onerror = onComplete;
                    Audio.currentAudio.play();
                    return;
                }
            } else if (settings.provider === 'speechify') {
                if (window.speechify?.speak) {
                    window.speechify.speak(text, { rate: settings.speed || 1.0 });
                    setTimeout(onComplete, text.length * 60);
                } else {
                    window.open(`https://speechify.com/text-to-speech-online/?text=${encodeURIComponent(text.substring(0, 500))}`, '_blank', 'width=500,height=400');
                    onComplete();
                }
                return;
            }
        } catch (e) { console.error('TTS error:', e); }
        
        // Fallback to browser TTS
        if (!('speechSynthesis' in window)) { onComplete(); return; }
        const utterance = new SpeechSynthesisUtterance(text);
        const voices = speechSynthesis.getVoices();
        const preferred = voices.find(v => v.name.includes('Google') || v.name.includes('Microsoft') || v.name.includes('Samantha') || v.name.includes('Alex'));
        if (preferred) utterance.voice = preferred;
        utterance.rate = settings.speed || 1.0;
        utterance.onend = onComplete;
        utterance.onerror = onComplete;
        speechSynthesis.speak(utterance);
    },

    _renderChart(type, title, dataStr) {
        const canvas = document.createElement('canvas');
        canvas.width = 280;
        canvas.height = 180;
        canvas.style.cssText = 'display:block;margin:10px 0;border-radius:8px;background:#1a1a2e';
        const ctx = canvas.getContext('2d');
        
        // Parse data: "label1,value1;label2,value2"
        const items = dataStr.split(';').map(s => {
            const [label, val] = s.split(',');
            return { label: label?.trim() || '', value: parseFloat(val) || 0 };
        }).filter(i => i.label);
        
        if (items.length === 0) return canvas;
        
        const colors = ['#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57', '#ff9ff3', '#54a0ff'];
        const maxVal = Math.max(...items.map(i => i.value), 1);
        const padding = 30;
        
        // Title
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(title, canvas.width / 2, 16);
        
        if (type === 'bar') {
            const barWidth = (canvas.width - padding * 2) / items.length - 10;
            items.forEach((item, i) => {
                const x = padding + i * (barWidth + 10);
                const barHeight = (item.value / maxVal) * (canvas.height - 60);
                const y = canvas.height - 25 - barHeight;
                
                ctx.fillStyle = colors[i % colors.length];
                ctx.fillRect(x, y, barWidth, barHeight);
                
                // Label
                ctx.fillStyle = '#aaa';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.label.slice(0, 8), x + barWidth / 2, canvas.height - 8);
                
                // Value
                ctx.fillStyle = '#fff';
                ctx.fillText(Math.round(item.value), x + barWidth / 2, y - 4);
            });
        } else if (type === 'pie') {
            const total = items.reduce((s, i) => s + i.value, 0);
            const cx = canvas.width / 2;
            const cy = canvas.height / 2 + 10;
            const radius = 55;
            let startAngle = -Math.PI / 2;
            
            items.forEach((item, i) => {
                const sliceAngle = (item.value / total) * Math.PI * 2;
                ctx.beginPath();
                ctx.moveTo(cx, cy);
                ctx.arc(cx, cy, radius, startAngle, startAngle + sliceAngle);
                ctx.fillStyle = colors[i % colors.length];
                ctx.fill();
                
                // Label
                const midAngle = startAngle + sliceAngle / 2;
                const labelX = cx + Math.cos(midAngle) * (radius + 15);
                const labelY = cy + Math.sin(midAngle) * (radius + 15);
                ctx.fillStyle = '#fff';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.label.slice(0, 6), labelX, labelY);
                
                startAngle += sliceAngle;
            });
        } else if (type === 'line') {
            const stepX = (canvas.width - padding * 2) / (items.length - 1 || 1);
            ctx.strokeStyle = colors[0];
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            items.forEach((item, i) => {
                const x = padding + i * stepX;
                const y = canvas.height - 25 - (item.value / maxVal) * (canvas.height - 60);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                
                // Point
                ctx.fillStyle = colors[0];
                ctx.beginPath();
                ctx.arc(x, y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Label
                ctx.fillStyle = '#aaa';
                ctx.font = '9px sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(item.label.slice(0, 6), x, canvas.height - 8);
            });
            ctx.stroke();
        }
        
        return canvas;
    }
};

// =====================================================================
// CALCULATOR
// =====================================================================
const Calc = {
    isOpen: false,
    expr: '',

    toggle() {
        this.isOpen = !this.isOpen;
        document.getElementById('calcPanel').classList.toggle('open', this.isOpen);
        document.getElementById('btnCalc').classList.toggle('active', this.isOpen);
    },

    clear() {
        this.expr = '';
        document.getElementById('calcDisplay').textContent = '0';
    },

    input(val) {
        this.expr += val;
        document.getElementById('calcDisplay').textContent = this.expr || '0';
    },

    backspace() {
        this.expr = this.expr.slice(0, -1);
        document.getElementById('calcDisplay').textContent = this.expr || '0';
    },

    equals() {
        try {
            // Safe eval using Function constructor
            const sanitized = this.expr.replace(/[^0-9+\-*/().]/g, '');
            const result = Function('"use strict"; return (' + sanitized + ')')();
            if (!isFinite(result)) {
                document.getElementById('calcDisplay').textContent = 'Error';
                this.expr = '';
                return;
            }
            const rounded = Math.round(result * 1000000) / 1000000;
            document.getElementById('calcDisplay').textContent = rounded;
            this.expr = String(rounded);
        } catch {
            document.getElementById('calcDisplay').textContent = 'Error';
            this.expr = '';
        }
    }
};

// =====================================================================
// INLINE CHART RENDERER (Canvas 2D)
// =====================================================================
const InlineChart = {
    /**
     * Generate placeholder graph data from question text containing [Graph: title]
     * Creates a reasonable sample graph based on the title/context
     */
    generatePlaceholderGraph(questionText) {
        const match = questionText.match(/\[Graph:\s*([^\]]+)\]/i);
        if (!match) return null;
        
        const title = match[1].trim();
        const lowerTitle = title.toLowerCase();
        
        // Try to infer graph type from title
        let graphData = {
            title: title,
            xLabel: 'x',
            yLabel: 'y',
            series: [{ data: [], color: '#2980b9' }]
        };
        
        // Profit/Revenue graphs - typically parabola or linear
        if (lowerTitle.includes('profit') || lowerTitle.includes('revenue') || lowerTitle.includes('cost')) {
            // Parabola: profit = -ax + bx - c (opens downward)
            graphData.xLabel = lowerTitle.includes('dishwasher') ? 'Dishwashers (hundreds)' : 'Units';
            graphData.yLabel = 'Profit ($1000s)';
            graphData.xMin = 0;
            graphData.yMin = -20;
            // Generate parabola: P(x) = -0.5x + 10x - 20 (max at x=10, P=30)
            for (let x = 0; x <= 20; x += 1) {
                const y = -0.5 * x * x + 10 * x - 20;
                graphData.series[0].data.push({ x, y });
            }
            // Add horizontal line at y=80 for reference
            graphData.asymptotes = [{ y: 80, label: '$80,000' }];
            graphData.yMax = 100;
        }
        // Supply/Demand graphs
        else if (lowerTitle.includes('supply') || lowerTitle.includes('demand')) {
            graphData.xLabel = 'Quantity';
            graphData.yLabel = 'Price';
            graphData.series = [
                { data: [], color: '#2980b9', label: 'Demand' },
                { data: [], color: '#e67e22', label: 'Supply' }
            ];
            for (let x = 0; x <= 100; x += 10) {
                graphData.series[0].data.push({ x, y: 100 - x }); // Demand: downward
                graphData.series[1].data.push({ x, y: x });       // Supply: upward
            }
        }
        // Distance/Time graphs
        else if (lowerTitle.includes('distance') || lowerTitle.includes('time') || lowerTitle.includes('speed')) {
            graphData.xLabel = 'Time (hours)';
            graphData.yLabel = 'Distance (miles)';
            for (let x = 0; x <= 10; x += 1) {
                graphData.series[0].data.push({ x, y: 50 * x });
            }
        }
        // Population/Growth graphs
        else if (lowerTitle.includes('population') || lowerTitle.includes('growth')) {
            graphData.xLabel = 'Years';
            graphData.yLabel = 'Population';
            for (let x = 0; x <= 10; x += 1) {
                graphData.series[0].data.push({ x, y: 1000 * Math.pow(1.1, x) });
            }
        }
        // Temperature graphs
        else if (lowerTitle.includes('temperature') || lowerTitle.includes('temp')) {
            graphData.xLabel = 'Time';
            graphData.yLabel = 'Temperature (F)';
            for (let x = 0; x <= 24; x += 2) {
                graphData.series[0].data.push({ x, y: 60 + 15 * Math.sin((x - 6) * Math.PI / 12) });
            }
        }
        // Default: simple linear graph
        else {
            for (let x = 0; x <= 10; x += 1) {
                graphData.series[0].data.push({ x, y: 2 * x + 5 });
            }
        }
        
        return graphData;
    },

    // Replace [Graph: ...] placeholders with rendered charts
    renderInElement(el, graphData) {
        if (!graphData || !el) return;
        const html = el.innerHTML;
        if (!html.includes('[Graph:')) return;

        // Handle grid type (2x2 panel of separate graphs)
        if (graphData.type === 'grid' && graphData.panels) {
            el.innerHTML = html.replace(/\[Graph:[^\]]*\]/g, () => {
                const gridHtml = graphData.panels.map((panel, i) => {
                    const id = 'chart-grid-' + Math.random().toString(36).substr(2, 9);
                    return `<div class="inline-chart-grid-item">
                        <div class="chart-grid-label">${panel.label || ('Graph ' + String.fromCharCode(65 + i))}</div>
                        <canvas id="${id}" data-panel-idx="${i}" width="260" height="200"></canvas>
                    </div>`;
                }).join('');
                return `<div class="inline-chart-grid">${gridHtml}</div>`;
            });

            requestAnimationFrame(() => {
                const canvases = el.querySelectorAll('canvas[data-panel-idx]');
                canvases.forEach(canvas => {
                    const idx = parseInt(canvas.dataset.panelIdx);
                    const panel = graphData.panels[idx];
                    if (panel) {
                        const panelGd = {
                            type: panel.type || 'line',
                            series: [{ data: panel.data, label: panel.label }],
                            xMin: graphData.xMin,
                            xMax: graphData.xMax,
                            yMin: graphData.yMin,
                            yMax: graphData.yMax,
                            noFill: true
                        };
                        this.draw(canvas, panelGd);
                    }
                });
            });
            return;
        }

        // Build legend HTML for multi-series graphs
        const series = graphData.series || [{ data: graphData.data || [] }];
        const seriesColors = ['#2980b9', '#e67e22', '#2ecc71', '#9b59b6'];
        let legendHtml = '';
        if (series.length > 1 && series.some(s => s.label)) {
            legendHtml = '<div class="chart-legend">' + series.map((s, i) => {
                if (!s.label) return '';
                const col = seriesColors[i % seriesColors.length];
                const dashedClass = s.dashed ? ' dashed' : '';
                return `<div class="chart-legend-item"><span class="chart-legend-color${dashedClass}" style="background-color:${col}"></span><span>${s.label}</span></div>`;
            }).join('') + '</div>';
        }

        // Replace placeholder with canvas container + legend
        el.innerHTML = html.replace(/\[Graph:[^\]]*\]/g, () => {
            const id = 'chart-' + Math.random().toString(36).substr(2, 9);
            return `<div class="inline-chart-wrap"><canvas id="${id}" width="560" height="360"></canvas>${legendHtml}</div>`;
        });

        // Render after DOM update
        requestAnimationFrame(() => {
            const canvases = el.querySelectorAll('canvas');
            canvases.forEach(canvas => this.draw(canvas, graphData));
        });
    },

    draw(canvas, gd) {
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;
        const w = canvas.clientWidth || 560;
        const h = canvas.clientHeight || 360;
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.scale(dpr, dpr);

        // Colors based on theme
        const isDark = Theme.isDark();
        const colors = isDark
            ? { bg: '#16213e', axes: '#9ca3af', grid: '#374151', text: '#d1d5db', title: '#93c5fd', line1: '#60a5fa', line2: '#f59e0b', dot: '#60a5fa', dot2: '#f59e0b', fill: 'rgba(96,165,250,0.15)', regLine: '#ef4444' }
            : { bg: '#ffffff', axes: '#555', grid: '#e5e5e5', text: '#555', title: '#1a3a5c', line1: '#2980b9', line2: '#e67e22', dot: '#2980b9', dot2: '#e67e22', fill: 'rgba(41,128,185,0.1)', regLine: '#c0392b' };

        // Margins - responsive based on width
        const isSmall = w < 400;
        const m = { top: 50, right: isSmall ? 15 : 25, bottom: 55, left: isSmall ? 52 : 62 };
        const pw = w - m.left - m.right;
        const ph = h - m.top - m.bottom;

        // Background
        ctx.fillStyle = colors.bg;
        ctx.fillRect(0, 0, w, h);

        // Data bounds
        const series = gd.series || [{ data: gd.data || [] }];
        let allPts = series.flatMap(s => s.data || []);
        if (allPts.length === 0) return;

        let xMin = gd.xMin != null ? gd.xMin : Math.min(...allPts.map(p => p.x));
        let xMax = gd.xMax != null ? gd.xMax : Math.max(...allPts.map(p => p.x));
        let yMin = gd.yMin != null ? gd.yMin : Math.min(...allPts.map(p => p.y));
        let yMax = gd.yMax != null ? gd.yMax : Math.max(...allPts.map(p => p.y));

        // Add padding
        if (xMin === xMax) { xMin -= 1; xMax += 1; }
        if (yMin === yMax) { yMin -= 1; yMax += 1; }
        const xPad = (xMax - xMin) * 0.05;
        const yPad = (yMax - yMin) * 0.08;
        if (gd.xMin == null) xMin -= xPad;
        if (gd.xMax == null) xMax += xPad;
        if (gd.yMin == null) yMin -= yPad;
        if (gd.yMax == null) yMax += yPad;

        const sx = v => m.left + ((v - xMin) / (xMax - xMin)) * pw;
        const sy = v => m.top + ph - ((v - yMin) / (yMax - yMin)) * ph;

        // Grid lines
        ctx.strokeStyle = colors.grid;
        ctx.lineWidth = 0.5;
        const xTicks = this._niceTicks(xMin, xMax, 8);
        const yTicks = this._niceTicks(yMin, yMax, 6);

        xTicks.forEach(v => {
            ctx.beginPath(); ctx.moveTo(sx(v), m.top); ctx.lineTo(sx(v), m.top + ph); ctx.stroke();
        });
        yTicks.forEach(v => {
            ctx.beginPath(); ctx.moveTo(m.left, sy(v)); ctx.lineTo(m.left + pw, sy(v)); ctx.stroke();
        });

        // Axes
        ctx.strokeStyle = colors.axes;
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.moveTo(m.left, m.top); ctx.lineTo(m.left, m.top + ph); ctx.lineTo(m.left + pw, m.top + ph); ctx.stroke();

        // Tick labels
        ctx.fillStyle = colors.text;
        ctx.font = isSmall ? '11px Arial' : '12px Arial';
        ctx.textAlign = 'center';
        xTicks.forEach(v => {
            const label = gd.xTickFormat ? gd.xTickFormat(v) : this._fmtNum(v);
            ctx.fillText(label, sx(v), m.top + ph + 18);
        });
        ctx.textAlign = 'right';
        yTicks.forEach(v => {
            const label = gd.yTickFormat ? gd.yTickFormat(v) : this._fmtNum(v);
            ctx.fillText(label, m.left - 6, sy(v) + 4);
        });

        // Axis labels - responsive font size
        const labelFont = isSmall ? '11px Arial' : '13px Arial';
        ctx.fillStyle = colors.text;
        ctx.font = labelFont;
        ctx.textAlign = 'center';
        if (gd.xLabel) {
            const xLabelTrunc = this._truncateText(ctx, gd.xLabel, pw);
            ctx.fillText(xLabelTrunc, m.left + pw / 2, h - 8);
        }
        ctx.save();
        ctx.translate(14, m.top + ph / 2);
        ctx.rotate(-Math.PI / 2);
        if (gd.yLabel) {
            const yLabelTrunc = this._truncateText(ctx, gd.yLabel, ph);
            ctx.fillText(yLabelTrunc, 0, 0);
        }
        ctx.restore();

        // Title - responsive and truncated if needed
        ctx.fillStyle = colors.title;
        ctx.font = isSmall ? 'bold 13px Arial' : 'bold 16px Arial';
        ctx.textAlign = 'center';
        if (gd.title) {
            const titleTrunc = this._truncateText(ctx, gd.title, w - 30);
            ctx.fillText(titleTrunc, w / 2, 28);
        }

        // Horizontal asymptotes
        if (gd.asymptotes) {
            ctx.setLineDash([6, 4]);
            ctx.strokeStyle = colors.regLine;
            ctx.lineWidth = 1;
            gd.asymptotes.forEach(a => {
                const y = sy(a.y);
                ctx.beginPath(); ctx.moveTo(m.left, y); ctx.lineTo(m.left + pw, y); ctx.stroke();
                if (a.label) {
                    ctx.fillStyle = colors.regLine;
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(a.label, m.left + pw - 60, y - 4);
                }
            });
            ctx.setLineDash([]);
        }

        // Draw each series
        const seriesColors = [colors.line1, colors.line2, '#2ecc71', '#9b59b6'];
        const dotColors = [colors.dot, colors.dot2, '#27ae60', '#8e44ad'];

        series.forEach((s, si) => {
            const data = s.data || [];
            if (data.length === 0) return;
            const sorted = [...data].sort((a, b) => a.x - b.x);
            const col = seriesColors[si % seriesColors.length];
            const dcol = dotColors[si % dotColors.length];
            const type = s.type || gd.type || 'line';

            if (type === 'line' || type === 'curve') {
                // Area fill
                if (si === 0 && !gd.noFill) {
                    ctx.fillStyle = colors.fill;
                    ctx.beginPath();
                    ctx.moveTo(sx(sorted[0].x), sy(yMin > 0 ? yMin : 0));
                    sorted.forEach(p => ctx.lineTo(sx(p.x), sy(p.y)));
                    ctx.lineTo(sx(sorted[sorted.length - 1].x), sy(yMin > 0 ? yMin : 0));
                    ctx.closePath();
                    ctx.fill();
                }

                // Line
                ctx.strokeStyle = col;
                ctx.lineWidth = 2.5;
                ctx.setLineDash(s.dashed ? [8, 4] : []);
                ctx.beginPath();
                if (type === 'curve' && sorted.length > 2) {
                    // Smooth curve using cardinal spline
                    ctx.moveTo(sx(sorted[0].x), sy(sorted[0].y));
                    for (let i = 0; i < sorted.length - 1; i++) {
                        const p0 = sorted[Math.max(0, i - 1)];
                        const p1 = sorted[i];
                        const p2 = sorted[i + 1];
                        const p3 = sorted[Math.min(sorted.length - 1, i + 2)];
                        const cp1x = sx(p1.x) + (sx(p2.x) - sx(p0.x)) / 6;
                        const cp1y = sy(p1.y) + (sy(p2.y) - sy(p0.y)) / 6;
                        const cp2x = sx(p2.x) - (sx(p3.x) - sx(p1.x)) / 6;
                        const cp2y = sy(p2.y) - (sy(p3.y) - sy(p1.y)) / 6;
                        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, sx(p2.x), sy(p2.y));
                    }
                } else {
                    sorted.forEach((p, i) => i === 0 ? ctx.moveTo(sx(p.x), sy(p.y)) : ctx.lineTo(sx(p.x), sy(p.y)));
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Dots
                sorted.forEach(p => {
                    ctx.fillStyle = dcol;
                    ctx.beginPath();
                    ctx.arc(sx(p.x), sy(p.y), 3.5, 0, Math.PI * 2);
                    ctx.fill();
                });
            } else if (type === 'scatter') {
                // Scatter dots
                data.forEach(p => {
                    ctx.fillStyle = dcol;
                    ctx.beginPath();
                    ctx.arc(sx(p.x), sy(p.y), 4.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = col;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                });
            } else if (type === 'bar') {
                const barW = Math.max(8, pw / data.length * 0.6);
                data.forEach(p => {
                    ctx.fillStyle = col;
                    const x0 = sx(p.x) - barW / 2;
                    const y0 = sy(Math.max(p.y, 0));
                    const yBase = sy(0);
                    ctx.fillRect(x0, Math.min(y0, yBase), barW, Math.abs(yBase - y0));
                });
            }

            // Series labels are now shown in the HTML legend below the chart
        });

        // Regression line
        if (gd.regression) {
            const r = gd.regression;
            ctx.strokeStyle = colors.regLine;
            ctx.lineWidth = 1.5;
            ctx.setLineDash([6, 3]);
            if (r.type === 'linear') {
                const x1 = xMin, x2 = xMax;
                ctx.beginPath();
                ctx.moveTo(sx(x1), sy(r.slope * x1 + r.intercept));
                ctx.lineTo(sx(x2), sy(r.slope * x2 + r.intercept));
                ctx.stroke();
            } else if (r.type === 'exponential' && r.fn) {
                ctx.beginPath();
                const steps = 80;
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * (i / steps);
                    const y = r.fn(x);
                    i === 0 ? ctx.moveTo(sx(x), sy(y)) : ctx.lineTo(sx(x), sy(y));
                }
                ctx.stroke();
            } else if (r.type === 'polynomial' && r.fn) {
                ctx.beginPath();
                const steps = 80;
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * (i / steps);
                    const y = r.fn(x);
                    i === 0 ? ctx.moveTo(sx(x), sy(y)) : ctx.lineTo(sx(x), sy(y));
                }
                ctx.stroke();
            } else if (r.type === 'logistic' && r.fn) {
                ctx.beginPath();
                const steps = 80;
                for (let i = 0; i <= steps; i++) {
                    const x = xMin + (xMax - xMin) * (i / steps);
                    const y = r.fn(x);
                    i === 0 ? ctx.moveTo(sx(x), sy(y)) : ctx.lineTo(sx(x), sy(y));
                }
                ctx.stroke();
            }
            ctx.setLineDash([]);
            if (r.r2 != null) {
                ctx.fillStyle = colors.regLine;
                ctx.font = '11px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('r\u00B2 = ' + r.r2.toFixed(2), m.left + pw - 4, m.top + 16);
            }
        }

        // Annotations
        if (gd.annotations) {
            gd.annotations.forEach(a => {
                ctx.fillStyle = colors.regLine;
                ctx.font = '10px Arial';
                ctx.textAlign = a.align || 'left';
                ctx.fillText(a.text, sx(a.x) + (a.dx || 4), sy(a.y) + (a.dy || -8));
                // Dot marker
                ctx.beginPath();
                ctx.arc(sx(a.x), sy(a.y), 5, 0, Math.PI * 2);
                ctx.fillStyle = colors.regLine;
                ctx.fill();
            });
        }
    },

    _niceTicks(min, max, count) {
        const range = max - min;
        const rough = range / count;
        const mag = Math.pow(10, Math.floor(Math.log10(rough)));
        let step;
        const norm = rough / mag;
        if (norm <= 1.5) step = 1 * mag;
        else if (norm <= 3) step = 2 * mag;
        else if (norm <= 7) step = 5 * mag;
        else step = 10 * mag;
        const start = Math.ceil(min / step) * step;
        const ticks = [];
        for (let v = start; v <= max + step * 0.01; v += step) {
            ticks.push(Math.round(v * 1e10) / 1e10);
        }
        return ticks;
    },

    _fmtNum(v) {
        // Don't abbreviate years (1900-2100 range)
        if (v >= 1900 && v <= 2100 && Number.isInteger(v)) return v.toString();
        if (Math.abs(v) >= 1e6) return (v / 1e6).toFixed(1) + 'M';
        if (Math.abs(v) >= 1e3) return (v / 1e3).toFixed(v % 1000 === 0 ? 0 : 1) + 'K';
        if (Number.isInteger(v)) return v.toString();
        return v.toFixed(1);
    },

    _truncateText(ctx, text, maxWidth) {
        if (ctx.measureText(text).width <= maxWidth) return text;
        let truncated = text;
        while (truncated.length > 0 && ctx.measureText(truncated + '').width > maxWidth) {
            truncated = truncated.slice(0, -1);
        }
        return truncated + '';
    }
};

// =====================================================================
// AUDIO (Text-to-Speech)
// =====================================================================
const Audio = {
    speaking: false,
    currentAudio: null,
    
    // ElevenLabs voices - high quality AI voices
    ELEVENLABS_VOICES: {
        rachel: { id: '21m00Tcm4TlvDq8ikWAM', name: 'Rachel', desc: 'Calm, professional female' },
        drew: { id: '29vD33N1CtxCmqQRPOHJ', name: 'Drew', desc: 'Well-rounded male' },
        clyde: { id: '2EiwWnXFnvU5JabPnv8n', name: 'Clyde', desc: 'War veteran character' },
        paul: { id: '5Q0t7uMcjvnagumLfvZi', name: 'Paul', desc: 'Ground reporter male' },
        domi: { id: 'AZnzlk1XvdvUeBnXmlld', name: 'Domi', desc: 'Strong, confident female' },
        dave: { id: 'CYw3kZ02Hs0563khs1Fj', name: 'Dave', desc: 'British conversational' },
        fin: { id: 'D38z5RcWu1voky8WS1ja', name: 'Fin', desc: 'Irish male' },
        sarah: { id: 'EXAVITQu4vr4xnSDxMaL', name: 'Sarah', desc: 'Soft, young female' },
        antoni: { id: 'ErXwobaYiN019PkySvjV', name: 'Antoni', desc: 'Well-rounded male' },
        thomas: { id: 'GBv7mTt0atIp3Br8iCZE', name: 'Thomas', desc: 'Calm American male' },
        charlie: { id: 'IKne3meq5aSn9XLyUdCD', name: 'Charlie', desc: 'Casual Australian' },
        emily: { id: 'LcfcDJNUP1GQjkzn1xUU', name: 'Emily', desc: 'Calm female' },
        elli: { id: 'MF3mGyEYCl7XYWbV9V6O', name: 'Elli', desc: 'Emotional young female' },
        callum: { id: 'N2lVS1w4EtoT3dr4eOWO', name: 'Callum', desc: 'Transatlantic male' },
        patrick: { id: 'ODq5zmih8GrVes37Dizd', name: 'Patrick', desc: 'Shouty male' },
        harry: { id: 'SOYHLrjzK2X1ezoPC6cr', name: 'Harry', desc: 'Anxious British male' },
        liam: { id: 'TX3LPaxmHKxFdv7VOQHJ', name: 'Liam', desc: 'Articulate male' },
        dorothy: { id: 'ThT5KcBeYPX3keUQqHPh', name: 'Dorothy', desc: 'Pleasant British female' },
        josh: { id: 'TxGEqnHWrfWFTfGW9XjX', name: 'Josh', desc: 'Deep young male' },
        arnold: { id: 'VR6AewLTigWG4xSOukaG', name: 'Arnold', desc: 'Crisp male' },
        charlotte: { id: 'XB0fDUnXU5powFXDhCwa', name: 'Charlotte', desc: 'Swedish seductive' },
        matilda: { id: 'XrExE9yKIg1WjnnlVkGX', name: 'Matilda', desc: 'Warm friendly female' },
        matthew: { id: 'Yko7PKHZNXotIFUBG7I9', name: 'Matthew', desc: 'Audiobook narrator' },
        james: { id: 'ZQe5CZNOzWyzPSCn5a3c', name: 'James', desc: 'Australian male' },
        joseph: { id: 'Zlb1dXrM653N07WRdFW3', name: 'Joseph', desc: 'British male' },
        jeremy: { id: 'bVMeCyTHy58xNoL34h3p', name: 'Jeremy', desc: 'Excited Irish male' },
        michael: { id: 'flq6f7yk4E4fJM5XTYuZ', name: 'Michael', desc: 'Old American male' },
        ethan: { id: 'g5CIjZEefAph4nQFvHAz', name: 'Ethan', desc: 'Young American male' },
        george: { id: 'jBpfuIE2acCO8z3wKNLl', name: 'George', desc: 'British warm male' },
        gigi: { id: 'jsCqWAovK2LkecY7zXl4', name: 'Gigi', desc: 'Childish American female' },
        freya: { id: 'jnO3fPMoZiDARy7cq8Kj', name: 'Freya', desc: 'German female' },
        grace: { id: 'oWAxZDx7w5VEj9dCyTzz', name: 'Grace', desc: 'Southern American female' },
        daniel: { id: 'onwK4e9ZLuTAKqWW03F9', name: 'Daniel', desc: 'Deep British male' },
        serena: { id: 'pMsXgVXv3BLzUgSXRplE', name: 'Serena', desc: 'Pleasant middle-aged female' },
        adam: { id: 'pNInz6obpgDQGcFmaJgB', name: 'Adam', desc: 'Deep American male' },
        nicole: { id: 'piTKgcLEGmPE4e6mEKli', name: 'Nicole', desc: 'Soft female' },
        jessie: { id: 't0jbNlBVZ17f02VDIeMI', name: 'Jessie', desc: 'Raspy American male' },
        ryan: { id: 'wViXBPUzp2ZZixB1xQuM', name: 'Ryan', desc: 'Soldier American male' },
        sam: { id: 'yoZ06aMxZJJ28mfd3POQ', name: 'Sam', desc: 'Raspy young male' },
        glinda: { id: 'z9fAnlkpzviPz146aGWa', name: 'Glinda', desc: 'Witch character' },
        mimi: { id: 'zrHiDhphv9ZnVXBqCLjz', name: 'Mimi', desc: 'Swedish childish female' }
    },
    
    // OpenAI TTS voices
    OPENAI_VOICES: {
        alloy: { name: 'Alloy', desc: 'Neutral, balanced' },
        echo: { name: 'Echo', desc: 'Warm, conversational' },
        fable: { name: 'Fable', desc: 'Expressive, British' },
        onyx: { name: 'Onyx', desc: 'Deep, authoritative' },
        nova: { name: 'Nova', desc: 'Friendly, upbeat female' },
        shimmer: { name: 'Shimmer', desc: 'Clear, pleasant female' }
    },
    
    getSettings() {
        const state = Gamification.getState();
        return state.ttsSettings || { 
            provider: 'browser', 
            elevenLabsKey: '', 
            openaiKey: '',
            voice: 'rachel',
            openaiVoice: 'nova',
            speed: 1.0 
        };
    },
    
    saveSettings(settings) {
        const state = Gamification.getState();
        state.ttsSettings = settings;
        Gamification.saveState(state);
    },

    async speak() {
        if (this.speaking) {
            this.stop();
            return;
        }

        // Get current question text
        let text = '';
        const screen = document.getElementById('screen-exam');
        if (screen.classList.contains('active')) {
            const q = App.questions[App.currentQ];
            if (q) {
                text = `Question ${App.currentQ + 1}. ${this._cleanText(q.text)}. `;
                text += 'Options: ';
                q.options.forEach((opt, i) => {
                    text += `${String.fromCharCode(65 + i)}: ${this._cleanText(opt)}. `;
                });
            }
        } else if (document.getElementById('screen-drill').classList.contains('active') && Drill.current) {
            const q = Drill.current.question;
            text = `${this._cleanText(q.text)}. Options: `;
            q.options.forEach((opt, i) => {
                text += `${String.fromCharCode(65 + i)}: ${this._cleanText(opt)}. `;
            });
        } else if (document.getElementById('screen-ai-practice').classList.contains('active') && AIPractice.currentQuestion) {
            const q = AIPractice.currentQuestion;
            text = `${this._cleanText(q.question)}. Options: `;
            q.options.forEach((opt, i) => {
                text += `${String.fromCharCode(65 + i)}: ${this._cleanText(opt)}. `;
            });
        }

        if (!text) {
            alert('No question to read.');
            return;
        }

        const settings = this.getSettings();
        this.speaking = true;
        document.getElementById('btnAudio').classList.add('active');
        
        if (settings.provider === 'elevenlabs' && settings.elevenLabsKey) {
            await this._speakElevenLabs(text, settings);
        } else if (settings.provider === 'openai' && settings.openaiKey) {
            await this._speakOpenAI(text, settings);
        } else if (settings.provider === 'speechify') {
            this._speakSpeechify(text, settings);
        } else {
            this._speakBrowser(text, settings);
        }
    },
    
    async _speakOpenAI(text, settings) {
        try {
            const response = await fetch('https://api.openai.com/v1/audio/speech', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${settings.openaiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    model: 'tts-1',
                    input: text,
                    voice: settings.openaiVoice || 'nova',
                    speed: settings.speed || 1.0
                })
            });
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                console.error('OpenAI TTS error:', error);
                this._speakBrowser(text, settings);
                return;
            }
            
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            this.currentAudio = new window.Audio(audioUrl);
            
            this.currentAudio.onended = () => {
                this.speaking = false;
                document.getElementById('btnAudio')?.classList.remove('active');
                URL.revokeObjectURL(audioUrl);
                this.currentAudio = null;
            };
            
            this.currentAudio.onerror = () => {
                this.speaking = false;
                document.getElementById('btnAudio')?.classList.remove('active');
                URL.revokeObjectURL(audioUrl);
                this.currentAudio = null;
            };
            
            this.currentAudio.play();
        } catch (err) {
            console.error('OpenAI TTS error:', err);
            this._speakBrowser(text, settings);
        }
    },
    
    _speakSpeechify(text, settings) {
        // Speechify uses their Chrome extension or embedded widget
        // Check if Speechify API is available (from extension)
        if (window.speechify && window.speechify.speak) {
            window.speechify.speak(text, { rate: settings.speed || 1.0 });
            // Speechify handles its own UI, we just track state
            this.speaking = true;
            setTimeout(() => {
                this.speaking = false;
                document.getElementById('btnAudio')?.classList.remove('active');
            }, text.length * 60); // Rough estimate
        } else {
            // Fallback: Open Speechify web reader with text
            const speechifyUrl = `https://speechify.com/text-to-speech-online/?text=${encodeURIComponent(text.substring(0, 500))}`;
            window.open(speechifyUrl, '_blank', 'width=500,height=400');
            this.speaking = false;
            document.getElementById('btnAudio')?.classList.remove('active');
        }
    },
    
    async _speakElevenLabs(text, settings) {
        const voiceId = this.ELEVENLABS_VOICES[settings.voice]?.id || this.ELEVENLABS_VOICES.rachel.id;
        
        try {
            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                method: 'POST',
                headers: {
                    'Accept': 'audio/mpeg',
                    'Content-Type': 'application/json',
                    'xi-api-key': settings.elevenLabsKey
                },
                body: JSON.stringify({
                    text: text,
                    model_id: 'eleven_monolingual_v1',
                    voice_settings: {
                        stability: 0.5,
                        similarity_boost: 0.75,
                        style: 0.0,
                        use_speaker_boost: true
                    }
                })
            });
            
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                console.error('ElevenLabs error:', error);
                // Fallback to browser TTS
                this._speakBrowser(text, settings);
                return;
            }
            
            const audioBlob = await response.blob();
            const audioUrl = URL.createObjectURL(audioBlob);
            this.currentAudio = new window.Audio(audioUrl);
            this.currentAudio.playbackRate = settings.speed || 1.0;
            
            this.currentAudio.onended = () => {
                this.speaking = false;
                document.getElementById('btnAudio').classList.remove('active');
                URL.revokeObjectURL(audioUrl);
                this.currentAudio = null;
            };
            
            this.currentAudio.onerror = () => {
                this.speaking = false;
                document.getElementById('btnAudio').classList.remove('active');
                URL.revokeObjectURL(audioUrl);
                this.currentAudio = null;
            };
            
            this.currentAudio.play();
        } catch (err) {
            console.error('ElevenLabs TTS error:', err);
            // Fallback to browser
            this._speakBrowser(text, settings);
        }
    },
    
    _speakBrowser(text, settings) {
        if (!('speechSynthesis' in window)) {
            alert('Text-to-speech not supported in this browser.');
            this.speaking = false;
            document.getElementById('btnAudio').classList.remove('active');
            return;
        }
        
        const utterance = new SpeechSynthesisUtterance(text);
        utterance.rate = settings.speed || 0.95;
        utterance.pitch = 1;
        
        // Try to get a better browser voice
        const voices = speechSynthesis.getVoices();
        const preferred = voices.find(v => 
            v.name.includes('Google') || 
            v.name.includes('Microsoft') || 
            v.name.includes('Samantha') || 
            v.name.includes('Alex') ||
            v.name.includes('Zira') ||
            v.name.includes('David')
        );
        if (preferred) utterance.voice = preferred;
        
        utterance.onend = () => {
            this.speaking = false;
            document.getElementById('btnAudio').classList.remove('active');
        };
        utterance.onerror = () => {
            this.speaking = false;
            document.getElementById('btnAudio').classList.remove('active');
        };
        
        speechSynthesis.speak(utterance);
    },

    _cleanText(text) {
        // Remove HTML tags and simplify for speech
        return text
            .replace(/<[^>]*>/g, '')
            .replace(/\[Graph[^\]]*\]/gi, 'See the graph provided.')
            .replace(/\$(\d[\d,.]*)/g, '$1 dollars')  // $50  "50 dollars"
            .replace(/\$/g, '')                         // Remove remaining $ (LaTeX delimiters)
            .replace(/\n/g, '. ')
            .trim();
    },

    stop() {
        if (this.speaking) {
            // Stop ElevenLabs audio
            if (this.currentAudio) {
                this.currentAudio.pause();
                this.currentAudio = null;
            }
            // Stop browser TTS
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }
            this.speaking = false;
            const btn = document.getElementById('btnAudio');
            if (btn) btn.classList.remove('active');
        }
    },
    
    showSettingsModal() {
        const settings = this.getSettings();
        const elevenVoices = Object.entries(this.ELEVENLABS_VOICES);
        const openaiVoices = Object.entries(this.OPENAI_VOICES);
        
        let elevenVoiceOptions = elevenVoices.map(([key, v]) => 
            `<option value="${key}" ${settings.voice === key ? 'selected' : ''}>${v.name} - ${v.desc}</option>`
        ).join('');
        
        let openaiVoiceOptions = openaiVoices.map(([key, v]) => 
            `<option value="${key}" ${settings.openaiVoice === key ? 'selected' : ''}>${v.name} - ${v.desc}</option>`
        ).join('');
        
        const html = `
            <div class="modal-overlay" id="ttsSettingsModal" onclick="if(event.target===this)this.remove()">
                <div class="modal-content" style="max-width:480px;max-height:90vh;overflow-y:auto">
                    <h3 style="margin:0 0 16px;display:flex;align-items:center;gap:8px">
                        <span style="font-size:24px"></span> Voice Settings
                    </h3>
                    
                    <div style="margin-bottom:16px">
                        <label style="display:block;font-weight:600;margin-bottom:6px">TTS Provider</label>
                        <select id="ttsProvider" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--gray-300);font-size:14px" onchange="Audio._toggleProviderSettings()">
                            <option value="browser" ${settings.provider === 'browser' ? 'selected' : ''}> Browser (Free, basic quality)</option>
                            <option value="elevenlabs" ${settings.provider === 'elevenlabs' ? 'selected' : ''}> ElevenLabs (Premium AI, 10k free/mo)</option>
                            <option value="openai" ${settings.provider === 'openai' ? 'selected' : ''}> OpenAI TTS (~$0.015/1k chars)</option>
                            <option value="speechify" ${settings.provider === 'speechify' ? 'selected' : ''}> Speechify (Extension/Web)</option>
                        </select>
                    </div>
                    
                    <!-- ElevenLabs Settings -->
                    <div id="elevenLabsSettings" class="provider-settings" style="display:${settings.provider === 'elevenlabs' ? 'block' : 'none'}">
                        <div style="padding:12px;background:rgba(139,92,246,.1);border-radius:8px;margin-bottom:12px">
                            <div style="margin-bottom:12px">
                                <label style="display:block;font-weight:600;margin-bottom:6px">ElevenLabs API Key</label>
                                <input type="password" id="elevenLabsKey" value="${settings.elevenLabsKey || ''}" 
                                       placeholder="Enter your API key" 
                                       style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--gray-300);font-size:14px;box-sizing:border-box">
                                <p style="font-size:11px;color:var(--gray-500);margin:4px 0 0">
                                    Get free key at <a href="https://elevenlabs.io" target="_blank" style="color:var(--blue)">elevenlabs.io</a>  10k chars/month free
                                </p>
                            </div>
                            <div>
                                <label style="display:block;font-weight:600;margin-bottom:6px">Voice (40+ options)</label>
                                <select id="ttsVoice" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--gray-300);font-size:14px">
                                    ${elevenVoiceOptions}
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- OpenAI Settings -->
                    <div id="openaiSettings" class="provider-settings" style="display:${settings.provider === 'openai' ? 'block' : 'none'}">
                        <div style="padding:12px;background:rgba(16,185,129,.1);border-radius:8px;margin-bottom:12px">
                            <div style="margin-bottom:12px">
                                <label style="display:block;font-weight:600;margin-bottom:6px">OpenAI API Key</label>
                                <input type="password" id="openaiKey" value="${settings.openaiKey || ''}" 
                                       placeholder="sk-..." 
                                       style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--gray-300);font-size:14px;box-sizing:border-box">
                                <p style="font-size:11px;color:var(--gray-500);margin:4px 0 0">
                                    Uses your existing OpenAI key  ~$0.015 per 1,000 characters
                                </p>
                            </div>
                            <div>
                                <label style="display:block;font-weight:600;margin-bottom:6px">Voice</label>
                                <select id="openaiVoice" style="width:100%;padding:10px;border-radius:8px;border:1px solid var(--gray-300);font-size:14px">
                                    ${openaiVoiceOptions}
                                </select>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Speechify Settings -->
                    <div id="speechifySettings" class="provider-settings" style="display:${settings.provider === 'speechify' ? 'block' : 'none'}">
                        <div style="padding:12px;background:rgba(59,130,246,.1);border-radius:8px;margin-bottom:12px">
                            <p style="margin:0 0 8px;font-size:13px">
                                <strong>Option 1:</strong> Install the <a href="https://speechify.com/chrome-extension/" target="_blank" style="color:var(--blue)">Speechify Chrome Extension</a> for seamless integration.
                            </p>
                            <p style="margin:0;font-size:13px">
                                <strong>Option 2:</strong> Opens Speechify's web reader with the question text.
                            </p>
                            <p style="margin:8px 0 0;font-size:11px;color:var(--gray-500)">
                                Speechify offers natural voices with their subscription plans.
                            </p>
                        </div>
                    </div>
                    
                    <!-- Browser Settings -->
                    <div id="browserSettings" class="provider-settings" style="display:${settings.provider === 'browser' ? 'block' : 'none'}">
                        <div style="padding:12px;background:rgba(107,114,128,.1);border-radius:8px;margin-bottom:12px">
                            <p style="margin:0;font-size:13px">
                                Uses your browser's built-in text-to-speech. Quality varies by browser and OS.
                            </p>
                        </div>
                    </div>
                    
                    <div style="margin-bottom:20px">
                        <label style="display:block;font-weight:600;margin-bottom:6px">Speed: <span id="speedValue">${settings.speed || 1.0}x</span></label>
                        <input type="range" id="ttsSpeed" min="0.5" max="2" step="0.1" value="${settings.speed || 1.0}" 
                               style="width:100%" oninput="document.getElementById('speedValue').textContent=this.value+'x'">
                    </div>
                    
                    <div style="display:flex;gap:12px">
                        <button onclick="Audio._testVoice()" style="flex:1;padding:12px;border-radius:8px;border:none;background:var(--gray-200);font-weight:600;cursor:pointer">
                             Test Voice
                        </button>
                        <button onclick="Audio._saveSettings()" style="flex:1;padding:12px;border-radius:8px;border:none;background:var(--green);color:#fff;font-weight:600;cursor:pointer">
                             Save
                        </button>
                    </div>
                </div>
            </div>
        `;
        
        document.body.insertAdjacentHTML('beforeend', html);
    },
    
    _toggleProviderSettings() {
        const provider = document.getElementById('ttsProvider').value;
        document.querySelectorAll('.provider-settings').forEach(el => el.style.display = 'none');
        const settingsId = {
            'elevenlabs': 'elevenLabsSettings',
            'openai': 'openaiSettings', 
            'speechify': 'speechifySettings',
            'browser': 'browserSettings'
        }[provider];
        if (settingsId) document.getElementById(settingsId).style.display = 'block';
    },
    
    async _testVoice() {
        const provider = document.getElementById('ttsProvider').value;
        const testSettings = {
            provider: provider,
            elevenLabsKey: document.getElementById('elevenLabsKey')?.value || '',
            openaiKey: document.getElementById('openaiKey')?.value || '',
            voice: document.getElementById('ttsVoice')?.value || 'rachel',
            openaiVoice: document.getElementById('openaiVoice')?.value || 'nova',
            speed: parseFloat(document.getElementById('ttsSpeed').value) || 1.0
        };
        
        this.stop();
        this.speaking = true;
        
        const testText = "Hello! This is a test of the text-to-speech system. How does this voice sound?";
        
        if (testSettings.provider === 'elevenlabs' && testSettings.elevenLabsKey) {
            await this._speakElevenLabs(testText, testSettings);
        } else if (testSettings.provider === 'openai' && testSettings.openaiKey) {
            await this._speakOpenAI(testText, testSettings);
        } else if (testSettings.provider === 'speechify') {
            this._speakSpeechify(testText, testSettings);
        } else {
            this._speakBrowser(testText, testSettings);
        }
    },
    
    _saveSettings() {
        const settings = {
            provider: document.getElementById('ttsProvider').value,
            elevenLabsKey: document.getElementById('elevenLabsKey')?.value || '',
            openaiKey: document.getElementById('openaiKey')?.value || '',
            voice: document.getElementById('ttsVoice')?.value || 'rachel',
            openaiVoice: document.getElementById('openaiVoice')?.value || 'nova',
            speed: parseFloat(document.getElementById('ttsSpeed').value) || 1.0
        };
        
        this.saveSettings(settings);
        document.getElementById('ttsSettingsModal')?.remove();
        
        // Show confirmation
        const toast = document.createElement('div');
        toast.className = 'achievement-toast';
        const providerNames = { browser: 'Browser', elevenlabs: 'ElevenLabs', openai: 'OpenAI', speechify: 'Speechify' };
        toast.innerHTML = `<span style="font-size:24px"></span><div><strong>Voice Settings Saved</strong><br><small>${providerNames[settings.provider] || 'Browser'} voice active</small></div>`;
        document.body.appendChild(toast);
        setTimeout(() => toast.remove(), 3000);
    }
};

// =====================================================================
// METRICS TRACKING
// =====================================================================
const Metrics = {
    questionTimes: {},  // { qIndex: { start, end, total } }
    currentStart: 0,

    startQuestion(qIndex) {
        if (!this.questionTimes[qIndex]) {
            this.questionTimes[qIndex] = { total: 0, visits: 0 };
        }
        this.currentStart = Date.now();
        this.questionTimes[qIndex].visits++;
    },

    endQuestion(qIndex) {
        if (this.currentStart && this.questionTimes[qIndex]) {
            this.questionTimes[qIndex].total += Date.now() - this.currentStart;
        }
        this.currentStart = 0;
    },

    getTimeSpent(qIndex) {
        const data = this.questionTimes[qIndex];
        if (!data) return 0;
        let time = data.total;
        if (this.currentStart && App.currentQ === qIndex) {
            time += Date.now() - this.currentStart;
        }
        return time;
    },

    getTotalTime() {
        let total = 0;
        for (const qIndex in this.questionTimes) {
            total += this.getTimeSpent(parseInt(qIndex));
        }
        return total;
    },

    getAvgTimePerQuestion() {
        const visited = Object.keys(this.questionTimes).length;
        return visited > 0 ? this.getTotalTime() / visited : 0;
    },

    reset() {
        this.questionTimes = {};
        this.currentStart = 0;
    },

    // Get stats by category
    getCategoryStats(questions, answers) {
        const catStats = {};
        questions.forEach((q, i) => {
            const cat = q.category || 'General';
            if (!catStats[cat]) {
                catStats[cat] = { correct: 0, total: 0, time: 0, answered: 0 };
            }
            catStats[cat].total++;
            if (answers[i] !== undefined) {
                catStats[cat].answered++;
                const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
                if (answers[i] === correctIdx) catStats[cat].correct++;
            }
            catStats[cat].time += this.getTimeSpent(i);
        });
        return catStats;
    },

    // Get answer change statistics
    getAnswerChangeStats(questions, answers, answerHistory) {
        let totalChanges = 0;
        let changedQuestions = 0;
        const changedFromCorrect = [];  // Questions where first answer was correct but final was wrong
        const changedToCorrect = [];    // Questions where first answer was wrong but final was correct

        for (const qIdx in answerHistory) {
            const history = answerHistory[qIdx];
            if (history.length > 1) {
                changedQuestions++;
                totalChanges += history.length - 1;

                const q = questions[qIdx];
                const firstAnswer = history[0];
                const finalAnswer = answers[qIdx];
                const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;

                if (firstAnswer === correctIdx && finalAnswer !== correctIdx) {
                    changedFromCorrect.push(parseInt(qIdx));
                } else if (firstAnswer !== correctIdx && finalAnswer === correctIdx) {
                    changedToCorrect.push(parseInt(qIdx));
                }
            }
        }
        return { totalChanges, changedQuestions, changedFromCorrect, changedToCorrect };
    },

    // Get first attempt accuracy statistics
    getFirstAttemptStats(questions, answers, answerHistory) {
        let firstAttemptCorrect = 0;
        let finalCorrect = 0;
        let answeredCount = 0;

        for (const qIdx in answers) {
            const q = questions[qIdx];
            const finalAnswer = answers[qIdx];
            answeredCount++;

            const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
            if (finalAnswer === correctIdx) {
                finalCorrect++;
            }

            // Check first attempt
            const history = answerHistory[qIdx];
            if (history && history.length > 0) {
                if (history[0] === correctIdx) {
                    firstAttemptCorrect++;
                }
            }
        }

        return {
            firstAttemptCorrect,
            finalCorrect,
            answeredCount,
            firstAccuracy: answeredCount > 0 ? Math.round((firstAttemptCorrect / answeredCount) * 100) : 0,
            finalAccuracy: answeredCount > 0 ? Math.round((finalCorrect / answeredCount) * 100) : 0
        };
    },

    // Get confidence vs accuracy correlation
    getConfidenceStats(questions, answers, confidence) {
        const stats = {
            1: { correct: 0, total: 0, label: 'Maybe' },
            2: { correct: 0, total: 0, label: 'Probably' },
            3: { correct: 0, total: 0, label: 'Definitely' }
        };

        for (const qIdx in confidence) {
            const level = confidence[qIdx];
            if (answers[qIdx] !== undefined && stats[level]) {
                stats[level].total++;
                if (answers[qIdx] === questions[qIdx].correctAnswer) {
                    stats[level].correct++;
                }
            }
        }

        return stats;
    },

    // Get questions with multiple revisits
    getRevisitedQuestions() {
        const revisited = [];
        for (const qIdx in this.questionTimes) {
            const visits = this.questionTimes[qIdx].visits;
            if (visits > 1) {
                revisited.push({ index: parseInt(qIdx), visits });
            }
        }
        return revisited.sort((a, b) => b.visits - a.visits);
    },

    // Build metrics summary HTML for score screen
    buildMetricsSummary(questions, answers) {
        const totalTime = this.getTotalTime();
        const avgTime = this.getAvgTimePerQuestion();
        const catStats = this.getCategoryStats(questions, answers);

        // New metrics
        const answerChangeStats = this.getAnswerChangeStats(questions, answers, App.answerHistory);
        const firstAttemptStats = this.getFirstAttemptStats(questions, answers, App.answerHistory);
        const confidenceStats = this.getConfidenceStats(questions, answers, App.confidence);
        const revisitedQuestions = this.getRevisitedQuestions();

        // Find slowest and fastest questions
        const times = [];
        for (let i = 0; i < questions.length; i++) {
            times.push({ index: i, time: this.getTimeSpent(i) });
        }
        times.sort((a, b) => b.time - a.time);
        const slowest = times.slice(0, 3).filter(t => t.time > 0);

        let html = '<div class="metrics-summary"><h3>Performance Metrics</h3>';
        html += '<div class="metrics-grid">';
        html += `<div class="metric-item"><div class="metric-val">${this._formatTime(totalTime)}</div><div class="metric-lbl">Total Time</div></div>`;
        html += `<div class="metric-item"><div class="metric-val">${this._formatTime(avgTime)}</div><div class="metric-lbl">Avg per Question</div></div>`;
        html += `<div class="metric-item"><div class="metric-val">${Object.keys(this.questionTimes).length}</div><div class="metric-lbl">Questions Viewed</div></div>`;
        html += `<div class="metric-item"><div class="metric-val">${answerChangeStats.totalChanges}</div><div class="metric-lbl">Answer Changes</div></div>`;
        html += '</div>';

        // First Attempt vs Final Accuracy
        if (firstAttemptStats.answeredCount > 0) {
            html += '<div class="time-per-q" style="margin-top:16px"><strong>First Attempt vs Final Accuracy:</strong>';
            html += '<table><tr><th>Metric</th><th>Correct</th><th>Accuracy</th></tr>';
            html += `<tr><td>First Attempt</td><td>${firstAttemptStats.firstAttemptCorrect}/${firstAttemptStats.answeredCount}</td><td>${firstAttemptStats.firstAccuracy}%</td></tr>`;
            html += `<tr><td>Final Answer</td><td>${firstAttemptStats.finalCorrect}/${firstAttemptStats.answeredCount}</td><td>${firstAttemptStats.finalAccuracy}%</td></tr>`;
            html += '</table>';

            // Show if changing answers helped or hurt
            if (answerChangeStats.changedQuestions > 0) {
                const helpedCount = answerChangeStats.changedToCorrect.length;
                const hurtCount = answerChangeStats.changedFromCorrect.length;
                html += `<p style="font-size:12px;color:var(--gray-600);margin-top:8px">Changed answers on ${answerChangeStats.changedQuestions} questions: `;
                html += `<span style="color:var(--green)">${helpedCount} helped</span>, `;
                html += `<span style="color:var(--red)">${hurtCount} hurt</span></p>`;

                if (answerChangeStats.changedFromCorrect.length > 0) {
                    html += `<p style="font-size:11px;color:var(--red);margin-top:4px">Changed FROM correct: Q${answerChangeStats.changedFromCorrect.map(i => i + 1).join(', Q')}</p>`;
                }
            }
            html += '</div>';
        }

        // Confidence vs Accuracy (only in Practice mode)
        const totalConfidenceRatings = Object.values(confidenceStats).reduce((sum, s) => sum + s.total, 0);
        if (totalConfidenceRatings > 0) {
            html += '<div class="time-per-q" style="margin-top:16px"><strong>Confidence vs Accuracy:</strong>';
            html += '<table><tr><th>Confidence</th><th>Correct</th><th>Accuracy</th></tr>';
            for (const level of [1, 2, 3]) {
                const s = confidenceStats[level];
                if (s.total > 0) {
                    const accuracy = Math.round((s.correct / s.total) * 100);
                    const color = accuracy >= 70 ? 'var(--green)' : accuracy >= 50 ? 'var(--orange)' : 'var(--red)';
                    html += `<tr><td>${s.label}</td><td>${s.correct}/${s.total}</td><td style="color:${color}">${accuracy}%</td></tr>`;
                }
            }
            html += '</table>';

            // Calculate calibration hint
            const maybeAcc = confidenceStats[1].total > 0 ? confidenceStats[1].correct / confidenceStats[1].total : 0;
            const defAcc = confidenceStats[3].total > 0 ? confidenceStats[3].correct / confidenceStats[3].total : 0;
            if (confidenceStats[1].total >= 2 && confidenceStats[3].total >= 2) {
                if (maybeAcc > defAcc + 0.1) {
                    html += '<p style="font-size:11px;color:var(--orange);margin-top:4px">You perform better when unsure - trust your instincts more!</p>';
                } else if (defAcc >= 0.8 && maybeAcc < 0.5) {
                    html += '<p style="font-size:11px;color:var(--green);margin-top:4px">Good calibration! Your confidence matches your accuracy.</p>';
                }
            }
            html += '</div>';
        }

        // Questions with multiple revisits
        if (revisitedQuestions.length > 0) {
            const topRevisited = revisitedQuestions.slice(0, 5);
            html += '<div class="time-per-q" style="margin-top:16px"><strong>Most Revisited Questions:</strong>';
            html += '<table><tr><th>Q#</th><th>Visits</th><th>Result</th></tr>';
            topRevisited.forEach(r => {
                const q = questions[r.index];
                const correctIdx = q._shuffledCorrect !== undefined ? q._shuffledCorrect : q.correctAnswer;
                const isCorrect = answers[r.index] === correctIdx;
                const wasAnswered = answers[r.index] !== undefined;
                const result = !wasAnswered ? 'Unanswered' : (isCorrect ? 'Correct' : 'Incorrect');
                const resultColor = !wasAnswered ? 'var(--orange)' : (isCorrect ? 'var(--green)' : 'var(--red)');
                html += `<tr><td>${r.index + 1}</td><td>${r.visits}</td><td style="color:${resultColor}">${result}</td></tr>`;
            });
            html += '</table></div>';
        }

        if (slowest.length > 0) {
            html += '<div class="time-per-q" style="margin-top:16px"><strong>Most Time Spent:</strong><table><tr><th>Q#</th><th>Time</th><th>Category</th></tr>';
            slowest.forEach(s => {
                const q = questions[s.index];
                html += `<tr><td>${s.index + 1}</td><td>${this._formatTime(s.time)}</td><td>${escapeHtml(q.category || 'General')}</td></tr>`;
            });
            html += '</table></div>';
        }

        // Category time breakdown
        html += '<div class="time-per-q" style="margin-top:16px"><strong>Time by Category:</strong><table><tr><th>Category</th><th>Time</th><th>Avg/Q</th></tr>';
        Object.entries(catStats).sort((a, b) => b[1].time - a[1].time).forEach(([cat, data]) => {
            const avgCatTime = data.total > 0 ? data.time / data.total : 0;
            html += `<tr><td>${escapeHtml(cat)}</td><td>${this._formatTime(data.time)}</td><td>${this._formatTime(avgCatTime)}</td></tr>`;
        });
        html += '</table></div>';

        html += '</div>';
        return html;
    },

    _formatTime(ms) {
        const secs = Math.round(ms / 1000);
        if (secs < 60) return secs + 's';
        const mins = Math.floor(secs / 60);
        const remainSecs = secs % 60;
        return mins + 'm ' + remainSecs + 's';
    }
};

// =====================================================================
// PER-QUESTION PERFORMANCE TRACKER
// =====================================================================
/**
 * @namespace QuestionTracker
 * @description Tracks per-question performance for spaced repetition.
 * Stores streak, ease factor, interval, and next due date.
 * 
 * State persisted to localStorage key: `wgu_questionTracker`
 * 
 * Key methods:
 * - record(bankId, questionId, correct, confidence) - Log attempt
 * - getStats(bankId, questionId) - Get question performance data
 * - getDueQuestions(bankId) - Get questions due for review
 * - getSummary(bankId) - Aggregate stats for a bank
 */
const QuestionTracker = {
    _key: 'questionTracker',

    _getData() {
        return Store.get(this._key, {});
    },

    _save(data) {
        Store.set(this._key, data);
    },

    // Record an array of question results (from test submission or single answers)
    recordResults(results) {
        const data = this._getData();
        const now = Date.now();
        for (const r of results) {
            if (!r.qId) continue;
            if (!data[r.qId]) {
                data[r.qId] = {
                    attempts: 0, correct: 0, incorrect: 0, skipped: 0,
                    totalTime: 0, category: r.category || 'General',
                    history: [],
                    streak: 0,
                    ease: 2.5,
                    interval: 1,
                    nextDue: now
                };
            }
            const entry = data[r.qId];
            entry.attempts++;
            if (!r.answered) { entry.skipped++; }
            else if (r.correct) { entry.correct++; }
            else { entry.incorrect++; }
            // Cap time to filter outliers (5 min max per question)
            const cappedTime = Math.min(r.timeSpent || 0, 5 * 60 * 1000);
            entry.totalTime += cappedTime;
            if (r.category) entry.category = r.category;
            if (r.confidence != null) {
                entry.confidenceSum = (entry.confidenceSum || 0) + r.confidence;
                entry.confidenceCount = (entry.confidenceCount || 0) + 1;
                entry.lastConfidence = r.confidence;
            }
            entry.lastResult = r.correct;
            this._updateScheduling(entry, r.correct, r.confidence);
            // Keep last 20 attempts
            entry.history.push({
                date: now, correct: r.correct, answered: r.answered,
                chosen: r.chosen, timeMs: cappedTime,
                confidence: r.confidence == null ? undefined : r.confidence,
                category: r.category || entry.category || 'General'
            });
            if (entry.history.length > 20) entry.history = entry.history.slice(-20);
        }
        this._save(data);
    },

    // Cap time to filter outliers (5 min max per question - longer = interruption)
    _capTime(timeMs) {
        const MAX_TIME = 5 * 60 * 1000; // 5 minutes
        return Math.min(timeMs || 0, MAX_TIME);
    },

    // Record a single question attempt (for drill and AI practice)
    recordSingle(qId, category, isCorrect, timeSpent, meta = {}) {
        console.log('[QuestionTracker] recordSingle called:', { qId, category, isCorrect, timeSpent });
        this.recordResults([{
            qId,
            category,
            correct: isCorrect,
            answered: true,
            chosen: null,
            correctAnswer: null,
            timeSpent: this._capTime(timeSpent),
            confidence: meta.confidence ?? null,
            mode: meta.mode || 'practice'
        }]);
        console.log('[QuestionTracker] Data after save:', this._getData());
    },

    _updateScheduling(entry, isCorrect, confidence) {
        const now = Date.now();
        entry.ease = entry.ease || 2.5;
        entry.interval = entry.interval || 1;
        entry.streak = entry.streak || 0;

        const confBoost = confidence != null ? (confidence - 2) * 0.15 : 0;

        if (isCorrect) {
            entry.streak++;
            entry.ease = Math.min(3.7, entry.ease + 0.05 + confBoost);
            const intervalHours = entry.streak <= 1 ? 1 : Math.max(1, entry.interval * entry.ease);
            entry.interval = intervalHours;
        } else {
            entry.streak = 0;
            const penalty = 0.3 + (confidence != null && confidence >= 3 ? 0.3 : 0);
            entry.ease = Math.max(1.3, entry.ease - penalty);
            entry.interval = 1;
        }

        const hours = Math.max(1, entry.interval);
        entry.nextDue = now + hours * 60 * 60 * 1000;
    },

    // Get most missed questions (sorted by miss rate, min 2 attempts)
    getMostMissed(limit) {
        limit = limit || 10;
        const data = this._getData();
        const entries = [];
        for (const qId in data) {
            const d = data[qId];
            if (d.attempts < 2) continue;
            const missRate = d.incorrect / d.attempts;
            if (missRate > 0) {
                entries.push({ qId, missRate, ...d });
            }
        }
        entries.sort((a, b) => b.missRate - a.missRate || b.attempts - a.attempts);
        return entries.slice(0, limit);
    },

    // Get category accuracy from tracked data
    getCategoryAccuracy() {
        const data = this._getData();
        const cats = {};
        for (const qId in data) {
            const d = data[qId];
            const cat = d.category || 'General';
            if (!cats[cat]) cats[cat] = { correct: 0, total: 0, time: 0 };
            cats[cat].correct += d.correct;
            cats[cat].total += d.attempts;
            cats[cat].time += d.totalTime;
        }
        return cats;
    },

    // Get category accuracy with trend (compare last 7 days vs previous 7 days)
    getCategoryAccuracyWithTrend() {
        const data = this._getData();
        const now = Date.now();
        const oneWeek = 7 * 24 * 60 * 60 * 1000;
        const twoWeeks = 14 * 24 * 60 * 60 * 1000;
        
        const cats = {};
        for (const qId in data) {
            const d = data[qId];
            const cat = d.category || 'General';
            if (!cats[cat]) cats[cat] = { 
                correct: 0, total: 0, 
                recentCorrect: 0, recentTotal: 0,
                olderCorrect: 0, olderTotal: 0
            };
            
            // Overall totals
            cats[cat].correct += d.correct;
            cats[cat].total += d.attempts;
            
            // Split by time period using history
            if (d.history && d.history.length > 0) {
                d.history.forEach(h => {
                    const ts = new Date(h.date).getTime();
                    const age = now - ts;
                    if (age <= oneWeek) {
                        cats[cat].recentTotal++;
                        if (h.correct) cats[cat].recentCorrect++;
                    } else if (age <= twoWeeks) {
                        cats[cat].olderTotal++;
                        if (h.correct) cats[cat].olderCorrect++;
                    }
                });
            }
        }
        
        // Calculate trends
        for (const cat in cats) {
            const c = cats[cat];
            const recentPct = c.recentTotal > 0 ? (c.recentCorrect / c.recentTotal) * 100 : null;
            const olderPct = c.olderTotal > 0 ? (c.olderCorrect / c.olderTotal) * 100 : null;
            
            if (recentPct !== null && olderPct !== null) {
                c.trend = Math.round(recentPct - olderPct);
            } else {
                c.trend = null; // Not enough data
            }
        }
        
        return cats;
    },

    // Get improvement trend (compare last N attempts vs previous N)
    getTrend(qId, lookback) {
        lookback = lookback || 5;
        const data = this._getData();
        const d = data[qId];
        if (!d || d.history.length < lookback * 2) return null;
        const recent = d.history.slice(-lookback);
        const previous = d.history.slice(-lookback * 2, -lookback);
        const recentAcc = recent.filter(h => h.correct).length / lookback;
        const prevAcc = previous.filter(h => h.correct).length / lookback;
        return { recentAcc, prevAcc, improving: recentAcc > prevAcc };
    },

    // Get overall stats summary
    getSummary() {
        const data = this._getData();
        let totalAttempts = 0, totalCorrect = 0, totalTime = 0, questionsTracked = 0;
        for (const qId in data) {
            const d = data[qId];
            questionsTracked++;
            totalAttempts += d.attempts;
            totalCorrect += d.correct;
            totalTime += d.totalTime;
        }
        return {
            questionsTracked, totalAttempts, totalCorrect,
            accuracy: totalAttempts > 0 ? Math.round((totalCorrect / totalAttempts) * 100) : 0,
            totalTime
        };
    },

    // Find question text by ID from loaded banks
    findQuestion(qId) {
        for (const bank of BankManager.banks) {
            const q = bank.questions.find(q => q.id === qId);
            if (q) return { question: q, bankTitle: bank.title };
        }
        return null;
    }
};

// =====================================================================
// KEYBOARD SHORTCUTS
// =====================================================================
const KeyboardShortcuts = {
    enabled: true,
    
    SHORTCUTS: {
        global: [
            { key: '?', desc: 'Toggle help modal', action: () => document.getElementById('helpModal').classList.toggle('active') },
            { key: 'c', desc: 'Toggle calculator', action: () => Calc.toggle() },
            { key: 'Escape', desc: 'Close modals', action: () => KeyboardShortcuts.closeModals() },
            { key: 'h', desc: 'Go to home screen', action: () => { showScreen('home'); Home.render(); } },
            { key: 's', desc: 'Open settings', action: () => Settings.openModal() },
            { key: 'g', desc: 'Open garden', action: () => showScreen('garden') },
        ],
        exam: [
            { key: 'ArrowRight', alt: 'n', desc: 'Next question', action: () => App.next() },
            { key: 'ArrowLeft', alt: 'p', desc: 'Previous question', action: () => App.prev() },
            { key: 'b', desc: 'Toggle bookmark', action: () => App.toggleBookmark() },
            { key: 't', desc: 'Toggle notes', action: () => Notes.toggle() },
            { key: '1-4', desc: 'Select answer option', action: null },
            { key: 'Enter', desc: 'Check answer (practice)', action: () => { if (App.mode === 'practice' && !App.practiceChecked[App.currentQ]) App.checkAnswer(); } },
            { key: 'Space', desc: 'Pause/resume timer', action: () => App.toggleTimer() },
            { key: 'f', desc: 'Toggle flag/bookmark', action: () => App.toggleBookmark() },
            { key: 'q', desc: 'Toggle question palette', action: () => App.togglePalette() },
        ],
        drill: [
            { key: 'Space', desc: 'Show answer', action: () => { if (!Drill.showingAnswer) Drill.showAnswer(); } },
            { key: '1', desc: 'Rate: Again', action: () => { if (Drill.showingAnswer) Drill.rate(1); } },
            { key: '2', desc: 'Rate: Hard', action: () => { if (Drill.showingAnswer) Drill.rate(2); } },
            { key: '3', desc: 'Rate: Good', action: () => { if (Drill.showingAnswer) Drill.rate(3); } },
            { key: '4', desc: 'Rate: Easy', action: () => { if (Drill.showingAnswer) Drill.rate(5); } },
        ]
    },

    closeModals() {
        document.getElementById('helpModal').classList.remove('active');
        if (Calc.isOpen) Calc.toggle();
        document.getElementById('settingsModal').style.display = 'none';
        document.getElementById('qCountModal').style.display = 'none';
    },

    getActiveScreen() {
        if (document.getElementById('screen-exam').classList.contains('active')) return 'exam';
        if (document.getElementById('screen-drill').classList.contains('active')) return 'drill';
        if (document.getElementById('screen-home').classList.contains('active')) return 'home';
        return 'other';
    },

    handle(e) {
        if (!this.enabled) return;
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        const screen = this.getActiveScreen();
        
        // Global shortcuts
        if (e.key === '?' || (e.shiftKey && e.key === '/')) {
            document.getElementById('helpModal').classList.toggle('active');
            e.preventDefault();
            return;
        }
        
        // Escape always closes modals
        if (e.key === 'Escape') {
            this.closeModals();
            return;
        }

        // Calculator
        if (e.key === 'c' && !e.ctrlKey && !e.metaKey) {
            Calc.toggle();
            return;
        }

        // Home navigation
        if (e.key === 'h' && !e.ctrlKey && !e.metaKey) {
            showScreen('home');
            Home.render();
            return;
        }

        // Settings
        if (e.key === 's' && !e.ctrlKey && !e.metaKey && screen === 'home') {
            Settings.openModal();
            return;
        }

        // Garden
        if (e.key === 'g' && !e.ctrlKey && !e.metaKey && screen === 'home') {
            showScreen('garden');
            return;
        }

        // Exam-specific shortcuts
        if (screen === 'exam') {
            if (e.key === 'ArrowRight' || e.key === 'n') { App.next(); return; }
            if (e.key === 'ArrowLeft' || e.key === 'p') { App.prev(); return; }
            if (e.key === 'b' || e.key === 'f') { App.toggleBookmark(); return; }
            if (e.key === 't') { Notes.toggle(); return; }
            if (e.key === 'q') { App.togglePalette(); return; }
            if (e.key === ' ') { e.preventDefault(); App.toggleTimer(); return; }
            if (e.key >= '1' && e.key <= '4' && !App.submitted && !App.practiceChecked[App.currentQ]) {
                const optIdx = parseInt(e.key) - 1;
                const q = App.questions[App.currentQ];
                if (q && q.options && optIdx < q.options.length) App.selectOption(optIdx);
                return;
            }
            if (e.key === 'Enter' && App.mode === 'practice' && !App.practiceChecked[App.currentQ]) {
                App.checkAnswer();
                return;
            }
        }

        // Drill-specific shortcuts
        if (screen === 'drill') {
            if (e.key === ' ' && !Drill.showingAnswer) { e.preventDefault(); Drill.showAnswer(); return; }
            if (Drill.showingAnswer) {
                if (e.key === '1') { Drill.rate(1); return; }
                if (e.key === '2') { Drill.rate(2); return; }
                if (e.key === '3') { Drill.rate(3); return; }
                if (e.key === '4') { Drill.rate(5); return; }
            }
        }
    },

    renderHelpSection() {
        const screen = this.getActiveScreen();
        let html = '<div class="shortcuts-help"><h4> Keyboard Shortcuts</h4>';
        html += '<div class="shortcuts-section"><strong>Global</strong><ul>';
        this.SHORTCUTS.global.forEach(s => {
            html += `<li><kbd>${s.key}</kbd> ${s.desc}</li>`;
        });
        html += '</ul></div>';
        
        if (screen === 'exam' || screen === 'home') {
            html += '<div class="shortcuts-section"><strong>Exam/Practice</strong><ul>';
            this.SHORTCUTS.exam.forEach(s => {
                const keyText = s.alt ? `${s.key}/${s.alt}` : s.key;
                html += `<li><kbd>${keyText}</kbd> ${s.desc}</li>`;
            });
            html += '</ul></div>';
        }
        
        if (screen === 'drill' || screen === 'home') {
            html += '<div class="shortcuts-section"><strong>Drill Mode</strong><ul>';
            this.SHORTCUTS.drill.forEach(s => {
                html += `<li><kbd>${s.key}</kbd> ${s.desc}</li>`;
            });
            html += '</ul></div>';
        }
        
        html += '</div>';
        return html;
    }
};

document.addEventListener('keydown', (e) => KeyboardShortcuts.handle(e));

// =====================================================================
// INIT
// =====================================================================
async function init() {
    try {
        // Load theme early to prevent flash of wrong theme
        Theme.load();
        Settings.load();

        // Initialize gamification system
        Gamification.init();

        // Initialize scene manager and trinkets
        SceneManager.init();
        Backpack.renderDeskTrinkets();

        // Initialize garden decay timers  checks every 60s for live feel
        Garden.decayWater();
        Garden.decayPetStats();
        Garden.idleGrow();
        setInterval(() => { Garden.decayWater(); Garden.decayPetStats(); Garden.idleGrow(); House.decayHouses(); Business.tick(); }, 15 * 1000);

        // Hide garden/shop/battle buttons if garden disabled
        const gState = Gamification.getState();
        const btnGarden = document.getElementById('btnGarden');
        const btnShop = document.getElementById('btnShop');
        const btnBattle = document.getElementById('btnBattle');
        if (btnGarden) btnGarden.style.display = gState.settings.garden ? '' : 'none';
        if (btnShop) btnShop.style.display = gState.settings.garden ? '' : 'none';
        if (btnBattle) btnBattle.style.display = gState.settings.garden ? '' : 'none';

        // Try loading the embedded fallback
        try {
            const script = document.getElementById('bankFallback');
            if (script) BANK_DATA = JSON.parse(script.textContent);
        } catch {}

        await BankManager.loadAll();

        // If no banks loaded via fetch and no embedded data, try to load from BANK_DATA global
        if (BankManager.banks.length === 0) {
            // Last resort: show error
            document.getElementById('bankList').innerHTML = '<p style="text-align:center;color:var(--red);padding:40px">Could not load question banks. If using file:// protocol, the embedded bank data is needed.</p>';
        }

        // Check for saved session and offer to resume
        if (SessionState.hasSavedSession()) {
            const shouldResume = await SessionState.showResumePrompt();
            if (shouldResume) {
                const state = SessionState.get();
                if (state) {
                    // Determine which mode to restore based on screen
                    const screen = state.app ? state.app.screen : 'home';
                    if (screen === 'drill') {
                        if (SessionState.restoreDrill(state)) {
                            return; // Successfully restored drill session
                        }
                    } else if (screen === 'exam') {
                        if (SessionState.restoreApp(state)) {
                            return; // Successfully restored app session
                        }
                    } else if (screen === 'ai-practice') {
                        if (SessionState.restoreAIPractice(state)) {
                            return; // Successfully restored AI Practice session
                        }
                    }
                }
                // If restoration failed, clear and show home
                SessionState.clear();
            }
        }

        Home.render();
    } catch (err) {
        console.error('Init failed', err);
        const target = document.getElementById('bankList');
        if (target) {
            target.innerHTML = `<div class="bank-card" style="border-color:var(--red);background:#fff5f5">
                <h2 style="color:var(--red)">Startup error</h2>
                <p style="color:var(--gray-700)">${escapeHtml(err?.message || String(err))}</p>
                <pre style="white-space:pre-wrap;font-size:11px;margin-top:8px;color:var(--gray-600)">${escapeHtml(err?.stack || '')}</pre>
            </div>`;
        }
        const metaBody = document.getElementById('metaSummaryBody');
        if (metaBody) metaBody.textContent = 'App failed to initialize.';
    }
}

document.addEventListener('DOMContentLoaded', init);

// Flush gamification cache to localStorage before page unload
window.addEventListener('beforeunload', () => { Session.end(); Gamification.saveStateImmediate(); });
</script>

<!-- EMBEDDED BANK DATA FALLBACK (for file:// protocol) -->
<script id="bankFallback" type="application/json">
{"bankId":"algebra-fxo1","title":"Applied Algebra - FXO1","description":"WGU Applied Algebra pre-assessment practice (70 questions)","timeLimit":5400,"passingScore":70,"categories":["Function Notation","Graph Reading","Rate of Change","Linear Functions","Exponential & Logistic","Regression & Predictions","Concavity & Curvature"],"questions":[{"id":1,"text":"A local business is looking to become a franchise. The company wants to predict the number of franchises, F, given a certain number of years, Y. This prediction is modeled by the function F(Y).\n What can be concluded by F(5) = 10?","options":["Every 5 years, 10 stores will be opened.","Every 10 years, 5 stores will be opened.","In 5 years, there will be 10 open stores.","In 10 years, there will be 5 open stores."],"correctAnswer":2,"explanation":"F(5) = 10 means when Y = 5 (the input, years), F = 10 (the output, franchises). This reads as: in 5 years, there will be 10 open stores. The other options either swap the input/output or misinterpret function notation as a rate.","category":"Function Notation","tags":["function-notation","interpret-output","franchise"],"difficulty":1},{"id":2,"text":"A bank begins a marketing campaign to increase its number of customers. Each month, all new customers are put into a drawing. One customer then receives a $50 credit in a checking account.\n The amount of money given away in the drawing, G, is a function of the number of months, M, the drawing has been going on for.\n What is the correct function notation to represent the amount of money given away after the drawing has been going on for 5 months?","options":["G(250) = 5","G(5) = 10","G(5) = 250","G(10) = 5"],"correctAnswer":2,"explanation":"G is a function of M (months). After 5 months, $50 is given away each month, so the total is $50 x 5 = $250. The correct notation places the input (5 months) inside the parentheses and the output ($250) on the right: G(5) = 250.","category":"Function Notation","tags":["function-notation","evaluate","money"],"difficulty":1},{"id":3,"text":"The volume of calls, V(h), at a particular customer service center can be written as a function of the number of hours after opening each day, h.\n What would the ordered pair (6,8) represent for this function?","options":["There were 8 calls 6 hours after opening.","There were 6 calls 8 hours after opening.","There were h calls 6 hours after opening.","There were 8 calls V hours after opening."],"correctAnswer":0,"explanation":"In the ordered pair (6, 8), the first value is the input h = 6 (hours after opening) and the second value is the output V = 8 (number of calls). So there were 8 calls 6 hours after opening.","category":"Function Notation","tags":["function-notation","ordered-pair","interpret"],"difficulty":1},{"id":4,"text":"A company has developed two functions, L(t) and M(t), that determine the least amount and most amount, respectively, of revenue it will make in any given month in dollars (with t = 1 corresponding to January).\n What can the company reasonably conclude if L(2) = 3,000 and M(2) = 5,000?","options":["In February, it will make $2,000.","It cannot make more than $3,000 in February but can make up to $5,000 after February.","In February, it will make between $3,000 and $5,000.","It will make more money in February if it uses M(t) instead of L(t)."],"correctAnswer":2,"explanation":"L(2) = 3,000 gives the least revenue in February and M(2) = 5,000 gives the most. Therefore, actual revenue in February will fall between these bounds: between $3,000 and $5,000.","category":"Function Notation","tags":["function-notation","bounds","revenue"],"difficulty":1},{"id":5,"text":"A server at a restaurant has realized that tips, T, in dollars are related to the number of hours, h, that have been worked on any given day. Tips can be modeled by the function T(h) = X.\n How can this function be interpreted?","options":["If the server works T hours, the tips will be $h.","If the server works h hours, the tips will be $X.","If the server works h hours, the tips will be $T(X).","If the server works X hours, the tips will be $T."],"correctAnswer":1,"explanation":"T(h) = X means the input is h (hours worked) and the output is X (dollar amount of tips). So if the server works h hours, the tips will be $X. The function T takes hours as input and returns tip dollars as output.","category":"Function Notation","tags":["function-notation","interpret","real-world"],"difficulty":1},{"id":6,"text":"A company pays its employees a base salary each month plus a commission, C, based on the number of sales, s, made by an employee during the month. An employee made 8 sales in the last month and received a commission of $1,600.\n How would this be represented in function notation?","options":["C(8) = 1600","C(1600) = 8","s(1600) = 8","s(8) = 1600"],"correctAnswer":0,"explanation":"Commission C is a function of sales s. With 8 sales (input) producing $1,600 commission (output), the correct notation is C(8) = 1600. The function name is C, the input is the number of sales, and the output is the commission amount.","category":"Function Notation","tags":["function-notation","write-notation","commission"],"difficulty":1},{"id":7,"text":"Below is a growth graph of a business. It compares gross growth and net growth.\n [Graph: Gross vs Net Growth 2010-2016]\n What can be said about the growth between the years of 2012 and 2014?","options":["Both gross and net growth decreased.","Both gross and net growth increased.","The gross growth decreased while the net growth increased.","The gross growth increased while the net growth decreased."],"correctAnswer":3,"explanation":"Between 2012 and 2014, the gross growth line trends upward while the net growth line trends downward. This means the company's total revenue grew, but after expenses, the net growth actually declined.","category":"Graph Reading","tags":["graph-reading","compare-trends","growth"],"difficulty":2},{"id":8,"text":"The graph below shows the three-month average percentage year-on-year growth for real total pay for the years 2010-2016, along with the Office for Budget Responsibility's (OBR's) growth forecast for the years 2016-2021.\n [Graph: Real Total Pay Growth]\n What can be concluded from this graph?","options":["The real total pay growth outturn exceeded 3% at some point between 2010 and 2016.","The real total pay growth outturn remained between -2% and 2% from 2010 and 2016.","The OBR forecasts the growth will remain above 1% between 2016 and 2021.","The OBR forecasts the growth will remain between 1% and 2% between 2016 and 2021."],"correctAnswer":1,"explanation":"Reading the graph carefully, the real total pay growth outturn line stays within the range of -2% to 2% throughout the 2010-2016 period. It never exceeds 3%, and the OBR forecast does not consistently stay above 1%.","category":"Graph Reading","tags":["graph-reading","range","pay-growth"],"difficulty":2},{"id":9,"text":"The following graph shows the profits of a company for the last fiscal year.\n [Graph: Company Profits]\n Approximately how much have the company's profits increased over the last year?","options":["50%","30%","110%","80%"],"correctAnswer":3,"explanation":"Reading the graph, the profits approximately doubled from around $1 million to $1.8 million over the year. The percentage increase is roughly (1.8 - 1.0)/1.0 = 80%. This is closest to 80% among the choices.","category":"Graph Reading","tags":["graph-reading","percent-change","profit"],"difficulty":2},{"id":10,"text":"Black Monday occurred on October 19, 1987, and represents the single largest decline of the Dow Jones average in history.\n The function f represents a seven-month period during which Black Monday occurred. The function value f(1) represents the Dow Jones average in June of 1987.\n [Graph: Dow Jones 1987]\n Which function value represents the Dow Jones average during the month when Black Monday occurred?","options":["f(6)","f(4)","f(5)","f(10)"],"correctAnswer":2,"explanation":"If f(1) = June 1987, then f(2) = July, f(3) = August, f(4) = September, and f(5) = October. Since Black Monday occurred in October 1987, the answer is f(5).","category":"Function Notation","tags":["function-notation","counting","historical"],"difficulty":2},{"id":11,"text":"The unemployment rate in Poland for the time period from 1990 to 2012 is shown in the graph below using the function U(t) (measured as a percentage), where t is the year.\n [Graph: Poland Unemployment Rate]\n What can be concluded based on this graph?","options":["The two lowest unemployment rates were U(1998) and U(2008).","The largest two-year increase in unemployment was from 1990 to 1992.","U(1992) was the same as U(2002).","The largest two-year decrease in unemployment was from 1996 to 1998."],"correctAnswer":0,"explanation":"Reading the graph, the unemployment rate hits its lowest points (troughs) around 1998 and 2008. These two years represent the local minimums on the graph, making them the two lowest unemployment rates in the period shown.","category":"Graph Reading","tags":["graph-reading","minimum","unemployment"],"difficulty":2},{"id":12,"text":"The graph of the function C below represents the number of coal miners in the United States from 1985 to 2015.\n C(y) represents the number of coal miners in the United States in the year y.\n [Graph: US Coal Miners]\n Which interpretation of the function C is accurate?","options":["C(2015) represents 68 coal miners in 2015.","C(1990) represents 140,000 coal miners in 1990.","C(1995) represents 100 coal miners in 1995.","C(2000) represents 70,000 coal miners in 2000."],"correctAnswer":1,"explanation":"Reading the graph at year 1990, the value is approximately 140,000 coal miners. The graph measures in thousands, so C(1990) = 140,000 is correct. The other options either misread the scale or confuse units.","category":"Graph Reading","tags":["graph-reading","scale","interpret-value"],"difficulty":2},{"id":13,"text":"The following table compares the number of employees hired and the number of employees dismissed over an 11-year period for a certain business.\n Year: 2007-2017, Hired vs Dismissed data provided.\n What can be concluded from this table?","options":["Fewer employees were hired than dismissed each year.","More employees were hired in 2007 and 2008 than in 2010 and 2011.","More employees were dismissed in 2016 and 2017 than in 2014 and 2015.","More employees were hired than dismissed each year."],"correctAnswer":3,"explanation":"Checking each year: 2007 (50>10), 2008 (20>10), 2009 (30>5), 2010 (21>17), 2011 (60>30), 2012 (70>15), 2013 (40>20), 2014 (15>5), 2015 (20>6), 2016 (10>2), 2017 (10>7). In every year, more employees were hired than dismissed.","category":"Graph Reading","tags":["table-reading","compare","employees"],"difficulty":1},{"id":14,"text":"A company has the following information on last quarter's sales (month 7 refers to July):\n Month 7: $303K, Month 8: $328K, Month 9: $333K\n What was the average rate of change over the entire quarter (from July to September)?","options":["Sales increased an average of $6,285.71 per month.","Sales increased an average of $10,000 per month.","Sales increased an average of $37,000 per month.","Sales increased an average of $15,000 per month."],"correctAnswer":3,"explanation":"Average rate of change = (333 - 303)/(9 - 7) = 30/2 = 15 thousand dollars per month. Since sales are in thousands, this is $15,000 per month. The rate is calculated over the entire interval from July (month 7) to September (month 9).","category":"Rate of Change","tags":["rate-of-change","average","sales"],"difficulty":1},{"id":15,"text":"An IT firm generates the following numbers to estimate its revenue in thousands of dollars based on the number of employees working on a project.\n Employees: 10,20,30,40,50 | Revenue: $12.40K, $21.99K, $30.74K, $36.01K, $38.43K\n Which conclusion can be made by examining the average rate of change between consecutive rows?","options":["The revenue is increasing steadily in relation to the number of employees.","The revenue is increasing at slower and slower rates in relation to the number of employees.","The revenue is not increasing in relation to the number of employees.","The revenue is increasing at faster and faster rates in relation to the number of employees."],"correctAnswer":1,"explanation":"Computing the rate of change between consecutive rows: (21.99-12.40)/10 = 0.959, (30.74-21.99)/10 = 0.875, (36.01-30.74)/10 = 0.527, (38.43-36.01)/10 = 0.242. Each successive rate is smaller, meaning revenue increases at slower and slower rates.","category":"Rate of Change","tags":["rate-of-change","decreasing-rate","revenue"],"difficulty":2},{"id":16,"text":"An airplane was cruising at an altitude of 39,000 feet and descended as shown in the table below.\n Time (min): 0,10,20,30,40,50,60 | Altitude (ft): 39000,33000,27000,21000,15000,9000,3000\n What can be concluded from this table?","options":["The airplane had a descent rate of 600 ft./min.","At minute 70, the airplane landed.","At minute 60, the airplane landed.","The airplane had a descent rate of 6,000 ft./min."],"correctAnswer":0,"explanation":"The altitude drops by 6,000 feet every 10 minutes: (39000 - 33000)/10 = 600 ft/min. This is a constant descent rate. At minute 60 the plane is still at 3,000 feet (not landed), and 6,000 ft/min would be far too fast.","category":"Rate of Change","tags":["rate-of-change","constant","descent"],"difficulty":1},{"id":17,"text":"The function table below shows a company's revenue function (R) and expense function (E) for each month.\n Monthly Revenues and Expenses for months 1-12 provided.\n Which conclusion can be made about this function table?","options":["Since R(11) is $10,234 and E(11) is $3,786, there was not a profit in November.","The lowest profit occurred during May.","Since R(2) is $3,220 and E(2) is $3,957, there was a profit in February.","The highest profit occurred during October."],"correctAnswer":3,"explanation":"Profit = Revenue - Expenses. For October: R(10) - E(10) = $12,337 - $927 = $11,410. Checking other months confirms this is the highest profit. February actually had a loss ($3,220 - $3,957 = -$737), and November had a profit ($10,234 - $3,786 = $6,448).","category":"Rate of Change","tags":["table-reading","profit","compute"],"difficulty":2},{"id":18,"text":"The original value of a company car bought in January of 2006 was $22,800. Below is a function table that tracks the value of the car V(y) as it depreciates from 2006 to 2015.\n Which other conclusion can be reached from this table?","options":["V(y) decreases the most from 2006 to 2007.","V(y) decreases by the same amount each year.","V(2013) = $22,800 - $6,879","V($4,970) = 2015"],"correctAnswer":0,"explanation":"From 2006 to 2007: $22,800 - $18,240 = $4,560 decrease. From 2007 to 2008: $18,240 - $15,504 = $2,736. Each subsequent year's decrease is smaller than $4,560, so the largest single-year decrease is from 2006 to 2007.","category":"Rate of Change","tags":["rate-of-change","depreciation","maximum-change"],"difficulty":2},{"id":19,"text":"The salvage or depreciated value, V, of a new truck purchased for $58,000 is given by the linear function V(t) = 58,000 - 4,000t, where t is the time in years between 0 and 10.\n What is the correct interpretation of V(3)?","options":["The truck's depreciated value after 5 years is $54,000.","The truck's depreciated value after 3 years is $46,000.","The truck's depreciated value after 5 years is $42,000.","The truck's depreciated value after 3 years is $50,000."],"correctAnswer":1,"explanation":"V(3) = 58,000 - 4,000(3) = 58,000 - 12,000 = $46,000. Plugging t = 3 into the function gives the truck's value after 3 years. The truck depreciates by $4,000 each year.","category":"Linear Functions","tags":["linear","evaluate","depreciation"],"difficulty":1},{"id":20,"text":"In the function C(x) = 21.25 + 0.25x, C(x) represents the total cost, in dollars, for a passenger to ride a shuttle service for x miles.\n What is the total cost for a passenger to ride the shuttle for 50 miles?","options":["$33.75","$12.50","$26.25","$50.25"],"correctAnswer":0,"explanation":"C(50) = 21.25 + 0.25(50) = 21.25 + 12.50 = $33.75. The base fare is $21.25, plus $0.25 per mile for 50 miles adds $12.50 to the total.","category":"Linear Functions","tags":["linear","evaluate","cost"],"difficulty":1},{"id":21,"text":"A company's total monthly cost is given by the linear function C(x) = 11,000 + 550x, where C is the total monthly cost and x is the number of units produced each month.\n What does the y-intercept represent in this situation?","options":["If 0 items are produced, the monthly cost is $550.00.","If 0 items are produced, the monthly cost is $11,000.00.","If 550 items are produced, the monthly cost is $0.00.","If 11,000 items are produced, the monthly cost is $0.00."],"correctAnswer":1,"explanation":"The y-intercept occurs when x = 0. C(0) = 11,000 + 550(0) = $11,000. This represents the fixed monthly cost when no items are produced. The $550 is the slope (cost per additional unit), not the y-intercept.","category":"Linear Functions","tags":["linear","y-intercept","fixed-cost"],"difficulty":1},{"id":22,"text":"A cable company, a satellite dish company, and a streaming service all offer TV viewing plans based on the number of channels, c.\n Cable: P(c) = 3c + 60\n Satellite dish: P(c) = 4c + 35\n Streaming service: P(c) = 5c + 50\n Which company's cost per additional channel is most expensive?","options":["Satellite dish company","Cable company","Streaming service","All have the same cost per channel"],"correctAnswer":2,"explanation":"The cost per additional channel is the slope of each linear function. Cable = $3/channel, Satellite = $4/channel, Streaming = $5/channel. The streaming service has the highest slope at $5 per channel, making it the most expensive per additional channel.","category":"Linear Functions","tags":["linear","slope","compare"],"difficulty":1},{"id":23,"text":"The number of gym memberships since January 1, 2015, for a particular gym is given by the function N(x) = 100 + 11x, where N is the number of gym members x months after January 1, 2015.\n How can the slope be interpreted?","options":["Each month, 100 members join the gym.","Each month, 11 members cancel their membership.","Each month, 100 members cancel their membership.","Each month, 11 members join the gym."],"correctAnswer":3,"explanation":"In N(x) = 100 + 11x, the slope is 11, meaning the number of members increases by 11 each month. The 100 is the y-intercept (starting members). A positive slope of 11 means 11 new members join per month.","category":"Linear Functions","tags":["linear","slope-interpretation","membership"],"difficulty":1},{"id":24,"text":"The pricing models of four contractors are given below, where t is the number of hours worked and P is the total cost of the job.\n Contractor A: P(t) = 100 + 20t\n Contractor B: P(t) = 99 + 25t\n Contractor C: P(t) = 50 + 35t\n Contractor D: P(t) = 80 + 25t\n Which contractor gives the cheapest hourly rate?","options":["Contractor B","Contractor D","Contractor C","Contractor A"],"correctAnswer":3,"explanation":"The hourly rate is the slope (coefficient of t) in each function. A = $20/hr, B = $25/hr, C = $35/hr, D = $25/hr. Contractor A has the lowest hourly rate at $20 per hour, even though their flat fee ($100) is the highest.","category":"Linear Functions","tags":["linear","slope","compare-rates"],"difficulty":1},{"id":25,"text":"An appliance manufacturer has determined that the profit, P(x), that it makes in manufacturing and selling x dishwashers can be determined from the function in the graph below.\n [Graph: Profit vs Dishwashers]\n How many dishwashers must the company manufacture and sell in order to make a profit of $80,000?","options":["30","130","140","120"],"correctAnswer":1,"explanation":"Reading the graph at P(x) = $80,000 on the y-axis and tracing horizontally to the curve, then down to the x-axis, the value lands at approximately 130 dishwashers. This is where the profit function reaches $80,000.","category":"Graph Reading","tags":["graph-reading","find-input","profit"],"difficulty":2},{"id":26,"text":"The profit function P(x) gives a company's total profit (in millions of U.S. dollars) for x products produced (in thousands). The graph of P(x) is below.\n [Graph: Profit Function]\n At which number of products produced does the company stop being profitable?","options":["About 1,000 items","About 3,000 items","About 2,500 items","About 4,500 items"],"correctAnswer":3,"explanation":"The company stops being profitable when P(x) = 0 (the graph crosses the x-axis from positive to negative). Reading the graph, this zero-crossing occurs at approximately x = 4.5 (in thousands), which is about 4,500 items.","category":"Graph Reading","tags":["graph-reading","zero","break-even"],"difficulty":2},{"id":27,"text":"A big box store found its number of customers, C, in thousands on Saturday is predicted by the time of day in hours, t. t = 0 corresponds to midnight.\n [Graph: Customers vs Time]\n How should the average rate of change from t = 8 to t = 10 be interpreted?","options":["There are, on average, 1,000 more customers per hour.","There are, on average, 2,000 fewer customers per hour.","There are, on average, 2,000 more customers per hour.","There are, on average, 1,000 fewer customers per hour."],"correctAnswer":0,"explanation":"Reading the graph: C(8) = 1 thousand and C(10) = 3 thousand. Average rate of change = (3 - 1)/(10 - 8) = 2/2 = 1 thousand customers per hour. Since the values are in thousands, this means 1,000 more customers per hour on average.","category":"Rate of Change","tags":["rate-of-change","average","customers"],"difficulty":2},{"id":28,"text":"The profit for a manufacturer of a certain product is given by the function P(x) = -4x^3 + 12x^2 + 16x, where P is the total profit (in thousands of dollars) for x items produced (in thousands).\n What is the average rate of change from x = 4 to x = 8?","options":["Profit increases by $288,000 per 1,000 items produced.","Profit decreases by $1,152,000 per 1,000 items produced.","Profit decreases by $288,000 per 1,000 items produced.","The profit neither increases nor decreases per 1,000 items produced."],"correctAnswer":2,"explanation":"P(4) = -4(64) + 12(16) + 16(4) = -256 + 192 + 64 = 0. P(8) = -4(512) + 12(64) + 16(8) = -2048 + 768 + 128 = -1152. Average rate = (-1152 - 0)/(8 - 4) = -1152/4 = -288 thousand dollars per thousand items. Profit decreases by $288,000 per 1,000 items.","category":"Rate of Change","tags":["rate-of-change","polynomial","compute"],"difficulty":3},{"id":29,"text":"The graph below represents the projected year-end assets, A(t), in the Social Security trust fund in trillions of dollars, where t represents the number of years since 2000.\n [Graph: Social Security Trust Fund]\n At which value of t is the fund increasing the most rapidly?","options":["About t = 45","About t = 7","About t = 30","About t = 0"],"correctAnswer":1,"explanation":"The fund is increasing most rapidly where the graph has its steepest positive slope. Looking at the graph, the steepest upward section occurs around t = 7 (approximately year 2007), where the curve is rising most sharply before it begins to flatten and eventually decline.","category":"Graph Reading","tags":["graph-reading","steepest-slope","social-security"],"difficulty":2},{"id":30,"text":"A local coffee shop found that its number of customers, N, can be predicted by the time of day in hours, t. The opening time of 5:00 a.m. corresponds to t = 0.\n [Graph: Coffee Shop Customers]\n How should the graph be interpreted between t = 5.5 and t = 9?","options":["Between 10:30 a.m. and 2:00 p.m., the number of customers is increasing slower and slower and then increasing faster and faster.","Between 10:30 a.m. and 2:00 p.m., the number of customers is increasing faster and faster and then decreasing slower and slower.","Between 10:30 a.m. and 2:00 p.m., the number of customers is increasing faster and faster and then increasing slower and slower.","Between 10:30 a.m. and 2:00 p.m., the number of customers is decreasing faster and faster and then increasing slower and slower."],"correctAnswer":2,"explanation":"Since t = 0 is 5:00 a.m., t = 5.5 is 10:30 a.m. and t = 9 is 2:00 p.m. The graph shows an S-shaped increase in this region: first concave up (increasing faster and faster), then an inflection point, then concave down (increasing slower and slower).","category":"Concavity & Curvature","tags":["concavity","inflection","interpret-graph"],"difficulty":3},{"id":31,"text":"The total profit, P(x), in thousands of dollars from the production of x thousands of laptop computers is given by the graph below. For this graph, x must be greater than or equal to 5.\n [Graph: Laptop Profit]\n How many laptops must be produced to maximize the profit?","options":["700,000","10","10,000","700"],"correctAnswer":2,"explanation":"Reading the graph, the maximum profit occurs at approximately x = 10. Since x is measured in thousands of laptops, x = 10 means 10,000 laptops. The peak of the profit curve is at this production level.","category":"Graph Reading","tags":["graph-reading","maximum","units"],"difficulty":2},{"id":32,"text":"For the years since a department store has been open, its annual revenue, R, (in millions of dollars) can be modeled by the function graphed below, where t is the number of years since the store opened.\n [Graph: Department Store Revenue]\n How should the maximum revenue be interpreted?","options":["About 4 years after the department store opened, the store earned a maximum revenue of about $1,600,000.00.","About 6 years after the department store opened, the store earned a maximum revenue of about $1,400,000.00.","About 14 years after the department store opened, the store earned a maximum revenue of about $1,400,000.00.","About 6 years after the department store opened, the store earned a maximum revenue of about $1,600,000.00."],"correctAnswer":3,"explanation":"Reading the graph, the peak (maximum) of the revenue curve occurs at approximately t = 6 years, with R approximately equal to 1.6 million dollars ($1,600,000). The revenue rises to this peak and then declines afterward.","category":"Graph Reading","tags":["graph-reading","maximum","revenue"],"difficulty":2},{"id":33,"text":"The population of the United States in millions of people can be estimated with the function P(t) = 282(1.01)^t, where t = 0 represents the population, P, in the year 2000, and t is measured in years.\n What does P(-2) represent?","options":["P(-2) represents the opposite of the population in 2002, which was approximately 250 million people.","P(-2) represents the population in 2002, which was approximately 288 million people.","P(-2) represents the population in 1998, which was approximately 276 million people.","P(-2) represents twice the population of 2000, which was approximately 564 million people."],"correctAnswer":2,"explanation":"Since t = 0 is the year 2000, t = -2 is two years before 2000, which is 1998. P(-2) = 282(1.01)^(-2) = 282/1.0201 = approximately 276 million people. Negative t values go backward in time from the reference year.","category":"Exponential & Logistic","tags":["exponential","negative-input","population"],"difficulty":2},{"id":34,"text":"A high-interest loan company uses the function L(d) = 100e^(0.02d) to calculate late fees, L, for payments overdue by d days.\n What does L(67) represent?","options":["L(67) is the average number of days a person waits to make a payment, which would be 67.","L(67) is the number of days that a payment is overdue, which would be 382 days.","L(67) is the overall amount due when a payment is 67 days overdue, which would be $67.","L(67) is the amount due in late fees for a payment that is 67 days overdue, which would be $381.90."],"correctAnswer":3,"explanation":"L(d) calculates late fees for d days overdue. L(67) = 100e^(0.02 x 67) = 100e^(1.34) = 100 x 3.819 = approximately $381.90. This is the late fee amount when the payment is 67 days overdue.","category":"Exponential & Logistic","tags":["exponential","evaluate","late-fees"],"difficulty":2},{"id":35,"text":"A bank uses the function A(t) = 1000(1.023)^t to calculate an account balance, A, after t years.\nWhat is the average rate of change of the account balance from t = 2 to t = 12?","options":["The account will decrease by $26.72, on average, each year.","The account will increase by $267.21, on average, each year.","The account will increase by $26.72, on average, each year.","The account will decrease by $267.21, on average, each year."],"correctAnswer":2,"explanation":"A(2) = 1000(1.023)^2 = 1046.53. A(12) = 1000(1.023)^12 = 1313.74. Average rate of change = (1313.74 - 1046.53)/(12 - 2) = 267.21/10 = $26.72 per year. The account balance increases on average by $26.72 each year over this period.","category":"Rate of Change","tags":["rate-of-change","exponential","banking"],"difficulty":2},{"id":36,"text":"A scientist found a sample of carbon-14 and knows the graph below models the exponential decay of carbon-14, where t is time measured in years and y is the amount of carbon-14 left in the sample in grams.\n [Graph: Carbon-14 Decay]\n What would the average rate of change over the time interval of t = 100 to t = 700 represent, and would that rate be positive or negative?","options":["It represents the annual change in the number of grams of carbon-14 between 100 and 700 years. The rate is negative.","It represents the annual change in 600 years per the number of grams of carbon-14. The rate is positive.","It represents the annual change in the number of grams of carbon-14 between 100 and 700 years. The rate is positive.","It represents the annual change in 600 years per the number of grams of carbon-14. The rate is negative."],"correctAnswer":0,"explanation":"The average rate of change = (y(700) - y(100))/(700 - 100), which gives the annual change in grams of carbon-14 over this 600-year interval. Since carbon-14 decays over time (decreasing function), y(700) < y(100), making the rate negative.","category":"Rate of Change","tags":["rate-of-change","decay","sign"],"difficulty":2},{"id":37,"text":"A company uses the function C = 15e^(-n) + 10, which is shown in the graph below, to model the average cost per toy produced, C, where n is the number of toys produced.\n [Graph: Cost per Toy]\n How should this horizontal asymptote be interpreted?","options":["As the number of toys produced increases, the average cost per toy tends toward $10.","As the cost of producing toys increases, the number of toys produced tends toward 10.","As the cost of producing toys increases, the number of toys produced tends toward 15.","As the number of toys produced increases, the average cost per toy tends toward $15."],"correctAnswer":0,"explanation":"As n approaches infinity, e^(-n) approaches 0, so C = 15(0) + 10 = 10. The horizontal asymptote is C = 10, meaning as more toys are produced, the average cost per toy approaches $10 but never quite reaches it.","category":"Exponential & Logistic","tags":["asymptote","exponential","cost"],"difficulty":2},{"id":38,"text":"Two medical operations are being compared to determine which is better for patients. Below is a graph of the chance of infection after operation (in percentage) for the first option (solid curve) and the second option (dashed curve), shown over time since 1950.\n [Graph: Infection Rates]\n As time has gone on, which is the better operation?","options":["Operation 1 is better because the chance of infection has dropped to a steady 15% since around the year 2000.","Operation 2 is better because the chance of infection has dropped to a steady 10% since around the year 2000.","Operation 2 is better because the chance of infection has dropped to a steady 15% since around the year 2000.","Operation 1 is better because the chance of infection has dropped to a steady 10% since around the year 2000."],"correctAnswer":1,"explanation":"Reading the graph, Operation 2 (dashed curve) has its infection rate leveling off at approximately 10% by around the year 2000, which is lower than Operation 1's steady rate of approximately 15%. Lower infection rate means a better operation.","category":"Graph Reading","tags":["graph-reading","asymptote","compare"],"difficulty":2},{"id":39,"text":"A factory with an assembly line can produce more automobiles per week as more employees are working at a given time, limited by the capacity of the assembly line. The model follows the function A(w) = 100/(1 + 25e^(-0.06w)) - 4, where A is the number of automobiles per week, and w is the number of workers.\n How many workers are needed to produce 50 automobiles per week?","options":["41 workers","57 workers","80 workers","96 workers"],"correctAnswer":1,"explanation":"Set A(w) = 50: 50 = 100/(1 + 25e^(-0.06w)) - 4, so 54 = 100/(1 + 25e^(-0.06w)). Then 1 + 25e^(-0.06w) = 100/54 = 1.852, so 25e^(-0.06w) = 0.852, e^(-0.06w) = 0.0341, -0.06w = ln(0.0341) = -3.378, w = 56.3, approximately 57 workers.","category":"Exponential & Logistic","tags":["logistic","solve","factory"],"difficulty":3},{"id":40,"text":"A cat population in a small town can be modeled with a logistic function and estimated with the table below, where t = 0 represents the cat population, P, in the year 2000, and t is measured in years.\n t: 1,2,3,4 | P(t): 24,55,103,150\n When does the cat population reach 110?","options":["During 2004","During 2001","During 2002","During 2003"],"correctAnswer":3,"explanation":"At t = 3, P(3) = 103 and at t = 4, P(4) = 150. Since 110 falls between 103 and 150, the population reaches 110 sometime between t = 3 and t = 4. Since t = 3 corresponds to year 2003, the population reaches 110 during 2003.","category":"Exponential & Logistic","tags":["logistic","table","interpolate"],"difficulty":2},{"id":41,"text":"A factory with an assembly line can produce more automobiles per week as more employees are working at a given time, limited by the capacity of the assembly line. The model follows the function A(w) = 100/(1 + 25e^(-0.06w)) - 4.\n The instantaneous rate of change at w = 50 is 1.\n How should this be interpreted?","options":["When the factory has 50 workers, the factory will produce 10 fewer cars for each worker added.","When the factory has 50 workers, the factory will produce 10 more cars for each worker added.","When the factory has 50 workers, the factory will produce 1 more car for each worker added.","When the factory has 50 workers, the factory will produce 1 fewer car for each worker added."],"correctAnswer":2,"explanation":"The instantaneous rate of change at w = 50 is 1, meaning the derivative A'(50) = 1. This means at exactly 50 workers, each additional worker adds approximately 1 more automobile per week to production.","category":"Exponential & Logistic","tags":["logistic","instantaneous-rate","interpret"],"difficulty":2},{"id":42,"text":"A rabbit population can be estimated with the function P(t) = 117/(1 + 5e^(-0.2t)), where t = 0 represents the rabbit population, P, in the year 2010, and t is measured in years.\n What is the average rate of change of the rabbit population from 2020 to 2040?","options":["The rabbit population is decreasing by about 115.57 rabbits per year during this time.","The rabbit population is increasing by about 115.57 rabbits per year during this time.","The rabbit population is increasing by about 2.29 rabbits per year during this time.","The rabbit population is decreasing by about 2.29 rabbits per year during this time."],"correctAnswer":2,"explanation":"2020 is t = 10 and 2040 is t = 30. P(10) = 117/(1 + 5e^(-2)) = 117/(1 + 0.677) = 69.79. P(30) = 117/(1 + 5e^(-6)) = 117/(1 + 0.0124) = 115.57. Average rate = (115.57 - 69.79)/20 = 45.78/20 = approximately 2.29 rabbits per year.","category":"Rate of Change","tags":["rate-of-change","logistic","population"],"difficulty":2},{"id":43,"text":"A factory with an assembly line produces automobiles and is limited by the capacity of its assembly line.\n [Graph: Automobile Production - Logistic Curve]\n What happens as additional workers between 10 workers and 40 workers are added?","options":["Adding additional workers increases the number of automobiles produced slower and slower.","Adding additional workers increases the number of automobiles produced faster and faster.","Adding additional workers decreases the number of automobiles produced faster and faster.","Adding additional workers decreases the number of automobiles produced slower and slower."],"correctAnswer":1,"explanation":"Between 10 and 40 workers on a logistic curve, we are in the early growth phase (before the inflection point). In this region, the curve is concave up, meaning production increases at an accelerating rate -- faster and faster with each additional worker.","category":"Concavity & Curvature","tags":["concavity","logistic","concave-up"],"difficulty":2},{"id":44,"text":"The function C(x), modeling cell phone price versus supply, is a decreasing logistic model (where C is the cost, and x is the number of cell phones available).\n [Graph: Cell Phone Cost - Decreasing Logistic]\n What is happening from x = 100 to x = 300?","options":["The cost of the phone is decreasing faster and faster.","The cost of the phone is increasing slower and slower.","The cost of the phone is increasing faster and faster.","The cost of the phone is decreasing slower and slower."],"correctAnswer":3,"explanation":"In a decreasing logistic model, the region from x = 100 to x = 300 is past the inflection point. The cost is still decreasing but the curve is flattening out (concave up for a decreasing function), meaning the cost decreases slower and slower as it approaches its lower asymptote.","category":"Concavity & Curvature","tags":["concavity","logistic","decreasing"],"difficulty":2},{"id":45,"text":"A factory with an assembly line can produce more automobiles per week as more employees are working at a given time, limited by the capacity of the assembly line. The model follows the function A(w) = 100/(1 + 25e^(-0.06w)) - 4.\n [Graph: Automobile Production]\n How should the upper horizontal asymptote be interpreted?","options":["The factory can produce a maximum of approximately 140 automobiles per week.","The factory can produce a maximum of approximately 95 automobiles per week.","The upper asymptote has no real world meaning in this scenario.","If there is a negative number of workers, then the number of automobiles produced is negative."],"correctAnswer":1,"explanation":"As w approaches infinity, e^(-0.06w) approaches 0, so A = 100/(1 + 0) - 4 = 100 - 4 = 96, which is approximately 95. The upper asymptote represents the maximum production capacity of the assembly line, regardless of how many workers are added.","category":"Exponential & Logistic","tags":["logistic","asymptote","capacity"],"difficulty":2},{"id":46,"text":"The rate that a rumor spreads through a middle school can be determined using the graph below, where R is the number of people who have heard the rumor after d days.\n [Graph: Rumor Spread]\n When should approximately 25% of the maximum number of people hear the rumor?","options":["On day 7","On day 1","On day 3","On day 5"],"correctAnswer":2,"explanation":"Reading the logistic growth graph, the maximum number of people who hear the rumor is the upper asymptote. 25% of that maximum corresponds to the early growth phase. Tracing the graph to where it reaches approximately one quarter of its maximum value leads to approximately day 3.","category":"Graph Reading","tags":["graph-reading","logistic","percentage"],"difficulty":2},{"id":47,"text":"The following graph shows the number of page views for a company's website over time (in months).\n [Graph: Page Views]\n During which month were there approximately 100 page views?","options":["July","February","June","March"],"correctAnswer":2,"explanation":"Reading the graph at y = 100 page views and tracing horizontally to the curve, then down to the x-axis, the month that corresponds to approximately 100 page views is June.","category":"Graph Reading","tags":["graph-reading","find-input","page-views"],"difficulty":1},{"id":48,"text":"The following graph measures revenue from vending machines at a large business on a typical day. The y-axis shows revenue in dollars, and the x-axis shows time based on the 24-hour clock. Revenue was measured every 15 minutes from 7:00 a.m. (700) to 8:00 p.m. (2000).\n [Graph: Vending Machine Revenue]\n What indicates that a shift ends at 5:00 p.m. (1700)?","options":["The vending machine revenues spike around 5:00 p.m. to about $55.","The vending machine revenues fall around 5:00 p.m. to about $20.","The vending machine revenues spike around 5:00 p.m. to about $100.","The vending machine revenues fall around 5:00 p.m. to about $40."],"correctAnswer":0,"explanation":"When a shift ends, employees take breaks and use vending machines before leaving, causing a spike in revenue. The graph shows a revenue spike around 5:00 p.m. reaching approximately $55, indicating the end of a work shift.","category":"Graph Reading","tags":["graph-reading","spike","interpret-event"],"difficulty":2},{"id":49,"text":"The following graph shows the price of the stock of a company x months after December 2014.\n [Graph: Stock Price]\n A program is set to automatically buy this stock on the first day of the month, provided the price is below $20. What month would it have first bought this stock, and would the investment have increased in value the following month?","options":["August 2016; yes, the stock would have increased in value the next month.","November 2015; no, the stock would not have increased in value the next month.","February 2015; no, the stock would not have increased in value the next month.","September 2015; yes, the stock would have increased in value the next month."],"correctAnswer":3,"explanation":"Reading the graph, the stock first drops below $20 at September 2015 (9 months after December 2014). Looking at the next month (October 2015), the stock price increased. So the program would have first bought in September 2015, and the investment would have gained value.","category":"Graph Reading","tags":["graph-reading","threshold","stock"],"difficulty":2},{"id":50,"text":"The following graph shows the number of page views for a company's website over time (in months).\n [Graph: Page Views Over Time]\n Estimate and interpret the average rate of change for the company's page views between March and August.","options":["The average rate of change was about -400 page views per month between these times, which means that the company's page views went down 400 on average each month between these times.","The average rate of change was about 240 page views per month between these times, which means that the company's page views went up 240 on average each month between these times.","The average rate of change was about -240 page views per month between these times, which means that the company's page views went down 240 on average each month between these times.","The average rate of change was about 400 page views per month between these times, which means that the company's page views went up 400 on average each month between these times."],"correctAnswer":2,"explanation":"Reading the graph: March page views are approximately 1,400 and August page views are approximately 200. Average rate of change = (200 - 1400)/(8 - 3) = -1200/5 = -240 page views per month. The negative sign indicates page views decreased on average.","category":"Rate of Change","tags":["rate-of-change","average","negative"],"difficulty":2},{"id":51,"text":"A chain of stores started out as 100 stores the first year, then increased by 400 stores the following year, and then increased each year for the next six years.\n [Graph: Store Growth]\n Which statement about the average rate of change is correct?","options":["The average rate of change from years 1 to 7 is 6 stores per year.","The average rate of change from years 1 to 4 is less than the average rate of change for years 4 to 7.","The average rate of change from years 1 to 7 is 1,200 stores per year.","The average rate of change from years 1 to 4 is greater than the average rate of change from years 4 to 7."],"correctAnswer":1,"explanation":"The graph shows accelerating growth (concave up). When growth is accelerating, the average rate of change over later intervals is greater than over earlier intervals. Therefore, the rate from years 4 to 7 is greater than from years 1 to 4, meaning the rate from years 1 to 4 is less than from years 4 to 7.","category":"Rate of Change","tags":["rate-of-change","compare-intervals","accelerating"],"difficulty":2},{"id":52,"text":"Each point on the following graph represents the revenue returned from a project with a specified marketing budget. The y-axis measures the revenue in thousands of dollars, and the x-axis represents the budget in thousands of dollars.\n [Graph: Revenue vs Budget]\n Which budget should new projects have at this company to maximize revenue?","options":["New projects should have a budget of $9,000 since this returned a revenue of $19,000.","New projects should have a budget of $19,000 since this returned a revenue of $9,000.","New projects should have a budget of $20,000 since this returned a revenue of $6,000.","New projects should have a budget of $6,000 since this returned a revenue of $20,000."],"correctAnswer":0,"explanation":"Reading the scatterplot, the data point with the highest revenue (y-value) is at approximately (9, 19), meaning a budget of $9,000 returned a revenue of $19,000. This is the maximum revenue observed in the data.","category":"Graph Reading","tags":["graph-reading","maximum","scatterplot"],"difficulty":2},{"id":53,"text":"The following graph represents profit on the y-axis (in thousands of dollars) based on production levels on the x-axis (in thousands of units). Each valley represents the decrease in profit after a major production expansion.\n [Graph: Profit with Expansions]\n After which production expansion do profits increase the fastest on average?","options":["The expansion at 9,500 units","The expansion at 3,500 units","The expansion at 1,500 units","The expansion at 6,500 units"],"correctAnswer":1,"explanation":"After each expansion (valley), profits recover and increase. The expansion at 3,500 units shows the steepest upward slope in the recovery phase, meaning profits increase the fastest on average after this particular expansion compared to the others.","category":"Graph Reading","tags":["graph-reading","rate-of-change","expansion"],"difficulty":3},{"id":54,"text":"In last week's sales meeting, a supervisor at a company stressed that current sales are increasing, but the graph of the sales is concave down. She seemed to emphasize this repeatedly to encourage the sales team to change the curvature of the sales.\n What could happen to the company sales if the sales graph keeps the trend of being concave down?","options":["Sales could begin decreasing faster and faster, or sales could begin increasing faster and faster.","Sales could begin decreasing slower and slower, or sales could begin decreasing faster and faster.","Sales could continue increasing slower and slower, or sales could begin decreasing slower and slower.","Sales could continue increasing slower and slower, or sales could begin decreasing faster and faster."],"correctAnswer":3,"explanation":"A concave down graph curves downward. If sales are currently increasing and the graph is concave down, sales are increasing slower and slower (the rate of increase is declining). If this trend continues, sales will eventually peak and begin decreasing. Once decreasing on a concave down graph, sales would decrease faster and faster.","category":"Concavity & Curvature","tags":["concavity","concave-down","prediction"],"difficulty":3},{"id":55,"text":"A technology firm in Erie, Pennsylvania, receives a contract to develop a computer program controlling the angle of a solar array on a daily basis. The firm first needs to model the hours of sunlight for every day of the year.\n From December to March, the hours of daylight are increasing faster and faster, and from March to June, they are increasing slower and slower.\n Which graph would be an appropriate model for this firm to use?","options":["Graph A","Graph B","Graph C","Graph D"],"correctAnswer":0,"explanation":"The description requires: increasing faster and faster (concave up) from December to March, then increasing slower and slower (concave down) from March to June, with an inflection point around March. Graph A shows this S-shaped pattern of concave up transitioning to concave down while continuously increasing.","category":"Concavity & Curvature","tags":["concavity","inflection","model-selection"],"difficulty":3},{"id":56,"text":"The following graph represents revenue from vending machines at a large business during a typical day. The y-axis represents revenue in dollars, and the x-axis represents time.\n [Graph: Vending Machine Revenue]\n What is the difference between the maximum revenue and the minimum revenue?","options":["$15","$100","$60","$85"],"correctAnswer":3,"explanation":"Reading the graph, the maximum revenue is approximately $100 and the minimum revenue is approximately $15. The difference is $100 - $15 = $85. This represents the range of daily revenue from the vending machines.","category":"Graph Reading","tags":["graph-reading","range","revenue"],"difficulty":1},{"id":57,"text":"The U.S. housing price index from 1970 to 2010 is plotted in the graph below.\n [Graph: US Housing Price Index]\n Which conclusion about this graph is correct?","options":["The lowest housing price index occurred in 1995, and the highest housing price index occurred in 2010.","The lowest housing price index occurred in 1970, and the highest housing price index occurred in 2010.","The lowest housing price index occurred in 2000, and the highest housing price index occurred in 2005.","The lowest housing price index occurred in 1970, and the highest housing price index occurred in 2005."],"correctAnswer":3,"explanation":"Reading the graph, the housing price index starts at its lowest point in 1970 and rises over the decades, reaching its peak around 2005 before declining. The highest value is around 2005, not 2010 (which shows the post-crash decline).","category":"Graph Reading","tags":["graph-reading","extremes","housing"],"difficulty":2},{"id":58,"text":"A company is trying to develop a computer algorithm to predict whether a customer will make a purchase of $100 or more. As the company collects more customer data, it updates its algorithm. The graph shows the algorithm's error rate for various amounts of customer data.\n [Graph: Error Rate]\n Which conclusion can the company make about the error rate for this algorithm?","options":["The error rate constantly decreases toward 0% error.","The error rate stabilizes and approaches an error rate of 2.5%.","The decrease in error rate is unsustainable and will eventually increase.","The asymptote indicates that 2.5% of customers make purchases of $100 or more in the online store."],"correctAnswer":1,"explanation":"The graph shows the error rate decreasing rapidly at first, then leveling off and approaching a horizontal asymptote at approximately 2.5%. The error rate stabilizes rather than continuing to decrease to 0%, indicating there is a fundamental limit to the algorithm's accuracy.","category":"Exponential & Logistic","tags":["asymptote","error-rate","algorithm"],"difficulty":2},{"id":59,"text":"The average cost in dollars, A(x), to produce x cell phone screen covers is given by the graph below.\n [Graph: Average Cost]\n What happens to the average cost as more and more covers are produced?","options":["The average cost increases to about $15 per cover.","The average cost reduces to about $0 per cover.","The average cost increases to about $4 per cover.","The average cost reduces to about $2 per cover."],"correctAnswer":3,"explanation":"Reading the graph, as x increases, the average cost curve decreases and approaches a horizontal asymptote at approximately $2 per cover. The cost decreases due to economies of scale but never reaches $0 because there are always some per-unit costs.","category":"Exponential & Logistic","tags":["asymptote","average-cost","economies-of-scale"],"difficulty":2},{"id":60,"text":"A software developer recently launched a new social media app and is studying user retention. Group A shared 3+ pictures in the first 5 days (solid line); Group B did not (dashed line). The graph shows retention rates over time.\n [Graph: User Retention]\n Which conclusion can be made from the data in this graph?","options":["The retention rates of both Group A and Group B stabilize as time increases and will eventually level off at the same rate.","The retention rate of Group B stabilizes as time increases, but the retention rate of Group A continues to decrease.","The retention rate of Group A stabilizes as time increases, but the retention rate of Group B continues to decrease.","The retention rates of both Group A and Group B stabilize as time increases and appear to have different asymptotes."],"correctAnswer":3,"explanation":"The graph shows both curves leveling off over time, each approaching its own horizontal asymptote. Group A (active users) stabilizes at a higher retention rate than Group B. The two different asymptotes indicate that early engagement (sharing pictures) leads to a permanently higher retention rate.","category":"Exponential & Logistic","tags":["asymptote","retention","compare-groups"],"difficulty":2},{"id":61,"text":"The following graph shows the sales of two popular items a company sells for a random sample of months. The company has chosen to fit the data with a linear model, and r^2 = 0.82.\n [Graph: Sales with Linear Fit]\n Is the linear function a good regression model for the data?","options":["No, the data would fit better with an exponential function.","Yes, the data is strongly correlated, and it has a roughly constant rate of change.","No, the data would fit better with a logistic function.","Yes, the data is S-shaped and therefore is best modeled by a linear function."],"correctAnswer":1,"explanation":"An r^2 value of 0.82 indicates a strong correlation (generally r^2 > 0.7 is considered strong). The data shows a roughly linear pattern with a constant rate of change, making a linear model appropriate. The data is not S-shaped or exponential in nature.","category":"Regression & Predictions","tags":["regression","r-squared","linear-fit"],"difficulty":2},{"id":62,"text":"A business wants to model the relationship between the number of items sold for two similar products. The monthly sales data for 20 months are shown in the graph below. The company fit its data with a linear model, which has an R-squared value of r^2 = 0.18.\n [Graph: Weak Linear Fit]\n What does r^2 imply for the fit of the model?","options":["This model has a weak fit; therefore, predictions should not be made based on this function.","This model has a weak fit; therefore, predictions can be reliably made based on this function.","This model has a moderate fit; therefore, predictions should not be made based on this function.","This model has a moderate fit; therefore, predictions can be reliably made based on this function."],"correctAnswer":0,"explanation":"An r^2 value of 0.18 means only 18% of the variation in the data is explained by the model. This is a very weak fit (well below 0.5). With such a weak correlation, predictions based on this model would be unreliable and should not be made.","category":"Regression & Predictions","tags":["regression","r-squared","weak-fit"],"difficulty":1},{"id":63,"text":"A real estate agent wanted to develop a model for the number of days a rental property sits vacant based on how the rental price compares to market value. The agent fit the data with an exponential function, which has an r^2 value of 0.83.\n [Graph: Vacancy vs Price]\n Is this exponential function a good regression model for the data?","options":["Yes, the data points increase by a constant rate.","No, there is a moderate correlation, and a linear function would be a better fit for the data.","Yes, there is a strong correlation, and the data points increase approximately by a constant ratio.","No, a polynomial model would be a better fit for the data."],"correctAnswer":2,"explanation":"With r^2 = 0.83, the correlation is strong. Exponential functions are characterized by data that increases by a constant ratio (multiplicative growth) rather than a constant amount. The data pattern matches exponential behavior, confirming the model is a good fit.","category":"Regression & Predictions","tags":["regression","exponential","constant-ratio"],"difficulty":2},{"id":64,"text":"A student created the scatterplot of data on the graph below. The x-axis represents the number of items, and the y-axis represents the total cost. The student drew a line of best fit. The calculator produced r^2 = 0.9946991797.\n [Graph: Items vs Cost]\n How can the value of r^2 be interpreted?","options":["The number of items has no correlation to the total cost.","The number of items has a weak correlation to the total cost.","The number of items has a moderate correlation to the total cost.","The number of items has a strong correlation to the total cost."],"correctAnswer":3,"explanation":"An r^2 value of 0.9947 is extremely close to 1, indicating that approximately 99.5% of the variation in total cost is explained by the number of items. This is a very strong correlation, meaning the linear model fits the data almost perfectly.","category":"Regression & Predictions","tags":["regression","r-squared","interpret"],"difficulty":1},{"id":65,"text":"A company has tracked the depreciating value of a company car over a 10-year period. The company performed a regression and modeled the value of the car, V, at year x with the function V(x) = 26,878.23e^(-0.21x) with r^2 = 0.98.\n [Graph: Car Depreciation]\n Would it be appropriate to use this model to make a prediction for the value of the car when the car is 12 years old?","options":["Yes, it would be appropriate because the data has a strong correlation, and 12 is within the range for accurate extrapolation.","Yes, it would be appropriate because 12 is an interpolation value.","No, it would not be appropriate because 12 is not close enough to the known data values, so it would be an extreme extrapolation value.","No, it would not be appropriate because 12 is an interpolation value."],"correctAnswer":2,"explanation":"The data covers years 0-10. Predicting at x = 12 is extrapolation (outside the known data range). While x = 12 is not extremely far from x = 10, it is far enough outside the 10-year data window that the model may not accurately represent real depreciation. This makes it an extreme extrapolation that should not be relied upon.","category":"Regression & Predictions","tags":["regression","extrapolation","appropriate"],"difficulty":2},{"id":66,"text":"A local university collects data related to its increasing enrollment for the past 19 years. The university models this with the logistic function P(t) = 9.51/(1 + 11.96e^(-0.37t)) with r^2 = 0.96, where t is time in years, and P is enrollment in thousands.\n [Graph: University Enrollment]\n Would it be appropriate for the university to use this model to predict enrollment five years from now (when t = 24)?","options":["Yes, t = 24 is an interpolation value.","Yes, the data are strongly correlated, so this would be considered a somewhat safe extrapolation.","No, the data is moderately correlated, so this would be considered too risky of an extrapolation.","No, t = 24 is an extreme extrapolation value."],"correctAnswer":1,"explanation":"The r^2 = 0.96 indicates very strong correlation. While t = 24 is outside the 19-year data range (extrapolation), it is only 5 years beyond, which is considered a somewhat safe extrapolation. Additionally, logistic functions naturally level off, so predictions slightly beyond the data are more reliable than with other model types.","category":"Regression & Predictions","tags":["regression","extrapolation","logistic","safe"],"difficulty":2},{"id":67,"text":"A company examined cost data in an effort to model the relationship between number of items produced, x, and cost, C. The regression equation is C(x) = 0.52x + 366 with a coefficient of determination of r^2 = 0.92. The company plans to use this function to determine the cost of producing 45 items.\n [Graph: Cost vs Items]\n Is the company's plan appropriate?","options":["No, it is not appropriate because the data should be modeled with a logistic function.","Yes, it is appropriate because as the number of items produced increases, so does the cost.","No, it is not appropriate because the data should be modeled with an exponential function.","Yes, it is appropriate because the coefficient of determination is close to 1, and this is an interpolation value."],"correctAnswer":3,"explanation":"The plan is appropriate for two reasons: (1) r^2 = 0.92 is close to 1, indicating a strong fit, and (2) x = 45 falls within the range of known data values, making it an interpolation (not extrapolation). Both conditions support making a reliable prediction.","category":"Regression & Predictions","tags":["regression","interpolation","r-squared"],"difficulty":2},{"id":68,"text":"A company has tracked the relationship between the selling price of an item, x, and the revenue generated by the sales of that item, f. The company performs a polynomial regression on the data and models the data with the function f(x) = -24.34x^2 + 336.21x + 53.88 with r^2 = 0.93.\n [Graph: Revenue vs Price]\n The company uses this model to predict that if it charges $12 per item, it will earn a revenue of approximately $583.44.\n Is this conclusion valid and why?","options":["No, it is not a valid conclusion because this data would be better modeled with a logistic function.","Yes, it is a valid conclusion because the relationship between selling price and revenue is quadratic.","No, it is not a valid conclusion because f(12) = 529.56.","Yes, it is a valid conclusion because f(12) = 583.44, r^2 is close to 1, and 12 is not far outside of the known data values."],"correctAnswer":3,"explanation":"Checking: f(12) = -24.34(144) + 336.21(12) + 53.88 = -3504.96 + 4034.52 + 53.88 = 583.44. The calculation is correct, r^2 = 0.93 indicates a strong fit, and x = 12 is close to the known data range. All three conditions validate the conclusion.","category":"Regression & Predictions","tags":["regression","polynomial","validate-prediction"],"difficulty":3},{"id":69,"text":"A company has tracked the relationship between the number of units of an item that sold, x, (measured in thousands) and the total revenue earned from the item in dollars, A. The company decided to perform an exponential regression and found the function A(x) = 223.7e^(0.04x) with r^2 = 0.76.\n [Graph: Revenue vs Units]\n The company uses this model to predict that when it sells 180,000 items, its revenue will be approximately $300,000.\n Is this a valid conclusion and why?","options":["Yes, this is a valid conclusion because A(180) = 300,000, and r^2 is close to 1, so the model is a good fit for the data.","Yes, this is a valid conclusion because the data is following an exponential pattern.","No, this is not a valid conclusion because A(180) = 200,000.","No, an accurate prediction cannot be made when x = 180 because it is too far from the known data values."],"correctAnswer":3,"explanation":"Even though r^2 = 0.76 suggests a moderate fit, x = 180 (180,000 items) is far outside the range of known data values. Extrapolating exponential functions far beyond the data range produces highly unreliable predictions. The extreme extrapolation makes this prediction invalid.","category":"Regression & Predictions","tags":["regression","extrapolation","invalid"],"difficulty":2},{"id":70,"text":"A company has tracked the depreciating value of a company car over an eight-year period. The company performed a linear regression and modeled the value of the car, V, at year x with the function V(x) = -2606.54x + 24109.37 with r^2 = 0.96.\n [Graph: Car Depreciation - Linear]\n Would it be appropriate to use this model to predict the value of the car when the car is 10 years old?","options":["Yes, it would be appropriate because r^2 is close to 1, and x = 10 is close to the given data values.","No, it would not be appropriate because this situation should be modeled using a quadratic function.","Yes, it would be appropriate because car depreciation should be modeled with a decreasing linear function.","No, it would not be appropriate because past x = 9 the linear trend will not continue, and data cannot be extrapolated."],"correctAnswer":0,"explanation":"The r^2 = 0.96 indicates a very strong linear correlation. Since the data covers 8 years and x = 10 is only 2 years beyond the data range, this is a close extrapolation. The strong fit combined with the proximity to known data makes this prediction appropriate.","category":"Regression & Predictions","tags":["regression","extrapolation","close","appropriate"],"difficulty":2}]}
</script>

<!-- GAMIFICATION UI ELEMENTS -->
<!-- Combo Display -->
<div class="combo-display" id="comboDisplay">
    <span class="combo-fire"></span>
    <span class="combo-count" id="comboCount">x0</span>
    <span class="combo-mult" id="comboMult">1.0x</span>
</div>

<!-- Achievement Toast -->
<div class="achievement-toast hidden" id="achievementToast">
    <div class="ach-icon" id="achIcon"></div>
    <div class="ach-info">
        <div class="ach-name" id="achName">Achievement</div>
        <div class="ach-desc" id="achDesc">Description</div>
        <div class="ach-xp" id="achXp">+100 XP</div>
    </div>
</div>

<!-- Level Up Modal -->
<div class="levelup-overlay" id="levelupOverlay" onclick="if(event.target===this)Gamification.closeLevelUp()">
    <div class="levelup-modal">
        <div class="level-icon"></div>
        <h2>LEVEL UP!</h2>
        <div class="level-num" id="levelupNum">2</div>
        <div class="level-title" id="levelupTitle">Algebra Apprentice</div>
        <div class="level-rewards" id="levelupRewards"></div>
        <button onclick="Gamification.closeLevelUp()">Awesome!</button>
    </div>
</div>

<!-- Study Buddy Widget -->
<div class="study-buddy" id="studyBuddy">
    <div class="buddy-sprite" id="buddySprite"></div>
    <div class="buddy-name" id="buddyName">Mathie</div>
    <div class="buddy-mood" id="buddyMood">Sleepy</div>
    <div class="buddy-progress">
        <div class="buddy-progress-fill" id="buddyProgress" style="width:0%"></div>
    </div>
</div>

<!-- Confetti Canvas -->
<canvas id="confettiCanvas"></canvas>

<!-- Version Footer -->
<div style="text-align:center;padding:16px;font-size:11px;color:var(--gray-500);opacity:0.7">v3.29</div>

</body>
</html>
